<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hnakamur&#39;s blog at github</title>
    <link>https://hnakamur.github.io/blog/tags/centos/index.xml</link>
    <description>Recent content on hnakamur&#39;s blog at github</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <atom:link href="https://hnakamur.github.io/blog/tags/centos/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LXD で privileged な CentOS 7コンテナを作る</title>
      <link>https://hnakamur.github.io/blog/2016/10/22/lxd-privileged-centos-container/</link>
      <pubDate>Sat, 22 Oct 2016 18:54:49 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2016/10/22/lxd-privileged-centos-container/</guid>
      <description>

&lt;p&gt;小ネタのメモです。&lt;/p&gt;

&lt;p&gt;先日 LXD 2.0.5 で CentOS 7 コンテナを起動して &lt;code&gt;journalctl -xe&lt;/code&gt; を実行すると以下のようなエラーが出ていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Oct 22 09:53:58 centos systemd-sysctl[36]: Failed to write &#39;16&#39; to &#39;/proc/sys/kernel/sysrq&#39;: Permission denied
Oct 22 09:53:58 centos systemd-sysctl[36]: Failed to write &#39;1&#39; to &#39;/proc/sys/fs/protected_hardlinks&#39;: Permission denied
Oct 22 09:53:58 centos systemd-sysctl[36]: Failed to write &#39;1&#39; to &#39;/proc/sys/kernel/core_uses_pid&#39;: Permission denied
Oct 22 09:53:58 centos systemd-sysctl[36]: Failed to write &#39;1&#39; to &#39;/proc/sys/fs/protected_symlinks&#39;: Permission denied
Oct 22 09:53:58 centos systemd-remount-fs[35]: /bin/mount for / exited with exit status 32.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナ作成時に以下のように config で &lt;code&gt;security.privileged&lt;/code&gt; を true に設定しておけば出なくなりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc launch -c security.privileged=true images:centos/7/amd64 コンテナ名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;設定の確認は以下のコマンドで行います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc config show コンテナ名
name: centos
profiles:
- default
config:
  security.privileged: &amp;quot;true&amp;quot;
  volatile.base_image: d2a0b3cf928778ad1582ee1feb39a0bbcd57edce01a60868f04e78d959886d71
  volatile.eth0.hwaddr: 00:16:3e:b2:dc:5e
  volatile.last_state.idmap: &#39;[]&#39;
devices:
  root:
    path: /
    type: disk
ephemeral: false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もっと限定した設定でも対応可能かもしれませんが、とりあえずこれで。&lt;/p&gt;

&lt;h2 id=&#34;2016-10-23-追記&#34;&gt;2016-10-23 追記&lt;/h2&gt;

&lt;p&gt;security.privileged を true にするのは良くないと指摘されました。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/hnakamur2&#34;&gt;@hnakamur2&lt;/a&gt; Don&amp;#39;t do that! This errors are actually bugs ( see &lt;a href=&#34;https://t.co/5IuFQzMI9u&#34;&gt;https://t.co/5IuFQzMI9u&lt;/a&gt; + &lt;a href=&#34;https://t.co/4ypMXS5FTq&#34;&gt;https://t.co/4ypMXS5FTq&lt;/a&gt; ), so report them to CentOS&lt;/p&gt;&amp;mdash; Marqin (@mrMarqin) &lt;a href=&#34;https://twitter.com/mrMarqin/status/789838146083098625&#34;&gt;October 22, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;CentOS にバグ報告というのはよくわからなかったので、LXDにイシューを立ててみました。
&lt;a href=&#34;https://github.com/lxc/lxd/issues/2544&#34;&gt;CentOS 7 container gets errors like systemd-sysctl[36]: Failed to write &amp;lsquo;16&amp;rsquo; to &amp;lsquo;/proc/sys/kernel/sysrq&amp;rsquo;: Permission denied · Issue #2544 · lxc/lxd&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CentOS 7用にPython2最新版のrpmを作ってみた</title>
      <link>https://hnakamur.github.io/blog/2015/12/19/build_latest_python2_rpm_for_centos7/</link>
      <pubDate>Sat, 19 Dec 2015 11:51:30 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2015/12/19/build_latest_python2_rpm_for_centos7/</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2015/12/16/calling_copr_api_with_curl/&#34;&gt;coprのAPIをcurlで呼び出す · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;にも書きましたが、CentOS 7のPythonは古くてhttps通信時にInsecurePlatformWarningが出てしまいます。&lt;/p&gt;

&lt;p&gt;そこで、&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-python-2.7.8-3.el7/&#34;&gt;Software CollectionsのPython27のpythonパッケージ&lt;/a&gt;を改変してPython2の最新版2.7.11のrpmを作ってみました。
&lt;a href=&#34;https://www.softwarecollections.org/en/&#34;&gt;Software Collections&lt;/a&gt;のrpmをベースにしていますので、CentOS 7にインストールされているPythonとは共存可能となっています。&lt;/p&gt;

&lt;h2 id=&#34;python2の最新版rpmの利用方法&#34;&gt;Python2の最新版rpmの利用方法&lt;/h2&gt;

&lt;p&gt;先に利用方法を書いておきます。&lt;/p&gt;

&lt;h3 id=&#34;インストール手順&#34;&gt;インストール手順&lt;/h3&gt;

&lt;p&gt;dockerのcentos:7コンテナにインストールする例で説明します。まず以下のコマンドでコンテナを起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -it centos:7 /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に以下のコマンドを実行してPython2をインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sL -o /etc/yum.repos.d/hnakamur-hnscl-python2.repo https://copr.fedoraproject.org/coprs/hnakamur/hnscl-python2/repo/epel-7/hnakamur-hnscl-python2-epel-7.repo
curl -sL -o /etc/yum.repos.d/hnakamur-hnscl-python2-python.repo https://copr.fedoraproject.org/coprs/hnakamur/hnscl-python2-python/repo/epel-7/hnakamur-hnscl-python2-python-epel-7.repo
yum -y install hn-python2-python
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使い方&#34;&gt;使い方&lt;/h3&gt;

&lt;p&gt;以下のコマンドでPython2最新版用のシェルを起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scl enable hn-python2 bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは通常通りpythonコマンドを実行すればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# which python
/opt/hn/hn-python2/root/usr/bin/python
# python -V
Python 2.7.11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使い終わったら &lt;code&gt;exit&lt;/code&gt; で上記で起動したシェルを抜けてください。&lt;/p&gt;

&lt;p&gt;ちなみに、Software Collectionsで提供されているPython 2.7のインストール方法は&lt;a href=&#34;https://www.softwarecollections.org/en/scls/rhscl/python27/&#34;&gt;Python 2.7 — Software Collections&lt;/a&gt;です。&lt;/p&gt;

&lt;h2 id=&#34;python2の最新版rpmを作った時のメモ&#34;&gt;Python2の最新版rpmを作った時のメモ&lt;/h2&gt;

&lt;p&gt;以下はrpmを作った時のメモです。&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/&#34;&gt;Packaging Guide — Software Collections&lt;/a&gt;を読みながら試行錯誤してrpmを作りました。&lt;/p&gt;

&lt;h3 id=&#34;software-collectionsのメタパッケージ&#34;&gt;Software Collectionsのメタパッケージ&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-Package_Layout&#34;&gt;Packaging Guide — Software Collections&lt;/a&gt;で説明されていますが、Software Collectionsではメタパッケージというのを作成します。&lt;/p&gt;

&lt;p&gt;例えば今回ベースにしたPython 2.7だと&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-1.1-20.el7/&#34;&gt;python27&lt;/a&gt;というのがメタパッケージで、　Python2本体のパッケージは&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-python-2.7.8-3.el7/&#34;&gt;Software CollectionsのPython27のpythonパッケージ&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;Software Collectionsを自作する場合は、パッケージ名が衝突しないように「組織名-」という接頭辞をつけるようにと&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-The_Software_Collections_Prefix&#34;&gt;2.4. The Software Collection Prefix&lt;/a&gt;に書かれています。公式のソフトウェアコレクションは接頭辞無しで &lt;code&gt;python27&lt;/code&gt; のようなコレクション名になっています。&lt;/p&gt;

&lt;p&gt;また、&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-The_File_System_Hierarchy&#34;&gt;2.2. The File System Hierarchy&lt;/a&gt;に書かれているように、ソフトウェアコレクションのrpmに含まれるファイルは &lt;code&gt;/opt/提供者名/ソフトウェアコレクション名/&lt;/code&gt; というディレクトリ構成を取ります。公式のソフトウェアコレクションは &lt;code&gt;/opt/rh/ソフトウェアコレクション名/&lt;/code&gt; というディレクトリになっています。rhはredhatの略だと思います。&lt;/p&gt;

&lt;p&gt;今回は &lt;code&gt;hn-python2&lt;/code&gt; というメタパッケージ名とし、ディレクトリは &lt;code&gt;/opt/hn/python2/&lt;/code&gt; としました。&lt;/p&gt;

&lt;h3 id=&#34;software-collectionsのメタパッケージのビルド&#34;&gt;Software Collectionsのメタパッケージのビルド&lt;/h3&gt;

&lt;p&gt;ビルド用のファイルは&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-rpm&#34;&gt;hnakamur/hnscl-python2-rpm&lt;/a&gt;に置いてあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-The_Software_Collection_Root_Directory&#34;&gt;2.3. The Software Collection Root Directory&lt;/a&gt;によるとspecファイルに以下のように書けばよいそうです。providerの箇所は提供者ごとの値に変えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%global _scl_prefix /opt/provider
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ですが、実際に試してみるとこの設定だけだと、ビルドされたrpm内のファイルパスだったりファイルの中身に &lt;code&gt;/opt/rh/&lt;/code&gt; というパスが残ってしまいました。試行錯誤の結果以下のように書くことで全て &lt;code&gt;/opt/hn/&lt;/code&gt; に変わりました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-rpm/blob/06a6fa366bd485d722139f0637ce2def364eaef3/SPECS/hn-python2.spec#L1-L22&#34;&gt;hn-python2-spec&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%global scl_name_prefix hn-
%global scl_name_base python
%global scl_name_version 2
%global scl %{scl_name_prefix}%{scl_name_base}%{scl_name_version}

# NOTE: You must set _scl_prefix before &#39;%scl_package %scl&#39;.
%global _scl_prefix /opt/hn
# NOTE: The following variables must be re-evaluated after changing _scl_prefix above.
# I got these settings after trials and errors.
# I don&#39;t know this is the right way to set directories with my _scl_prefix.
%global _scl_scripts            %{_scl_prefix}/%{scl}
%global _scl_root               %{_scl_prefix}/%{scl}/root
%global _prefix                 %{_scl_root}/usr
%global _sysconfdir             %{_scl_root}/etc
%global _sharedstatedir         %{_scl_root}/var/lib
%global _localstatedir          %{_scl_root}/var
%global _datadir                %{_scl_root}/share
%global _docdir                 %{_datadir}/doc
%global _mandir                 %{_datadir}/man


%scl_package %scl
...(snip)...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;python本体のパッケージのビルド&#34;&gt;Python本体のパッケージのビルド&lt;/h3&gt;

&lt;p&gt;ビルド用のファイルは&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm&#34;&gt;hnakamur/hnscl-python2-python-rpm&lt;/a&gt;に置いてあります。&lt;/p&gt;

&lt;p&gt;インストールディレクトリを &lt;code&gt;/opt/hn/&lt;/code&gt; 以下にするため、試行錯誤した結果specファイルに以下のように書けばOKでした。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/blob/3a13fe74587d6beca871d28a68149a2273488672/SPECS/python.spec#L1-L31&#34;&gt;python.spec&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%global scl_name_prefix hn-
%global scl_name_base python
%global scl_name_version 2
%global scl %{scl_name_prefix}%{scl_name_base}%{scl_name_version}

# NOTE: You must set _scl_prefix before &#39;%scl_package %scl&#39;.
%global _scl_prefix /opt/hn
# NOTE: The following variables must be re-evaluated after changing _scl_prefix above.
%global _scl_scripts            %{_scl_prefix}/%{scl}
%global _scl_root               %{_scl_prefix}/%{scl}/root
%global _prefix                 %{_scl_root}/usr
%global _sysconfdir             %{_scl_root}/etc
%global _sharedstatedir         %{_scl_root}/var/lib
%global _localstatedir          %{_scl_root}/var

%global _includedir             %{_prefix}/include
%if &amp;quot;%{_lib}&amp;quot; == &amp;quot;lib64&amp;quot;
%global _libdir                 %{_prefix}/lib64
%else
%global _libdir                 %{_prefix}/lib
%endif
%global _datadir                %{_prefix}/share
%global _docdir                 %{_prefix}/share/doc
%global _datarootdir            %{_prefix}/share
%global _infodir                %{_prefix}/share/info
%global _mandir                 %{_prefix}/share/man
%global _defaultdocdir          %{_prefix}/share/doc

%global _exec_prefix            %{_prefix}
%global _bindir                 %{_exec_prefix}/bin
%global _sbindir                %{_exec_prefix}/sbin
...(snip)...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;python本体のspecファイルのパッチ更新&#34;&gt;Python本体のspecファイルのパッチ更新&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/blob/3a13fe74587d6beca871d28a68149a2273488672/SPECS/python.spec&#34;&gt;python.spec&lt;/a&gt;には約60個のパッチが含まれています。&lt;/p&gt;

&lt;p&gt;Pythonのソースのバージョンを上げたのでパッチが当たらなくなるケースが出てきました。patchを実行した時に生成される &lt;code&gt;*.rej&lt;/code&gt; ファイルを見て、なんとなくこんな感じだろという軽いノリでパッチを一通り更新しました。&lt;/p&gt;

&lt;p&gt;作業手順は&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2015/12/16/how_to_debug_errors_in_rpm_build_using_mock/&#34;&gt;mockを使ったrpmビルドが失敗した時の調査方法 · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;に書いた手順で、mockのchroot環境内でパッチを修正して &lt;code&gt;rpmbuild -bp specファイル名&lt;/code&gt; でパッチを当てるというのをひたすら繰り返した感じです。&lt;/p&gt;

&lt;p&gt;パッチ1つごとの修正を&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/commits/master&#34;&gt;Commits · hnakamur/hnscl-python2-python-rpm&lt;/a&gt;のだいたい1つのコミットにしています。ただ、後からさらに修正が必要だったものは別コミットになっていますが。&lt;/p&gt;

&lt;p&gt;また、CentOSのPythonのspecファイルではリリースビルドとデバッグビルドを作ってテストも実行するようになっています。これがかなり時間がかるので、ビルドが通らない段階では&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/commit/ebb31040e3e5bfe0ceb62cd4eb67793bd1a333b0&#34;&gt;リリースビルドだけにしてテストは実行しないようにしていました&lt;/a&gt;。ビルドが落ち着いてきたところで&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/commit/8a293e3dbd25f6cb6638b00efc07ce5cf962a397&#34;&gt;この変更をgit revert&lt;/a&gt;してビルド・テストするようにしました。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-python-2.7.8-3.el7/&#34;&gt;Software CollectionsのPython27のpythonパッケージ&lt;/a&gt;を改変して作ったPython2の最新版2.7.11のrpmについて説明しました。&lt;/p&gt;

&lt;p&gt;CentOS 7でもPython2の最新版が手軽に利用可能になるので、ぜひご活用ください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mockコマンドでrpmをビルドする</title>
      <link>https://hnakamur.github.io/blog/2015/12/05/build_rpm_with_mock/</link>
      <pubDate>Sat, 05 Dec 2015 22:10:26 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2015/12/05/build_rpm_with_mock/</guid>
      <description>

&lt;h2 id=&#34;2015-12-15-追記&#34;&gt;2015-12-15 追記&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/&#34;&gt;nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;という記事を書きましたのでそちらもご参照ください。&lt;/p&gt;

&lt;h2 id=&#34;以下元記事です&#34;&gt;以下元記事です&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2015/11/26/use_travis_and_copr_to_build_and_host_rpm/&#34;&gt;Travis CIとcopr.fedoraproject.orgを使ってrpmをビルド・配布するのを試してみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;でrpmを外部のサーバでビルドできるようになりましたが、試行錯誤中はこの手順だと時間がかかりますので、手元の環境でビルドしたいところです。&lt;/p&gt;

&lt;h2 id=&#34;rpmbuild&#34;&gt;rpmbuild&lt;/h2&gt;

&lt;p&gt;私は最近までrpmbuildでrpmをビルドしていました。以下のコマンドでspecファイルの &lt;code&gt;BuildRequires&lt;/code&gt; に書いたrpmをまとめてインストールすることが出来ることも最近知りました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum-builddep -y specファイルのパス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけでも十分便利ですが、1つの環境でいろんなrpmをビルドするような使い方をしていると不満が出てきます。ビルドに必要なパッケージを &lt;code&gt;BuildRequires&lt;/code&gt; に書き忘れていても、別のrpmのビルドの際にインストールされていてビルドが通ってしまい気づかない恐れがあるからです。&lt;/p&gt;

&lt;h2 id=&#34;mock&#34;&gt;mock&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Mock&#34;&gt;Mock - FedoraProject&lt;/a&gt;を使えば、chrootでクリーンな環境でrpmをビルドしてくれるので、上記のように &lt;code&gt;BuildRequires&lt;/code&gt; に必要なパッケージを書き忘れた場合はビルドエラーになり間違いに気づくことができます。&lt;/p&gt;

&lt;p&gt;また、実行環境と異なるCPUアーキテクチャやRHELのバージョン用のrpmもビルドできます。 &lt;a href=&#34;http://linux.die.net/man/1/mock&#34;&gt;mock(1): build SRPMs in chroot - Linux man page&lt;/a&gt;によると &lt;code&gt;-r&lt;/code&gt; オプションで &lt;code&gt;/etc/mock/&amp;lt;chroot&amp;gt;.cfg&lt;/code&gt; の &lt;code&gt;&amp;lt;chroot&amp;gt;&lt;/code&gt; の部分を指定すればよいそうです。&lt;/p&gt;

&lt;p&gt;CentOS 7で &lt;code&gt;/etc/mock&lt;/code&gt; を見てみたところ、以下のような環境が用意されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[vagrant@localhost ~]$ ls /etc/mock/
default.cfg            fedora-21-armhfp.cfg   fedora-22-i386.cfg     fedora-23-ppc64.cfg         fedora-rawhide-ppc64le.cfg
epel-5-i386.cfg        fedora-21-i386.cfg     fedora-22-ppc64.cfg    fedora-23-ppc64le.cfg       fedora-rawhide-s390.cfg
epel-5-ppc.cfg         fedora-21-ppc64.cfg    fedora-22-ppc64le.cfg  fedora-23-s390.cfg          fedora-rawhide-s390x.cfg
epel-5-x86_64.cfg      fedora-21-ppc64le.cfg  fedora-22-s390.cfg     fedora-23-s390x.cfg         fedora-rawhide-sparc.cfg
epel-6-i386.cfg        fedora-21-s390.cfg     fedora-22-s390x.cfg    fedora-23-x86_64.cfg        fedora-rawhide-x86_64.cfg
epel-6-ppc64.cfg       fedora-21-s390x.cfg    fedora-22-x86_64.cfg   fedora-rawhide-aarch64.cfg  logging.ini
epel-6-x86_64.cfg      fedora-21-x86_64.cfg   fedora-23-aarch64.cfg  fedora-rawhide-armhfp.cfg   site-defaults.cfg
epel-7-x86_64.cfg      fedora-22-aarch64.cfg  fedora-23-armhfp.cfg   fedora-rawhide-i386.cfg
fedora-21-aarch64.cfg  fedora-22-armhfp.cfg   fedora-23-i386.cfg     fedora-rawhide-ppc64.cfg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Using_Mock_to_test_package_builds#Caching_in_mock_0.8.x_and_later&#34;&gt;Caching in mock 0.8.x and later&lt;/a&gt;を見るとmockの今のバージョンでは &lt;code&gt;mock&lt;/code&gt; を実行してchroot環境を作ってyumでダウンロードしたrpmはホスト環境にキャッシュされるそうです。&lt;/p&gt;

&lt;p&gt;ですので、複数のrpmをビルドしたり、同じrpmを試行錯誤で何度もビルドする場合に、キャッシュによる高速化が期待できます。&lt;/p&gt;

&lt;p&gt;まとめると、mockの利点は以下の2つです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;chrootによりクリーンな環境でビルドできるのでspecファイルの間違いに気づきやすい&lt;/li&gt;
&lt;li&gt;yumのキャッシュがあるのでビルドの際の &lt;code&gt;yum install&lt;/code&gt; が高速化される&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;coprもmockを使用しています&#34;&gt;coprもmockを使用しています&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://copr.fedoraproject.org/&#34;&gt;copr&lt;/a&gt;でビルドした結果のmockchaing.log.gzを見ると、以下の様な行がありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[2015-12-05 11:13:20,751][  INFO][PID:19554] executing: /usr/bin/mockchain -r epel-7-x86_64 -l /var/tmp/mockremote-ZTm5H/build/ -a https://copr-be.cloud.fedoraproject.org/results/hnakamur/nginx/epel-7-x86_64 -a https://copr-be.cloud.fedoraproject.org/results/hnakamur/nginx/epel-7-x86_64/devel -m &#39;--define=copr_username hnakamur&#39; -m &#39;--define=copr_projectname nginx&#39; -m &#39;--define=vendor Fedora Project COPR (hnakamur/nginx)&#39; /tmp/build_package_repo/nginx/nginx-1.9.7-1.el7.ngx.src.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://linux.die.net/man/1/mockchain&#34;&gt;mockchain(1): chain package builder - Linux man page&lt;/a&gt;によると複数のrpmを一括ビルドするためのコマンドだそうです。&lt;/p&gt;

&lt;h3 id=&#34;mockを使うためのセットアップ&#34;&gt;mockを使うためのセットアップ&lt;/h3&gt;

&lt;p&gt;epelを入れればmockはyumでインストール可能です。他にもsrpmを作るためにrpm-buildなどもyumでインストールする必要があるので、Vagrant用とDocker用にそれぞれセットアップ手順をまとめたものを作りました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hnakamur/centos-mock-vagrant&#34;&gt;hnakamur/centos-mock-vagrant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hnakamur/centos-mock-docker&#34;&gt;hnakamur/centos-mock-docker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vagrant環境のほうは単に &lt;code&gt;vagrant up&lt;/code&gt; で起動して &lt;code&gt;vagrant ssh&lt;/code&gt; でログインし、 &lt;code&gt;sudo su - mockbuild&lt;/code&gt; で &lt;code&gt;mockbuild&lt;/code&gt; ユーザになって作業します。&lt;/p&gt;

&lt;p&gt;Docker環境でmockを利用する場合、mockがunshareシステムコールを呼ぶので &lt;code&gt;SYS_ADMIN&lt;/code&gt; ケーパビリティが必要になります。そこで &lt;code&gt;docker run&lt;/code&gt; の際に &lt;code&gt;--cap-add=SYS_ADMIN&lt;/code&gt; オプションが必要です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker build -t mock .&lt;/code&gt; で &lt;code&gt;mock&lt;/code&gt; という名前でdockerイメージをビルドした場合、
&lt;code&gt;docker run --cap-add=SYS_ADMIN -it mock&lt;/code&gt; でbashプロンプトが起動しますので、 &lt;code&gt;su - mockbuild&lt;/code&gt; で &lt;code&gt;mockbuild&lt;/code&gt; ユーザになって作業します。&lt;/p&gt;

&lt;p&gt;mockのyumキャッシュを有効活用するには、複数のビルド間に環境を破棄せずに維持したほうが良いです。dockerのほうはbashを抜けると環境が消えてしまうので、もう少しDockerfileを工夫したようが良さそうです。&lt;/p&gt;

&lt;p&gt;とりあえず私はVagrantの環境の方を使っています。&lt;/p&gt;

&lt;h3 id=&#34;mockでのビルド&#34;&gt;mockでのビルド&lt;/h3&gt;

&lt;p&gt;まずsrpmファイルを作ります。
上記の環境ですと、&lt;code&gt;mockbuild&lt;/code&gt; ユーザの &lt;code&gt;/home/mockbuild/rpmbuild/&lt;/code&gt; の下に &lt;code&gt;SPECS&lt;/code&gt; や &lt;code&gt;SOURCES&lt;/code&gt; ディレクトリが作ってありますので、そこにspecファイルやソースを置いて以下のコマンドを実行して作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpmbuild -bs specファイルのパス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記の環境では &lt;code&gt;/home/mockbuild/rpmbuild/SRPMS/&lt;/code&gt; にsrpmファイルが生成されます。
その後、以下のようにmockコマンドを実行してビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mock --rebuild srpmファイルのパス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ビルドで生成されたrpmとsrpmファイルは &lt;code&gt;/var/lib/mock/&amp;lt;chroot&amp;gt;/result/&lt;/code&gt; に置かれます。
また、ビルドの作業ディレクトリは &lt;code&gt;/var/lib/mock/&amp;lt;chroot&amp;gt;/root/builddir/build/&lt;/code&gt; 以下に &lt;code&gt;BUILD&lt;/code&gt;, &lt;code&gt;BUILDROOT&lt;/code&gt;, &lt;code&gt;RPMS&lt;/code&gt;, &lt;code&gt;SOURCES&lt;/code&gt;, &lt;code&gt;SPECS&lt;/code&gt;, &lt;code&gt;SRPMS&lt;/code&gt; ディレクトリが作成されていますので、ビルドが失敗した場合はこの中を見て調査できます。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;実は&lt;a href=&#34;https://fedoraproject.org/wiki/Mock&#34;&gt;Mock - FedoraProject&lt;/a&gt;や&lt;a href=&#34;https://copr.fedoraproject.org/&#34;&gt;Project List&lt;/a&gt;はしばらく前に存在を知っていたのですが、ググっても情報が少ないしよくわからないのでスルーしていました。今回ついに使ってみたのですが、非常に便利なツールとサービスだということがわかりました。もっと前から使っておけばよかったです。&lt;/p&gt;

&lt;p&gt;みなさんも&lt;a href=&#34;https://fedoraproject.org/wiki/Mock&#34;&gt;Mock - FedoraProject&lt;/a&gt;と&lt;a href=&#34;https://copr.fedoraproject.org/&#34;&gt;Project List&lt;/a&gt;を活用して、快適なrpmビルド・配布環境を手に入れましょう！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Travis CIとcopr.fedoraproject.orgを使ってrpmをビルド・配布するのを試してみた</title>
      <link>https://hnakamur.github.io/blog/2015/11/26/use_travis_and_copr_to_build_and_host_rpm/</link>
      <pubDate>Thu, 26 Nov 2015 22:33:57 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2015/11/26/use_travis_and_copr_to_build_and_host_rpm/</guid>
      <description>

&lt;h2 id=&#34;2015-12-15-追記&#34;&gt;2015-12-15 追記&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/&#34;&gt;nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;という記事を書きましたのでそちらもご参照ください。&lt;/p&gt;

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;CentOSを使っていると、パッケージのバージョンが古いのでspecファイルを改変してrpmをビルドすることがちょくちょくあります。
一度ビルドした後は、自作rpmのレポジトリサーバを立ててそこに置いておくのが本来は良いんだろうなと思います。
ですが、サーバの運用の手間を考えると面倒だなと思って、AnsibleやDockerでのプロビジョニング中にビルドするようにしていました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://copr.fedoraproject.org/coprs/&#34;&gt;fedora projectのcoprというサービス&lt;/a&gt;を使うと、自分でサーバを用意しなくても
自作rpmのビルドとホスティングが出来ることを知り、試してみました。&lt;/p&gt;

&lt;h3 id=&#34;今回試したサンプル&#34;&gt;今回試したサンプル&lt;/h3&gt;

&lt;p&gt;githubのレポジトリは&lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm&#34;&gt;hnakamur/nodejs-rpm&lt;/a&gt;にあります。Node.jsをビルドするrpmです。&lt;/p&gt;

&lt;p&gt;specファイルは&lt;a href=&#34;https://github.com/kazuhisya/nodejs-rpm&#34;&gt;kazuhisya/nodejs-rpm&lt;/a&gt;のをほぼ流用しています。ありがとうございます！
一点変更したのはダウンロードするNode.jsのソースのtarballを &lt;code&gt;node-v*.tar.gz&lt;/code&gt; ではなく &lt;code&gt;node-v*.tar.xz&lt;/code&gt; にしています。&lt;/p&gt;

&lt;h2 id=&#34;coprについて&#34;&gt;coprについて&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://fedorahosted.org/copr/&#34;&gt;copr&lt;/a&gt;に説明があります。FAQの&lt;a href=&#34;https://fedorahosted.org/copr/wiki/UserDocs#HowisCoprpronounced&#34;&gt;How is Copr pronounced?&lt;/a&gt;によると、銅(copper)と同じでカッパーと発音するそうです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://fedorahosted.org/copr/wiki/UserDocs#Howlongdoyoukeepthebuilds&#34;&gt;How long do you keep the builds?&lt;/a&gt;によるとプロジェクトごとに最後に成功したビルドだけが保持されて、古いバージョンのビルドや失敗したビルドは14日後に削除されるそうです。&lt;/p&gt;

&lt;p&gt;ですので、古いバージョンも残しておきたい場合は、coprは使えません。その場合は自前でレポジトリサーバを立てて運用するしかなさそうです。&lt;/p&gt;

&lt;h3 id=&#34;参考-coprのウェブ管理画面にsrpmをアップロードしてrpmをビルドする手順&#34;&gt;参考: coprのウェブ管理画面にsrpmをアップロードしてrpmをビルドする手順&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://fedorahosted.org/copr/wiki/ScreenshotsTutorial&#34;&gt;ScreenshotsTutorial – copr&lt;/a&gt;にcoprのウェブ管理画面からsrpmをアップロードしてrpmをビルドする手順がスクリーンショット満載で説明されています。&lt;/p&gt;

&lt;h2 id=&#34;今回試したビルド手順の流れ&#34;&gt;今回試したビルド手順の流れ&lt;/h2&gt;

&lt;p&gt;今回試したビルド手順の流れは以下の通りです。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;githubのプロジェクトにspecファイルを置きます。&lt;/li&gt;
&lt;li&gt;git pushしたときにTravis CIでdockerコンテナを動かしてsrpmを作ってcoprに投入します。&lt;/li&gt;
&lt;li&gt;coprでrpmをビルドしてホスティングしてもらいます。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;事前準備&#34;&gt;事前準備&lt;/h2&gt;

&lt;h3 id=&#34;fedora-account-登録&#34;&gt;Fedora account 登録&lt;/h3&gt;

&lt;p&gt;まずは &lt;a href=&#34;https://admin.fedoraproject.org/accounts/user/new&#34;&gt;Sign up for a Fedora account&lt;/a&gt; からアカウント登録します。手順はメモしてなかったので省略します。&lt;/p&gt;

&lt;p&gt;私のアカウントのログイン後の「アカウントの詳細」のページを見ると「あなたの役割」のところにSigned CLA GroupとSigners of the Fedora Project Contributor Agreementという項目があり、共にステータスが「承認されました」となっているので、これらの申請の手順が必要だったと思います。&lt;/p&gt;

&lt;p&gt;承認されるまでしばらく時間がかかって、その間にrpmをビルドしてみたら署名されないことがありました。今ではプロジェクトごとに鍵が自動生成されてrpmが署名されるようになっています。&lt;/p&gt;

&lt;h3 id=&#34;travis-ciのプロジェクト作成&#34;&gt;Travis CIのプロジェクト作成&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/hnakamur/nodejs-rpm&#34;&gt;Travis CI上にhnakamur/nodejs-rpmプロジェクト&lt;/a&gt;を作成して、githubのレポジトリ&lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm&#34;&gt;hnakamur/nodejs-rpm&lt;/a&gt;に対応付けておきます。手順はメモしてなかったので省略します。&lt;/p&gt;

&lt;h3 id=&#34;travis-ciでdockerでコンテナを動かしてsrpmを作る&#34;&gt;Travis CIでdockerでコンテナを動かしてsrpmを作る&lt;/h3&gt;

&lt;p&gt;Travis CIでdockerを使う方法は &lt;a href=&#34;https://docs.travis-ci.com/user/docker/&#34;&gt;Using Docker in Builds - Travis CI&lt;/a&gt; で説明されています。&lt;/p&gt;

&lt;p&gt;試行錯誤の結果、以下のような &lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm/blob/0ed19cd5504fcb11875f12184bdb3ccd27caa6aa/.travis.yml&#34;&gt;.travis.yml&lt;/a&gt;を作成しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo: required

services:
  - docker

branches:
  only:
    - master
    - LTS

install:
  - docker build -t hnakamur/nodejsrpm .

script:
  - case $TRAVIS_BRANCH in master) project=nodejs5;; LTS) project=nodejs;; esac
  - docker run hnakamur/nodejsrpm &amp;quot;$COPR_LOGIN&amp;quot; &amp;quot;$COPR_USERNAME&amp;quot; &amp;quot;$COPR_TOKEN&amp;quot; &amp;quot;$project&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm&#34;&gt;hnakamur/nodejs-rpm&lt;/a&gt;では、mainブランチでNode.jsのv5.x (Stable)、LTSブランチでNode.jsのv4.x (LTS)のspecファイルを保持しています。&lt;/p&gt;

&lt;p&gt;coprは上記の通り1つのプロジェクトで複数バージョンは保持できないので、 &lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nodejs5/&#34;&gt;hnakamur/nodejs5 Copr&lt;/a&gt; と &lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nodejs/&#34;&gt;hnakamur/nodejs Copr&lt;/a&gt; の2つのプロジェクトを作ることにしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.travis-ci.com/user/environment-variables/#Default-Environment-Variables&#34;&gt;Environment Variables - Travis CI&lt;/a&gt;によると &lt;code&gt;TRAVIS_BRANCH&lt;/code&gt; 環境変数でgitのブランチが取得できます。ブランチ名に応じてプロジェクト名を切り替え、 &lt;code&gt;docker run&lt;/code&gt; で呼び出すスクリプトの引数に渡しています。&lt;/p&gt;

&lt;p&gt;COPR_LOGIN、COPR_USERNAME、COPR_TOKENの3つの環境変数ですが、Fedora accountにログインした状態で &lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;にアクセスし表示された値を使います。表示されているのはcoprのコマンドラインクライアント &lt;a href=&#34;https://pypi.python.org/pypi/copr-cli&#34;&gt;copr-cli&lt;/a&gt;用の設定ファイル &lt;code&gt;~/.config/copr&lt;/code&gt; の内容です。&lt;/p&gt;

&lt;p&gt;APIのアクセストークンなどは秘密にすべき情報なのでgithubのレポジトリ内のファイルには含めてはいけません。&lt;/p&gt;

&lt;p&gt;そこでこれらの値は&lt;a href=&#34;https://travis-ci.org/hnakamur/nodejs-rpm&#34;&gt;Travis CI上のhnakamur/nodejs-rpmプロジェクト&lt;/a&gt;で&lt;a href=&#34;https://docs.travis-ci.com/user/environment-variables/#Defining-Variables-in-Repository-Settings&#34;&gt;Defining Variables in Repository Settings&lt;/a&gt;の手順に従って設定しておきます。&lt;/p&gt;

&lt;p&gt;プロジェクトの管理画面の右上の[Settings]/[Settings]メニュー (このメニューはプロジェクトの管理者にのみ表示されます)を選んでCOPR_LOGIN、COPR_USERNAME、COPR_TOKENの3つの環境変数を追加します。COPR_LOGINとCOPR_TOKENの2つは[Display value in build log]を[ON]にしてログに出力しないようにしました。&lt;/p&gt;

&lt;p&gt;docker runで実行されるスクリプトの内容は以下の通りです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm/blob/0ed19cd5504fcb11875f12184bdb3ccd27caa6aa/copr-build.sh&#34;&gt;https://github.com/hnakamur/nodejs-rpm/blob/0ed19cd5504fcb11875f12184bdb3ccd27caa6aa/copr-build.sh&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
set -e
copr_login=$1
copr_username=$2
copr_token=$3
project_name=$4

spec_file=/root/rpmbuild/SPECS/nodejs.spec

mkdir -p /root/.config
cat &amp;gt; /root/.config/copr &amp;lt;&amp;lt;EOF
[copr-cli]
login = ${copr_login}
username = ${copr_username}
token = ${copr_token}
copr_url = https://copr.fedoraproject.org
EOF

status=`curl -s -o /dev/null -w &amp;quot;%{http_code}&amp;quot; https://copr.fedoraproject.org/api/coprs/${copr_username}/${project_name}/detail/`
if [ $status = &amp;quot;404&amp;quot; ]; then
  copr-cli create --chroot epel-7-x86_64 --description &#39;node.js repository&#39; ${project_name}
fi
version=`awk &#39;$1==&amp;quot;Version:&amp;quot; {print $2}&#39; ${spec_file}`
release=$(rpm --eval `awk &#39;$1==&amp;quot;Release:&amp;quot; {print $2}&#39; ${spec_file}`)
srpm_file=/root/rpmbuild/SRPMS/nodejs-${version}-${release}.src.rpm
copr-cli build --nowait ${project_name} ${srpm_file}

rm /root/.config/copr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、引数で渡された情報を元にcopr-cliの設定ファイル &lt;code&gt;/root/.config/copr&lt;/code&gt; を生成します。
次にcoprのAPIでプロジェクトが作成済みかチェックし、作成されていなければ作成します。
その後、 &lt;code&gt;copr-cli build&lt;/code&gt; でsrpmをcoprにアップロードしてビルドを開始します。&lt;/p&gt;

&lt;p&gt;curlでhttpステータスだけを出力する方法は &lt;a href=&#34;http://superuser.com/questions/272265/getting-curl-to-output-http-status-code/442395#442395&#34;&gt;Getting curl to output HTTP status code? - Super User&lt;/a&gt; で知りました。ありがとうございます！&lt;/p&gt;

&lt;p&gt;ビルド完了までTravis側で待つようにするのはムダだと思ったので &lt;code&gt;copr-cli build&lt;/code&gt; には &lt;code&gt;--nowait&lt;/code&gt; オプションを指定しました。代わりに &lt;a href=&#34;https://apps.fedoraproject.org/notifications/&#34;&gt;Fedora Notifications&lt;/a&gt;でメール通知を有効にして、ビルド終了時には &lt;code&gt;notifications@fedoraproject.org&lt;/code&gt; からメールが届くようにして使っています。&lt;/p&gt;

&lt;h3 id=&#34;srpmのビルドとcopr-cliのインストール&#34;&gt;srpmのビルドとcopr-cliのインストール&lt;/h3&gt;

&lt;p&gt;話が前後しますが、srpmのビルドとcopr-cliのインストールは &lt;code&gt;docker build&lt;/code&gt; で行っています。
&lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm/blob/0ed19cd5504fcb11875f12184bdb3ccd27caa6aa/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt;の内容は以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM centos:7
MAINTAINER Hiroaki Nakamura &amp;lt;hnakamur@gmail.com&amp;gt;

RUN yum -y install rpmdevtools rpm-build \
 &amp;amp;&amp;amp; rpmdev-setuptree

RUN yum -y install epel-release \
 &amp;amp;&amp;amp; yum -y install python-pip \
 &amp;amp;&amp;amp; pip install copr-cli

ADD nodejs.spec /root/rpmbuild/SPECS/
ADD node-js.*patch /root/rpmbuild/SOURCES/

RUN version=`awk &#39;$1==&amp;quot;Version:&amp;quot; {print $2}&#39; /root/rpmbuild/SPECS/nodejs.spec` \
 &amp;amp;&amp;amp; curl -sL -o /root/rpmbuild/SOURCES/node-v${version}.tar.xz https://nodejs.org/dist/v${version}/node-v${version}.tar.xz \
 &amp;amp;&amp;amp; rpmbuild -bs /root/rpmbuild/SPECS/nodejs.spec

ADD copr-build.sh /root/
ENTRYPOINT [&amp;quot;/bin/bash&amp;quot;, &amp;quot;/root/copr-build.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;copr-cliはCentOS 7だとepelから &lt;code&gt;yum install&lt;/code&gt; でインストール可能なのですが、バージョンが古いため &lt;code&gt;copr-cli build&lt;/code&gt; でsrpmファイルのパスを指定してアップロードする機能が無いようです。サイトにアップロードしておいてURLを指定することは可能なのですが、それだと面倒なので &lt;code&gt;pip&lt;/code&gt; を使って最新版の &lt;code&gt;copr-cli&lt;/code&gt; をインストールしています。&lt;/p&gt;

&lt;p&gt;長く運用するサーバならrpmでインストールされるパスと同じパスにpipでインストールしてしまうのは良くないかもしれませんが、ビルド終了したら破棄するコンテナなので気にせず上書きインストールとしています。&lt;/p&gt;

&lt;h2 id=&#34;rpmを使う手順&#34;&gt;rpmを使う手順&lt;/h2&gt;

&lt;p&gt;例えば&lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nodejs/&#34;&gt;hnakamur/nodejs Copr&lt;/a&gt;だと右の方の[Quick Enable]という欄に &lt;code&gt;dnf copr enable hnakamur/nodejs&lt;/code&gt; というコマンドで有効にできるという説明があります。&lt;/p&gt;

&lt;p&gt;その下のリンクをたどると&lt;a href=&#34;https://fedorahosted.org/copr/wiki/HowToEnableRepo&#34;&gt;HowToEnableRepo – copr&lt;/a&gt;に
yumの場合は &lt;code&gt;yum copr enable user/project&lt;/code&gt; となるとあります。ただし、 &lt;code&gt;yum-plugin-copr&lt;/code&gt; という &lt;code&gt;yum&lt;/code&gt; のプラグインが必要です。&lt;/p&gt;

&lt;p&gt;これはepelとかには無いようで、&lt;a href=&#34;https://copr.fedoraproject.org/coprs/alonid/yum-plugin-copr/&#34;&gt;alonid/yum-plugin-copr Copr&lt;/a&gt;にありました。が、これをインストールするにはこのプロジェクトを有効にする必要があるので面倒です。&lt;/p&gt;

&lt;p&gt;コマンドを使わなくても&lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nodejs/&#34;&gt;hnakamur/nodejs Copr&lt;/a&gt;のActive Releasesセクションの表のRepo Downloadの列にある[Epel 7]というボタンを押すと以下のようにレポジトリの設定ファイルが表示されます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nodejs/repo/epel-7/hnakamur-nodejs-epel-7.repo&#34;&gt;https://copr.fedoraproject.org/coprs/hnakamur/nodejs/repo/epel-7/hnakamur-nodejs-epel-7.repo&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[hnakamur-nodejs]
name=Copr repo for nodejs owned by hnakamur
baseurl=https://copr-be.cloud.fedoraproject.org/results/hnakamur/nodejs/epel-7-$basearch/
skip_if_unavailable=True
gpgcheck=1
gpgkey=https://copr-be.cloud.fedoraproject.org/results/hnakamur/nodejs/pubkey.gpg
enabled=1
enabled_metadata=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なので、これを &lt;code&gt;/etc/yum.repos.d/hnakamur-nodejs-epel-7.repo&lt;/code&gt; に保存して &lt;code&gt;yum install nodejs&lt;/code&gt; でインストールすればOKです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;これでスペックファイルを書いてgithubにプッシュすれば、coprでrpmをビルドして公開されるようになり便利になりました。&lt;/p&gt;

&lt;p&gt;ただし問題もあって、coprのビルドはときどき失敗してしまうようです。スペックファイルの中身を変えずにREADMEに無意味な空行を入れるなどして再度pushしてビルドを再実行すると成功したりしました。&lt;/p&gt;

&lt;h2 id=&#34;さらに気になっていること&#34;&gt;さらに気になっていること&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://fedorahosted.org/copr/wiki/ScreenshotsTutorial&#34;&gt;ScreenshotsTutorial – copr&lt;/a&gt;の[New Build]タブのスクリーンショットには[From URLs]と[Upload SRPM]という2つのタブしかないですが、実際の画面ではそれに加えて [Git and Tito]、[Mock SCM]というタブがあります。&lt;/p&gt;

&lt;p&gt;これらを使うとTravis CIを使わずにビルドできるかもしれないと期待しているのですが、使い方の説明を見つけられておらず使い方がわからない状態です。ということで一旦この記事を書きました。&lt;/p&gt;

&lt;h2 id=&#34;2015-12-06-追記&#34;&gt;2015-12-06 追記&lt;/h2&gt;

&lt;p&gt;rpmのビルドが通るまでの試行錯誤中は毎回coprでビルドするより手元の環境でビルドするほうが快適です。そのための手順を&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2015/12/05/build_rpm_with_mock/&#34;&gt;mockコマンドでrpmをビルドする · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;に書きましたので、ご参照ください。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>