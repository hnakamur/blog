<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on hnakamur&#39;s blog at github</title>
    <link>/blog/tags/golang/</link>
    <description>Recent content in Golang on hnakamur&#39;s blog at github</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Sat, 04 Jun 2016 22:17:52 +0900</lastBuildDate>
    <atom:link href="/blog/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>GoのMessagePackのライブラリのベンチマークをしてみた</title>
      <link>/blog/2016/06/04/benchmark_go_msgpack_libraries/</link>
      <pubDate>Sat, 04 Jun 2016 22:17:52 +0900</pubDate>
      
      <guid>/blog/2016/06/04/benchmark_go_msgpack_libraries/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://qiita.com/yosisa/items/f21d3476bc8d368d7494&#34;&gt;Go の msgpack ライブラリ比較 - Qiita&lt;/a&gt;の記事が最終更新日から1年以上経過しているとのことなので、現在の最新のコミットで試してみました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;github.com/vmihailenco/msgpack&lt;/code&gt; を &lt;code&gt;go get&lt;/code&gt; すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/vmihailenco/msgpack
package github.com/vmihailenco/msgpack: code in directory /home/hnakamur/gocode/src/github.com/vmihailenco/msgpack expects import &amp;quot;gopkg.in/vmihailenco/msgpack.v2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と言われたので &lt;code&gt;go get gopkg.in/vmihailenco/msgpack.v2&lt;/code&gt; で取得し、この記事のコードの &lt;code&gt;&amp;quot;github.com/vmihailenco/msgpack&amp;quot;&lt;/code&gt; を &lt;code&gt;&amp;quot;gopkg.in/vmihailenco/msgpack.v2&amp;quot;&lt;/code&gt; に書き換え &lt;code&gt;msgpack_test.go&lt;/code&gt; という名前で保存して試しました。&lt;/p&gt;

&lt;p&gt;エンコードは &lt;code&gt;gopkg.in/vmihailenco/msgpack.v2&lt;/code&gt; 、デコードは &lt;code&gt;github.com/ugorji/go/codec&lt;/code&gt; が速いという結果になりましたが、総合的にはほぼ同等と言えると思います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test -bench . -benchmem
testing: warning: no tests to run
PASS
BenchmarkCodecEncode-2            500000              3236 ns/op              48 B/op          2 allocs/op
BenchmarkCodecDecode-2            200000              8998 ns/op             264 B/op         25 allocs/op
BenchmarkMsgpackEncode-2          500000              2624 ns/op              48 B/op          2 allocs/op
BenchmarkMsgpackDecode-2          200000             10604 ns/op             448 B/op         35 allocs/op
ok      bitbucket.org/hnakamur/msgpack_experiment       7.146s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ベンチマークに使用したライブラリとGoのバージョンは以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git -C $GOPATH/src/github.com/ugorji/go rev-parse HEAD
a396ed22fc049df733440d90efe17475e3929ccb
$ git -C $GOPATH/src/gopkg.in/vmihailenco/msgpack.v2 rev-parse HEAD
851cd631b60599a692b136c60eb6eb2899b0e664
$ go version
go version go1.6.2 linux/amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/vmihailenco/msgpack&#34;&gt;vmihailenco/msgpack: MessagePack encoding for Golang&lt;/a&gt;のベンチマークもやってみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test -bench . -benchmem                                          
2016/06/04 22:12:13 
************************************************ 
package github.com/ugorji/go-msgpack has been deprecated (05/29/2013). 
It will be retired anytime from July 1, 2013.
Please update to faster and much much better github.com/ugorji/go/codec.
See https://github.com/ugorji/go/tree/master/codec#readme for more information.
************************************************ 
OK: 27 passed, 1 skipped
PASS
BenchmarkBool-2                         20000000                90.3 ns/op             0 B/op          0 allocs/op
BenchmarkInt0-2                         20000000                96.1 ns/op             0 B/op          0 allocs/op
BenchmarkInt1-2                         10000000               123 ns/op               0 B/op          0 allocs/op
BenchmarkInt2-2                         10000000               123 ns/op               0 B/op          0 allocs/op
BenchmarkInt4-2                         10000000               179 ns/op               0 B/op          0 allocs/op
BenchmarkInt8-2                         10000000               176 ns/op               0 B/op          0 allocs/op
BenchmarkInt0Binary-2                    5000000               340 ns/op              24 B/op          3 allocs/op
BenchmarkInt0UgorjiGoMsgpack-2           3000000               586 ns/op               8 B/op          1 allocs/op
BenchmarkInt0UgorjiGoCodec-2             5000000               360 ns/op               0 B/op          0 allocs/op
BenchmarkTime-2                          5000000               353 ns/op               0 B/op          0 allocs/op
BenchmarkDuration-2                     10000000               180 ns/op               0 B/op          0 allocs/op
BenchmarkByteSlice-2                     1000000              1021 ns/op            1024 B/op          1 allocs/op
BenchmarkByteArray-2                      500000              2741 ns/op            2112 B/op          4 allocs/op
BenchmarkByteSliceUgorjiGoCodec-2        2000000               647 ns/op               0 B/op          0 allocs/op
BenchmarkByteArrayUgorjiGoCodec-2        1000000              2632 ns/op            1088 B/op          3 allocs/op
BenchmarkMapStringString-2               1000000              1898 ns/op              16 B/op          4 allocs/op
BenchmarkMapStringStringPtr-2             500000              2461 ns/op              32 B/op          5 allocs/op
BenchmarkMapStringStringUgorjiGoCodec-2  1000000              1737 ns/op              16 B/op          4 allocs/op
BenchmarkMapIntInt-2                      500000              3424 ns/op             208 B/op         10 allocs/op
BenchmarkStringSlice-2                   3000000               530 ns/op              10 B/op          2 allocs/op
BenchmarkStringSlicePtr-2                1000000              1270 ns/op              26 B/op          3 allocs/op
BenchmarkStructVmihailencoMsgpack-2       100000             12732 ns/op            3152 B/op         27 allocs/op
BenchmarkStructMarshal-2                  300000              6003 ns/op            1808 B/op          8 allocs/op
BenchmarkStructUnmarshal-2                200000              5788 ns/op            1344 B/op         19 allocs/op
BenchmarkStructManual-2                   200000              6610 ns/op            2720 B/op         21 allocs/op
BenchmarkStructUgorjiGoMsgpack-2          100000             17138 ns/op            3616 B/op         70 allocs/op
BenchmarkStructUgorjiGoCodec-2            100000             21833 ns/op            7345 B/op         23 allocs/op
BenchmarkStructJSON-2                      20000             63809 ns/op            7896 B/op         26 allocs/op
BenchmarkStructGOB-2                       20000             96275 ns/op           14664 B/op        278 allocs/op
BenchmarkStructUnmarshalPartially-2       300000              5791 ns/op            2272 B/op         12 allocs/op
BenchmarkCSV-2                            200000              6971 ns/op            8748 B/op         12 allocs/op
BenchmarkCSVMsgpack-2                    1000000              1541 ns/op             384 B/op         13 allocs/op
ok      gopkg.in/vmihailenco/msgpack.v2 58.623s
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gopkg-in-vmihailenco-msgpack-v2-でgoのstructをエンコード-デコードするインターフェース:b74e35b057eed94577fdfad5f24e6611&#34;&gt;gopkg.in/vmihailenco/msgpack.v2 でGoのstructをエンコード・デコードするインターフェース&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/gopkg.in/vmihailenco/msgpack.v2#Marshaler&#34;&gt;Marshaler&lt;/a&gt; はdeprecatedで&lt;a href=&#34;https://godoc.org/gopkg.in/vmihailenco/msgpack.v2#CustomEncoder&#34;&gt;CustomEncoder&lt;/a&gt;を使えとのことです。&lt;a href=&#34;https://godoc.org/gopkg.in/vmihailenco/msgpack.v2#CustomEncoder&#34;&gt;CustomEncoder&lt;/a&gt; の Example を見ると使い方も簡単そうです。&lt;/p&gt;

&lt;h2 id=&#34;gopkg-in-vmihailenco-msgpack-v2-を使うことにします:b74e35b057eed94577fdfad5f24e6611&#34;&gt;gopkg.in/vmihailenco/msgpack.v2 を使うことにします&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/vmihailenco/msgpack&#34;&gt;github.com/vmihailenco/msgpack&lt;/a&gt;も&lt;a href=&#34;https://github.com/ugorji/go/tree/master/codec&#34;&gt;go/codec at master · ugorji/go&lt;/a&gt;も活発にメンテナンスされているようです。&lt;/p&gt;

&lt;p&gt;APIドキュメント &lt;a href=&#34;https://godoc.org/gopkg.in/vmihailenco/msgpack.v2&#34;&gt;gopkg.in/vmihailenco/msgpack.v2&lt;/a&gt;、&lt;a href=&#34;https://godoc.org/github.com/ugorji/go/codec&#34;&gt;github.com/ugorji/go/codec&lt;/a&gt; を見ると私は前者のほうがしっくりきました。ということで gopkg.in/vmihailenco/msgpack.v2 を使うことにします。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go-daemonとgoのos.StartProcess()のコードを読んでみた</title>
      <link>/blog/2016/04/23/go-daemon-and-golang-os-startprocess-code-reading/</link>
      <pubDate>Sat, 23 Apr 2016 16:45:09 +0900</pubDate>
      
      <guid>/blog/2016/04/23/go-daemon-and-golang-os-startprocess-code-reading/</guid>
      <description>

&lt;h2 id=&#34;発端-goでデーモンを書くのは無理と思っていたら実は出来るらしい:2b5c8b3f2d099ab733ab91c60a7ca6a5&#34;&gt;発端: Goでデーモンを書くのは無理と思っていたら実は出来るらしい&lt;/h2&gt;

&lt;p&gt;Goでデーモンを書くのは無理と以前どこかで読んだ気がします。
ところが、Pythonで書かれた&lt;a href=&#34;https://github.com/graphite-project&#34;&gt;Graphite Project&lt;/a&gt;の&lt;a href=&#34;https://github.com/graphite-project/carbon&#34;&gt;carbon&lt;/a&gt;をGo言語で実装した&lt;a href=&#34;https://github.com/lomik/go-carbon&#34;&gt;lomik/go-carbon&lt;/a&gt;の Features に Run as daemon と書かれていました。どうやって実現しているのか気になって調べてみたのでメモです。&lt;/p&gt;

&lt;h2 id=&#34;go-carbonでデーモン化するための設定:2b5c8b3f2d099ab733ab91c60a7ca6a5&#34;&gt;go-carbonでデーモン化するための設定&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lomik/go-carbon#configuration&#34;&gt;Configuration&lt;/a&gt;に書いてありますが、設定ファイルの &lt;code&gt;[common]&lt;/code&gt; セクションの &lt;code&gt;user&lt;/code&gt; を指定して、起動オプションに &lt;code&gt;-daemon&lt;/code&gt; を指定すればデーモンとして起動します。&lt;/p&gt;

&lt;h2 id=&#34;コードリーディング:2b5c8b3f2d099ab733ab91c60a7ca6a5&#34;&gt;コードリーディング&lt;/h2&gt;

&lt;p&gt;デーモンとして起動するためのコードは以下のようになっています。
&lt;a href=&#34;https://github.com/lomik/go-carbon/blob/v0.7.1/carbon-agent.go#L103-L137&#34;&gt;https://github.com/lomik/go-carbon/blob/v0.7.1/carbon-agent.go#L103-L137&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if *isDaemon {
		runtime.LockOSThread()

		context := new(daemon.Context)
		if *pidfile != &amp;quot;&amp;quot; {
			context.PidFileName = *pidfile
			context.PidFilePerm = 0644
		}

		if runAsUser != nil {
			uid, err := strconv.ParseInt(runAsUser.Uid, 10, 0)
			if err != nil {
				log.Fatal(err)
			}

			gid, err := strconv.ParseInt(runAsUser.Gid, 10, 0)
			if err != nil {
				log.Fatal(err)
			}

			context.Credential = &amp;amp;syscall.Credential{
				Uid: uint32(uid),
				Gid: uint32(gid),
			}
		}

		child, _ := context.Reborn()

		if child != nil {
			return
		}
		defer context.Release()

		runtime.UnlockOSThread()
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;daemon.Context&lt;/code&gt; は &lt;a href=&#34;https://github.com/sevlyar/go-daemon&#34;&gt;github.com/sevlyar/go-daemon&lt;/a&gt;のfork版の &lt;a href=&#34;https://github.com/lomik/go-daemon&#34;&gt;github.com/lomik/go-daemon&lt;/a&gt;で定義されています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lomik/go-daemon/blob/205ceae1aeac90abdbcae9fca16ba44b407c598d/daemon_posix.go#L20-L61&#34;&gt;Contextの定義&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// A Context describes daemon context.
type Context struct {
	// If PidFileName is non-empty, parent process will try to create and lock
	// pid file with given name. Child process writes process id to file.
	PidFileName string
	// Permissions for new pid file.
	PidFilePerm os.FileMode

	// If LogFileName is non-empty, parent process will create file with given name
	// and will link to fd 2 (stderr) for child process.
	LogFileName string
	// Permissions for new log file.
	LogFilePerm os.FileMode

	// If WorkDir is non-empty, the child changes into the directory before
	// creating the process.
	WorkDir string
	// If Chroot is non-empty, the child changes root directory
	Chroot string

	// If Env is non-nil, it gives the environment variables for the
	// daemon-process in the form returned by os.Environ.
	// If it is nil, the result of os.Environ will be used.
	Env []string
	// If Args is non-nil, it gives the command-line args for the
	// daemon-process. If it is nil, the result of os.Args will be used
	// (without program name).
	Args []string

	// Credential holds user and group identities to be assumed by a daemon-process.
	Credential *syscall.Credential
	// If Umask is non-zero, the daemon-process call Umask() func with given value.
	Umask int

	// Struct contains only serializable public fields (!!!)
	abspath  string
	pidFile  *LockFile
	logFile  *os.File
	nullFile *os.File

	rpipe, wpipe *os.File
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go-carbonのcarbon-agent.goから呼び出していた &lt;code&gt;Context.Reborn()&lt;/code&gt; の定義はこちらです。
&lt;a href=&#34;https://github.com/lomik/go-daemon/blob/205ceae1aeac90abdbcae9fca16ba44b407c598d/daemon_posix.go#L63-L76&#34;&gt;Context.Reborn()&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Reborn runs second copy of current process in the given context.
// function executes separate parts of code in child process and parent process
// and provides demonization of child process. It look similar as the
// fork-daemonization, but goroutine-safe.
// In success returns *os.Process in parent process and nil in child process.
// Otherwise returns error.
func (d *Context) Reborn() (child *os.Process, err error) {
	if !WasReborn() {
		child, err = d.parent()
	} else {
		err = d.child()
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてここで読んでいる &lt;code&gt;Context.parent()&lt;/code&gt; の定義がこちらです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lomik/go-daemon/blob/205ceae1aeac90abdbcae9fca16ba44b407c598d/daemon_posix.go#L97-L130&#34;&gt;Context.parent()&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (d *Context) parent() (child *os.Process, err error) {
	if err = d.prepareEnv(); err != nil {
		return
	}

	defer d.closeFiles()
	if err = d.openFiles(); err != nil {
		return
	}

	attr := &amp;amp;os.ProcAttr{
		Dir:   d.WorkDir,
		Env:   d.Env,
		Files: d.files(),
		Sys: &amp;amp;syscall.SysProcAttr{
			//Chroot:     d.Chroot,
			Credential: d.Credential,
			Setsid:     true,
		},
	}

	if child, err = os.StartProcess(d.abspath, d.Args, attr); err != nil {
		if d.pidFile != nil {
			d.pidFile.Remove()
		}
		return
	}

	d.rpipe.Close()
	encoder := json.NewEncoder(d.wpipe)
	err = encoder.Encode(d)

	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Goの標準ライブラリで &lt;code&gt;os.StartProcess()&lt;/code&gt; というのがあったんですね。APIドキュメントはこちらです。&lt;a href=&#34;https://golang.org/pkg/os/#StartProcess&#34;&gt;os.StartProcess()&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/os/doc.go#L20-L29&#34;&gt;os.StartProcess()の実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// StartProcess starts a new process with the program, arguments and attributes
// specified by name, argv and attr.
//
// StartProcess is a low-level interface. The os/exec package provides
// higher-level interfaces.
//
// If there is an error, it will be of type *PathError.
func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error) {
	return startProcess(name, argv, attr)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/os/exec.go#L34-L56&#34;&gt;os.ProcAttrの定義&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ProcAttr holds the attributes that will be applied to a new process
// started by StartProcess.
type ProcAttr struct {
	// If Dir is non-empty, the child changes into the directory before
	// creating the process.
	Dir string
	// If Env is non-nil, it gives the environment variables for the
	// new process in the form returned by Environ.
	// If it is nil, the result of Environ will be used.
	Env []string
	// Files specifies the open files inherited by the new process.  The
	// first three entries correspond to standard input, standard output, and
	// standard error.  An implementation may support additional entries,
	// depending on the underlying operating system.  A nil entry corresponds
	// to that file being closed when the process starts.
	Files []*File

	// Operating system-specific process creation attributes.
	// Note that setting this field means that your program
	// may not execute properly or even compile on some
	// operating systems.
	Sys *syscall.SysProcAttr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここからはOS依存になりますが、Linuxの実装を見ていきます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_linux.go#L21-L41&#34;&gt;SysProcAttrのLinuxでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type SysProcAttr struct {
	Chroot      string         // Chroot.
	Credential  *Credential    // Credential.
	Ptrace      bool           // Enable tracing.
	Setsid      bool           // Create session.
	Setpgid     bool           // Set process group ID to Pgid, or, if Pgid == 0, to new pid.
	Setctty     bool           // Set controlling terminal to fd Ctty (only meaningful if Setsid is set)
	Noctty      bool           // Detach fd 0 from controlling terminal
	Ctty        int            // Controlling TTY fd
	Foreground  bool           // Place child&#39;s process group in foreground. (Implies Setpgid. Uses Ctty as fd of controlling TTY)
	Pgid        int            // Child&#39;s process group ID if Setpgid.
	Pdeathsig   Signal         // Signal that the process will get when its parent dies (Linux only)
	Cloneflags  uintptr        // Flags for clone calls (Linux only)
	UidMappings []SysProcIDMap // User ID mappings for user namespaces.
	GidMappings []SysProcIDMap // Group ID mappings for user namespaces.
	// GidMappingsEnableSetgroups enabling setgroups syscall.
	// If false, then setgroups syscall will be disabled for the child process.
	// This parameter is no-op if GidMappings == nil. Otherwise for unprivileged
	// users this should be set to false for mappings work.
	GidMappingsEnableSetgroups bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_unix.go#L112-L118&#34;&gt;syscall.CredentialのLinuxなどでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Credential holds user and group identities to be assumed
// by a child process started by StartProcess.
type Credential struct {
	Uid    uint32   // User ID.
	Gid    uint32   // Group ID.
	Groups []uint32 // Supplementary group IDs.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/os/exec_posix.go#L21-L50&#34;&gt;os.startProcess()のLinuxなどでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error) {
	// If there is no SysProcAttr (ie. no Chroot or changed
	// UID/GID), double-check existence of the directory we want
	// to chdir into.  We can make the error clearer this way.
	if attr != nil &amp;amp;&amp;amp; attr.Sys == nil &amp;amp;&amp;amp; attr.Dir != &amp;quot;&amp;quot; {
		if _, err := Stat(attr.Dir); err != nil {
			pe := err.(*PathError)
			pe.Op = &amp;quot;chdir&amp;quot;
			return nil, pe
		}
	}

	sysattr := &amp;amp;syscall.ProcAttr{
		Dir: attr.Dir,
		Env: attr.Env,
		Sys: attr.Sys,
	}
	if sysattr.Env == nil {
		sysattr.Env = Environ()
	}
	for _, f := range attr.Files {
		sysattr.Files = append(sysattr.Files, f.Fd())
	}

	pid, h, e := syscall.StartProcess(name, argv, sysattr)
	if e != nil {
		return nil, &amp;amp;PathError{&amp;quot;fork/exec&amp;quot;, name, e}
	}
	return newProcess(pid, h), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_unix.go#L120-L127&#34;&gt;os.ProcAttrのLinuxなどでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ProcAttr holds attributes that will be applied to a new process started
// by StartProcess.
type ProcAttr struct {
	Dir   string    // Current working directory.
	Env   []string  // Environment.
	Files []uintptr // File descriptors.
	Sys   *SysProcAttr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_unix.go#L238-L242&#34;&gt;syscall.StartProcess()のLinuxなどでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// StartProcess wraps ForkExec for package os.
func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle uintptr, err error) {
	pid, err = forkExec(argv0, argv, attr)
	return pid, 0, err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_unix.go#L132-L231&#34;&gt;syscall.forkExec()のLinuxなどでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error) {
	var p [2]int
	var n int
	var err1 Errno
	var wstatus WaitStatus

	if attr == nil {
		attr = &amp;amp;zeroProcAttr
	}
	sys := attr.Sys
	if sys == nil {
		sys = &amp;amp;zeroSysProcAttr
	}

	p[0] = -1
	p[1] = -1

	// Convert args to C form.
	argv0p, err := BytePtrFromString(argv0)
	if err != nil {
		return 0, err
	}
	argvp, err := SlicePtrFromStrings(argv)
	if err != nil {
		return 0, err
	}
	envvp, err := SlicePtrFromStrings(attr.Env)
	if err != nil {
		return 0, err
	}

	if (runtime.GOOS == &amp;quot;freebsd&amp;quot; || runtime.GOOS == &amp;quot;dragonfly&amp;quot;) &amp;amp;&amp;amp; len(argv[0]) &amp;gt; len(argv0) {
		argvp[0] = argv0p
	}

	var chroot *byte
	if sys.Chroot != &amp;quot;&amp;quot; {
		chroot, err = BytePtrFromString(sys.Chroot)
		if err != nil {
			return 0, err
		}
	}
	var dir *byte
	if attr.Dir != &amp;quot;&amp;quot; {
		dir, err = BytePtrFromString(attr.Dir)
		if err != nil {
			return 0, err
		}
	}

	// Acquire the fork lock so that no other threads
	// create new fds that are not yet close-on-exec
	// before we fork.
	ForkLock.Lock()

	// Allocate child status pipe close on exec.
	if err = forkExecPipe(p[:]); err != nil {
		goto error
	}

	// Kick off child.
	pid, err1 = forkAndExecInChild(argv0p, argvp, envvp, chroot, dir, attr, sys, p[1])
	if err1 != 0 {
		err = Errno(err1)
		goto error
	}
	ForkLock.Unlock()

	// Read child error status from pipe.
	Close(p[1])
	n, err = readlen(p[0], (*byte)(unsafe.Pointer(&amp;amp;err1)), int(unsafe.Sizeof(err1)))
	Close(p[0])
	if err != nil || n != 0 {
		if n == int(unsafe.Sizeof(err1)) {
			err = Errno(err1)
		}
		if err == nil {
			err = EPIPE
		}

		// Child failed; wait for it to exit, to make sure
		// the zombies don&#39;t accumulate.
		_, err1 := Wait4(pid, &amp;amp;wstatus, 0, nil)
		for err1 == EINTR {
			_, err1 = Wait4(pid, &amp;amp;wstatus, 0, nil)
		}
		return 0, err
	}

	// Read got EOF, so pipe closed on exec, so exec succeeded.
	return pid, nil

error:
	if p[0] &amp;gt;= 0 {
		Close(p[0])
		Close(p[1])
	}
	ForkLock.Unlock()
	return 0, err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いよいよ核心に迫ります。
&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_linux.go#L47-L325&#34;&gt;syscall.forkAndExecInChild()のLinuxでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Fork, dup fd onto 0..len(fd), and exec(argv0, argvv, envv) in child.
// If a dup or exec fails, write the errno error to pipe.
// (Pipe is close-on-exec so if exec succeeds, it will be closed.)
// In the child, this function must not acquire any locks, because
// they might have been locked at the time of the fork.  This means
// no rescheduling, no malloc calls, and no new stack segments.
// For the same reason compiler does not race instrument it.
// The calls to RawSyscall are okay because they are assembly
// functions that do not grow the stack.
//go:norace
func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr *ProcAttr, sys *SysProcAttr, pipe int) (pid int, err Errno) {
	// Declare all variables at top in case any
	// declarations require heap allocation (e.g., err1).
	var (
		r1     uintptr
		err1   Errno
		err2   Errno
		nextfd int
		i      int
		p      [2]int
	)

	// Record parent PID so child can test if it has died.
	ppid, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)

	// Guard against side effects of shuffling fds below.
	// Make sure that nextfd is beyond any currently open files so
	// that we can&#39;t run the risk of overwriting any of them.
	fd := make([]int, len(attr.Files))
	nextfd = len(attr.Files)
	for i, ufd := range attr.Files {
		if nextfd &amp;lt; int(ufd) {
			nextfd = int(ufd)
		}
		fd[i] = int(ufd)
	}
	nextfd++

	// Allocate another pipe for parent to child communication for
	// synchronizing writing of User ID/Group ID mappings.
	if sys.UidMappings != nil || sys.GidMappings != nil {
		if err := forkExecPipe(p[:]); err != nil {
			return 0, err.(Errno)
		}
	}

	// About to call fork.
	// No more allocation or calls of non-assembly functions.
	runtime_BeforeFork()
	r1, _, err1 = RawSyscall6(SYS_CLONE, uintptr(SIGCHLD)|sys.Cloneflags, 0, 0, 0, 0, 0)
	if err1 != 0 {
		runtime_AfterFork()
		return 0, err1
	}

	if r1 != 0 {
		// parent; return PID
		runtime_AfterFork()
		pid = int(r1)

		if sys.UidMappings != nil || sys.GidMappings != nil {
			Close(p[0])
			err := writeUidGidMappings(pid, sys)
			if err != nil {
				err2 = err.(Errno)
			}
			RawSyscall(SYS_WRITE, uintptr(p[1]), uintptr(unsafe.Pointer(&amp;amp;err2)), unsafe.Sizeof(err2))
			Close(p[1])
		}

		return pid, 0
	}

	// Fork succeeded, now in child.

	// Wait for User ID/Group ID mappings to be written.
	if sys.UidMappings != nil || sys.GidMappings != nil {
		if _, _, err1 = RawSyscall(SYS_CLOSE, uintptr(p[1]), 0, 0); err1 != 0 {
			goto childerror
		}
		r1, _, err1 = RawSyscall(SYS_READ, uintptr(p[0]), uintptr(unsafe.Pointer(&amp;amp;err2)), unsafe.Sizeof(err2))
		if err1 != 0 {
			goto childerror
		}
		if r1 != unsafe.Sizeof(err2) {
			err1 = EINVAL
			goto childerror
		}
		if err2 != 0 {
			err1 = err2
			goto childerror
		}
	}

	// Enable tracing if requested.
	if sys.Ptrace {
		_, _, err1 = RawSyscall(SYS_PTRACE, uintptr(PTRACE_TRACEME), 0, 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Session ID
	if sys.Setsid {
		_, _, err1 = RawSyscall(SYS_SETSID, 0, 0, 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Set process group
	if sys.Setpgid || sys.Foreground {
		// Place child in process group.
		_, _, err1 = RawSyscall(SYS_SETPGID, 0, uintptr(sys.Pgid), 0)
		if err1 != 0 {
			goto childerror
		}
	}

	if sys.Foreground {
		pgrp := int32(sys.Pgid)
		if pgrp == 0 {
			r1, _, err1 = RawSyscall(SYS_GETPID, 0, 0, 0)
			if err1 != 0 {
				goto childerror
			}

			pgrp = int32(r1)
		}

		// Place process group in foreground.
		_, _, err1 = RawSyscall(SYS_IOCTL, uintptr(sys.Ctty), uintptr(TIOCSPGRP), uintptr(unsafe.Pointer(&amp;amp;pgrp)))
		if err1 != 0 {
			goto childerror
		}
	}

	// Chroot
	if chroot != nil {
		_, _, err1 = RawSyscall(SYS_CHROOT, uintptr(unsafe.Pointer(chroot)), 0, 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// User and groups
	if cred := sys.Credential; cred != nil {
		ngroups := uintptr(len(cred.Groups))
		if ngroups &amp;gt; 0 {
			groups := unsafe.Pointer(&amp;amp;cred.Groups[0])
			_, _, err1 = RawSyscall(SYS_SETGROUPS, ngroups, uintptr(groups), 0)
			if err1 != 0 {
				goto childerror
			}
		}
		_, _, err1 = RawSyscall(SYS_SETGID, uintptr(cred.Gid), 0, 0)
		if err1 != 0 {
			goto childerror
		}
		_, _, err1 = RawSyscall(SYS_SETUID, uintptr(cred.Uid), 0, 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Chdir
	if dir != nil {
		_, _, err1 = RawSyscall(SYS_CHDIR, uintptr(unsafe.Pointer(dir)), 0, 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Parent death signal
	if sys.Pdeathsig != 0 {
		_, _, err1 = RawSyscall6(SYS_PRCTL, PR_SET_PDEATHSIG, uintptr(sys.Pdeathsig), 0, 0, 0, 0)
		if err1 != 0 {
			goto childerror
		}

		// Signal self if parent is already dead. This might cause a
		// duplicate signal in rare cases, but it won&#39;t matter when
		// using SIGKILL.
		r1, _, _ = RawSyscall(SYS_GETPPID, 0, 0, 0)
		if r1 != ppid {
			pid, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)
			_, _, err1 := RawSyscall(SYS_KILL, pid, uintptr(sys.Pdeathsig), 0)
			if err1 != 0 {
				goto childerror
			}
		}
	}

	// Pass 1: look for fd[i] &amp;lt; i and move those up above len(fd)
	// so that pass 2 won&#39;t stomp on an fd it needs later.
	if pipe &amp;lt; nextfd {
		_, _, err1 = RawSyscall(_SYS_dup, uintptr(pipe), uintptr(nextfd), 0)
		if err1 != 0 {
			goto childerror
		}
		RawSyscall(SYS_FCNTL, uintptr(nextfd), F_SETFD, FD_CLOEXEC)
		pipe = nextfd
		nextfd++
	}
	for i = 0; i &amp;lt; len(fd); i++ {
		if fd[i] &amp;gt;= 0 &amp;amp;&amp;amp; fd[i] &amp;lt; int(i) {
			_, _, err1 = RawSyscall(_SYS_dup, uintptr(fd[i]), uintptr(nextfd), 0)
			if err1 != 0 {
				goto childerror
			}
			RawSyscall(SYS_FCNTL, uintptr(nextfd), F_SETFD, FD_CLOEXEC)
			fd[i] = nextfd
			nextfd++
			if nextfd == pipe { // don&#39;t stomp on pipe
				nextfd++
			}
		}
	}

	// Pass 2: dup fd[i] down onto i.
	for i = 0; i &amp;lt; len(fd); i++ {
		if fd[i] == -1 {
			RawSyscall(SYS_CLOSE, uintptr(i), 0, 0)
			continue
		}
		if fd[i] == int(i) {
			// dup2(i, i) won&#39;t clear close-on-exec flag on Linux,
			// probably not elsewhere either.
			_, _, err1 = RawSyscall(SYS_FCNTL, uintptr(fd[i]), F_SETFD, 0)
			if err1 != 0 {
				goto childerror
			}
			continue
		}
		// The new fd is created NOT close-on-exec,
		// which is exactly what we want.
		_, _, err1 = RawSyscall(_SYS_dup, uintptr(fd[i]), uintptr(i), 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// By convention, we don&#39;t close-on-exec the fds we are
	// started with, so if len(fd) &amp;lt; 3, close 0, 1, 2 as needed.
	// Programs that know they inherit fds &amp;gt;= 3 will need
	// to set them close-on-exec.
	for i = len(fd); i &amp;lt; 3; i++ {
		RawSyscall(SYS_CLOSE, uintptr(i), 0, 0)
	}

	// Detach fd 0 from tty
	if sys.Noctty {
		_, _, err1 = RawSyscall(SYS_IOCTL, 0, uintptr(TIOCNOTTY), 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Set the controlling TTY to Ctty
	if sys.Setctty {
		_, _, err1 = RawSyscall(SYS_IOCTL, uintptr(sys.Ctty), uintptr(TIOCSCTTY), 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Time to exec.
	_, _, err1 = RawSyscall(SYS_EXECVE,
		uintptr(unsafe.Pointer(argv0)),
		uintptr(unsafe.Pointer(&amp;amp;argv[0])),
		uintptr(unsafe.Pointer(&amp;amp;envv[0])))

childerror:
	// send error code on pipe
	RawSyscall(SYS_WRITE, uintptr(pipe), uintptr(unsafe.Pointer(&amp;amp;err1)), unsafe.Sizeof(err1))
	for {
		RawSyscall(SYS_EXIT, 253, 0, 0)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linuxシステムコールの呼び出しのうち気になったところだけをピックアップします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/clone.2.html&#34;&gt;clone(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/setsid.2.html&#34;&gt;setsid(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/chroot.2.html&#34;&gt;chroot(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/setgid.2.html&#34;&gt;setgid(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/setuid.2.html&#34;&gt;setuid(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/chdir.2.html&#34;&gt;chdir(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://www.oreilly.co.jp/books/9784873115856/&#34;&gt;O&amp;rsquo;Reilly Japan - Linuxプログラミングインタフェース&lt;/a&gt;の「デーモン」の章を見ると、デーモン化の手順として7つの項目が上げられていますが、それら全てを行っているわけではないようです。&lt;/p&gt;

&lt;p&gt;例えばumaskのクリアは、上のコードをざっと見た感じではやってなさそうな感じです。&lt;/p&gt;

&lt;p&gt;また、ファイルディスクリプタ0, 1, 2をクローズはしていますが、 /dev/null をオープンはしていないようです。「通常は /dev/null をオープンする」と書いてあるので問題はなさそうです。&lt;/p&gt;

&lt;p&gt;端末デバイスからの切り離しは &lt;a href=&#34;http://man7.org/linux/man-pages/man2/ioctl.2.html&#34;&gt;ioctl(2) - Linux manual page&lt;/a&gt; に &lt;code&gt;TIOCNOTTY&lt;/code&gt; を指定して行っています。 &lt;code&gt;TIOCNOTTY&lt;/code&gt; については &lt;a href=&#34;http://man7.org/linux/man-pages/man4/tty.4.html&#34;&gt;tty(4) - Linux manual page&lt;/a&gt; に説明がありました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;syscall.SysProcAttr&lt;/code&gt; の &lt;code&gt;Setctty&lt;/code&gt; に &lt;code&gt;true&lt;/code&gt; を指定していた場合は、 &lt;a href=&#34;http://man7.org/linux/man-pages/man2/ioctl.2.html&#34;&gt;ioctl(2) - Linux manual page&lt;/a&gt; に &lt;code&gt;TIOCSCTTY&lt;/code&gt; を指定して制御端末の設定を行っています。 &lt;code&gt;TIOCSCTTY&lt;/code&gt; については &lt;a href=&#34;http://man7.org/linux/man-pages/man4/tty.4.html&#34;&gt;tty(4) - Linux manual page&lt;/a&gt; に説明がありました。&lt;/p&gt;

&lt;p&gt;ということで、&lt;a href=&#34;http://www.oreilly.co.jp/books/9784873115856/&#34;&gt;O&amp;rsquo;Reilly Japan - Linuxプログラミングインタフェース&lt;/a&gt;のデーモン化の手順の全てではないですが、かなりの部分は &lt;a href=&#34;https://golang.org/pkg/os/#StartProcess&#34;&gt;os - The Go Programming Language&lt;/a&gt; で実現できるということがわかりました。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>