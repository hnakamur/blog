<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rpmbuild on hnakamur&#39;s blog at github</title>
    <link>/blog/tags/rpmbuild/</link>
    <description>Recent content in Rpmbuild on hnakamur&#39;s blog at github</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Wed, 16 Dec 2015 01:10:33 +0900</lastBuildDate>
    <atom:link href="/blog/tags/rpmbuild/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>mockを使ったrpmビルドが失敗した時の調査方法</title>
      <link>/blog/2015/12/16/how_to_debug_errors_in_rpm_build_using_mock/</link>
      <pubDate>Wed, 16 Dec 2015 01:10:33 +0900</pubDate>
      
      <guid>/blog/2015/12/16/how_to_debug_errors_in_rpm_build_using_mock/</guid>
      <description>

&lt;h2 id=&#34;はじめに:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/&#34;&gt;nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;でspecファイルを書いている最中はmockでのrpmのビルドに失敗することがよくあります。&lt;/p&gt;

&lt;p&gt;私は「なんとなくこんな感じか？」と書いて動かしてみてエラーを見て修正していくスタイルなので、失敗時の調査は重要です。&lt;/p&gt;

&lt;h2 id=&#34;ビルドログ:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;ビルドログ&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sudo mock -r epel-7-x86_64 --rebuild ${srpmファイル名}&lt;/code&gt; のように実行してビルドした場合、 &lt;code&gt;/var/lib/mock/epel-7-x86_64/result/&lt;/code&gt; に &lt;code&gt;build.log&lt;/code&gt; というファイルができるのでそれを見ます。&lt;/p&gt;

&lt;h2 id=&#34;mockコマンドでchroot環境内に入る:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;mockコマンドでchroot環境内に入る&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://linux.die.net/man/1/mock&#34;&gt;mock(1)のmanページ&lt;/a&gt;によると &lt;code&gt;sudo mock -r epel-7-x86_64 --shell&lt;/code&gt; でchroot環境内に入ることが出来ます。 &lt;code&gt;exit&lt;/code&gt; で抜けます。&lt;/p&gt;

&lt;p&gt;mockで作られるchroot環境はビルドに必要な最低限のパッケージしかインストールされておらず、 &lt;code&gt;vim&lt;/code&gt; や &lt;code&gt;less&lt;/code&gt; も使えません。 &lt;code&gt;yum&lt;/code&gt; で入れようにも &lt;code&gt;yum&lt;/code&gt; も無いと言われてしまいます。&lt;/p&gt;

&lt;p&gt;chroot環境に入る前に &lt;code&gt;sudo mock -r epel-7-x86_64 --install vim less&lt;/code&gt; のようにしてインストールしておけばchroot内でvimやlessが使えます。&lt;/p&gt;

&lt;p&gt;あるいはchroot外で &lt;code&gt;/var/lib/mock/epel-7-x86_64/root/&lt;/code&gt; 配下のファイルをvimやlessで見るという手もあります。&lt;/p&gt;

&lt;h2 id=&#34;chroot環境内のrpmビルドディレクトリ:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;chroot環境内のrpmビルドディレクトリ&lt;/h2&gt;

&lt;p&gt;chroot環境内では &lt;code&gt;/builddir/build/&lt;/code&gt; 以下に &lt;code&gt;BUILD&lt;/code&gt;, &lt;code&gt;BUILDDIR&lt;/code&gt;, &lt;code&gt;SOURCES&lt;/code&gt;, &lt;code&gt;SPECS&lt;/code&gt; などのディレクトリが作られているので、これらの中を見ればビルド失敗時の状況を調べられます。&lt;/p&gt;

&lt;h2 id=&#34;chroot環境内でファイルを修正してビルドを再実行:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;chroot環境内でファイルを修正してビルドを再実行&lt;/h2&gt;

&lt;p&gt;mockを使ったrpmビルドはchroot環境を作成してその中で行われるのですが、毎回chroot環境を作るところからやっていると時間がかかって効率が悪いです。&lt;/p&gt;

&lt;p&gt;ですので、chroot環境内のspecファイルや &lt;code&gt;SOURCES&lt;/code&gt; ディレクトリ下のファイルを直接修正して、その後 &lt;code&gt;rpmbuild -bb ${specファイル名}&lt;/code&gt; でrpmのビルドを再度試します。&lt;/p&gt;

&lt;h2 id=&#34;修正したファイルをdockerコンテナ外に取り出す:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;修正したファイルをdockerコンテナ外に取り出す&lt;/h2&gt;

&lt;p&gt;修正のきりが良い所で、chroot環境内の修正したファイルを &lt;code&gt;docker cp&lt;/code&gt; コマンドでdockerコンテナ内からコンテナ外に取り出します。&lt;/p&gt;

&lt;p&gt;まずdockerホストで &lt;code&gt;docker ps&lt;/code&gt; コマンドでコンテナIDかコンテナ名を調べます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
363ad4f85fda        nginxrpm            &amp;quot;/bin/bash&amp;quot;         18 hours ago        Up 18 hours                             romantic_fermi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に &lt;code&gt;docker cp&lt;/code&gt; コマンドでファイルをコピーします。例えばこんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker cp romantic_fermi:/var/lib/mock/epel-7-x86_64/root/builddir/build/SPECS/nginx.spec SPECS/nginx.spec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取り出した修正ファイルはgitにコミットして、さらに修正作業を続けていきます。&lt;/p&gt;

&lt;p&gt;修正が一通り終わったら、クリーンな状態からビルドが成功することを確認するため、dockerコンテナを一度破棄して&lt;a href=&#34;http://localhost:1313/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/&#34;&gt;nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました · hnakamur&amp;rsquo;s blog at github&lt;/a&gt; の手順で再度ビルドしてみます。これでエラーが出なければOKです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;mockを使ったrpmのビルドが失敗した場合の調査方法を紹介しました。もっと良い方法などありましたら、ぜひ教えてください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rpmのspecファイルのSourceにGitHubの任意のコミットのtarballのURLを指定するときの良い書き方</title>
      <link>/blog/2015/12/06/good_rpm_spec_source_url_syntax_for_tarball_on_github/</link>
      <pubDate>Sun, 06 Dec 2015 00:07:23 +0900</pubDate>
      
      <guid>/blog/2015/12/06/good_rpm_spec_source_url_syntax_for_tarball_on_github/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Packaging:SourceURL?rd=Packaging/SourceURL#Commit_Revision&#34;&gt;Packaging:SourceURL - FedoraProject&lt;/a&gt;で知ったtipsの紹介です。&lt;/p&gt;

&lt;p&gt;GitHubでプロジェクトの[Download ZIP]ボタンを押すと、ソースをZIP形式でダウンロードできます。
コミット数が多いプロジェクトだと &lt;code&gt;git clone&lt;/code&gt; するよりも高速に取得できるので履歴が不要な場合には便利な方法です。&lt;/p&gt;

&lt;p&gt;例えば&lt;a href=&#34;https://github.com/openresty/lua-nginx-module&#34;&gt;openresty/lua-nginx-module&lt;/a&gt;なら &lt;code&gt;https://github.com/openresty/lua-nginx-module/archive/master.zip&lt;/code&gt; というURLになるのですが、 &lt;code&gt;.zip&lt;/code&gt; を &lt;code&gt;.tar.gz&lt;/code&gt; に変えればtar.gz形式でダウンロードできます。&lt;/p&gt;

&lt;p&gt;また、 &lt;code&gt;master&lt;/code&gt; の部分はブランチ名、タグ名、コミットハッシュを指定することも出来るので任意のコミットのソースを取得可能です。&lt;/p&gt;

&lt;p&gt;好みのファイル名でダウンロードするのは、通常ならダウンロードするツール側で対応すれば良い話です。例えば&lt;a href=&#34;http://linux.die.net/man/1/curl&#34;&gt;curl(1): transfer URL - Linux man page&lt;/a&gt;を使う場合は &lt;code&gt;-o&lt;/code&gt; オプションで &lt;code&gt;-o ファイル名&lt;/code&gt; のように指定すれば良いだけです。&lt;/p&gt;

&lt;p&gt;ただ、RPMのspecファイルの &lt;code&gt;Source:&lt;/code&gt; に指定するときはちょっと厄介です。
&lt;a href=&#34;https://fedoraproject.org/wiki/How_to_create_an_RPM_package#SPEC_file_overview&#34;&gt;SPEC file overview&lt;/a&gt;の &lt;code&gt;Source0&lt;/code&gt; の説明を読むと、URLのベースネーム (最後のスラッシュの後の部分) が &lt;code&gt;~/rpmbuild/SOURCES&lt;/code&gt; ディレクトリ配下に置くファイル名になるようにするべきとあります。&lt;/p&gt;

&lt;p&gt;しかし、上述のようにGitHubでソースのtarballのURLのベースネームは &lt;code&gt;コミットハッシュなど.tar.gz&lt;/code&gt; という形式となっています。これだと複数のソースをダウンロードした時に、どれがどれかわかりにくいですし、 &lt;code&gt;バージョン番号.tar.gz&lt;/code&gt; の場合だとファイル名が衝突する恐れもあります。&lt;/p&gt;

&lt;p&gt;解決策ですが、元のURLに &lt;code&gt;#/&lt;/code&gt; をつけてその後に好きなファイル名を指定すればOKです。具体的には &lt;code&gt;https://github.com/ユーザ名/プロジェクト名/archive/コミットハッシュなど.tar.gz#/プロジェクト名-コミットハッシュなど.tar.gz&lt;/code&gt; のように書きます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Packaging:SourceURL?rd=Packaging/SourceURL#Commit_Revision&#34;&gt;Packaging:SourceURL - FedoraProject&lt;/a&gt;にはbitbucket.orgとgitlab.comの場合の書き方も紹介されていますので、必要に応じてご参照ください。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>