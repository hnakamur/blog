<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rpmbuild on hnakamur&#39;s blog at github</title>
    <link>https://hnakamur.github.io/blog/tags/rpmbuild/index.xml</link>
    <description>Recent content in Rpmbuild on hnakamur&#39;s blog at github</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <atom:link href="https://hnakamur.github.io/blog/tags/rpmbuild/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>CentOS 7用にPython2最新版のrpmを作ってみた</title>
      <link>https://hnakamur.github.io/blog/2015/12/19/build_latest_python2_rpm_for_centos7/</link>
      <pubDate>Sat, 19 Dec 2015 11:51:30 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2015/12/19/build_latest_python2_rpm_for_centos7/</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2015/12/16/calling_copr_api_with_curl/&#34;&gt;coprのAPIをcurlで呼び出す · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;にも書きましたが、CentOS 7のPythonは古くてhttps通信時にInsecurePlatformWarningが出てしまいます。&lt;/p&gt;

&lt;p&gt;そこで、&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-python-2.7.8-3.el7/&#34;&gt;Software CollectionsのPython27のpythonパッケージ&lt;/a&gt;を改変してPython2の最新版2.7.11のrpmを作ってみました。
&lt;a href=&#34;https://www.softwarecollections.org/en/&#34;&gt;Software Collections&lt;/a&gt;のrpmをベースにしていますので、CentOS 7にインストールされているPythonとは共存可能となっています。&lt;/p&gt;

&lt;h2 id=&#34;python2の最新版rpmの利用方法&#34;&gt;Python2の最新版rpmの利用方法&lt;/h2&gt;

&lt;p&gt;先に利用方法を書いておきます。&lt;/p&gt;

&lt;h3 id=&#34;インストール手順&#34;&gt;インストール手順&lt;/h3&gt;

&lt;p&gt;dockerのcentos:7コンテナにインストールする例で説明します。まず以下のコマンドでコンテナを起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -it centos:7 /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に以下のコマンドを実行してPython2をインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sL -o /etc/yum.repos.d/hnakamur-hnscl-python2.repo https://copr.fedoraproject.org/coprs/hnakamur/hnscl-python2/repo/epel-7/hnakamur-hnscl-python2-epel-7.repo
curl -sL -o /etc/yum.repos.d/hnakamur-hnscl-python2-python.repo https://copr.fedoraproject.org/coprs/hnakamur/hnscl-python2-python/repo/epel-7/hnakamur-hnscl-python2-python-epel-7.repo
yum -y install hn-python2-python
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使い方&#34;&gt;使い方&lt;/h3&gt;

&lt;p&gt;以下のコマンドでPython2最新版用のシェルを起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scl enable hn-python2 bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは通常通りpythonコマンドを実行すればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# which python
/opt/hn/hn-python2/root/usr/bin/python
# python -V
Python 2.7.11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使い終わったら &lt;code&gt;exit&lt;/code&gt; で上記で起動したシェルを抜けてください。&lt;/p&gt;

&lt;p&gt;ちなみに、Software Collectionsで提供されているPython 2.7のインストール方法は&lt;a href=&#34;https://www.softwarecollections.org/en/scls/rhscl/python27/&#34;&gt;Python 2.7 — Software Collections&lt;/a&gt;です。&lt;/p&gt;

&lt;h2 id=&#34;python2の最新版rpmを作った時のメモ&#34;&gt;Python2の最新版rpmを作った時のメモ&lt;/h2&gt;

&lt;p&gt;以下はrpmを作った時のメモです。&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/&#34;&gt;Packaging Guide — Software Collections&lt;/a&gt;を読みながら試行錯誤してrpmを作りました。&lt;/p&gt;

&lt;h3 id=&#34;software-collectionsのメタパッケージ&#34;&gt;Software Collectionsのメタパッケージ&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-Package_Layout&#34;&gt;Packaging Guide — Software Collections&lt;/a&gt;で説明されていますが、Software Collectionsではメタパッケージというのを作成します。&lt;/p&gt;

&lt;p&gt;例えば今回ベースにしたPython 2.7だと&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-1.1-20.el7/&#34;&gt;python27&lt;/a&gt;というのがメタパッケージで、　Python2本体のパッケージは&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-python-2.7.8-3.el7/&#34;&gt;Software CollectionsのPython27のpythonパッケージ&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;Software Collectionsを自作する場合は、パッケージ名が衝突しないように「組織名-」という接頭辞をつけるようにと&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-The_Software_Collections_Prefix&#34;&gt;2.4. The Software Collection Prefix&lt;/a&gt;に書かれています。公式のソフトウェアコレクションは接頭辞無しで &lt;code&gt;python27&lt;/code&gt; のようなコレクション名になっています。&lt;/p&gt;

&lt;p&gt;また、&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-The_File_System_Hierarchy&#34;&gt;2.2. The File System Hierarchy&lt;/a&gt;に書かれているように、ソフトウェアコレクションのrpmに含まれるファイルは &lt;code&gt;/opt/提供者名/ソフトウェアコレクション名/&lt;/code&gt; というディレクトリ構成を取ります。公式のソフトウェアコレクションは &lt;code&gt;/opt/rh/ソフトウェアコレクション名/&lt;/code&gt; というディレクトリになっています。rhはredhatの略だと思います。&lt;/p&gt;

&lt;p&gt;今回は &lt;code&gt;hn-python2&lt;/code&gt; というメタパッケージ名とし、ディレクトリは &lt;code&gt;/opt/hn/python2/&lt;/code&gt; としました。&lt;/p&gt;

&lt;h3 id=&#34;software-collectionsのメタパッケージのビルド&#34;&gt;Software Collectionsのメタパッケージのビルド&lt;/h3&gt;

&lt;p&gt;ビルド用のファイルは&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-rpm&#34;&gt;hnakamur/hnscl-python2-rpm&lt;/a&gt;に置いてあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-The_Software_Collection_Root_Directory&#34;&gt;2.3. The Software Collection Root Directory&lt;/a&gt;によるとspecファイルに以下のように書けばよいそうです。providerの箇所は提供者ごとの値に変えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%global _scl_prefix /opt/provider
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ですが、実際に試してみるとこの設定だけだと、ビルドされたrpm内のファイルパスだったりファイルの中身に &lt;code&gt;/opt/rh/&lt;/code&gt; というパスが残ってしまいました。試行錯誤の結果以下のように書くことで全て &lt;code&gt;/opt/hn/&lt;/code&gt; に変わりました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-rpm/blob/06a6fa366bd485d722139f0637ce2def364eaef3/SPECS/hn-python2.spec#L1-L22&#34;&gt;hn-python2-spec&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%global scl_name_prefix hn-
%global scl_name_base python
%global scl_name_version 2
%global scl %{scl_name_prefix}%{scl_name_base}%{scl_name_version}

# NOTE: You must set _scl_prefix before &#39;%scl_package %scl&#39;.
%global _scl_prefix /opt/hn
# NOTE: The following variables must be re-evaluated after changing _scl_prefix above.
# I got these settings after trials and errors.
# I don&#39;t know this is the right way to set directories with my _scl_prefix.
%global _scl_scripts            %{_scl_prefix}/%{scl}
%global _scl_root               %{_scl_prefix}/%{scl}/root
%global _prefix                 %{_scl_root}/usr
%global _sysconfdir             %{_scl_root}/etc
%global _sharedstatedir         %{_scl_root}/var/lib
%global _localstatedir          %{_scl_root}/var
%global _datadir                %{_scl_root}/share
%global _docdir                 %{_datadir}/doc
%global _mandir                 %{_datadir}/man


%scl_package %scl
...(snip)...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;python本体のパッケージのビルド&#34;&gt;Python本体のパッケージのビルド&lt;/h3&gt;

&lt;p&gt;ビルド用のファイルは&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm&#34;&gt;hnakamur/hnscl-python2-python-rpm&lt;/a&gt;に置いてあります。&lt;/p&gt;

&lt;p&gt;インストールディレクトリを &lt;code&gt;/opt/hn/&lt;/code&gt; 以下にするため、試行錯誤した結果specファイルに以下のように書けばOKでした。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/blob/3a13fe74587d6beca871d28a68149a2273488672/SPECS/python.spec#L1-L31&#34;&gt;python.spec&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%global scl_name_prefix hn-
%global scl_name_base python
%global scl_name_version 2
%global scl %{scl_name_prefix}%{scl_name_base}%{scl_name_version}

# NOTE: You must set _scl_prefix before &#39;%scl_package %scl&#39;.
%global _scl_prefix /opt/hn
# NOTE: The following variables must be re-evaluated after changing _scl_prefix above.
%global _scl_scripts            %{_scl_prefix}/%{scl}
%global _scl_root               %{_scl_prefix}/%{scl}/root
%global _prefix                 %{_scl_root}/usr
%global _sysconfdir             %{_scl_root}/etc
%global _sharedstatedir         %{_scl_root}/var/lib
%global _localstatedir          %{_scl_root}/var

%global _includedir             %{_prefix}/include
%if &amp;quot;%{_lib}&amp;quot; == &amp;quot;lib64&amp;quot;
%global _libdir                 %{_prefix}/lib64
%else
%global _libdir                 %{_prefix}/lib
%endif
%global _datadir                %{_prefix}/share
%global _docdir                 %{_prefix}/share/doc
%global _datarootdir            %{_prefix}/share
%global _infodir                %{_prefix}/share/info
%global _mandir                 %{_prefix}/share/man
%global _defaultdocdir          %{_prefix}/share/doc

%global _exec_prefix            %{_prefix}
%global _bindir                 %{_exec_prefix}/bin
%global _sbindir                %{_exec_prefix}/sbin
...(snip)...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;python本体のspecファイルのパッチ更新&#34;&gt;Python本体のspecファイルのパッチ更新&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/blob/3a13fe74587d6beca871d28a68149a2273488672/SPECS/python.spec&#34;&gt;python.spec&lt;/a&gt;には約60個のパッチが含まれています。&lt;/p&gt;

&lt;p&gt;Pythonのソースのバージョンを上げたのでパッチが当たらなくなるケースが出てきました。patchを実行した時に生成される &lt;code&gt;*.rej&lt;/code&gt; ファイルを見て、なんとなくこんな感じだろという軽いノリでパッチを一通り更新しました。&lt;/p&gt;

&lt;p&gt;作業手順は&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2015/12/16/how_to_debug_errors_in_rpm_build_using_mock/&#34;&gt;mockを使ったrpmビルドが失敗した時の調査方法 · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;に書いた手順で、mockのchroot環境内でパッチを修正して &lt;code&gt;rpmbuild -bp specファイル名&lt;/code&gt; でパッチを当てるというのをひたすら繰り返した感じです。&lt;/p&gt;

&lt;p&gt;パッチ1つごとの修正を&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/commits/master&#34;&gt;Commits · hnakamur/hnscl-python2-python-rpm&lt;/a&gt;のだいたい1つのコミットにしています。ただ、後からさらに修正が必要だったものは別コミットになっていますが。&lt;/p&gt;

&lt;p&gt;また、CentOSのPythonのspecファイルではリリースビルドとデバッグビルドを作ってテストも実行するようになっています。これがかなり時間がかるので、ビルドが通らない段階では&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/commit/ebb31040e3e5bfe0ceb62cd4eb67793bd1a333b0&#34;&gt;リリースビルドだけにしてテストは実行しないようにしていました&lt;/a&gt;。ビルドが落ち着いてきたところで&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/commit/8a293e3dbd25f6cb6638b00efc07ce5cf962a397&#34;&gt;この変更をgit revert&lt;/a&gt;してビルド・テストするようにしました。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-python-2.7.8-3.el7/&#34;&gt;Software CollectionsのPython27のpythonパッケージ&lt;/a&gt;を改変して作ったPython2の最新版2.7.11のrpmについて説明しました。&lt;/p&gt;

&lt;p&gt;CentOS 7でもPython2の最新版が手軽に利用可能になるので、ぜひご活用ください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mockやcoprでrpmをビルドする際にサードパーティのレポジトリを追加する方法</title>
      <link>https://hnakamur.github.io/blog/2015/12/18/add_third_party_to_build_on_mock_and_copr/</link>
      <pubDate>Fri, 18 Dec 2015 01:43:28 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2015/12/18/add_third_party_to_build_on_mock_and_copr/</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Mock&#34;&gt;Mock&lt;/a&gt;や&lt;a href=&#34;https://copr.fedoraproject.org/&#34;&gt;copr&lt;/a&gt;でrpmをビルドする際にCentOS標準のレポジトリ以外のサードパーティのレポジトリのrpmに依存したい場合があります。この記事ではサードパーティのレポジトリの追加方法を説明します。&lt;/p&gt;

&lt;p&gt;この記事では&lt;a href=&#34;https://www.varnish-cache.org/vmod/header-manipulation&#34;&gt;libvmod-header&lt;/a&gt;をビルドするために&lt;a href=&#34;https://www.varnish-cache.org/installation/redhat&#34;&gt;varnish-cache.orgのRedHat用インストール手順&lt;/a&gt;で提供されているEL7用のレポジトリを追加する例で説明します。&lt;/p&gt;

&lt;p&gt;ビルドするために私が作成したDockerfileとシェルスクリプトは&lt;a href=&#34;https://github.com/hnakamur/libvmod-header-rpm&#34;&gt;hnakamur/libvmod-header-rpm&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h2 id=&#34;mockでのrpmビルド時にサードパーティのレポジトリを追加する方法&#34;&gt;Mockでのrpmビルド時にサードパーティのレポジトリを追加する方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lists.fedorahosted.org/pipermail/softwarecollections/2012-November/000018.html&#34;&gt;Building SCL packages with mock&lt;/a&gt;で紹介されていた方法です。&lt;/p&gt;

&lt;p&gt;CentOS 7用のrpmをビルドする場合 &lt;code&gt;/etc/mock/epel-7-x86_64.cfg&lt;/code&gt; をコピーして &lt;code&gt;/etc/mock/epel-7-varnish-x86_64.cfg&lt;/code&gt; のように別名で保存します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/mock/epel-7-varnish-x86_64.cfg&lt;/code&gt; の最後に &lt;code&gt;config_opts[&#39;yum.conf&#39;]&lt;/code&gt; の設定があります。変更前は以下のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config_opts[&#39;root&#39;] = &#39;epel-7-x86_64&#39;
config_opts[&#39;target_arch&#39;] = &#39;x86_64&#39;
config_opts[&#39;legal_host_arches&#39;] = (&#39;x86_64&#39;,)
config_opts[&#39;chroot_setup_cmd&#39;] = &#39;install @buildsys-build&#39;
config_opts[&#39;dist&#39;] = &#39;el7&#39;  # only useful for --resultdir variable subst
config_opts[&#39;releasever&#39;] = &#39;7&#39;

config_opts[&#39;yum.conf&#39;] = &amp;quot;&amp;quot;&amp;quot;
[main]
keepcache=1
debuglevel=2
reposdir=/dev/null
logfile=/var/log/yum.log
retries=20
obsoletes=1
gpgcheck=0
assumeyes=1
syslog_ident=mock
syslog_device=

# repos
[base]
name=BaseOS
mirrorlist=http://mirrorlist.centos.org/?release=7&amp;amp;arch=x86_64&amp;amp;repo=os
failovermethod=priority
gpgkey=file:///etc/pki/mock/RPM-GPG-KEY-CentOS-7
gpgcheck=1

[updates]
name=updates
enabled=1
mirrorlist=http://mirrorlist.centos.org/?release=7&amp;amp;arch=x86_64&amp;amp;repo=updates
failovermethod=priority
gpgkey=file:///etc/pki/mock/RPM-GPG-KEY-CentOS-7
gpgcheck=1

[epel]
name=epel
mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=epel-7&amp;amp;arch=x86_64
failovermethod=priority
gpgkey=file:///etc/pki/mock/RPM-GPG-KEY-EPEL-7
gpgcheck=1

[extras]
name=extras
mirrorlist=http://mirrorlist.centos.org/?release=7&amp;amp;arch=x86_64&amp;amp;repo=extras
failovermethod=priority
gpgkey=file:///etc/pki/mock/RPM-GPG-KEY-EPEL-7
gpgcheck=1

[testing]
name=epel-testing
enabled=0
mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=testing-epel7&amp;amp;arch=x86_64
failovermethod=priority


[local]
name=local
baseurl=http://kojipkgs.fedoraproject.org/repos/epel7-build/latest/x86_64/
cost=2000
enabled=0

[epel-debug]
name=epel-debug
mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=epel-debug-7&amp;amp;arch=x86_64
failovermethod=priority
enabled=0
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;失敗例1&#34;&gt;失敗例1&lt;/h3&gt;

&lt;p&gt;varnish-cache.orgではEL7用のレポジトリ定義が &lt;a href=&#34;https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm&#34;&gt;https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm&lt;/a&gt; で配布されています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;config_opts[&#39;chroot_setup_cmd&#39;] = &#39;install @buildsys-build&#39;&lt;/code&gt; にこのrpmのURLを追加して
&lt;code&gt;config_opts[&#39;chroot_setup_cmd&#39;] = &#39;install @buildsys-build https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm&#39;&lt;/code&gt; にするというのを試してみましたが、これは失敗でした。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo mock -r epel-7-varnish-x86_64 --init&lt;/code&gt; で &lt;code&gt;varnish-4.1&lt;/code&gt; というレポジトリのrpmがインストールされるところまではOKでした。
が、 &lt;code&gt;sudo mock -r epel-7-varnish-x86_64 --install varnish&lt;/code&gt; としてvarnishをインストールすると、このレポジトリからvarnish 4.1.0がインストールされずにepelから4.0.3がインストールされてしまいました。&lt;/p&gt;

&lt;h3 id=&#34;うまくいく方法&#34;&gt;うまくいく方法&lt;/h3&gt;

&lt;p&gt;ということでmockで作成するchroot環境では &lt;code&gt;config_opts[&#39;yum.conf&#39;]&lt;/code&gt; に予めレポジトリ定義を書いておく必要があるようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm&#34;&gt;https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm&lt;/a&gt; に含まれる &lt;code&gt;etc/yum.repos.d/varnish-4.1.repo&lt;/code&gt; には以下の様なレポジトリ定義が含まれています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[varnish-4.1]
name=Varnish Cache 4.1 for Enterprise Linux
baseurl=https://repo.varnish-cache.org/redhat/varnish-4.1/el7/$basearch
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-VARNISH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/pki/rpm-gpg/RPM-GPG-KEY-VARNISH&lt;/code&gt; というgpgkeyが折角用意されているので使いたいのですが良い方法が思いつきませんでした。 &lt;code&gt;config_opts[&#39;chroot_setup_cmd&#39;]&lt;/code&gt; にセットアップ時に実行されるコマンドを書けるのですが、先頭に &lt;code&gt;yum&lt;/code&gt; を追加して実行されるので任意のコマンドを実行できるわけではないです。&lt;/p&gt;

&lt;p&gt;今回は諦めてgpgkeyを使うのは諦めて、下記の内容を &lt;code&gt;config_opts[&#39;yum.conf&#39;]&lt;/code&gt; の最後に追加するようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[varnish-4.1]
name=Varnish Cache 4.1 for Enterprise Linux
baseurl=https://repo.varnish-cache.org/redhat/varnish-4.1/el7/$basearch
enabled=1
gpgcheck=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スクリプトでは以下のようにしています。
&lt;a href=&#34;https://github.com/hnakamur/libvmod-header-rpm/blob/5d5b2e580b11944ee630c6fbc2bea81b9fa7bb9a/scripts/build.sh#L47-L75&#34;&gt;https://github.com/hnakamur/libvmod-header-rpm/blob/5d5b2e580b11944ee630c6fbc2bea81b9fa7bb9a/scripts/build.sh#L47-L75&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;create_varnish_repo_file() {
  varnish_repo_file=varnish-4.1.repo
  if [ ! -f $varnish_repo_file ]; then
    # NOTE: Although https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm at https://www.varnish-cache.org/installation/redhat
    #       has the gpgkey in it, I don&#39;t use it since I don&#39;t know how to add it to /etc/mock/*.cfg
    cat &amp;gt; ${varnish_repo_file} &amp;lt;&amp;lt;EOF
[${varnish_repo_id}]
name=${varnish_repo_name}
baseurl=${varnish_repo_baseurl}
enabled=1
gpgcheck=0
EOF
  fi
}

create_mock_chroot_cfg() {
  create_varnish_repo_file

  # Insert ${scl_repo_file} before closing &amp;quot;&amp;quot;&amp;quot; of config_opts[&#39;yum.conf&#39;]
  # See: http://unix.stackexchange.com/a/193513/135274
  #
  # NOTE: Support of adding repository was added to mock,
  #       so you can use it in the future.
  # See: https://github.com/rpm-software-management/ci-dnf-stack/issues/30
  (cd ${topdir} \
    &amp;amp;&amp;amp; echo | sed -e &#39;$d;N;P;/\n&amp;quot;&amp;quot;&amp;quot;$/i\
&#39; -e &#39;/\n&amp;quot;&amp;quot;&amp;quot;$/r &#39;${varnish_repo_file} -e &#39;/\n&amp;quot;&amp;quot;&amp;quot;$/a\
&#39; -e D /etc/mock/${base_chroot}.cfg - | sudo sh -c &amp;quot;cat &amp;gt; /etc/mock/${mock_chroot}.cfg&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sedでパターンにマッチした行の後にファイルを挿入するのは &lt;code&gt;/パターン/r ファイル名&lt;/code&gt;ですが、マッチした行の前に挿入するのはトリッキーです。
ここでは &lt;a href=&#34;http://unix.stackexchange.com/a/193513/135274&#34;&gt;http://unix.stackexchange.com/a/193513/135274&lt;/a&gt; で紹介されていた &lt;code&gt;echo | sed -e &#39;$d;N;P;/\nPointer/r file1&#39; -e D file2 -&lt;/code&gt; という手法を使っています。
ただし、ファイルを挿入する前後に改行を入れたかったので &lt;code&gt;i&lt;/code&gt; や &lt;code&gt;a&lt;/code&gt; も使っています。&lt;/p&gt;

&lt;p&gt;これで &lt;code&gt;sudo mock -r epel-7-varnish-x86_64 --rebuild ${SRPMのパス}&lt;/code&gt; でrpmをビルドできます。&lt;/p&gt;

&lt;h2 id=&#34;coprでのrpmビルド時にサードパーティのレポジトリを追加する方法&#34;&gt;coprでのrpmビルド時にサードパーティのレポジトリを追加する方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;の&amp;rdquo;Create new project&amp;rdquo;のAPIにreposパラメータがありますので、ここに &lt;code&gt;*.repo&lt;/code&gt; ファイルの &lt;code&gt;baseurl&lt;/code&gt; の値、 &lt;code&gt;https://repo.varnish-cache.org/redhat/varnish-4.1/el7/$basearch&lt;/code&gt; を指定すればOKです。&lt;/p&gt;

&lt;p&gt;実際のスクリプトでは以下の箇所です。
&lt;a href=&#34;https://github.com/hnakamur/libvmod-header-rpm/blob/5d5b2e580b11944ee630c6fbc2bea81b9fa7bb9a/scripts/build.sh#L108-L119&#34;&gt;https://github.com/hnakamur/libvmod-header-rpm/blob/5d5b2e580b11944ee630c6fbc2bea81b9fa7bb9a/scripts/build.sh#L108-L119&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Create the project on copr.
    # We call copr APIs with curl to work around the InsecurePlatformWarning problem
    # since system python in CentOS 7 is old.
    # I read the source code of https://pypi.python.org/pypi/copr/1.62.1
    # since the API document at https://copr.fedoraproject.org/api/ is old.
    curl -s -X POST -u &amp;quot;${COPR_LOGIN}:${COPR_TOKEN}&amp;quot; \
      --data-urlencode &amp;quot;name=${project_name}&amp;quot; \
      --data-urlencode &amp;quot;${base_chroot}=y&amp;quot; \
      --data-urlencode &amp;quot;repos=${varnish_repo_baseurl}&amp;quot; \
      --data-urlencode &amp;quot;description=$copr_project_description&amp;quot; \
      --data-urlencode &amp;quot;instructions=$copr_project_instructions&amp;quot; \
      https://copr.fedoraproject.org/api/coprs/${COPR_USERNAME}/new/
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>mockを使ったrpmビルドが失敗した時の調査方法</title>
      <link>https://hnakamur.github.io/blog/2015/12/16/how_to_debug_errors_in_rpm_build_using_mock/</link>
      <pubDate>Wed, 16 Dec 2015 01:10:33 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2015/12/16/how_to_debug_errors_in_rpm_build_using_mock/</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/&#34;&gt;nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;でspecファイルを書いている最中はmockでのrpmのビルドに失敗することがよくあります。&lt;/p&gt;

&lt;p&gt;私は「なんとなくこんな感じか？」と書いて動かしてみてエラーを見て修正していくスタイルなので、失敗時の調査は重要です。&lt;/p&gt;

&lt;h2 id=&#34;ビルドログ&#34;&gt;ビルドログ&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sudo mock -r epel-7-x86_64 --rebuild ${srpmファイル名}&lt;/code&gt; のように実行してビルドした場合、 &lt;code&gt;/var/lib/mock/epel-7-x86_64/result/&lt;/code&gt; に &lt;code&gt;build.log&lt;/code&gt; というファイルができるのでそれを見ます。&lt;/p&gt;

&lt;h2 id=&#34;mockコマンドでchroot環境内に入る&#34;&gt;mockコマンドでchroot環境内に入る&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://linux.die.net/man/1/mock&#34;&gt;mock(1)のmanページ&lt;/a&gt;によると &lt;code&gt;sudo mock -r epel-7-x86_64 --shell&lt;/code&gt; でchroot環境内に入ることが出来ます。 &lt;code&gt;exit&lt;/code&gt; で抜けます。&lt;/p&gt;

&lt;p&gt;mockで作られるchroot環境はビルドに必要な最低限のパッケージしかインストールされておらず、 &lt;code&gt;vim&lt;/code&gt; や &lt;code&gt;less&lt;/code&gt; も使えません。 &lt;code&gt;yum&lt;/code&gt; で入れようにも &lt;code&gt;yum&lt;/code&gt; も無いと言われてしまいます。&lt;/p&gt;

&lt;p&gt;chroot環境に入る前に &lt;code&gt;sudo mock -r epel-7-x86_64 --install vim less&lt;/code&gt; のようにしてインストールしておけばchroot内でvimやlessが使えます。&lt;/p&gt;

&lt;p&gt;あるいはchroot外で &lt;code&gt;/var/lib/mock/epel-7-x86_64/root/&lt;/code&gt; 配下のファイルをvimやlessで見るという手もあります。&lt;/p&gt;

&lt;h2 id=&#34;chroot環境内のrpmビルドディレクトリ&#34;&gt;chroot環境内のrpmビルドディレクトリ&lt;/h2&gt;

&lt;p&gt;chroot環境内では &lt;code&gt;/builddir/build/&lt;/code&gt; 以下に &lt;code&gt;BUILD&lt;/code&gt;, &lt;code&gt;BUILDDIR&lt;/code&gt;, &lt;code&gt;SOURCES&lt;/code&gt;, &lt;code&gt;SPECS&lt;/code&gt; などのディレクトリが作られているので、これらの中を見ればビルド失敗時の状況を調べられます。&lt;/p&gt;

&lt;h2 id=&#34;chroot環境内でファイルを修正してビルドを再実行&#34;&gt;chroot環境内でファイルを修正してビルドを再実行&lt;/h2&gt;

&lt;p&gt;mockを使ったrpmビルドはchroot環境を作成してその中で行われるのですが、毎回chroot環境を作るところからやっていると時間がかかって効率が悪いです。&lt;/p&gt;

&lt;p&gt;ですので、chroot環境内のspecファイルや &lt;code&gt;SOURCES&lt;/code&gt; ディレクトリ下のファイルを直接修正して、その後 &lt;code&gt;rpmbuild -bb ${specファイル名}&lt;/code&gt; でrpmのビルドを再度試します。&lt;/p&gt;

&lt;h2 id=&#34;修正したファイルをdockerコンテナ外に取り出す&#34;&gt;修正したファイルをdockerコンテナ外に取り出す&lt;/h2&gt;

&lt;p&gt;修正のきりが良い所で、chroot環境内の修正したファイルを &lt;code&gt;docker cp&lt;/code&gt; コマンドでdockerコンテナ内からコンテナ外に取り出します。&lt;/p&gt;

&lt;p&gt;まずdockerホストで &lt;code&gt;docker ps&lt;/code&gt; コマンドでコンテナIDかコンテナ名を調べます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
363ad4f85fda        nginxrpm            &amp;quot;/bin/bash&amp;quot;         18 hours ago        Up 18 hours                             romantic_fermi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に &lt;code&gt;docker cp&lt;/code&gt; コマンドでファイルをコピーします。例えばこんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker cp romantic_fermi:/var/lib/mock/epel-7-x86_64/root/builddir/build/SPECS/nginx.spec SPECS/nginx.spec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取り出した修正ファイルはgitにコミットして、さらに修正作業を続けていきます。&lt;/p&gt;

&lt;p&gt;修正が一通り終わったら、クリーンな状態からビルドが成功することを確認するため、dockerコンテナを一度破棄して&lt;a href=&#34;http://localhost:1313/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/&#34;&gt;nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました · hnakamur&amp;rsquo;s blog at github&lt;/a&gt; の手順で再度ビルドしてみます。これでエラーが出なければOKです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;mockを使ったrpmのビルドが失敗した場合の調査方法を紹介しました。もっと良い方法などありましたら、ぜひ教えてください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rpmのspecファイルのSourceにGitHubの任意のコミットのtarballのURLを指定するときの良い書き方</title>
      <link>https://hnakamur.github.io/blog/2015/12/06/good_rpm_spec_source_url_syntax_for_tarball_on_github/</link>
      <pubDate>Sun, 06 Dec 2015 00:07:23 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2015/12/06/good_rpm_spec_source_url_syntax_for_tarball_on_github/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Packaging:SourceURL?rd=Packaging/SourceURL#Commit_Revision&#34;&gt;Packaging:SourceURL - FedoraProject&lt;/a&gt;で知ったtipsの紹介です。&lt;/p&gt;

&lt;p&gt;GitHubでプロジェクトの[Download ZIP]ボタンを押すと、ソースをZIP形式でダウンロードできます。
コミット数が多いプロジェクトだと &lt;code&gt;git clone&lt;/code&gt; するよりも高速に取得できるので履歴が不要な場合には便利な方法です。&lt;/p&gt;

&lt;p&gt;例えば&lt;a href=&#34;https://github.com/openresty/lua-nginx-module&#34;&gt;openresty/lua-nginx-module&lt;/a&gt;なら &lt;code&gt;https://github.com/openresty/lua-nginx-module/archive/master.zip&lt;/code&gt; というURLになるのですが、 &lt;code&gt;.zip&lt;/code&gt; を &lt;code&gt;.tar.gz&lt;/code&gt; に変えればtar.gz形式でダウンロードできます。&lt;/p&gt;

&lt;p&gt;また、 &lt;code&gt;master&lt;/code&gt; の部分はブランチ名、タグ名、コミットハッシュを指定することも出来るので任意のコミットのソースを取得可能です。&lt;/p&gt;

&lt;p&gt;好みのファイル名でダウンロードするのは、通常ならダウンロードするツール側で対応すれば良い話です。例えば&lt;a href=&#34;http://linux.die.net/man/1/curl&#34;&gt;curl(1): transfer URL - Linux man page&lt;/a&gt;を使う場合は &lt;code&gt;-o&lt;/code&gt; オプションで &lt;code&gt;-o ファイル名&lt;/code&gt; のように指定すれば良いだけです。&lt;/p&gt;

&lt;p&gt;ただ、RPMのspecファイルの &lt;code&gt;Source:&lt;/code&gt; に指定するときはちょっと厄介です。
&lt;a href=&#34;https://fedoraproject.org/wiki/How_to_create_an_RPM_package#SPEC_file_overview&#34;&gt;SPEC file overview&lt;/a&gt;の &lt;code&gt;Source0&lt;/code&gt; の説明を読むと、URLのベースネーム (最後のスラッシュの後の部分) が &lt;code&gt;~/rpmbuild/SOURCES&lt;/code&gt; ディレクトリ配下に置くファイル名になるようにするべきとあります。&lt;/p&gt;

&lt;p&gt;しかし、上述のようにGitHubでソースのtarballのURLのベースネームは &lt;code&gt;コミットハッシュなど.tar.gz&lt;/code&gt; という形式となっています。これだと複数のソースをダウンロードした時に、どれがどれかわかりにくいですし、 &lt;code&gt;バージョン番号.tar.gz&lt;/code&gt; の場合だとファイル名が衝突する恐れもあります。&lt;/p&gt;

&lt;p&gt;解決策ですが、元のURLに &lt;code&gt;#/&lt;/code&gt; をつけてその後に好きなファイル名を指定すればOKです。具体的には &lt;code&gt;https://github.com/ユーザ名/プロジェクト名/archive/コミットハッシュなど.tar.gz#/プロジェクト名-コミットハッシュなど.tar.gz&lt;/code&gt; のように書きます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Packaging:SourceURL?rd=Packaging/SourceURL#Commit_Revision&#34;&gt;Packaging:SourceURL - FedoraProject&lt;/a&gt;にはbitbucket.orgとgitlab.comの場合の書き方も紹介されていますので、必要に応じてご参照ください。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>