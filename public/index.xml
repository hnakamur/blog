<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hnakamur&#39;s blog at github</title>
    <link>/blog/</link>
    <description>Recent content on hnakamur&#39;s blog at github</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Mon, 20 Jun 2016 22:23:54 +0900</lastBuildDate>
    <atom:link href="/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LSM-TreeとRocksDB、TiDB、CockroachDBが気になる</title>
      <link>/blog/2016/06/20/lsm-tree-and-rocksdb/</link>
      <pubDate>Mon, 20 Jun 2016 22:23:54 +0900</pubDate>
      
      <guid>/blog/2016/06/20/lsm-tree-and-rocksdb/</guid>
      <description>

&lt;h2 id=&#34;はじめに:4c97747b39b98778589cfc717acd1a16&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;キーバリューストアについて調べていたらLSM-Treeというデータ構造とRocksDBが気になったということで調査メモです。ただし、それぞれの技術詳細を調査したり自分で検証してみたというメモではないです。&lt;/p&gt;

&lt;p&gt;そうではなく、いろんな記事で言及されていたり、ソフトウェアで採用されているのが気になったというだけの浅いメモです。が、脳内バッファからあふれる量になったので自分用に軽くまとめ。&lt;/p&gt;

&lt;h2 id=&#34;lsm-tree:4c97747b39b98778589cfc717acd1a16&#34;&gt;LSM Tree&lt;/h2&gt;

&lt;p&gt;Log-structured merge-treeを略してLSM Treeと呼ぶそうです。概要は&lt;a href=&#34;https://en.wikipedia.org/wiki/Log-structured_merge-tree&#34;&gt;Log-structured merge-tree - Wikipedia&lt;/a&gt;を参照してください。&lt;/p&gt;

&lt;p&gt;CockroachDBのデザインドキュメントの&lt;a href=&#34;https://github.com/cockroachdb/cockroach/blob/master/docs/design.md#read-vs-write-optimization-spectrum&#34;&gt;Read vs. Write Optimization Spectrum&lt;/a&gt;によると、B+ Treeというデータ構造は書き込みより読み取りが多いケースに最適化されているが、LSM Treeのほうは書き込みが多いケースに最適化されているそうです。&lt;/p&gt;

&lt;p&gt;一方、LSM Treeのほうはディスク使用量は肥大化しがちで定期的にコンパクションする必要があって、コンパクションには負荷がかかるので、この方式を各実装で工夫しているという話を何処かで読んだんですがリンクを紛失してしまいました。&lt;/p&gt;

&lt;h2 id=&#34;influxdbの事例:4c97747b39b98778589cfc717acd1a16&#34;&gt;InfluxDBの事例&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.influxdata.com/influxdb/v0.13/concepts/storage_engine/&#34;&gt;InfluxData | Documentation | Storage Engine&lt;/a&gt;によるとInfluxDBのストレージエンジンは以下の変遷を辿ったそうです。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;LSM Treeの実装の1つである&lt;a href=&#34;https://github.com/google/leveldb&#34;&gt;LevelDB&lt;/a&gt;を採用&lt;/li&gt;
&lt;li&gt;B+Treeの実装の1つである&lt;a href=&#34;https://github.com/boltdb/bolt&#34;&gt;BoltDB&lt;/a&gt;を採用&lt;/li&gt;
&lt;li&gt;LSM Treeに似た独自のデータ構造でストレージエンジンを自作&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;tidbの事例:4c97747b39b98778589cfc717acd1a16&#34;&gt;TiDBの事例&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/pingcap/tidb&#34;&gt;pingcap/tidb: TiDB is a distributed NewSQL database compatible with MySQL protocol&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TiDB自体はGoで書かれている。&lt;/li&gt;
&lt;li&gt;MySQLのプロトコルを解釈できる。&lt;/li&gt;
&lt;li&gt;MySQLで使用できるSQLのサブセットを実装している。&lt;/li&gt;
&lt;li&gt;TiDBはRustで書かれRaftアルゴリズムを使った分散トランザクション対応のキーバリューデータベース &lt;a href=&#34;https://github.com/pingcap/tikv&#34;&gt;TiKV&lt;/a&gt;を使っている。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/pingcap/tidb#what-is-tidb&#34;&gt;What is TiDB?&lt;/a&gt;にはGolevelDB, LevelDB, RocksDB, LMDB, BoltDBに対応しているとあるのですが、TiDBの開発者のLi Shenさんによるとgoleveldbはローカルストレージとしてのみ利用可能で、分散環境ではTiKVを使っているそうです。&lt;/li&gt;
&lt;li&gt;TiKVのストレージエンジンはLSM Treeの実装である&lt;a href=&#34;http://rocksdb.org/&#34;&gt;RocksDB&lt;/a&gt;を採用。Li ShenさんによるとTiDBの開発チームはRocsDBのチームとも連絡をとっているそうです。&lt;/li&gt;
&lt;li&gt;TiKV用の&lt;a href=&#34;https://github.com/pingcap/tidb/blob/master/store/tikv/txn.go&#34;&gt;Goのクライアント&lt;/a&gt;もある。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;現在バリバリ開発中。&lt;a href=&#34;https://github.com/pingcap/tidb/blob/master/docs/ROADMAP.md&#34;&gt;ロードマップ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cockroachdbの事例:4c97747b39b98778589cfc717acd1a16&#34;&gt;CockroachDBの事例&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/cockroachdb/cockroach&#34;&gt;cockroachdb/cockroach: A Scalable, Survivable, Strongly-Consistent SQL Database&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;名前の由来: &lt;a href=&#34;https://github.com/cockroachdb/cockroach/wiki#why-the-name-cockroach&#34;&gt;Why the name Cockroach?&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CoackroachDBはGoで書かれている。&lt;/li&gt;
&lt;li&gt;PostgreSQLのプロトコルを解釈できる。&lt;/li&gt;
&lt;li&gt;PostgreSQLで使用できるSQLのサブセットを実装している。&lt;/li&gt;
&lt;li&gt;ストレージエンジンは&lt;a href=&#34;http://rocksdb.org/&#34;&gt;RocksDB&lt;/a&gt;を採用。&lt;/li&gt;
&lt;li&gt;現在バリバリ開発中。

&lt;ul&gt;
&lt;li&gt;バージョン1.0に向けてベータ版を頻繁に出している。 &lt;a href=&#34;https://github.com/cockroachdb/cockroach/releases&#34;&gt;Releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cockroachdb/cockroach/wiki&#34;&gt;ロードマップ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;デザインドキュメント &lt;a href=&#34;https://github.com/cockroachdb/cockroach#design&#34;&gt;Design overview&lt;/a&gt;, &lt;a href=&#34;https://github.com/cockroachdb/cockroach/blob/master/docs/design.md&#34;&gt;full design doc&lt;/a&gt;と&lt;a href=&#34;https://www.cockroachlabs.com/docs/frequently-asked-questions.html&#34;&gt;Frequently Asked Questions&lt;/a&gt;がとても充実しています

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cockroachdb/cockroach/blob/master/docs/design.md#lock-free-distributed-transactions&#34;&gt;Lock-Free Distributed Transactions&lt;/a&gt;にCockroachDBの分散トランザクションの設計について解説があります。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lsm-treeの実装はいろいろあるがrocksdbが良いらしい:4c97747b39b98778589cfc717acd1a16&#34;&gt;LSM Treeの実装はいろいろあるがRocksDBが良いらしい&lt;/h2&gt;

&lt;p&gt;InfluxDBの開発元influxdataのブログのベンチマーク記事 &lt;a href=&#34;https://influxdata.com/blog/benchmarking-leveldb-vs-rocksdb-vs-hyperleveldb-vs-lmdb-performance-for-influxdb/&#34;&gt;Benchmarking LevelDB vs. RocksDB vs. HyperLevelDB vs. LMDB Performance for InfluxDB | InfluxData&lt;/a&gt;でも値の書き込みとクエリ実行の性能が良いのはRocksDBとなっています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://smalldatum.blogspot.jp/2015/04/comparing-leveldb-and-rocksdb-take-2.html&#34;&gt;Small Datum: Comparing LevelDB and RocksDB, take 2&lt;/a&gt;にRocksDBとLevelDBのベンチマークがありますが、RocksDBのほうが良い感じです。&lt;/p&gt;

&lt;p&gt;上記の通りTiDBでもCockroachDBでもRocksDBを採用していますし、現在のところ有望そうです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://rocksdb.blogspot.jp/2013/11/the-history-of-rocksdb.html&#34;&gt;Rocksdb: The History of RocksDB&lt;/a&gt;にRocksDBを開始した頃の話が書かれていました。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:4c97747b39b98778589cfc717acd1a16&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;書き込みが多いケースに向いているキーバリューストアであるRocksDBと、RocksDBをつかて分散トランザクションを実現しているデータベースであるTiDBとCockroachDBの今後に注目したいと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>sleuthというGoのライブラリでサービスディスカバリを試してみた</title>
      <link>/blog/2016/06/15/tried-service-discovery-with-sleuth/</link>
      <pubDate>Wed, 15 Jun 2016 06:56:10 +0900</pubDate>
      
      <guid>/blog/2016/06/15/tried-service-discovery-with-sleuth/</guid>
      <description>

&lt;h2 id=&#34;はじめに:ddadb6ee7dee03e92fb3b4df013b68c7&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://darian.af/post/master-less-peer-to-peer-micro-service-autodiscovery-in-golang-with-sleuth/&#34;&gt;Service autodiscovery in Go with sleuth - darian.af&lt;/a&gt;という記事を見かけて試してみたのでメモです。&lt;/p&gt;

&lt;h2 id=&#34;github-com-ursiform-sleuthのセットアップ:ddadb6ee7dee03e92fb3b4df013b68c7&#34;&gt;github.com/ursiform/sleuthのセットアップ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ursiform/sleuth#installation&#34;&gt;Installation&lt;/a&gt;を見ながらセットアップします。&lt;/p&gt;

&lt;p&gt;いきなりgo getでインストールしてみるとZeroMQ version 4が必要というエラーメッセージが出ました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get -u github.com/ursiform/sleuth
# github.com/pebbe/zmq4
In file included from ../../../pebbe/zmq4/ctxoptions_unix.go:7:0:
zmq4.h:2:2: error: #error &amp;quot;You need ZeroMQ version 4 to build this&amp;quot;
 #error &amp;quot;You need ZeroMQ version 4 to build this&amp;quot;
  ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ubuntu 16.04では&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt install -y libzmq3-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CentOS 7では&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install -y zeromq-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でZeroMQ 4.xのライブラリとヘッダファイルがインストールできます。&lt;/p&gt;

&lt;p&gt;このあとで go get でsleuthをインストールすると今度は大丈夫でした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get -u github.com/ursiform/sleuth
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;動作確認のためエコーバックのサービスの例を試す:ddadb6ee7dee03e92fb3b4df013b68c7&#34;&gt;動作確認のためエコーバックのサービスの例を試す&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ursiform/sleuth#examples&#34;&gt;Examples&lt;/a&gt;のExample (1)にエコーバックのサーバとクライアントがあるのでそれを試します。&lt;/p&gt;

&lt;p&gt;コードをコピペするのが面倒な人は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get -d github.com/hnakamur/sleuth-echo-example
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で取得できます。&lt;/p&gt;

&lt;p&gt;以下のコマンドでプロジェクトのディレクトリに移動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd $GOPATH/src/github.com/hnakamur/sleuth-echo-example
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドでエコーバックのサーバを起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(cd echo-server &amp;amp;&amp;amp; go run main.go &amp;amp;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動すると以下のようなログが出力されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2016/06/15 06:54:06 [**warning**] sleuth: config.Interface not defined [801]
2016/06/15 06:54:06 [ listening ] sleuth: [SLEUTH-v0:5670][echo-service E13055]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドでクライアントを実行し、&amp;rdquo;It works.&amp;rdquo; と表示されれば成功です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ (cd echo-client &amp;amp;&amp;amp; go run main.go)
It works.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;curlでも試してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s -d Hello 127.0.0.1:9873/echo-service/
Hello
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;サービスディスカバリの例を試す:ddadb6ee7dee03e92fb3b4df013b68c7&#34;&gt;サービスディスカバリの例を試す&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;go get -u github.com/afshin/sleuth-example/...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でサンプルのコードと依存するライブラリを取得し&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd $GOPATH/src/github.com/afshin/sleuth-example
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でプロジェクトのディレクトリに移動します。&lt;/p&gt;

&lt;p&gt;この例にはarticle-serviceとcomment-serviceという2つのサービスが含まれています。&lt;/p&gt;

&lt;p&gt;まずは article-service を起動します。article-serviceはポート9872で起動されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ (cd article-service &amp;amp;&amp;amp; go run main.go)
2016/06/14 22:38:08 [**warning**] sleuth: config.Interface not defined [801]
2016/06/14 22:38:08 [ listening ] sleuth: [SLEUTH-v0:5670][client-only EC740A]
2016/06/14 22:38:08 [**blocked**] sleuth: waiting for client to find [comment-service]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ログに書かれているようにcomment-serviceが見つからなくて待っている状態です。&lt;/p&gt;

&lt;p&gt;別の端末を開いて以下のコマンドを実行してcomment-serviceを起動します。comment-serviceはポート9871で起動されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ (cd comment-service &amp;amp;&amp;amp; go run main.go)
2016/06/15 07:47:42 [**warning**] sleuth: config.Interface not defined [801]
2016/06/15 07:47:42 [ listening ] sleuth: [SLEUTH-v0:5670][comment-service 0DBE04]
ready...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;comment-serviceを起動するとarticle-serviceの端末には以下のログが追加で出力されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2016/06/15 07:47:43 [*unblocked*] sleuth: client found [comment-service]
ready...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまりarticle-serviceがcomment-serviceを発見（サービスディカバリ）出来たということです。&lt;/p&gt;

&lt;p&gt;別の端末を開いて以下のコマンドを実行してcurlでarticle-serviceから記事のデータを1件取得してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s localhost:9872/articles/049cd8fc-a66b-4a3d-956b-7c2ab5fb9c5d | jq .
{
  &amp;quot;success&amp;quot;: true,
  &amp;quot;data&amp;quot;: {
    &amp;quot;guid&amp;quot;: &amp;quot;049cd8fc-a66b-4a3d-956b-7c2ab5fb9c5d&amp;quot;,
    &amp;quot;byline&amp;quot;: &amp;quot;Kristen Rasmussen&amp;quot;,
    &amp;quot;headline&amp;quot;: &amp;quot;Wanting the Unwanted: Why Eat Weeds&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;http://www.rootedfood.com/musings/2015/4/1/a-foraged-affair&amp;quot;,
    &amp;quot;time&amp;quot;: 1428168580
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;comment-serviceからコメントのデータを1件取得します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s localhost:9871/comments/06500da3-f9b0-4731-b0fa-fbc6cbe8c155 | jq .
{
  &amp;quot;success&amp;quot;: true,
  &amp;quot;data&amp;quot;: [
    {
      &amp;quot;guid&amp;quot;: &amp;quot;d7041752-6854-4b2c-ad6d-1b48d898668d&amp;quot;,
      &amp;quot;article&amp;quot;: &amp;quot;06500da3-f9b0-4731-b0fa-fbc6cbe8c155&amp;quot;,
      &amp;quot;text&amp;quot;: &amp;quot;Star Trek, on the other hand, consistently presents an optimistic view of our capacity for civilization. I love science-fiction, even when it&amp;amp;#x27;s dystopian. But why does so much of it have to be dystopian?&amp;quot;,
      &amp;quot;time&amp;quot;: 1452738329
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に2つのサービスを連携させた使い方として、以下のコマンドで1件の記事とそれに紐づくコメントを取得します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s localhost:9872/articles/049cd8fc-a66b-4a3d-956b-7c2ab5fb9c5d?includecomments=true | jq .
{
  &amp;quot;success&amp;quot;: true,
  &amp;quot;data&amp;quot;: {
    &amp;quot;guid&amp;quot;: &amp;quot;049cd8fc-a66b-4a3d-956b-7c2ab5fb9c5d&amp;quot;,
    &amp;quot;byline&amp;quot;: &amp;quot;Kristen Rasmussen&amp;quot;,
    &amp;quot;comments&amp;quot;: [
      {
        &amp;quot;guid&amp;quot;: &amp;quot;1b1e937b-8521-4c88-a13c-105d421ea030&amp;quot;,
        &amp;quot;article&amp;quot;: &amp;quot;049cd8fc-a66b-4a3d-956b-7c2ab5fb9c5d&amp;quot;,
        &amp;quot;text&amp;quot;: &amp;quot;I believe the premise to be false, while it is true that you can eat many different &amp;amp;quot;weeds&amp;amp;quot; I cannot find any methodology or theory where that doing so increases the efficiency of land use. There are some key things like nutrients in == nutrie
nts out and digestibility in humans which is not a given.&amp;lt;p&amp;gt;That said, there were some interesting recipes for what are nominally weeds in the Foxfire[1], and Euell Gibbons books[2] which were certainly edible although nothing I&amp;amp;#x27;ve tried really struck me as excepti
onal. As Boy Scouts we got a merit badge for creating a meal out of locally harvested plants, that was fun.&amp;lt;p&amp;gt;[1] &amp;lt;a href=\&amp;quot;http:&amp;amp;#x2F;&amp;amp;#x2F;www.foxfire.org&amp;amp;#x2F;thefoxfirebooks.aspx\&amp;quot; rel=\&amp;quot;nofollow\&amp;quot;&amp;gt;http:&amp;amp;#x2F;&amp;amp;#x2F;www.foxfire.org&amp;amp;#x2F;thefoxfirebooks.aspx&amp;lt;/a&amp;gt;&amp;lt;p&amp;gt;[2]
 &amp;lt;a href=\&amp;quot;http:&amp;amp;#x2F;&amp;amp;#x2F;www.amazon.com&amp;amp;#x2F;Euell-Gibbons-Handbook-Edible-Plants&amp;amp;#x2F;dp&amp;amp;#x2F;0915442787\&amp;quot; rel=\&amp;quot;nofollow\&amp;quot;&amp;gt;http:&amp;amp;#x2F;&amp;amp;#x2F;www.amazon.com&amp;amp;#x2F;Euell-Gibbons-Handbook-Edible-Plants&amp;amp;#x2F;d...&amp;lt;/a&amp;gt;&amp;quot;,
        &amp;quot;time&amp;quot;: 1428172888
      },
      {
        &amp;quot;guid&amp;quot;: &amp;quot;1ffa59ea-1b62-41fe-87c3-98ec6901d768&amp;quot;,
        &amp;quot;article&amp;quot;: &amp;quot;049cd8fc-a66b-4a3d-956b-7c2ab5fb9c5d&amp;quot;,
        &amp;quot;text&amp;quot;: &amp;quot;Something to keep in mind here is that once a viable market is found then the product will be fully commercialised and mass-produced.  No longer will poor conditions be good enough when compared to the yield you get from ideal conditions.&amp;lt;p&amp;gt;Then we will
 start fertilising them, then tweaking the seeds etc etc etc. And before long it will be just like anything else grown on the land.&amp;quot;,
        &amp;quot;time&amp;quot;: 1428188859
      },
…(略)…
        &amp;quot;guid&amp;quot;: &amp;quot;587b528f-f4fe-4620-959e-f0d087c97348&amp;quot;,
        &amp;quot;article&amp;quot;: &amp;quot;049cd8fc-a66b-4a3d-956b-7c2ab5fb9c5d&amp;quot;,
        &amp;quot;text&amp;quot;: &amp;quot;The premise that weeds are a suitable food for humans is wrong. Most of these plants are loaded with toxins. You can&amp;amp;#x27;t eat them in any quantity for calories without getting poisoned.&amp;lt;p&amp;gt;Cows and goats and sheep can eat these things, though, because 
they have more advanced digestive systems. The udder provides an added toxin filtration system.&amp;lt;p&amp;gt;In theory you might be able to design an efficient system to detoxify wild plants such as grass and weeds directly into a high quality human food. At this moment cheese is 
already an incredibly effective way to use wild forage to make human food.&amp;quot;,
        &amp;quot;time&amp;quot;: 1428192718
      }
    ],
    &amp;quot;headline&amp;quot;: &amp;quot;Wanting the Unwanted: Why Eat Weeds&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;http://www.rootedfood.com/musings/2015/4/1/a-foraged-affair&amp;quot;,
    &amp;quot;time&amp;quot;: 1428168580
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sleuthのq-aを見てみる:ddadb6ee7dee03e92fb3b4df013b68c7&#34;&gt;sleuthのQ &amp;amp; Aを見てみる&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ursiform/sleuth#q--a&#34;&gt;Q &amp;amp; A&lt;/a&gt;を見ると、sleuthのメッセージプロトコルはJSONをgzipしてHTTPで通信しているとのことです。Protocol Buffersなどの他のライブラリに依存するのを避けたいという意図で、マイクロサービスのAPIレスポンスのほとんどは小さいのでJSONをgzipする方式で十分だし、そのほうがGo以外の言語でも利用しやすいので良いだろうということです。&lt;/p&gt;

&lt;p&gt;sleuthは熊のグループの集合名詞とのことです。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:ddadb6ee7dee03e92fb3b4df013b68c7&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;sleuthはzeromqとGoさえあれば使えるということでセットアップが簡単です。&lt;/p&gt;

&lt;p&gt;サービスの実装&lt;a href=&#34;https://github.com/afshin/sleuth-example/blob/master/article-service/main.go&#34;&gt;sleuth-example/main.go&lt;/a&gt;と&lt;a href=&#34;https://github.com/afshin/sleuth-example/blob/master/comment-service/main.go&#34;&gt;sleuth-example/main.go&lt;/a&gt;も、Goで普通にウェブサービスを実装したところに、sleuthを使うためのコードを少し足すだけでいいのでお手軽でいいですね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>gistを作成するGoのCLIを見つけた</title>
      <link>/blog/2016/06/14/go_cli_to_create_a_gist/</link>
      <pubDate>Tue, 14 Jun 2016 00:52:22 +0900</pubDate>
      
      <guid>/blog/2016/06/14/go_cli_to_create_a_gist/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/delta24/gist&#34;&gt;delta24/gist: A command line gister in Go&lt;/a&gt;です。期待通りに動かない点があったのでプルリクエストを送ったら、すぐにマージされました。&lt;/p&gt;

&lt;h2 id=&#34;インストール:fc3bd82c10a86f881e77f6b5f9ec06f5&#34;&gt;インストール&lt;/h2&gt;

&lt;p&gt;Goはインストール済みという前提で、以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get -u github.com/delta24/gist
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;事前準備:fc3bd82c10a86f881e77f6b5f9ec06f5&#34;&gt;事前準備&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://help.github.com/articles/creating-an-access-token-for-command-line-use/&#34;&gt;Creating an access token for command-line use - User Documentation&lt;/a&gt;の手順でアクセストークンを作って、 &lt;code&gt;~/.bash_profile&lt;/code&gt; とかに &lt;code&gt;export GITHUB_TOKEN=...&lt;/code&gt; のように書くなどして環境変数として設定するか、 あるいは &lt;code&gt;~/.gist&lt;/code&gt; というファイルを作ってトークンの値を書いておきます。&lt;/p&gt;

&lt;h2 id=&#34;使い方の例:fc3bd82c10a86f881e77f6b5f9ec06f5&#34;&gt;使い方の例&lt;/h2&gt;

&lt;p&gt;自分のユーザでpublicなgistを作成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gist -a=false -d &#39;説明&#39; ファイル名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自分のユーザでprivate (secret)なgistを作成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gist -a=false -p=false -d &#39;説明&#39; ファイル名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;anonymousユーザでpublicなgistを作成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gist -d &#39;説明&#39; ファイル名
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Goのシリアライゼーションのベンチマークを自分でも試してみた</title>
      <link>/blog/2016/06/13/tried_go_serialization_benchmarks/</link>
      <pubDate>Mon, 13 Jun 2016 23:34:16 +0900</pubDate>
      
      <guid>/blog/2016/06/13/tried_go_serialization_benchmarks/</guid>
      <description>&lt;p&gt;2015年12月の記事ですが&lt;a href=&#34;http://qiita.com/shibukawa/items/878c5fe8ec09935fccd2&#34;&gt;最速という噂のFlatbuffersの速度のヒミツと、導入方法の紹介(Go) - Qiita&lt;/a&gt;を読んで、「gobは遅いのかー、残念」、「一方Flatbuffersは面倒そうだなー」と思っていました。&lt;/p&gt;

&lt;p&gt;で、&lt;a href=&#34;https://github.com/alecthomas/go_serialization_benchmarks/tree/48e2bb8b7b6c38c24c88a0b027b30c80175a7b59#results&#34;&gt;alecthomas/go_serialization_benchmarks at 48e2bb8b7b6c38c24c88a0b027b30c80175a7b59&lt;/a&gt;のベンチマーク結果を見てみると、あれgob遅くないよ、というかVmihailencoMsgpackとUgorjiCodecMsgpackより速くなってました。&lt;/p&gt;

&lt;p&gt;自宅サーバ (NEC Express5800/S70)でもベンチマークを試してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test -bench . -benchmem | tee bench.txt                                                                                                                                               

A test suite for benchmarking various Go serialization methods.

See README.md for details on running the benchmarks.

PASS
BenchmarkMsgpMarshal-2                   3000000               423 ns/op             128 B/op          1 allocs/op
BenchmarkMsgpUnmarshal-2                 2000000               741 ns/op             112 B/op          3 allocs/op
BenchmarkVmihailencoMsgpackMarshal-2      500000              3107 ns/op             368 B/op          6 allocs/op
BenchmarkVmihailencoMsgpackUnmarshal-2    300000              4469 ns/op             352 B/op         13 allocs/op
BenchmarkJsonMarshal-2                    200000              7070 ns/op            1232 B/op         10 allocs/op
BenchmarkJsonUnmarshal-2                  200000              7331 ns/op             416 B/op          7 allocs/op
BenchmarkEasyJsonMarshal-2                500000              3116 ns/op             784 B/op          5 allocs/op
BenchmarkEasyJsonUnmarshal-2              500000              2936 ns/op             160 B/op          4 allocs/op
BenchmarkBsonMarshal-2                    500000              3031 ns/op             392 B/op         10 allocs/op
BenchmarkBsonUnmarshal-2                  500000              4047 ns/op             248 B/op         21 allocs/op
BenchmarkGobMarshal-2                    1000000              2189 ns/op              48 B/op          2 allocs/op
BenchmarkGobUnmarshal-2                  1000000              2226 ns/op             112 B/op          3 allocs/op
BenchmarkXdrMarshal-2                     500000              3862 ns/op             456 B/op         21 allocs/op
BenchmarkXdrUnmarshal-2                   500000              2885 ns/op             239 B/op         11 allocs/op
BenchmarkUgorjiCodecMsgpackMarshal-2      200000              7052 ns/op            2752 B/op          8 allocs/op
BenchmarkUgorjiCodecMsgpackUnmarshal-2    200000              7586 ns/op            3008 B/op          6 allocs/op
BenchmarkUgorjiCodecBincMarshal-2         200000              7347 ns/op            2784 B/op          8 allocs/op
BenchmarkUgorjiCodecBincUnmarshal-2       200000              8163 ns/op            3168 B/op          9 allocs/op
BenchmarkSerealMarshal-2                  200000              7518 ns/op             912 B/op         21 allocs/op
BenchmarkSerealUnmarshal-2                200000              7039 ns/op            1008 B/op         34 allocs/op
BenchmarkBinaryMarshal-2                  500000              2757 ns/op             256 B/op         16 allocs/op
BenchmarkBinaryUnmarshal-2                500000              3057 ns/op             336 B/op         22 allocs/op
BenchmarkFlatBuffersMarshal-2            3000000               573 ns/op               0 B/op          0 allocs/op
BenchmarkFlatBuffersUnmarshal-2          3000000               538 ns/op             112 B/op          3 allocs/op
BenchmarkCapNProtoMarshal-2              2000000               874 ns/op              56 B/op          2 allocs/op
BenchmarkCapNProtoUnmarshal-2            2000000               817 ns/op             200 B/op          6 allocs/op
BenchmarkCapNProto2Marshal-2             1000000              1991 ns/op             244 B/op          3 allocs/op
BenchmarkCapNProto2Unmarshal-2           1000000              2064 ns/op             320 B/op          6 allocs/op
BenchmarkHproseMarshal-2                 1000000              1797 ns/op             479 B/op          8 allocs/op
BenchmarkHproseUnmarshal-2                500000              2250 ns/op             320 B/op         10 allocs/op
BenchmarkProtobufMarshal-2               1000000              2052 ns/op             200 B/op          7 allocs/op
BenchmarkProtobufUnmarshal-2             1000000              1700 ns/op             192 B/op         10 allocs/op
BenchmarkGoprotobufMarshal-2             1000000              1141 ns/op             312 B/op          4 allocs/op
BenchmarkGoprotobufUnmarshal-2           1000000              1721 ns/op             432 B/op          9 allocs/op
BenchmarkGogoprotobufMarshal-2           5000000               291 ns/op              64 B/op          1 allocs/op
BenchmarkGogoprotobufUnmarshal-2         3000000               445 ns/op              96 B/op          3 allocs/op
BenchmarkColferMarshal-2                 5000000               260 ns/op              64 B/op          1 allocs/op
BenchmarkColferUnmarshal-2               5000000               387 ns/op             112 B/op          3 allocs/op
BenchmarkGencodeMarshal-2                5000000               322 ns/op              80 B/op          2 allocs/op
BenchmarkGencodeUnmarshal-2              5000000               392 ns/op             112 B/op          3 allocs/op
BenchmarkGencodeUnsafeMarshal-2         10000000               196 ns/op              48 B/op          1 allocs/op
BenchmarkGencodeUnsafeUnmarshal-2        5000000               322 ns/op              96 B/op          3 allocs/op
BenchmarkXDR2Marshal-2                   5000000               333 ns/op              64 B/op          1 allocs/op
BenchmarkXDR2Unmarshal-2                 5000000               313 ns/op              32 B/op          2 allocs/op
ok      github.com/alecthomas/go_serialization_benchmarks       81.009s
$ go version
go version go1.6.2 linux/amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こちらも同じくgobはVmihailencoMsgpackとUgorjiCodecMsgpackより速かったです。Goのバージョンの違いなのかライブラリの進化なのかは調べてないですが、いつのまにか逆転していたようです。&lt;/p&gt;

&lt;p&gt;ということで、Go以外の言語との相互運用性を考えなくて良いなら、gobもシリアライゼーションのライブラリ選択の候補に入れて良さそうと思いました。&lt;a href=&#34;https://golang.org/pkg/encoding/gob/&#34;&gt;gob&lt;/a&gt;を見る限りはstructに対して特に何もしなくても使えるようなのでお手軽さでは一番良さそうですし。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GoでLTSV形式でログ出力するライブラリを書いた</title>
      <link>/blog/2016/06/13/wrote_go_ltsvlog_library/</link>
      <pubDate>Mon, 13 Jun 2016 21:42:53 +0900</pubDate>
      
      <guid>/blog/2016/06/13/wrote_go_ltsvlog_library/</guid>
      <description>

&lt;h2 id=&#34;なぜ書いたか:9bb767831423b01f10b84a34c21f4871&#34;&gt;なぜ書いたか&lt;/h2&gt;

&lt;p&gt;Goで高機能なサードパーティのログ出力ライブラリと言えば&lt;a href=&#34;https://github.com/Sirupsen/logrus&#34;&gt;Sirupsen/logrus&lt;/a&gt;が有名です。私も&lt;a href=&#34;https://github.com/doloopwhile/logrusltsv&#34;&gt;doloopwhile/logrusltsv&lt;/a&gt;と組み合わせてLTSV形式のログ出力するのに使っていました。&lt;/p&gt;

&lt;p&gt;しかし、&lt;a href=&#34;http://methane.hatenablog.jp/entry/2015/09/17/logger_%E3%81%AE%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6_%5BGo%5D&#34;&gt;logger のパフォーマンスについて [Go] - methaneのブログ&lt;/a&gt;にも書かれていますが、&lt;a href=&#34;https://godoc.org/github.com/Sirupsen/logrus#WithFields&#34;&gt;logrus.WithFields&lt;/a&gt;は&lt;a href=&#34;https://godoc.org/github.com/Sirupsen/logrus#Fields&#34;&gt;Fields&lt;/a&gt;、つまり &lt;code&gt;map[string]interface{}&lt;/code&gt; の値を渡す必要があります。これはGCに負荷をかけそうというのも気になりますが、Goのmapは順不同なのでログ出力の際にキーの順番がソースに書いた順番と必ずしも一致しないというのがイマイチだよなーと思っていました。&lt;/p&gt;

&lt;p&gt;ログ出力ライブラリはライブラリによって違うものを使うのはよくないから、自作するよりメジャーなものを使うほうが良いと自重する思いもありました。&lt;/p&gt;

&lt;p&gt;一方で、&lt;a href=&#34;http://dave.cheney.net/2015/11/05/lets-talk-about-logging&#34;&gt;Let’s talk about logging | Dave Cheney&lt;/a&gt;には賛同する点も多く、感銘を受けました。&lt;/p&gt;

&lt;p&gt;で、一度自作してみようかなーと思っていたところに、&lt;a href=&#34;https://github.com/uber-go/zap&#34;&gt;uber-go/zap&lt;/a&gt;を見かけて、ログ出力の引数側を加工するという方式にインスパイアされ、ついに自分が欲しいものを自分で書いてみました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;githubレポジトリ: &lt;a href=&#34;https://github.com/hnakamur/ltsvlog&#34;&gt;hnakamur/ltsvlog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;APIドキュメント: &lt;a href=&#34;https://godoc.org/github.com/hnakamur/ltsvlog&#34;&gt;ltsvlog - GoDoc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;githubレポジトリのREADMEに使用例のコードがあります。&lt;/p&gt;

&lt;h2 id=&#34;ltsvlogの設計と実装:9bb767831423b01f10b84a34c21f4871&#34;&gt;ltsvlogの設計と実装&lt;/h2&gt;

&lt;h3 id=&#34;ltsvlogのログレベル:9bb767831423b01f10b84a34c21f4871&#34;&gt;ltsvlogのログレベル&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://dave.cheney.net/2015/11/05/lets-talk-about-logging&#34;&gt;Let’s talk about logging | Dave Cheney&lt;/a&gt;にもありましたが、ログレベルが多すぎると使い分けで悩むので少ないほうが良いと私も思います。ただ、エラー以外にもなにかが成功したときに記録しておきたいことはあるので、ErrorとInfoは分けたほうが良いと思います。あと私はprintデバッグ信者なのでデバッグログ用のDebugレベルは必要です。&lt;/p&gt;

&lt;p&gt;ということで、ltsvlogのログレベルはDebug, Info, Errorの3つです。&lt;/p&gt;

&lt;p&gt;レベル毎に出力するかしないかの切り替えはDebugレベルのみ許可することにしました。InfoとErrorは本番運用時にもログ出力するものだけに使うという考えです。Debugレベルを出力するかどうかは&lt;a href=&#34;https://godoc.org/github.com/hnakamur/ltsvlog#NewLTSVLogger&#34;&gt;NewLTSVLogger&lt;/a&gt;でロガーを作るときに指定します。&lt;/p&gt;

&lt;p&gt;またDebugレベルのログ出力は無効時には引数の評価もしたくないので、 &lt;a href=&#34;https://godoc.org/github.com/hnakamur/ltsvlog#LTSVLogger.DebugEnabled&#34;&gt;LTSVLogger.DebugEnabled()&lt;/a&gt;というメソッドも用意しました。使用例はこんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if ltsvlog.Logger.DebugEnabled() {
        ltsvlog.Logger.Debug(ltsvlog.LV{&amp;quot;msg&amp;quot;, &amp;quot;This is a debug message&amp;quot;},
            ltsvlog.LV{&amp;quot;key&amp;quot;, &amp;quot;key1&amp;quot;}, ltsvlog.LV{&amp;quot;intValue&amp;quot;, 234})
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;スタックトレースの出力:9bb767831423b01f10b84a34c21f4871&#34;&gt;スタックトレースの出力&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/hnakamur/ltsvlog#LTSVLogger.ErrorWithStack&#34;&gt;LTSVLogger.ErrorWithStack&lt;/a&gt;でスタックトレース付きでログ出力できます。&lt;/p&gt;

&lt;p&gt;LTSV形式ではログは1レコードで1行にする必要があります。&lt;a href=&#34;https://golang.org/pkg/runtime/#Stack&#34;&gt;runtime.Stack&lt;/a&gt;でスタックトレースをバッファに書いてくれるのですが、こちらは複数行の出力になっています。コードを適宜コピペして好きな形式で出力するようにしようかと思ったのですが、&lt;a href=&#34;https://golang.org/src/runtime/mprof.go?s=16037:16073#L574&#34;&gt;src/runtime/mprof.go&lt;/a&gt;のソースコードを見て思いとどまりました。&lt;/p&gt;

&lt;p&gt;ということで、runtime.Stackの出力結果を加工するという方式で実装しています。
実際のコードは&lt;a href=&#34;https://github.com/hnakamur/ltsvlog/blob/v0.9.3/stack.go#L13-L60&#34;&gt;ltsvlog/stack.go&lt;/a&gt;です。コールスタックから不要な部分を取り除きつつ複数行から1行に変形するということで必ず元の長さより縮むので runtime.Stack で出力したバッファをそのまま使って変形しています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/runtime/#Stack&#34;&gt;runtime.Stack&lt;/a&gt;は呼び出し側がバッファを渡す必要があるのですが、サイズが小さいとスタックトレースが途中で切れてしまいます。デフォルトで 8192 というサイズにしたのですが、足りない場合は &lt;a href=&#34;https://godoc.org/github.com/hnakamur/ltsvlog#NewLTSVLoggerCustomFormat&#34;&gt;NewLTSVLoggerCustomFormat&lt;/a&gt; の引数でバッファサイズを指定できるようにしてます。&lt;/p&gt;

&lt;h3 id=&#34;時刻とログレベルの出力:9bb767831423b01f10b84a34c21f4871&#34;&gt;時刻とログレベルの出力&lt;/h3&gt;

&lt;p&gt;時刻はUTCでフォーマットは &lt;a href=&#34;https://golang.org/pkg/time/#pkg-constants&#34;&gt;time&lt;/a&gt;パッケージの &lt;code&gt;RFC3339Nano = &amp;quot;2006-01-02T15:04:05.999999999Z07:00&amp;quot;&lt;/code&gt; に近いですが、ナノセカンドの部分は個人的な好みで9桁固定で出力するようにしました。&lt;/p&gt;

&lt;h3 id=&#34;値の文字列化:9bb767831423b01f10b84a34c21f4871&#34;&gt;値の文字列化&lt;/h3&gt;

&lt;p&gt;上のコード例のようにラベルと値の組は&lt;a href=&#34;https://godoc.org/github.com/hnakamur/ltsvlog#LV&#34;&gt;ltsvlog.LV&lt;/a&gt;で指定します。&lt;/p&gt;

&lt;p&gt;将来 LV にフィールドが追加されるかもしれないと防御的に実装するなら、以下のように書いたほうが良いわけですが、LabelとValueでLVということでフィールド追加するつもりは無いので &lt;code&gt;L:&lt;/code&gt; や &lt;code&gt;V:&lt;/code&gt; は省略して、上記の例のように書いています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if ltsvlog.Logger.DebugEnabled() {
        ltsvlog.Logger.Debug(ltsvlog.LV{L: &amp;quot;msg&amp;quot;, V: &amp;quot;This is a debug message&amp;quot;},
            ltsvlog.LV{L: &amp;quot;key&amp;quot;, V: &amp;quot;key1&amp;quot;}, ltsvlog.LV{L: &amp;quot;intValue&amp;quot;, V: 234})
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;値の文字列化は &lt;a href=&#34;https://github.com/hnakamur/ltsvlog/blob/v0.9.3/log.go#L175-L219&#34;&gt;https://github.com/hnakamur/ltsvlog/blob/v0.9.3/log.go#L175-L219&lt;/a&gt; で行っています。&lt;a href=&#34;https://golang.org/ref/spec#Type_switches&#34;&gt;Type switches&lt;/a&gt;を使って、値の型に応じて文字列化しています。コメントにも書いていますが、byteとuint8、runeとuintは別のcaseとして書くとコンパイルエラーになったので諦めてuint8とuintのほうだけを残しています。&lt;/p&gt;

&lt;p&gt;時刻とログレベルの出力形式と値の文字列化の方式を変えたい場合は関数を実装して&lt;a href=&#34;https://godoc.org/github.com/hnakamur/ltsvlog#NewLTSVLoggerCustomFormat&#34;&gt;NewLTSVLoggerCustomFormat&lt;/a&gt; の引数に指定すれば良いようにしてあります。&lt;/p&gt;

&lt;h3 id=&#34;グローバルロガー:9bb767831423b01f10b84a34c21f4871&#34;&gt;グローバルロガー&lt;/h3&gt;

&lt;p&gt;標準の&lt;a href=&#34;https://golang.org/pkg/log/&#34;&gt;log&lt;/a&gt;パッケージではグローバルロガーの変数は非公開で&lt;a href=&#34;https://golang.org/pkg/log/#Print&#34;&gt;log.Print&lt;/a&gt;や&lt;a href=&#34;https://golang.org/pkg/log/#SetOutput&#34;&gt;log.SetOutput&lt;/a&gt;の関数で操作するようになっています。&lt;/p&gt;

&lt;p&gt;私は関数を増やすのが嫌だったのとグローバルロガーの変数は公開しても良いのではと思ったのでそうしました。&lt;a href=&#34;https://godoc.org/github.com/hnakamur/ltsvlog#pkg-variables&#34;&gt;ltsvlog.Logger&lt;/a&gt;で参照できます。デフォルトでは標準出力にデバッグログありで出力するようになっています。デバッグログをオフにしたい場合はmain関数の最初のほうで(ログ出力する前に)以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ltsvlog.Logger = ltsvlog.NewLTSVLogger(os.Stdout, false)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ログ出力中に設定を変えることはないという想定です。&lt;/p&gt;

&lt;h3 id=&#34;logwriterインタフェースと常に何も出力しないdiscard:9bb767831423b01f10b84a34c21f4871&#34;&gt;LogWriterインタフェースと常に何も出力しないDiscard&lt;/h3&gt;

&lt;p&gt;後付ですが&lt;a href=&#34;https://godoc.org/github.com/hnakamur/ltsvlog#LogWriter&#34;&gt;ltsvlog.LogWriter&lt;/a&gt;というインタフェースも定義してみました。インタフェースは Logger という名前にしたいところでしたが、グローバルロガーに Logger という名前を使っていたので仕方なく LogWriter にしました。そして常に何も出力しない Discard というのも作りました。ただし、Infoなどの引数は評価されてしまうので実行コストが0なわけではないです。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:9bb767831423b01f10b84a34c21f4871&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/ltsvlog#benchmark-result&#34;&gt;Benchmark result&lt;/a&gt;に標準のlogパッケージと比較したベンチマーク結果を載せています。logパッケージよりは遅い手ですがほぼ同等だと言えると思います。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/ltsvlog&#34;&gt;hnakamur/ltsvlog&lt;/a&gt;はコード量も大したことないので、保守で困ることはないと楽観視しています。&lt;/p&gt;

&lt;p&gt;ということで自分で書くライブラリやアプリケーションではどんどん使っていきたいと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Goで複数のリモートのワーカーにジョブを実行させるremoteworkersというパッケージを書いた</title>
      <link>/blog/2016/06/12/wrote_remoteworkers_go_pacakge/</link>
      <pubDate>Sun, 12 Jun 2016 21:53:35 +0900</pubDate>
      
      <guid>/blog/2016/06/12/wrote_remoteworkers_go_pacakge/</guid>
      <description>

&lt;h2 id=&#34;なぜ書いたか:f08dcf6e6ce356e4d337921a2f499b3e&#34;&gt;なぜ書いたか&lt;/h2&gt;

&lt;p&gt;仕事で複数のサーバで同じ処理を実行して結果を集めたいというニーズがあって、各サーバをgRPCのサーバにするという実装でとりあえず実現していました。でも、出来れば処理を実行するワーカーサーバから制御サーバに接続して繋ぎっぱなしにしておいて、制御サーバからジョブを送り込む方式にしたいなーと思っていて、家で実装を進めていました。&lt;/p&gt;

&lt;h2 id=&#34;これまでに試したこと:f08dcf6e6ce356e4d337921a2f499b3e&#34;&gt;これまでに試したこと&lt;/h2&gt;

&lt;p&gt;gRPCに&lt;a href=&#34;http://www.grpc.io/docs/tutorials/basic/go.html#bidirectional-streaming-rpc&#34;&gt;Bidirectional streaming RPC&lt;/a&gt;というのがあったので、&lt;a href=&#34;https://github.com/hnakamur/grpc_notification_experiment&#34;&gt;hnakamur/grpc_notification_experiment&lt;/a&gt;で試してみたのですが、複数クライアントがサーバに接続した状態で、サーバからクライアントにジョブを投げても、1つのクライアントでしか処理が実行されないということがわかりました。&lt;/p&gt;

&lt;p&gt;次に、ワーカーサーバから制御サーバにTCPのソケットで接続しておいて、制御サーバからワーカーサーバにジョブを投げて結果を集めるサンプルを書いてみました。
&lt;a href=&#34;https://github.com/hnakamur/tcp_pubsubreply_experiment&#34;&gt;hnakamur/tcp_pubsubreply_experiment&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;複数のワーカーに同じジョブを投げて結果を集めて、全てのワーカーからの結果が揃ったらクライアントに結果を返すというものです。 &lt;a href=&#34;https://github.com/hnakamur/tcp_pubsubreply_experiment/blob/f9201c075661c5d58895f9a30b47f73f5c4cc13d/main.go#L167-L189&#34;&gt;https://github.com/hnakamur/tcp_pubsubreply_experiment/blob/f9201c075661c5d58895f9a30b47f73f5c4cc13d/main.go#L167-L189&lt;/a&gt; でジョブを各ワーカーのコネクションが持つチャンネルに送って、各ワーカーの結果を返すチャンネルから受け取るという素朴な実装になっています。&lt;/p&gt;

&lt;p&gt;しかし、この実装では1つのジョブを実行中は他のジョブを実行できないという制限があります。また試しているとタイミングによっては期待通りの動きにならないことがありました。&lt;/p&gt;

&lt;h2 id=&#34;今回の実装:f08dcf6e6ce356e4d337921a2f499b3e&#34;&gt;今回の実装&lt;/h2&gt;

&lt;p&gt;実装は&lt;a href=&#34;https://github.com/hnakamur/remoteworkers&#34;&gt;hnakamur/remoteworkers&lt;/a&gt;で公開しています。使用例は&lt;a href=&#34;https://github.com/hnakamur/remoteworkers/tree/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example&#34;&gt;remoteworkers/example&lt;/a&gt;、APIドキュメントは&lt;a href=&#34;https://godoc.org/github.com/hnakamur/remoteworkers&#34;&gt;remoteworkers - GoDoc&lt;/a&gt;を参照してください。&lt;/p&gt;

&lt;p&gt;最初はWebSocketのライブラリ&lt;a href=&#34;https://github.com/gorilla/websocket&#34;&gt;github.com/gorilla/websocket&lt;/a&gt;の&lt;a href=&#34;https://github.com/gorilla/websocket/tree/a68708917c6a4f06314ab4e52493cc61359c9d42/examples&#34;&gt;examples&lt;/a&gt;のchatとechoのclientを組み合わせて改変していきました。chatは1つのクライアントからのメッセージを他のクライアントに送って終わりですが、今回はジョブを実行して結果を集めたいので、その処理を追加で実装しました。また、元のサンプルはグローバル変数や設定用の定数を使うようになっていたのでstructを定義してグローバル変数をやめて設定もstructのメンバーに持つようにしました。&lt;/p&gt;

&lt;p&gt;ワーカーはサーバにwebsocketで接続しますが、クライアントは通常のhttpリクエストでジョブを投げてレスポンスで結果を受け取るようにしてみました。ワーカーとサーバの間のメッセージは&lt;a href=&#34;/blog/blog/2016/06/04/benchmark_go_msgpack_libraries/&#34;&gt;GoのMessagePackのライブラリのベンチマークをしてみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;で試した&lt;a href=&#34;https://github.com/vmihailenco/msgpack&#34;&gt;vmihailenco/msgpack&lt;/a&gt;を使ってMessagePackでエンコード・デコードしています。&lt;/p&gt;

&lt;p&gt;以下実装メモです。&lt;/p&gt;

&lt;h3 id=&#34;connとhub:f08dcf6e6ce356e4d337921a2f499b3e&#34;&gt;ConnとHub&lt;/h3&gt;

&lt;p&gt;サーバ側のメインの処理は、サーバとワーカーのコネクションを扱う&lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/conn.go&#34;&gt;Conn&lt;/a&gt;と複数のConnの間を取り持つ&lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go&#34;&gt;Hub&lt;/a&gt;が担当しています。&lt;/p&gt;

&lt;h3 id=&#34;読み取りと書き出しでgoroutineを分ける:f08dcf6e6ce356e4d337921a2f499b3e&#34;&gt;読み取りと書き出しでgoroutineを分ける&lt;/h3&gt;

&lt;p&gt;上記の&lt;a href=&#34;https://github.com/hnakamur/tcp_pubsubreply_experiment&#34;&gt;hnakamur/tcp_pubsubreply_experiment&lt;/a&gt;では、ワーカーとサーバ間のTCPコネクション1つのに対して1つgoroutineを作ってデータの読み書きをしていました。&lt;/p&gt;

&lt;p&gt;一方、&lt;a href=&#34;https://godoc.org/github.com/gorilla/websocket&#34;&gt;github.com/gorilla/websocketのAPIドキュメント&lt;/a&gt;の&lt;a href=&#34;https://godoc.org/github.com/gorilla/websocket#hdr-Concurrency&#34;&gt;Concurrency&lt;/a&gt;にコネクションは1つのコンカレントなリーダーと1つのコンカレントなライターをサポートすると書いてあります。&lt;/p&gt;

&lt;p&gt;chatのexampleを見ると&lt;a href=&#34;https://github.com/gorilla/websocket/blob/a68708917c6a4f06314ab4e52493cc61359c9d42/examples/chat/conn.go#L50-L69&#34;&gt;Conn.readPump()&lt;/a&gt;で読み取り処理のループ、&lt;a href=&#34;https://github.com/gorilla/websocket/blob/a68708917c6a4f06314ab4e52493cc61359c9d42/examples/chat/conn.go#L78-L116&#34;&gt;Conn.writePump()&lt;/a&gt;で書き出し処理のループを実装していて &lt;a href=&#34;https://github.com/gorilla/websocket/blob/a68708917c6a4f06314ab4e52493cc61359c9d42/examples/chat/conn.go#L127-L128&#34;&gt;https://github.com/gorilla/websocket/blob/a68708917c6a4f06314ab4e52493cc61359c9d42/examples/chat/conn.go#L127-L128&lt;/a&gt; でgoroutineを使って並行(concurrent)に実行しています。&lt;/p&gt;

&lt;p&gt;この方式により上記の&lt;a href=&#34;https://godoc.org/github.com/gorilla/websocket#hdr-Concurrency&#34;&gt;Concurrency&lt;/a&gt;の1つのコネクションに1つのコンカレントなリーダーと1つのコンカレントなライターという条件を自動的に満たすことが出来ます。&lt;/p&gt;

&lt;p&gt;さらに、ワーカーでのジョブの実行も &lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/worker.go#L200-L214&#34;&gt;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/worker.go#L200-L214&lt;/a&gt; のように別のgoroutineで実行するようにしました。読み取りと書き出しのgoroutineを分け、ジョブ実行のgoroutineも別にしたことで、ワーカーでジョブを実行中でも別のジョブを受け取って実行することが出来るようになりました。&lt;/p&gt;

&lt;h3 id=&#34;ジョブのディスパッチと結果の収集:f08dcf6e6ce356e4d337921a2f499b3e&#34;&gt;ジョブのディスパッチと結果の収集&lt;/h3&gt;

&lt;p&gt;各ワーカーからにジョブを投げて結果を集める部分も &lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L139-L171&#34;&gt;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L139-L171&lt;/a&gt; のように書くことで、複数のジョブを並行で実行できるようになっています。&lt;/p&gt;

&lt;p&gt;例えば、あるジョブを依頼されてそれの結果が集まる前に、次のジョブを受け取ってそちらの結果が先に集まった場合はそちらを先に返すことができます。&lt;/p&gt;

&lt;h3 id=&#34;自動で再接続:f08dcf6e6ce356e4d337921a2f499b3e&#34;&gt;自動で再接続&lt;/h3&gt;

&lt;p&gt;ワーカーとの接続が切れた場合は、残ったワーカーだけで処理を実行する仕様としました。ジョブを受け取った時にワーカーが1つもいない場合はエラーとしています。また、ワーカーからサーバへの接続が切れた場合は1秒待って再起動を無限に繰り替えすようにしています。時間は設定で変更可能です。ただし、だんだん間隔を開けるといったことは出来ないのでその場合はフォークして改変してください。&lt;/p&gt;

&lt;h3 id=&#34;返信用のチャンネルを渡して実行:f08dcf6e6ce356e4d337921a2f499b3e&#34;&gt;返信用のチャンネルを渡して実行&lt;/h3&gt;

&lt;p&gt;サーバとワーカのコネクションをHubに登録する箇所 &lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/conn.go#L86-L92&#34;&gt;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/conn.go#L86-L92&lt;/a&gt; とクライアントから依頼されたジョブをHubに投げて全ワーカーからの結果を受け取る箇所 &lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L194-L203&#34;&gt;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L194-L203&lt;/a&gt; では、結果を受け取るためのチャンネルをHubへのチャンネルに渡して実行するという方法を取りました。&lt;/p&gt;

&lt;p&gt;これによってHubとのやり取りは全てチャンネル経由になりシンプルになりました。さらに関数の中に閉じ込めることで、ライブラリの利用者はチャンネルを意識することなく単なる関数呼び出しで使えるようになっています。&lt;/p&gt;

&lt;h3 id=&#34;ジョブのエンコード-デコード:f08dcf6e6ce356e4d337921a2f499b3e&#34;&gt;ジョブのエンコード・デコード&lt;/h3&gt;

&lt;p&gt;まずクライアントではジョブをJSONでエンコードしています。
&lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/client/client.go#L25-L30&#34;&gt;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/client/client.go#L25-L30&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;サーバでは受け取ったジョブをJSONでデコードします。
&lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/server/main.go#L52-L54&#34;&gt;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/server/main.go#L52-L54&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;その後&lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L193-L205&#34;&gt;Hub.RequestWork()&lt;/a&gt;でHubにジョブが渡されて
&lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L142&#34;&gt;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L142&lt;/a&gt;
でMessagePackでエンコードしてワーカーに送ります。&lt;/p&gt;

&lt;p&gt;ワーカーでは
&lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/worker.go#L187-L188&#34;&gt;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/worker.go#L187-L188&lt;/a&gt;
で受け取ったジョブをMessagePackでデコードします。&lt;/p&gt;

&lt;p&gt;ワーカーでジョブを受け取って処理する部分は
&lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/worker/main.go#L47-L58&#34;&gt;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/worker/main.go#L47-L58&lt;/a&gt;
です。&lt;a href=&#34;https://github.com/vmihailenco/msgpack&#34;&gt;vmihailenco/msgpack&lt;/a&gt;で &lt;code&gt;map[string]string&lt;/code&gt; 型をエンコードしてデコードすると &lt;code&gt;map[interface{}]interface{}&lt;/code&gt; になったので&lt;a href=&#34;https://golang.org/ref/spec#Type_assertions&#34;&gt;type assertion&lt;/a&gt;を使って参照する必要がありました。&lt;/p&gt;

&lt;h3 id=&#34;結果のエンコード-デコード:f08dcf6e6ce356e4d337921a2f499b3e&#34;&gt;結果のエンコード・デコード&lt;/h3&gt;

&lt;p&gt;ワーカーでの結果は
&lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/worker.go#L202-L206&#34;&gt;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/worker.go#L202-L206&lt;/a&gt;
でMessagePackにエンコードしています。&lt;/p&gt;

&lt;p&gt;サーバでは
&lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/conn.go#L148-L163&#34;&gt;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/conn.go#L148-L163&lt;/a&gt;
で結果をMessagePackでデコードしてHubに送っています。&lt;/p&gt;

&lt;p&gt;Hubでは
&lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L165-L171&#34;&gt;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L165-L171&lt;/a&gt;
で1つのワーカーからの結果を受け取り、全てのワーカーからの結果が揃ったらクライアントへ返信するためのチャンネルに集めた結果を送ります。&lt;/p&gt;

&lt;p&gt;サーバでは
&lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/server/main.go#L28-L39&#34;&gt;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/server/main.go#L28-L39&lt;/a&gt;
で集めた結果の構造を変形し、
&lt;a href=&#34;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/server/main.go#L69-L70&#34;&gt;https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/server/main.go#L69-L70&lt;/a&gt;
でJSONにエンコードしています。&lt;/p&gt;

&lt;h3 id=&#34;tcpソケットからwebsocketにして良かったところ:f08dcf6e6ce356e4d337921a2f499b3e&#34;&gt;TCPソケットからWebSocketにして良かったところ&lt;/h3&gt;

&lt;p&gt;ワーカーからサーバに接続したときにワーカーのIDを登録しているのですが、TCPソケットのときはそのためにワーカーから登録用のメッセージを送って成功失敗の結果を送る必要がありました。一方WebSocketではエンドポイントに接続するときにリクエストヘッダで追加の情報を送れるので &lt;code&gt;X-Worker-ID&lt;/code&gt; と言うヘッダ名でワーカーIDを送るようにしました。&lt;/p&gt;

&lt;p&gt;また、TCPソケットだと1つのポートでクライアントとワーカーからの通信を受ける場合はメッセージの内容で区別がつくようにしておく必要があります。WebSocketの場合は1つのポートでもURLのPathを別にするという手が使えるので楽です。しかも今回のようにワーカーはWebSocketで接続し、クライアントはhttpで接続ということも出来て便利です。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:f08dcf6e6ce356e4d337921a2f499b3e&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;当初やりたいと思っていたことがようやく実現できました。しかも、これだけ並列性が高いプログラムなのにgoroutineとchannelのおかげですっきりシンプルなコードで実装出来ています。これなら保守や改変もしやすくて助かります。やっぱりGoは素晴らしいです！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GoのMessagePackのライブラリのベンチマークをしてみた</title>
      <link>/blog/2016/06/04/benchmark_go_msgpack_libraries/</link>
      <pubDate>Sat, 04 Jun 2016 22:17:52 +0900</pubDate>
      
      <guid>/blog/2016/06/04/benchmark_go_msgpack_libraries/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://qiita.com/yosisa/items/f21d3476bc8d368d7494&#34;&gt;Go の msgpack ライブラリ比較 - Qiita&lt;/a&gt;の記事が最終更新日から1年以上経過しているとのことなので、現在の最新のコミットで試してみました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;github.com/vmihailenco/msgpack&lt;/code&gt; を &lt;code&gt;go get&lt;/code&gt; すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/vmihailenco/msgpack
package github.com/vmihailenco/msgpack: code in directory /home/hnakamur/gocode/src/github.com/vmihailenco/msgpack expects import &amp;quot;gopkg.in/vmihailenco/msgpack.v2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と言われたので &lt;code&gt;go get gopkg.in/vmihailenco/msgpack.v2&lt;/code&gt; で取得し、この記事のコードの &lt;code&gt;&amp;quot;github.com/vmihailenco/msgpack&amp;quot;&lt;/code&gt; を &lt;code&gt;&amp;quot;gopkg.in/vmihailenco/msgpack.v2&amp;quot;&lt;/code&gt; に書き換え &lt;code&gt;msgpack_test.go&lt;/code&gt; という名前で保存して試しました。&lt;/p&gt;

&lt;p&gt;エンコードは &lt;code&gt;gopkg.in/vmihailenco/msgpack.v2&lt;/code&gt; 、デコードは &lt;code&gt;github.com/ugorji/go/codec&lt;/code&gt; が速いという結果になりましたが、総合的にはほぼ同等と言えると思います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test -bench . -benchmem
testing: warning: no tests to run
PASS
BenchmarkCodecEncode-2            500000              3236 ns/op              48 B/op          2 allocs/op
BenchmarkCodecDecode-2            200000              8998 ns/op             264 B/op         25 allocs/op
BenchmarkMsgpackEncode-2          500000              2624 ns/op              48 B/op          2 allocs/op
BenchmarkMsgpackDecode-2          200000             10604 ns/op             448 B/op         35 allocs/op
ok      bitbucket.org/hnakamur/msgpack_experiment       7.146s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ベンチマークに使用したライブラリとGoのバージョンは以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git -C $GOPATH/src/github.com/ugorji/go rev-parse HEAD
a396ed22fc049df733440d90efe17475e3929ccb
$ git -C $GOPATH/src/gopkg.in/vmihailenco/msgpack.v2 rev-parse HEAD
851cd631b60599a692b136c60eb6eb2899b0e664
$ go version
go version go1.6.2 linux/amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/vmihailenco/msgpack&#34;&gt;vmihailenco/msgpack: MessagePack encoding for Golang&lt;/a&gt;のベンチマークもやってみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test -bench . -benchmem                                          
2016/06/04 22:12:13 
************************************************ 
package github.com/ugorji/go-msgpack has been deprecated (05/29/2013). 
It will be retired anytime from July 1, 2013.
Please update to faster and much much better github.com/ugorji/go/codec.
See https://github.com/ugorji/go/tree/master/codec#readme for more information.
************************************************ 
OK: 27 passed, 1 skipped
PASS
BenchmarkBool-2                         20000000                90.3 ns/op             0 B/op          0 allocs/op
BenchmarkInt0-2                         20000000                96.1 ns/op             0 B/op          0 allocs/op
BenchmarkInt1-2                         10000000               123 ns/op               0 B/op          0 allocs/op
BenchmarkInt2-2                         10000000               123 ns/op               0 B/op          0 allocs/op
BenchmarkInt4-2                         10000000               179 ns/op               0 B/op          0 allocs/op
BenchmarkInt8-2                         10000000               176 ns/op               0 B/op          0 allocs/op
BenchmarkInt0Binary-2                    5000000               340 ns/op              24 B/op          3 allocs/op
BenchmarkInt0UgorjiGoMsgpack-2           3000000               586 ns/op               8 B/op          1 allocs/op
BenchmarkInt0UgorjiGoCodec-2             5000000               360 ns/op               0 B/op          0 allocs/op
BenchmarkTime-2                          5000000               353 ns/op               0 B/op          0 allocs/op
BenchmarkDuration-2                     10000000               180 ns/op               0 B/op          0 allocs/op
BenchmarkByteSlice-2                     1000000              1021 ns/op            1024 B/op          1 allocs/op
BenchmarkByteArray-2                      500000              2741 ns/op            2112 B/op          4 allocs/op
BenchmarkByteSliceUgorjiGoCodec-2        2000000               647 ns/op               0 B/op          0 allocs/op
BenchmarkByteArrayUgorjiGoCodec-2        1000000              2632 ns/op            1088 B/op          3 allocs/op
BenchmarkMapStringString-2               1000000              1898 ns/op              16 B/op          4 allocs/op
BenchmarkMapStringStringPtr-2             500000              2461 ns/op              32 B/op          5 allocs/op
BenchmarkMapStringStringUgorjiGoCodec-2  1000000              1737 ns/op              16 B/op          4 allocs/op
BenchmarkMapIntInt-2                      500000              3424 ns/op             208 B/op         10 allocs/op
BenchmarkStringSlice-2                   3000000               530 ns/op              10 B/op          2 allocs/op
BenchmarkStringSlicePtr-2                1000000              1270 ns/op              26 B/op          3 allocs/op
BenchmarkStructVmihailencoMsgpack-2       100000             12732 ns/op            3152 B/op         27 allocs/op
BenchmarkStructMarshal-2                  300000              6003 ns/op            1808 B/op          8 allocs/op
BenchmarkStructUnmarshal-2                200000              5788 ns/op            1344 B/op         19 allocs/op
BenchmarkStructManual-2                   200000              6610 ns/op            2720 B/op         21 allocs/op
BenchmarkStructUgorjiGoMsgpack-2          100000             17138 ns/op            3616 B/op         70 allocs/op
BenchmarkStructUgorjiGoCodec-2            100000             21833 ns/op            7345 B/op         23 allocs/op
BenchmarkStructJSON-2                      20000             63809 ns/op            7896 B/op         26 allocs/op
BenchmarkStructGOB-2                       20000             96275 ns/op           14664 B/op        278 allocs/op
BenchmarkStructUnmarshalPartially-2       300000              5791 ns/op            2272 B/op         12 allocs/op
BenchmarkCSV-2                            200000              6971 ns/op            8748 B/op         12 allocs/op
BenchmarkCSVMsgpack-2                    1000000              1541 ns/op             384 B/op         13 allocs/op
ok      gopkg.in/vmihailenco/msgpack.v2 58.623s
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gopkg-in-vmihailenco-msgpack-v2-でgoのstructをエンコード-デコードするインターフェース:b74e35b057eed94577fdfad5f24e6611&#34;&gt;gopkg.in/vmihailenco/msgpack.v2 でGoのstructをエンコード・デコードするインターフェース&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/gopkg.in/vmihailenco/msgpack.v2#Marshaler&#34;&gt;Marshaler&lt;/a&gt; はdeprecatedで&lt;a href=&#34;https://godoc.org/gopkg.in/vmihailenco/msgpack.v2#CustomEncoder&#34;&gt;CustomEncoder&lt;/a&gt;を使えとのことです。&lt;a href=&#34;https://godoc.org/gopkg.in/vmihailenco/msgpack.v2#CustomEncoder&#34;&gt;CustomEncoder&lt;/a&gt; の Example を見ると使い方も簡単そうです。&lt;/p&gt;

&lt;h2 id=&#34;gopkg-in-vmihailenco-msgpack-v2-を使うことにします:b74e35b057eed94577fdfad5f24e6611&#34;&gt;gopkg.in/vmihailenco/msgpack.v2 を使うことにします&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/vmihailenco/msgpack&#34;&gt;github.com/vmihailenco/msgpack&lt;/a&gt;も&lt;a href=&#34;https://github.com/ugorji/go/tree/master/codec&#34;&gt;go/codec at master · ugorji/go&lt;/a&gt;も活発にメンテナンスされているようです。&lt;/p&gt;

&lt;p&gt;APIドキュメント &lt;a href=&#34;https://godoc.org/gopkg.in/vmihailenco/msgpack.v2&#34;&gt;gopkg.in/vmihailenco/msgpack.v2&lt;/a&gt;、&lt;a href=&#34;https://godoc.org/github.com/ugorji/go/codec&#34;&gt;github.com/ugorji/go/codec&lt;/a&gt; を見ると私は前者のほうがしっくりきました。ということで gopkg.in/vmihailenco/msgpack.v2 を使うことにします。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LXDのREST APIクライアントライブラリpylxdを試してみた</title>
      <link>/blog/2016/05/07/tried-pylxd/</link>
      <pubDate>Sat, 07 May 2016 21:17:35 +0900</pubDate>
      
      <guid>/blog/2016/05/07/tried-pylxd/</guid>
      <description>

&lt;p&gt;Python Package Index (PyPI)の &lt;a href=&#34;https://pypi.python.org/pypi/pylxd/2.0.0&#34;&gt;pylxd 2.0.0&lt;/a&gt;のページにインストール方法と使い方の例が書いてあるので、これに沿って試しました。&lt;/p&gt;

&lt;h2 id=&#34;インストール:bdf999a6ff5e91d3491152b509b9755e&#34;&gt;インストール&lt;/h2&gt;

&lt;p&gt;Ubuntu 16.04だとaptでインストール可能なのでそちらでインストールしました。Python3用のpython3-pylxdパッケージとPython2用のpython-pylxdパッケージがありますが、今後Ansibleのモジュールを作ることを想定してPython2用のパッケージをインストールして試してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt install -y python-pylxd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストールしたpython-pylxdのバージョンは &lt;code&gt;2.0.0-0ubuntu1&lt;/code&gt; です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dpkg-query -W -f=&#39;${Version}\n&#39; python-pylxd
2.0.0-0ubuntu1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;試してみる:bdf999a6ff5e91d3491152b509b9755e&#34;&gt;試してみる&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ python
Python 2.7.11+ (default, Apr 17 2016, 14:00:29)
[GCC 5.3.1 20160413] on linux2
Type &amp;quot;help&amp;quot;, &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information.
&amp;gt;&amp;gt;&amp;gt; from pylxd import api
&amp;gt;&amp;gt;&amp;gt; lxd = api.API()
&amp;gt;&amp;gt;&amp;gt; lxd.container_defined(&#39;cent01&#39;)
True
&amp;gt;&amp;gt;&amp;gt; lxd.container_defined(&#39;hoge&#39;)
False
&amp;gt;&amp;gt;&amp;gt; lxd.container_list()
[u&#39;cent01&#39;, u&#39;cent02&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここから先は &lt;a href=&#34;https://github.com/lxc/pylxd/blob/master/pylxd/client.py&#34;&gt;pylxd/client.py&lt;/a&gt; と &lt;a href=&#34;https://github.com/lxc/pylxd/blob/master/pylxd/container.py&#34;&gt;pylxd/container.py&lt;/a&gt; の ソースを見ながら試しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from pylxd.client import Client
&amp;gt;&amp;gt;&amp;gt; client = Client()
&amp;gt;&amp;gt;&amp;gt; client.containers.all()
[&amp;lt;pylxd.container.Container object at 0x7fd44065db00&amp;gt;, &amp;lt;pylxd.container.Container object at 0x7fd44065db98&amp;gt;]
&amp;gt;&amp;gt;&amp;gt; client.containers.get(u&#39;cent01&#39;)
&amp;lt;pylxd.container.Container object at 0x7fd44065dc30&amp;gt;
&amp;gt;&amp;gt;&amp;gt; client.containers.get(u&#39;cent01&#39;).status
u&#39;Running&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LXDのREST APIをcurlで試してみた</title>
      <link>/blog/2016/05/07/tried-lxd-rest-api-with-curl/</link>
      <pubDate>Sat, 07 May 2016 21:17:34 +0900</pubDate>
      
      <guid>/blog/2016/05/07/tried-lxd-rest-api-with-curl/</guid>
      <description>

&lt;h2 id=&#34;lxdのrest-api:7237ac0558fc8bd24e4a1da16716b70c&#34;&gt;LXDのREST API&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/rest-api/&#34;&gt;Linux Containers - LXD - REST API&lt;/a&gt;と&lt;a href=&#34;https://github.com/lxc/lxd/blob/master/doc/rest-api.md&#34;&gt;lxd/rest-api.md at master · lxc/lxd&lt;/a&gt;にLXDのREST APIについて説明があります。&lt;/p&gt;

&lt;p&gt;また&lt;a href=&#34;https://github.com/lxc/lxd#using-the-rest-api&#34;&gt;Using the REST API&lt;/a&gt;に &lt;code&gt;curl&lt;/code&gt; コマンドでのAPI呼び出し例が書かれていました。&lt;/p&gt;

&lt;h2 id=&#34;curlでhttpsのエンドポイントにアクセスしてみたがエラー:7237ac0558fc8bd24e4a1da16716b70c&#34;&gt;curlでhttpsのエンドポイントにアクセスしてみたがエラー&lt;/h2&gt;

&lt;p&gt;まずはhttpsのURLで &lt;a href=&#34;https://github.com/lxc/lxd/blob/master/doc/rest-api.md#10&#34;&gt;/1.0&lt;/a&gt; エンドポイントを試してみたのですが、 &lt;code&gt;ALPN, server did not agree to a protocol&lt;/code&gt; というエラーになってしまいました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -k -v --cert ~/.config/lxc/client.crt --key ~/.config/lxc/client.key https://127.0.0.1:8443/1.0
*   Trying 127.0.0.1...
* Connected to 127.0.0.1 (127.0.0.1) port 8443 (#0)
* found 173 certificates in /etc/ssl/certs/ca-certificates.crt
* found 692 certificates in /etc/ssl/certs
* ALPN, offering http/1.1
* SSL connection using TLS1.2 / ECDHE_RSA_AES_128_GCM_SHA256
*        server certificate verification SKIPPED
*        server certificate status verification SKIPPED
*        common name: root@express (does not match &#39;127.0.0.1&#39;)
*        server certificate expiration date OK
*        server certificate activation date OK
*        certificate public key: RSA
*        certificate version: #3
*        subject: O=linuxcontainers.org,CN=root@express
*        start date: Tue, 03 May 2016 11:26:51 GMT
*        expire date: Fri, 01 May 2026 11:26:51 GMT
*        issuer: O=linuxcontainers.org,CN=root@express
*        compression: NULL
* ALPN, server did not agree to a protocol
&amp;gt; GET /1.0 HTTP/1.1
&amp;gt; Host: 127.0.0.1:8443
&amp;gt; User-Agent: curl/7.47.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Content-Type: application/json
&amp;lt; Date: Sat, 07 May 2016 12:25:53 GMT
&amp;lt; Content-Length: 162
&amp;lt;
{&amp;quot;type&amp;quot;:&amp;quot;sync&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;Success&amp;quot;,&amp;quot;status_code&amp;quot;:200,&amp;quot;metadata&amp;quot;:{&amp;quot;api_extensions&amp;quot;:[],&amp;quot;api_status&amp;quot;:&amp;quot;stable&amp;quot;,&amp;quot;api_version&amp;quot;:&amp;quot;1.0&amp;quot;,&amp;quot;auth&amp;quot;:&amp;quot;untrusted&amp;quot;,&amp;quot;public&amp;quot;:false}}
* Connection #0 to host 127.0.0.1 left intact
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この件は&lt;a href=&#34;https://lists.linuxcontainers.org/pipermail/lxc-users/2016-May/011603.html&#34;&gt;[lxc-users] The error &amp;ldquo;ALPN, server did not agree to a protocol&amp;rdquo; from LXD Rest API&lt;/a&gt;で質問してみました。&lt;/p&gt;

&lt;h2 id=&#34;curlでunix-domain-socket経由でアクセスしてみたら成功:7237ac0558fc8bd24e4a1da16716b70c&#34;&gt;curlでunix domain socket経由でアクセスしてみたら成功&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/toritori0318/items/193df8f749a9c4bda883&#34;&gt;curlでunix domain socket経由アクセスする - Qiita&lt;/a&gt;を参考に以下のようにアクセスしてみると成功しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s --unix-socket /var/lib/lxd/unix.socket https:/1.0 | jq .
{
  &amp;quot;type&amp;quot;: &amp;quot;sync&amp;quot;,
  &amp;quot;status&amp;quot;: &amp;quot;Success&amp;quot;,
  &amp;quot;status_code&amp;quot;: 200,
  &amp;quot;metadata&amp;quot;: {
    &amp;quot;api_extensions&amp;quot;: [],
    &amp;quot;api_status&amp;quot;: &amp;quot;stable&amp;quot;,
    &amp;quot;api_version&amp;quot;: &amp;quot;1.0&amp;quot;,
    &amp;quot;auth&amp;quot;: &amp;quot;trusted&amp;quot;,
    &amp;quot;config&amp;quot;: {
      &amp;quot;core.https_address&amp;quot;: &amp;quot;127.0.0.1:8443&amp;quot;,
      &amp;quot;core.trust_password&amp;quot;: true
    },
    &amp;quot;environment&amp;quot;: {
      &amp;quot;addresses&amp;quot;: [
        &amp;quot;127.0.0.1:8443&amp;quot;
      ],
      &amp;quot;architectures&amp;quot;: [
        &amp;quot;x86_64&amp;quot;,
        &amp;quot;i686&amp;quot;
      ],
      &amp;quot;certificate&amp;quot;: &amp;quot;-----BEGIN CERTIFICATE-----\n …(略)… \n-----END CERTIFICATE-----\n&amp;quot;,
      &amp;quot;driver&amp;quot;: &amp;quot;lxc&amp;quot;,
      &amp;quot;driver_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;kernel&amp;quot;: &amp;quot;Linux&amp;quot;,
      &amp;quot;kernel_architecture&amp;quot;: &amp;quot;x86_64&amp;quot;,
      &amp;quot;kernel_version&amp;quot;: &amp;quot;4.4.0-21-generic&amp;quot;,
      &amp;quot;server&amp;quot;: &amp;quot;lxd&amp;quot;,
      &amp;quot;server_pid&amp;quot;: 6446,
      &amp;quot;server_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;storage&amp;quot;: &amp;quot;dir&amp;quot;,
      &amp;quot;storage_version&amp;quot;: &amp;quot;&amp;quot;
    },
    &amp;quot;public&amp;quot;: false
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sudo lxd init&lt;/code&gt; でLXDをネットワーク越しに使うかの問いにnoと答えた環境では以下のような出力になりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s --unix-socket /var/lib/lxd/unix.socket http:/1.0 | jq .
{
  &amp;quot;type&amp;quot;: &amp;quot;sync&amp;quot;,
  &amp;quot;status&amp;quot;: &amp;quot;Success&amp;quot;,
  &amp;quot;status_code&amp;quot;: 200,
  &amp;quot;metadata&amp;quot;: {
    &amp;quot;api_extensions&amp;quot;: [],
    &amp;quot;api_status&amp;quot;: &amp;quot;stable&amp;quot;,
    &amp;quot;api_version&amp;quot;: &amp;quot;1.0&amp;quot;,
    &amp;quot;auth&amp;quot;: &amp;quot;trusted&amp;quot;,
    &amp;quot;config&amp;quot;: {},
    &amp;quot;environment&amp;quot;: {
      &amp;quot;addresses&amp;quot;: [],
      &amp;quot;architectures&amp;quot;: [
        &amp;quot;x86_64&amp;quot;,
        &amp;quot;i686&amp;quot;
      ],
      &amp;quot;certificate&amp;quot;: &amp;quot;-----BEGIN CERTIFICATE-----\n …(略)… \n-----END CERTIFICATE-----\n&amp;quot;,
      &amp;quot;driver&amp;quot;: &amp;quot;lxc&amp;quot;,
      &amp;quot;driver_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;kernel&amp;quot;: &amp;quot;Linux&amp;quot;,
      &amp;quot;kernel_architecture&amp;quot;: &amp;quot;x86_64&amp;quot;,
      &amp;quot;kernel_version&amp;quot;: &amp;quot;4.4.0-21-generic&amp;quot;,
      &amp;quot;server&amp;quot;: &amp;quot;lxd&amp;quot;,
      &amp;quot;server_pid&amp;quot;: 2150,
      &amp;quot;server_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;storage&amp;quot;: &amp;quot;dir&amp;quot;,
      &amp;quot;storage_version&amp;quot;: &amp;quot;&amp;quot;
    },
    &amp;quot;public&amp;quot;: false
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>AnsibleのLXDコネクションプラグインを試してみた</title>
      <link>/blog/2016/05/07/tried-ansible-lxd-connection-plugin/</link>
      <pubDate>Sat, 07 May 2016 20:32:13 +0900</pubDate>
      
      <guid>/blog/2016/05/07/tried-ansible-lxd-connection-plugin/</guid>
      <description>

&lt;p&gt;LXDを使うとなるとAnsibleのLXDコネクションプラグインが欲しいなと思って&lt;a href=&#34;https://github.com/ansible/ansible&#34;&gt;ansible/ansibleのgithubのレポジトリ&lt;/a&gt;を眺めていたら &lt;a href=&#34;https://github.com/ansible/ansible/blob/fca5ba153e9258d6a9a28c418d8339d507eee81c/lib/ansible/plugins/connection/lxd.py&#34;&gt;lib/ansible/plugins/connection/lxd.py&lt;/a&gt; に既に作られていることに気付きました。&lt;/p&gt;

&lt;p&gt;ソースを見ると &lt;code&gt;lxc&lt;/code&gt; コマンドを使った実装になっていました。aptでインストールしたansible 2.0.0.2にこのファイルだけ追加して使えないか試してみたのですが、 &lt;code&gt;AttributeError: &#39;PlayContext&#39; object has no attribute &#39;executable&#39;&lt;/code&gt; というエラーが出て使えませんでした。&lt;/p&gt;

&lt;p&gt;そこでvirtualenvで環境を作ってpipでgithubのmasterのansibleをインストールして試してみました。&lt;/p&gt;

&lt;h2 id=&#34;インストール手順:13ce47f5622032d397b4204850206b47&#34;&gt;インストール手順&lt;/h2&gt;

&lt;p&gt;インストール手順は以下の通りです。
まず、virtualenv環境でAnsibleをインストールするのに必要なパッケージをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt update
sudo apt install -y virtualenv build-essential python-dev libffi-dev libssl-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作業ディレクトリを作ってそこに移動し、virtualenvで環境を作ってansibleをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir ~/ansible-lxd-example
cd ~/ansible-lxd-example
virtualenv venv
. venv/bin/activate
pip install git+https://github.com/ansible/ansible
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使ってみる:13ce47f5622032d397b4204850206b47&#34;&gt;使ってみる&lt;/h2&gt;

&lt;p&gt;以下のような設定ファイルとテスト用のプレイブックを作りました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ansible.cfg
[defaults]
inventory = hosts
$ cat hosts
[containers]
cent01 ansible_connection=lxd
cent02 ansible_connection=lxd
$ cat test.yml
---
- hosts: containers
  remote_user: root
  tasks:
    - debug: msg=ipv4_address={{ ansible_default_ipv4.address }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行してみると、問題なく動作しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ansible-playbook test.yml

PLAY [containers] **************************************************************

TASK [setup] *******************************************************************
ok: [cent01]
ok: [cent02]

TASK [debug] *******************************************************************
ok: [cent01] =&amp;gt; {
    &amp;quot;msg&amp;quot;: &amp;quot;ipv4_address=10.155.92.101&amp;quot;
}
ok: [cent02] =&amp;gt; {
    &amp;quot;msg&amp;quot;: &amp;quot;ipv4_address=10.155.92.103&amp;quot;
}

PLAY RECAP *********************************************************************
cent01                     : ok=2    changed=0    unreachable=0    failed=0
cent02                     : ok=2    changed=0    unreachable=0    failed=0

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LXDコンテナで固定IPアドレスを使うための設定</title>
      <link>/blog/2016/05/07/how-to-use-fixed-ip-address-for-a-lxd-container/</link>
      <pubDate>Sat, 07 May 2016 18:01:51 +0900</pubDate>
      
      <guid>/blog/2016/05/07/how-to-use-fixed-ip-address-for-a-lxd-container/</guid>
      <description>

&lt;h2 id=&#34;設定まとめ:de0d43504d2d04b1f52e2f979627ae1f&#34;&gt;設定まとめ&lt;/h2&gt;

&lt;p&gt;自分が後から参照することを想定して先に設定方法をまとめます。&lt;/p&gt;

&lt;p&gt;LXDコンテナで固定IPアドレスを使うためには以下の設定が必要です。なお、設定にはroot権限が必要です。&lt;/p&gt;

&lt;p&gt;まず &lt;code&gt;/etc/dnsmasq.conf&lt;/code&gt; に以下のようにコンテナ名に対するIPアドレスを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dhcp-host=cent01,10.64.177.101
dhcp-host=cent02,10.64.177.102
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lxd-bridge&lt;/code&gt; サービスを再起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl restart lxd-bridge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IPアドレスを変更したコンテナを再起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc restart cent01
lxc restart cent02
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;調査メモ:de0d43504d2d04b1f52e2f979627ae1f&#34;&gt;調査メモ&lt;/h2&gt;

&lt;p&gt;以下は調査メモです。&lt;/p&gt;

&lt;p&gt;まず &lt;a href=&#34;https://github.com/lxc/lxd/issues/1168&#34;&gt;Persistent IP for Containers · Issue #1168 · lxc/lxd&lt;/a&gt; に固定IPアドレスを使うための情報がありました。LXDで特にサポートはないが、各コンテナでDHCPを使わずに静的IPアドレスを使用するか、あるいはホストのDHCPサーバ側で設定すれば実現できるとのことです。&lt;/p&gt;

&lt;p&gt;各コンテナで静的IPアドレスを使う方法も試してみたのですが、ホストのコンテナ内から別のコンテナをコンテナ名で参照しようとすると変更前のIPアドレスで通信しようとしてしまいうまく行きませんでした。&lt;/p&gt;

&lt;p&gt;これを実現するにはホストのDHCPサーバに各コンテナのIPアドレスを把握してもらう必要があるので、後者のDHCPサーバ側で設定するほうが良いです。&lt;/p&gt;

&lt;h3 id=&#34;lxdのブリッジインターフェースとdnsmasqの設定ファイル:de0d43504d2d04b1f52e2f979627ae1f&#34;&gt;LXDのブリッジインターフェースとdnsmasqの設定ファイル&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://insights.ubuntu.com/2016/04/07/lxd-networking-lxdbr0-explained/&#34;&gt;LXD networking: lxdbr0 explained | Ubuntu Insights&lt;/a&gt;と&lt;a href=&#34;https://gist.github.com/cronnelly/98345100afe21840267270da3283b371&#34;&gt;lxcbr0 is being replaced by lxdbr0&lt;/a&gt;によると、 LXCでは &lt;code&gt;lxcbr0&lt;/code&gt; というブリッジインターフェースを使っていましたが、LXDでは &lt;code&gt;lxdbr0&lt;/code&gt; と別のインターフェースを使うように変更されたそうです。&lt;/p&gt;

&lt;p&gt;これらの記事を見るとLXCの &lt;code&gt;lxcbr0&lt;/code&gt; はインストール時に固定のアドレスネットワークが設定されて環境によっては既存のネットワークと衝突するという問題があったので、LXD の &lt;code&gt;lxdbr0&lt;/code&gt; ではインストール時にはIPv4やIPv6のサブネットは設定せずに &lt;code&gt;sudo lxd init&lt;/code&gt; を実行したときに設定するように変更されたということのようです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo lxd init&lt;/code&gt; で生成した &lt;code&gt;lxdbr0&lt;/code&gt; 用の設定は &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; に保存されています。
ファイルの先頭に書かれていますが、変更したい場合は直接編集せずに &lt;code&gt;dpkg-reconfigure -p medium lxd&lt;/code&gt; を実行するのが良いそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /etc/default/lxd-bridge
# WARNING: This file is generated by a debconf template!
# It is recommended to update it by using &amp;quot;dpkg-reconfigure -p medium lxd&amp;quot;

# Whether to setup a new bridge or use an existing one
USE_LXD_BRIDGE=&amp;quot;true&amp;quot;

# Bridge name
# This is still used even if USE_LXD_BRIDGE is set to false
# set to an empty value to fully disable
LXD_BRIDGE=&amp;quot;lxdbr0&amp;quot;

# Update the &amp;quot;default&amp;quot; LXD profile
UPDATE_PROFILE=&amp;quot;true&amp;quot;

# Path to an extra dnsmasq configuration file
LXD_CONFILE=&amp;quot;&amp;quot;

# DNS domain for the bridge
LXD_DOMAIN=&amp;quot;lxd&amp;quot;

# IPv4
## IPv4 address (e.g. 10.0.8.1)
LXD_IPV4_ADDR=&amp;quot;10.16.29.1&amp;quot;

## IPv4 netmask (e.g. 255.255.255.0)
LXD_IPV4_NETMASK=&amp;quot;255.255.255.0&amp;quot;

## IPv4 network (e.g. 10.0.8.0/24)
LXD_IPV4_NETWORK=&amp;quot;10.16.29.1/24&amp;quot;

## IPv4 DHCP range (e.g. 10.0.8.2,10.0.8.254)
LXD_IPV4_DHCP_RANGE=&amp;quot;10.16.29.2,10.16.29.254&amp;quot;

## IPv4 DHCP number of hosts (e.g. 250)
LXD_IPV4_DHCP_MAX=&amp;quot;252&amp;quot;

## NAT IPv4 traffic
LXD_IPV4_NAT=&amp;quot;true&amp;quot;

# IPv6
## IPv6 address (e.g. 2001:470:b368:4242::1)
LXD_IPV6_ADDR=&amp;quot;fd94:d372:e27f:2987::1&amp;quot;

## IPv6 CIDR mask (e.g. 64)
LXD_IPV6_MASK=&amp;quot;64&amp;quot;

## IPv6 network (e.g. 2001:470:b368:4242::/64)
LXD_IPV6_NETWORK=&amp;quot;fd94:d372:e27f:2987::1/64&amp;quot;

## NAT IPv6 traffic
LXD_IPV6_NAT=&amp;quot;true&amp;quot;

# Run a minimal HTTP PROXY server
LXD_IPV6_PROXY=&amp;quot;false&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このブリッジインタフェースを有効にするには &lt;code&gt;lxd-bridge.service&lt;/code&gt; を開始します。サービスの定義ファイルは以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /lib/systemd/system/lxd-bridge.service
[Unit]
Description=LXD - network bridge
Documentation=man:lxd(1)
Before=lxd.service

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/lib/lxd/lxd-bridge.start
ExecStop=/usr/lib/lxd/lxd-bridge stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ExecStart&lt;/code&gt; に指定しているスクリプトの中身は以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /usr/lib/lxd/lxd-bridge.start
#!/bin/sh -e

[ ! -e /etc/default/lxd-bridge ] &amp;amp;&amp;amp; exit 0

. /etc/default/lxd-bridge

# Start by bringing up the bridge
/usr/lib/lxd/lxd-bridge start

# Switch LXD in setup mode if needed
if [ &amp;quot;${UPDATE_PROFILE:-true}&amp;quot; = &amp;quot;true&amp;quot; ] &amp;amp;&amp;amp; [ -e &amp;quot;/var/lib/lxd&amp;quot; ] &amp;amp;&amp;amp; \
    ([ ! -e &amp;quot;/var/lib/lxd-bridge/timestamp&amp;quot; ] || \
     [ &amp;quot;/etc/default/lxd-bridge&amp;quot; -nt &amp;quot;/var/lib/lxd-bridge/timestamp&amp;quot; ]); then

    mkdir -p /var/lib/lxd-bridge
    touch /var/lib/lxd-bridge/timestamp

    touch /var/lib/lxd/.setup_mode
fi

exit 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここから呼ばれる &lt;code&gt;/usr/lib/lxd/lxd-bridge&lt;/code&gt; を見てみると、initスクリプトになっていて &lt;code&gt;iptables&lt;/code&gt;, &lt;code&gt;ip6tables&lt;/code&gt;, &lt;code&gt;dnsmasq&lt;/code&gt; を実行するようになっていました。また &lt;code&gt;/usr/lib/lxd/lxd-bridge&lt;/code&gt; は上記の &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; を読み込むようになっています。&lt;/p&gt;

&lt;p&gt;起動された &lt;code&gt;dnsmasq&lt;/code&gt; を &lt;code&gt;ps&lt;/code&gt; で見ると以下のようなコマンドラインになっていました。&lt;/p&gt;

&lt;p&gt;$ ps auxww | grep [d]nsmasq
  lxd       2134  0.0  0.0  49984   388 ?        S    09:48   0:00 dnsmasq -s lxd -S /lxd/ -u lxd &amp;ndash;strict-order &amp;ndash;bind-interfaces &amp;ndash;pid-file=/run/lxd-bridge//dnsmasq.pid &amp;ndash;dhcp-no-override &amp;ndash;except-interface=lo &amp;ndash;interface=lxdbr0 &amp;ndash;dhcp-leasefile=/var/lib/lxd-bridge//dnsmasq.lxdbr0.leases &amp;ndash;dhcp-authoritative &amp;ndash;listen-address 10.16.29.1 &amp;ndash;dhcp-range 10.16.29.2,10.16.29.254 &amp;ndash;dhcp-lease-max=252 &amp;ndash;dhcp-range=fd94:d372:e27f:2987::1,ra-only &amp;ndash;listen-address fd94:d372:e27f:2987::1&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/lib/lxd/lxd-bridge&lt;/code&gt; を見ると &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; の &lt;code&gt;LXD_CONFILE&lt;/code&gt; にファイル名を指定しておけば &lt;code&gt;dnsmasq&lt;/code&gt; の &lt;code&gt;--conf-file&lt;/code&gt; オプションを使ってそのファイルを読み込むように書かれています。この方法を使おうかと思ったのですが、一方で &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; の設定にかかわらず &lt;code&gt;--dhcp-authoritative&lt;/code&gt; オプションが常に指定されるように書かれています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;man dnsmasq&lt;/code&gt; によると &lt;code&gt;--dhcp-authoritative&lt;/code&gt; オプションはネットワーク内に他にDHCPサーバが無く唯一のDHCPになっているときに指定するオプションとのことです。ホストで稼働する &lt;code&gt;dnsmasq&lt;/code&gt; が1つという前提であれば、デフォルトの設定ファイル &lt;code&gt;/etc/dnsmasq.conf&lt;/code&gt; を作ってそこに設定を書くほうが手っ取り早いので、そうすることにしました。&lt;/p&gt;

&lt;h3 id=&#34;lxd-bridge-serviceの設定変更はreloadではなくrestartが必要:de0d43504d2d04b1f52e2f979627ae1f&#34;&gt;lxd-bridge.serviceの設定変更はreloadではなくrestartが必要&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sudo systemctl reload lxd-bridge&lt;/code&gt; を実行してみると以下のようなエラーが出て失敗しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo systemctl reload lxd-bridge
Failed to reload lxd-bridge.service: Job type reload is not applicable for unit lxd-bridge.service.
See system logs and &#39;systemctl status lxd-bridge.service&#39; for details.
$ sudo systemctl status lxd-bridge
● lxd-bridge.service - LXD - network bridge
   Loaded: loaded (/lib/systemd/system/lxd-bridge.service; static; vendor preset: enabled)
   Active: active (exited) since 土 2016-05-07 13:06:06 JST; 6h ago
     Docs: man:lxd(1)
  Process: 3704 ExecStop=/usr/lib/lxd/lxd-bridge stop (code=exited, status=0/SUCCESS)
  Process: 3723 ExecStart=/usr/lib/lxd/lxd-bridge.start (code=exited, status=0/SUCCESS)
 Main PID: 3723 (code=exited, status=0/SUCCESS)
    Tasks: 1 (limit: 512)
   Memory: 412.0K
      CPU: 1.293s
   CGroup: /system.slice/lxd-bridge.service
           └─3755 dnsmasq -s lxd -S /lxd/ -u lxd --strict-order --bind-interfaces --pid-file=/run/lxd-bridge//dnsmasq.pid --dhcp-no-override --except-interface=lo --interface=lxdbr0 --dhcp-leasefile=/var/lib/lxd-bridge//dnsmasq.lxdbr0.leases --dhcp-authoritative --lis
 5月 07 18:56:28 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
 5月 07 19:06:21 express dnsmasq-dhcp[3755]: DHCPREQUEST(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7
 5月 07 19:06:21 express dnsmasq-dhcp[3755]: DHCPACK(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7 cent02
 5月 07 19:06:21 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
 5月 07 19:23:24 express dnsmasq-dhcp[3755]: DHCPREQUEST(lxdbr0) 10.155.92.101 00:16:3e:5f:01:7e
 5月 07 19:23:24 express dnsmasq-dhcp[3755]: DHCPACK(lxdbr0) 10.155.92.101 00:16:3e:5f:01:7e cent01
 5月 07 19:23:24 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
 5月 07 19:33:08 express dnsmasq-dhcp[3755]: DHCPREQUEST(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7
 5月 07 19:33:08 express dnsmasq-dhcp[3755]: DHCPACK(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7 cent02
 5月 07 19:33:08 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで、設定ファイルを変更反映するにも &lt;code&gt;sudo systemctl restart lxd-bridge&lt;/code&gt; のように再起動する必要があります。&lt;/p&gt;

&lt;h3 id=&#34;dnsmasqの再起動後-コンテナの再起動が必要:de0d43504d2d04b1f52e2f979627ae1f&#34;&gt;dnsmasqの再起動後、コンテナの再起動が必要&lt;/h3&gt;

&lt;p&gt;dnsmasqを再起動しただけではコンテナのIPアドレスは変わらないのでネットワークを再起動する必要がありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc exec cent01 systemctl restart network
lxc exec cent02 systemctl restart network
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナごと再起動でも良いと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc restart cent01
lxc restart cent02
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何回か試してみたところ、作っただけで特に何もしてないコンテナだとネットワーク再起動よりコンテナ自体を再起動するほうが速かったです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time lxc exec cent02 systemctl restart network

real    0m2.878s
user    0m0.008s
sys     0m0.000s
$ time lxc restart cent02

real    0m1.236s
user    0m0.004s
sys     0m0.004s
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LXCの特定の1つのコンテナの起動状態をシェルスクリプトで確認したいときのお勧めの方法</title>
      <link>/blog/2016/05/07/script-to-check-running-status-of-lxd-container/</link>
      <pubDate>Sat, 07 May 2016 14:12:49 +0900</pubDate>
      
      <guid>/blog/2016/05/07/script-to-check-running-status-of-lxd-container/</guid>
      <description>

&lt;h2 id=&#34;イマイチな方法1-lxc-listの出力をawkで加工:a407ff63c19d9133860d9fcb896e88f6&#34;&gt;イマイチな方法1: lxc listの出力をawkで加工&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lxc list -h&lt;/code&gt; を見ると &lt;code&gt;lxc list [resource] [filters] [--format table|json] [-c columns] [--fast]&lt;/code&gt; というコマンドラインになっていて、 &lt;code&gt;-c&lt;/code&gt; オプションで表示するカラムを指定可能です。&lt;/p&gt;

&lt;p&gt;例えば　以下のようにすれば &lt;code&gt;cent01&lt;/code&gt; コンテナの起動状態だけを表示できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c s cent01
+---------+
|  STATE  |
+---------+
| RUNNING |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、デフォルトの &lt;code&gt;--format table&lt;/code&gt; だとASCII文字の罫線が表示されるので、状態を抜き出すにはawkで加工する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c s cent01 | awk &#39;NR==4{print $2}&#39;
RUNNING
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;イマイチな方法2-lxc-list-format-jsonの出力をjqで加工:a407ff63c19d9133860d9fcb896e88f6&#34;&gt;イマイチな方法2: lxc list &amp;ndash;format jsonの出力をjqで加工&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;--format json&lt;/code&gt; でJSON形式で出力できるのですが、この場合は &lt;code&gt;-c&lt;/code&gt; オプションで項目を限定することは出来ませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list --format json -c s cent01
[{&amp;quot;architecture&amp;quot;:&amp;quot;x86_64&amp;quot;,&amp;quot;config&amp;quot;:{&amp;quot;volatile.base_image&amp;quot;:&amp;quot;a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2&amp;quot;,&amp;quot;volatile.eth0.hwaddr&amp;quot;:&amp;quot;00:16:3e:5f:01:7e&amp;quot;,&amp;quot;volatile.last_state.idmap&amp;quot;:&amp;quot;[{\&amp;quot;Isuid\&amp;quot;:true,\&amp;quot;Isgid\&amp;quot;:false,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\
&amp;quot;:65536},{\&amp;quot;Isuid\&amp;quot;:false,\&amp;quot;Isgid\&amp;quot;:true,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\&amp;quot;:65536}]&amp;quot;},&amp;quot;created_at&amp;quot;:&amp;quot;2016-05-06T18:56:46+09:00&amp;quot;,&amp;quot;devices&amp;quot;:{&amp;quot;root&amp;quot;:{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;disk&amp;quot;}},&amp;quot;ephemeral&amp;quot;:false,&amp;quot;expanded_config&amp;quot;:{&amp;quot;volatile.base_image&amp;quot;:&amp;quot;a027d59858d663fb2bc12b5ba767e9
2196a4aee8dbb2a607db53d718b91eb5d2&amp;quot;,&amp;quot;volatile.eth0.hwaddr&amp;quot;:&amp;quot;00:16:3e:5f:01:7e&amp;quot;,&amp;quot;volatile.last_state.idmap&amp;quot;:&amp;quot;[{\&amp;quot;Isuid\&amp;quot;:true,\&amp;quot;Isgid\&amp;quot;:false,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\&amp;quot;:65536},{\&amp;quot;Isuid\&amp;quot;:false,\&amp;quot;Isgid\&amp;quot;:true,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\&amp;quot;:65536}
]&amp;quot;},&amp;quot;expanded_devices&amp;quot;:{&amp;quot;eth0&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;eth0&amp;quot;,&amp;quot;nictype&amp;quot;:&amp;quot;bridged&amp;quot;,&amp;quot;parent&amp;quot;:&amp;quot;lxdbr0&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;nic&amp;quot;},&amp;quot;root&amp;quot;:{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;disk&amp;quot;}},&amp;quot;name&amp;quot;:&amp;quot;cent01&amp;quot;,&amp;quot;profiles&amp;quot;:[&amp;quot;default&amp;quot;],&amp;quot;stateful&amp;quot;:false,&amp;quot;status&amp;quot;:&amp;quot;Running&amp;quot;,&amp;quot;status_code&amp;quot;:103,&amp;quot;state&amp;quot;:null,&amp;quot;snapshots&amp;quot;:null}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sudo apt install jq&lt;/code&gt; で &lt;code&gt;jq&lt;/code&gt; コマンドをインストールして、それで状態を抜き出すことは可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list --format json cent01 | jq -r &#39;.[0].status&#39;
Running
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;お勧めの方法-lxc-infoの出力をawkで加工:a407ff63c19d9133860d9fcb896e88f6&#34;&gt;お勧めの方法: lxc infoの出力をawkで加工&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lxc list&lt;/code&gt; の場合は指定した文字列は完全一致ではなくて前方一致で表示されました。上記の例のように &lt;code&gt;cent01&lt;/code&gt; と &lt;code&gt;cent02&lt;/code&gt; の2つのコンテナがあるときに、 &lt;code&gt;lxc list -c s cent0&lt;/code&gt; と実行すると以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c s cent0
+---------+
|  STATE  |
+---------+
| RUNNING |
+---------+
| RUNNING |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだとどの行がどのコンテナかわからないのでコンテナ名の列も付ける必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c ns cent0
+--------+---------+
|  NAME  |  STATE  |
+--------+---------+
| cent01 | RUNNING |
+--------+---------+
| cent02 | RUNNING |
+--------+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この結果をawkで加工するのでも良いのですが、もっと良いのは &lt;code&gt;lxc info&lt;/code&gt; コマンドを使うことです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc info cent01
コンテナ名: cent01
アーキテクチャ: x86_64
作成日時: 2016/05/06 09:56 UTC
状態: Running
タイプ: persistent
プロファイル: default
Pid: 29354
IPアドレス:
  eth0: inet    10.155.92.101   vethG4XSE4
  eth0: inet6   fe80::216:3eff:fe5f:17e vethG4XSE4
  lo:   inet    127.0.0.1
  lo:   inet6   ::1
リソース:
  プロセス数: 10
  メモリ消費量:
    メモリ (現在値): 23.60MB
    メモリ (ピーク): 43.08MB
  ネットワーク使用状況:
    eth0:
      受信バイト数: 24.16kB
      送信バイト数: 8.06kB
      受信パケット: 232
      送信パケット: 88
    lo:
      受信バイト数: 0 bytes
      送信バイト数: 0 bytes
      受信パケット: 0
      送信パケット: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存在しないコンテナ名を指定するとエラーになります。これは標準エラー出力に出力されています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc info hoge
エラー: not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;シェルスクリプトで加工するには英語出力のほうが良いので &lt;code&gt;LANG=C&lt;/code&gt; 付きで実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ LANG=C lxc info cent01
Name: cent01
Architecture: x86_64
Created: 2016/05/06 09:56 UTC
Status: Running
Type: persistent
Profiles: default
Pid: 29354
Ips:
  eth0: inet    10.155.92.101   vethG4XSE4
  eth0: inet6   fe80::216:3eff:fe5f:17e vethG4XSE4
  lo:   inet    127.0.0.1
  lo:   inet6   ::1
Resources:
  Processes: 10
  Memory usage:
    Memory (current): 23.60MB
    Memory (peak): 43.08MB
  Network usage:
    eth0:
      Bytes received: 24.58kB
      Bytes sent: 8.56kB
      Packets received: 235
      Packets sent: 93
    lo:
      Bytes received: 0 bytes
      Bytes sent: 0 bytes
      Packets received: 0
      Packets sent: 0
$ LANG=C lxc info hoge
error: not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結局以下のように実行するのがお勧めです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ LANG=C lxc info cent01 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;
Running
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存在しない場合は空文字列になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ LANG=C lxc info hoge 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判定例はこんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ [ x`LANG=C lxc info cent01 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;` == xRunning ] &amp;amp;&amp;amp; echo &amp;quot;container is running&amp;quot;
container is running
$ [ x`LANG=C lxc info hoge 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;` == xRunning ] &amp;amp;&amp;amp; echo &amp;quot;container is running&amp;quot;
$
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04 LTSでLXD 2.0をセットアップして使ってみる</title>
      <link>/blog/2016/05/07/start-using-lxd-2.0-on-ubuntu-16.04/</link>
      <pubDate>Sat, 07 May 2016 14:12:49 +0900</pubDate>
      
      <guid>/blog/2016/05/07/start-using-lxd-2.0-on-ubuntu-16.04/</guid>
      <description>

&lt;h2 id=&#34;参考記事:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;参考記事&lt;/h2&gt;

&lt;p&gt;公式ドキュメントの&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/getting-started-cli/&#34;&gt;Linux Containers - LXD - はじめに - コマンドライン&lt;/a&gt;によくまとまっているのですが、より詳細には &lt;a href=&#34;http://insights.ubuntu.com/2016/03/14/the-lxd-2-0-story-prologue/&#34;&gt;The LXD 2.0 Story (Prologue) | Ubuntu Insights&lt;/a&gt; にリストアップされている記事がわかりやすかったです。&lt;/p&gt;

&lt;h3 id=&#34;ubuntu-16-04-serverでのlxdの初期セットアップ:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;Ubuntu 16.04 serverでのLXDの初期セットアップ&lt;/h3&gt;

&lt;p&gt;Ubuntu 16.04 serverならLXDはインストール済みなので、 &lt;code&gt;apt-get install lxd&lt;/code&gt; と &lt;code&gt;newgrp lxd&lt;/code&gt; は不要でした。&lt;/p&gt;

&lt;p&gt;LXCではコンテナ一覧表示は &lt;code&gt;lxc-ls&lt;/code&gt;、コンテナ作成は &lt;code&gt;lxc-create&lt;/code&gt; のように別々のコマンドになっていましたが、 LXDではそれぞれ &lt;code&gt;lxc list&lt;/code&gt;, &lt;code&gt;lxc launch&lt;/code&gt; と &lt;code&gt;lxc&lt;/code&gt; コマンドのサブコマンドになっています。&lt;/p&gt;

&lt;p&gt;また &lt;code&gt;lxd&lt;/code&gt; というプログラムもあります。 &lt;code&gt;man lxd&lt;/code&gt; と &lt;code&gt;man lxc&lt;/code&gt; してみると &lt;code&gt;lxd&lt;/code&gt; はコンテナのハイパーバイザのデーモンで、 &lt;code&gt;lxc&lt;/code&gt; はコンテナのハイパーバイザのクライアントです。&lt;/p&gt;

&lt;p&gt;まずバージョンを確認してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxd --version
2.0.0
$ lxc --version
2.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、 &lt;code&gt;lxc&lt;/code&gt; のほうは &lt;code&gt;lxc version&lt;/code&gt; と &lt;code&gt;version&lt;/code&gt; サブコマンドも用意されていますが、 &lt;code&gt;lxd version&lt;/code&gt; は &lt;code&gt;error: Unknown arguments&lt;/code&gt; とエラーになりました。&lt;/p&gt;

&lt;p&gt;コンテナ一覧を表示してみます。まだ1つもコンテナを作っていないので一覧は空です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
Generating a client certificate. This may take a minute...
If this is your first time using LXD, you should also run: sudo lxd init

+------+-------+------+------+------+-----------+
| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |
+------+-------+------+------+------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lxc list&lt;/code&gt; の出力の1行目にある通り、初回実行時にはクライアント証明書が生成されます。 &lt;code&gt;~/.config/lxc/client.key&lt;/code&gt; に秘密鍵、 &lt;code&gt;~/.config/lxc/client.crt&lt;/code&gt; に証明書が作られました。&lt;/p&gt;

&lt;p&gt;また、 &lt;code&gt;lxc list&lt;/code&gt; の出力の2行目に LXDを初めて使うときは &lt;code&gt;sudo lxd init&lt;/code&gt; を実行するようにも書かれていますので、実行します。&lt;/p&gt;

&lt;p&gt;すると、いくつか質問されるので入力していきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lxd init
sudo: unable to resolve host ubuntu-xenial
Name of the storage backend to use (dir or zfs): dir
Would you like LXD to be available over the network (yes/no)? no
Do you want to configure the LXD bridge (yes/no)? yes
Warning: Stopping lxd.service, but it can still be activated by:
  lxd.socket
LXD has been successfully configured.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1つ目はストレージバックアップの選択です。選択肢は &lt;code&gt;dir&lt;/code&gt; か &lt;code&gt;zfs&lt;/code&gt; ですが、上記では &lt;code&gt;dir&lt;/code&gt; にしました。&lt;/p&gt;

&lt;p&gt;2つ目はLXDをネットワーク越しで利用するかどうかです。上記では &lt;code&gt;no&lt;/code&gt; にしました。
すると上記の警告にあるとおり &lt;code&gt;lxd.service&lt;/code&gt; が停止されました。 &lt;code&gt;sudo systemctl status lxd&lt;/code&gt; で確認すると &lt;code&gt;Active:&lt;/code&gt; の右が &lt;code&gt;inactive (dead)&lt;/code&gt; になっていました。&lt;/p&gt;

&lt;p&gt;一方で、 &lt;code&gt;lxd.socket&lt;/code&gt; は稼働しています。 &lt;code&gt;sudo systemctl status lxd.socket&lt;/code&gt; で確認すると &lt;code&gt;Active:&lt;/code&gt; の右が &lt;code&gt;active (running)&lt;/code&gt; になっていました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/lib/systemd/system/lxd.socket&lt;/code&gt; を見ると &lt;code&gt;/var/lib/lxd/unix.socket&lt;/code&gt; というファイル名でUnixドメインソケットが作られていることがわかりました。&lt;/p&gt;

&lt;p&gt;3つ目はLXDのブリッジを設定するかどうかです。上記は &lt;code&gt;yes&lt;/code&gt; にしました。すると CUI でダイアログが次々開いて DHCPで発行するIPv4やIPv6のアドレスの範囲などを聞かれるので、順次入力していきます。ランダムなアドレスの範囲が事前入力されているので、特に変更不要な場合はenterキーを連打していけばOKでした。&lt;/p&gt;

&lt;p&gt;再度 &lt;code&gt;lxc list&lt;/code&gt; を実行してみると、今度はクライアント証明書を生成したとか、 &lt;code&gt;sudo lxc init&lt;/code&gt; を実行せよとかの文言は表示されなくなりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+------+-------+------+------+------+-----------+
| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |
+------+-------+------+------+------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;別パターンの初期化の検証:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;別パターンの初期化の検証&lt;/h4&gt;

&lt;p&gt;このパターンではLXDをネットワーク越しに使うかの質問に &lt;code&gt;yes&lt;/code&gt; と答えました。すると、バインドするアドレスとポートを聞かれます。ポートは &lt;code&gt;8443&lt;/code&gt; がお勧めと書かれていますが、enterキー空打ちではだめで、ちゃんと値を入力する必要がありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lxd init
sudo: unable to resolve host ubuntu-xenial
Name of the storage backend to use (dir or zfs): dir
Would you like LXD to be available over the network (yes/no)? yes
Address to bind LXD to (not including port): 0.0.0.0
Port to bind LXD to (8443 recommended):
Invalid input, try again.

Port to bind LXD to (8443 recommended): 8443
Trust password for new clients:
Again:
Do you want to configure the LXD bridge (yes/no)? no
LXD has been successfully configured.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この設定の後に &lt;code&gt;sudo systemctl status lxd&lt;/code&gt; を実行すると &lt;code&gt;Active:&lt;/code&gt; の右は &lt;code&gt;active (running)&lt;/code&gt; になっていました。&lt;/p&gt;

&lt;p&gt;また、上記ではLXDブリッジを設定するかの質問に &lt;code&gt;no&lt;/code&gt; と答えてみました。この場合は CUIのダイアログは開かれず、すぐに &lt;code&gt;LXD has been successfully configured.&lt;/code&gt; が表示されて完了しました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ip a&lt;/code&gt; で確認すると、この場合も &lt;code&gt;lxdbr0&lt;/code&gt; というネットワークインターフェース自体は作成されていました。ただし、IPアドレスは設定されていない状態です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ip a
...(略)...
4: lxdbr0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN group default qlen 1000
    link/ether 0a:b4:d4:fa:b3:71 brd ff:ff:ff:ff:ff:ff
    inet6 fe80::8b4:d4ff:fefa:b371/64 scope link
       valid_lft forever preferred_lft forever
    inet6 fe80::1/64 scope link
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、その後 &lt;code&gt;lxc launch&lt;/code&gt; でコンテナを起動した後再度確認すると &lt;code&gt;lxdbr0&lt;/code&gt; の左の番号が &lt;code&gt;4:&lt;/code&gt; から &lt;code&gt;5:&lt;/code&gt; に変わっていて、IPv4アドレスも設定されていました。また &lt;code&gt;lxc.service&lt;/code&gt; も起動していました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo ss -antp&lt;/code&gt; で確認したところ、LXDをネットワーク越しに使う設定を &lt;code&gt;yes&lt;/code&gt; にしたときは &lt;code&gt;lxd&lt;/code&gt; のプロセスが指定したポート（上記の例では8443番ポート）をLISTENしていますが、 &lt;code&gt;no&lt;/code&gt; にしたときはLISTENしていませんでした。&lt;/p&gt;

&lt;h3 id=&#34;リモートとローカルのイメージ一覧表示:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;リモートとローカルのイメージ一覧表示&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;lxc image&lt;/code&gt; サブコマンドでイメージを取り扱います。 &lt;code&gt;lxc image -h&lt;/code&gt; と入力すると使用方法が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lxc image list&lt;/code&gt; の説明の部分を以下に引用します。 &lt;code&gt;LANG&lt;/code&gt; 環境変数が &lt;code&gt;ja_JP.UTF8&lt;/code&gt; ならヘルプメッセージは日本語で表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc image list [remote:] [filter]
    LXD のイメージストア内のイメージを一覧表示します。プロパティでフィルタ
    を行う場合は、フィルタは &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; の形になります。フィルタはイメー
    ジハッシュの一部やイメージエイリアス名の一部も指定できます。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;英語のヘルプメッセージを見たい場合は &lt;code&gt;LANG=C&lt;/code&gt; をつけて &lt;code&gt;LANG=C lxc image&lt;/code&gt; のように実行すればOKです。 &lt;code&gt;lxc image list&lt;/code&gt; の英語ヘルプメッセージを以下に引用します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc image list [remote:] [filter]
    List images in the LXD image store. Filters may be of the
    &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; form for property based filtering, or part of the image
    hash or part of the image alias name.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リモートのイメージ一覧は &lt;code&gt;lxc image list images:&lt;/code&gt; で表示できます。最後の &lt;code&gt;:&lt;/code&gt; はリモートの指定か区別するために必要です。&lt;/p&gt;

&lt;p&gt;ローカルのイメージ一覧は &lt;code&gt;lxc image list&lt;/code&gt; で表示できます。1つもコンテナを作っていない時は空になります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[remote:]&lt;/code&gt; の部分に指定可能なリモートの一覧は &lt;code&gt;lxc remote list&lt;/code&gt; で確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc remote list
+-----------------+------------------------------------------+---------------+--------+--------+
|      NAME       |                   URL                    |   PROTOCOL    | PUBLIC | STATIC |
+-----------------+------------------------------------------+---------------+--------+--------+
| images          | https://images.linuxcontainers.org       | lxd           | YES    | NO     |
+-----------------+------------------------------------------+---------------+--------+--------+
| local (default) | unix://                                  | lxd           | NO     | YES    |
+-----------------+------------------------------------------+---------------+--------+--------+
| ubuntu          | https://cloud-images.ubuntu.com/releases | simplestreams | YES    | YES    |
+-----------------+------------------------------------------+---------------+--------+--------+
| ubuntu-daily    | https://cloud-images.ubuntu.com/daily    | simplestreams | YES    | YES    |
+-----------------+------------------------------------------+---------------+--------+--------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フィルタを指定してリモートのcentosのイメージ一覧を表示すると以下の3つがヒットしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc image list images: centos
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
|          ALIAS          | FINGERPRINT  | PUBLIC |            DESCRIPTION            |  ARCH  |  SIZE   |         UPLOAD DATE         |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| centos/6/amd64 (1 more) | 81c42e7d8c4e | yes    | Centos 6 (amd64) (20160507_02:16) | x86_64 | 52.23MB | May 7, 2016 at 3:15am (UTC) |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| centos/6/i386 (1 more)  | 74c61c775024 | yes    | Centos 6 (i386) (20160507_02:16)  | i686   | 52.16MB | May 7, 2016 at 3:16am (UTC) |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| centos/7/amd64 (1 more) | 9c8a52ca68e4 | yes    | Centos 7 (amd64) (20160507_02:16) | x86_64 | 62.93MB | May 7, 2016 at 3:16am (UTC) |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;centos-7のコンテナを起動してみる:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;CentOS 7のコンテナを起動してみる&lt;/h3&gt;

&lt;p&gt;起動に使用するのは &lt;code&gt;lxc launch&lt;/code&gt; サブコマンドです。 &lt;code&gt;lxc launch -h&lt;/code&gt; でヘルプが見られます。&lt;/p&gt;

&lt;p&gt;ここでは &lt;code&gt;images&lt;/code&gt; のリモートの &lt;code&gt;centos/7/amd64&lt;/code&gt; のエイリアスのイメージを起動して &lt;code&gt;cent01&lt;/code&gt; というコンテナ名を付けてみます。どれぐらい時間がかかるか計測するため &lt;code&gt;time&lt;/code&gt; コマンドを付けて実行してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time lxc launch images:centos/7/amd64 cent01
Creating cent01
Retrieving image: 100%
Starting cent01

real    0m58.036s
user    0m0.056s
sys     0m0.036s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Retrieving image: 100%&lt;/code&gt; と表示されているように初回はイメージのダウンロードを行うので少し時間がかかります。私の環境では1分弱でした。&lt;/p&gt;

&lt;p&gt;起動直後に &lt;code&gt;lxc list&lt;/code&gt; を実行すると、 IPv6アドレスは付与されていますが、 IPv4アドレスはまだ空です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  | IPV4 |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING |      | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数秒立ってから再度実行するとIPv4アドレスが付与されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  |         IPV4         |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING | 10.64.177.167 (eth0) | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この時点でローカルのイメージ一覧を表示してみると、CentOS 7のイメージが追加されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc image list
+-------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| ALIAS | FINGERPRINT  | PUBLIC |            DESCRIPTION            |  ARCH  |  SIZE   |         UPLOAD DATE         |
+-------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
|       | 9c8a52ca68e4 | no     | Centos 7 (amd64) (20160507_02:16) | x86_64 | 62.93MB | May 7, 2016 at 7:13am (UTC) |
+-------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じイメージで2つめのコンテナを起動してみると今度はローカルのイメージを使うので起動時間は短くてすみました。私の環境では約10秒でした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time lxc launch images:centos/7/amd64 cent02
Creating cent02
Starting cent02

real    0m10.189s
user    0m0.044s
sys     0m0.008s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動直後にコンテナ一覧を確認すると、今起動した &lt;code&gt;cent02&lt;/code&gt; コンテナのIPv4アドレスはやはり空です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  |         IPV4         |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING | 10.64.177.167 (eth0) | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent02 | RUNNING |                      | fd36:b946:6537:931e:216:3eff:fe18:680a (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数秒立ってから再度確認すると &lt;code&gt;centos02&lt;/code&gt; コンテナにもIPv4アドレスが付与されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  |         IPV4         |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING | 10.64.177.167 (eth0) | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent02 | RUNNING | 10.64.177.34 (eth0)  | fd36:b946:6537:931e:216:3eff:fe18:680a (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;コンテナ内でコマンドを実行する:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;コンテナ内でコマンドを実行する&lt;/h3&gt;

&lt;p&gt;例えば &lt;code&gt;cent01&lt;/code&gt; コンテナで &lt;code&gt;bash&lt;/code&gt; を起動するには &lt;code&gt;lxc exec cent01 bash&lt;/code&gt; と実行します。するとコンテナ内で root ユーザになってプロンプトが表示されるので、好きなコマンドを入力して実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc exec cent01 bash
[root@cent01 ~]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
37: eth0@if38: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP qlen 1000
    link/ether 00:16:3e:5f:01:7e brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 10.155.92.101/24 brd 10.155.92.255 scope global dynamic eth0
       valid_lft 2508sec preferred_lft 2508sec
    inet6 fe80::216:3eff:fe5f:17e/64 scope link
       valid_lft forever preferred_lft forever
[root@cent01 ~]# ping -c 3 cent02
PING cent02.lxd (10.64.177.34) 56(84) bytes of data.
64 bytes from cent02.lxd (10.64.177.34): icmp_seq=1 ttl=64 time=0.034 ms
64 bytes from cent02.lxd (10.64.177.34): icmp_seq=2 ttl=64 time=0.068 ms
64 bytes from cent02.lxd (10.64.177.34): icmp_seq=3 ttl=64 time=0.081 ms

--- cent02.lxd ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1998ms
rtt min/avg/max/mdev = 0.034/0.061/0.081/0.019 ms
[root@cent01 ~]# exit
exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記の &lt;code&gt;ping&lt;/code&gt; の例でも分かる通り、コンテナ内から別のコンテナの名前を指定して通信可能です。 &lt;code&gt;ping&lt;/code&gt; の出力を見ると &lt;code&gt;.lxd&lt;/code&gt; というトップレベルドメインがつけられていて、 &lt;code&gt;ping -c 3 cent02.lxd&lt;/code&gt; でも大丈夫でした。この &lt;code&gt;.lxd&lt;/code&gt; という値は &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; の &lt;code&gt;LXD_DOMAIN=&amp;quot;lxd&amp;quot;&lt;/code&gt; という設定で指定されています。&lt;/p&gt;

&lt;p&gt;Control-Dを押すか、&lt;code&gt;exit&lt;/code&gt; に続いてenterキーで &lt;code&gt;bash&lt;/code&gt; から抜けます。&lt;/p&gt;

&lt;p&gt;単一のコマンドを実行したい場合は &lt;code&gt;bash&lt;/code&gt; の代わりにコマンドを書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc exec cent01 ls /
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドにオプションを指定するとエラーになりますが、コマンドの前に &lt;code&gt;--&lt;/code&gt; を入れれば大丈夫です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc exec cent01 ls -a /
error: flag provided but not defined: -a
$ lxc exec cent01 -- ls -a /
.  ..  .autorelabel  bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ホストosを再起動するとコンテナは自動起動されます:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;ホストOSを再起動するとコンテナは自動起動されます&lt;/h2&gt;

&lt;p&gt;LXCではホストOS起動時にコンテナを自動起動するには設定ファイルの編集が必要でしたが、LXDは特に設定は不要でした。　
ホストOSを再起動して &lt;code&gt;lxc list&lt;/code&gt; を実行してみると上記で作成した2つのコンテナのSTATEがRUNNINGになっていました。&lt;/p&gt;

&lt;h2 id=&#34;コンテナの停止と削除:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;コンテナの停止と削除&lt;/h2&gt;

&lt;p&gt;停止は &lt;code&gt;lxc stop コンテナ名&lt;/code&gt; 、削除は &lt;code&gt;lxc delete コンテナ名&lt;/code&gt; で出来ます。が、 CentOS 7 のコンテナを停止するには以下の事前準備が必要でした。&lt;/p&gt;

&lt;h3 id=&#34;centos-7-のコンテナを停止可能にするための設定:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;CentOS 7 のコンテナを停止可能にするための設定&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;cent01&lt;/code&gt; のところは実際のコンテナ名に置き換えて、各コンテナで実行が必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc exec cent01 -- sh -c &#39;ln -s /usr/lib/systemd/system/halt.target /etc/systemd/system/sigpwr.target &amp;amp;&amp;amp; systemctl daemon-reload&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この回避方法は &lt;a href=&#34;https://lists.linuxcontainers.org/pipermail/lxc-users/2014-February/006304.html&#34;&gt;[lxc-users] lxc-stop doesn&amp;rsquo;t stop centos, waits for the timeout&lt;/a&gt; で紹介されていました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lists.linuxcontainers.org/pipermail/lxc-users/2016-May/011602.html&#34;&gt;[lxc-users] lxc stop does not stop a CentOS 7 container&lt;/a&gt; で &lt;code&gt;images:&lt;/code&gt; で公開しているイメージにこの修正を取り込めないか問い合わせ中です。&lt;/p&gt;

&lt;h2 id=&#34;コンテナやイメージのファイルの在り処:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;コンテナやイメージのファイルの在り処&lt;/h2&gt;

&lt;p&gt;コンテナのファイルは &lt;code&gt;/var/lib/lxd/containers/&lt;/code&gt; にありました。操作しているユーザのuidとgidは1000なのですが、コンテナのディレクトリは100000と異なっていました。どこかでマッピングを持っているのだと思いますが、未調査です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ls -l /var/lib/lxd/containers/
合計 24
drwxr-xr-x+ 4 100000 100000  4096  5月  6 18:56 cent01
drwxr-xr-x+ 4 100000 100000  4096  5月  7 03:18 cent02
-rw-r--r--  1 root   root   10756  5月  7 19:47 lxc-monitord.log
drwxr-xr-x+ 4 100000 100000  4096  5月  3 20:46 my-ubuntu
$ sudo ls -l /var/lib/lxd/containers/cent01
合計 12
-rw-r--r--  1 root   root    628  1月  1  1970 metadata.yaml
dr-xr-xr-x 18 100000 100000 4096  5月  6 18:56 rootfs
drwxr-xr-x  2 root   root   4096  5月  6 18:56 templates
1$ sudo ls -l /var/lib/lxd/containers/cent01/rootfs/
合計 64
lrwxrwxrwx  1 100000 100000    7  5月  6 11:25 bin -&amp;gt; usr/bin
dr-xr-xr-x  2 100000 100000 4096  8月 12  2015 boot
drwxr-xr-x  4 100000 100000 4096  5月  6 11:25 dev
drwxr-xr-x 55 100000 100000 4096  5月  7 12:13 etc
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 home
lrwxrwxrwx  1 100000 100000    7  5月  6 11:25 lib -&amp;gt; usr/lib
lrwxrwxrwx  1 100000 100000    9  5月  6 11:25 lib64 -&amp;gt; usr/lib64
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 media
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 mnt
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 opt
dr-xr-xr-x  2 100000 100000 4096  8月 12  2015 proc
dr-xr-x---  3 100000 100000 4096  5月  7 03:42 root
drwxr-xr-x  7 100000 100000 4096  5月  6 11:25 run
lrwxrwxrwx  1 100000 100000    8  5月  6 11:25 sbin -&amp;gt; usr/sbin
drwxr-xr-x  2 100000 100000 4096  5月  6 11:25 selinux
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 srv
dr-xr-xr-x  2 100000 100000 4096  8月 12  2015 sys
drwxrwxrwt  7 100000 100000 4096  5月  7 12:54 tmp
drwxr-xr-x 13 100000 100000 4096  5月  6 11:25 usr
drwxr-xr-x 19 100000 100000 4096  5月  6 18:56 var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イメージのファイルは &lt;code&gt;/var/lib/lxd/images/&lt;/code&gt; にありました。 &lt;code&gt;lxc image list&lt;/code&gt; で表示されるフィンガープリント名のファイルとフィンガープリントに &lt;code&gt;.rootfs&lt;/code&gt; を追加した名前のファイルがあります。調べてみるとtar.xz形式のファイルになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ls -l /var/lib/lxd/images/
合計 205244
-rw-r--r-- 1 root root       588  5月  6 18:54 a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2
-rw-r--r-- 1 root root  65931516  5月  6 18:55 a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs
-rw-r--r-- 1 root root       792  5月  3 20:32 f4c4c60a6b752a381288ae72a1689a9da00f8e03b732c8d1b8a8fcd1a8890800
-rw-r--r-- 1 root root 144223868  5月  3 20:46 f4c4c60a6b752a381288ae72a1689a9da00f8e03b732c8d1b8a8fcd1a8890800.rootfs
$ sudo file /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2
/var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2: XZ compressed data
$ sudo file /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs
/var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs: XZ compressed data
$ sudo tar tvf /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2
-rw-r--r-- 0/0             239 1970-01-01 09:00 templates/hosts.tpl
-rw-r--r-- 0/0             628 1970-01-01 09:00 metadata.yaml
-rw-r--r-- 0/0              21 1970-01-01 09:00 templates/hostname.tpl
$ sudo tar tvf /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs | head
dr-xr-xr-x 0/0               0 2016-05-06 11:25 ./
drwxr-xr-x 0/0               0 2016-05-06 11:25 ./dev/
crw-rw-rw- 0/0             5,2 2016-05-06 11:25 ./dev/ptmx
prw------- 0/0               0 2016-05-06 11:25 ./dev/initctl
crw-rw-rw- 0/0             1,7 2016-05-06 11:25 ./dev/full
crw------- 0/0             5,1 2016-05-06 11:25 ./dev/console
crw-rw-rw- 0/0             4,4 2016-05-06 11:25 ./dev/tty4
crw-rw-rw- 0/0             4,3 2016-05-06 11:25 ./dev/tty3
crw-rw-rw- 0/0             4,2 2016-05-06 11:25 ./dev/tty2
crw-rw-rw- 0/0             4,1 2016-05-06 11:25 ./dev/tty1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/var/lib/lxd/&lt;/code&gt; には他にもディレクトリやファイルが存在しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l /var/lib/lxd
合計 84
drwx--x--x 5 root root  4096  5月  7 12:54 containers
drwx--x--x 5 root root  4096  5月  7 12:54 devices
drwxr-xr-x 2 root root  4096  5月  7 19:41 devlxd
drwx------ 2 root root  4096  5月  7 06:13 images
-rw-r--r-- 1 root root 43008  5月  7 19:46 lxd.db
drwx------ 4 root root  4096  5月  3 20:46 security
-rw-r--r-- 1 root root  2004  5月  3 20:26 server.crt
-rw------- 1 root root  3247  5月  3 20:26 server.key
drwx--x--x 5 root root  4096  5月  7 12:54 shmounts
drwx------ 2 root root  4096  5月  3 20:26 snapshots
srw-rw---- 1 root lxd      0  5月  7 12:51 unix.socket
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04 LTSでLXD 2.0を試してみた</title>
      <link>/blog/2016/05/07/tried-lxd-2.0-on-ubuntu-16.04/</link>
      <pubDate>Sat, 07 May 2016 14:12:49 +0900</pubDate>
      
      <guid>/blog/2016/05/07/tried-lxd-2.0-on-ubuntu-16.04/</guid>
      <description>

&lt;h2 id=&#34;はじめに:c3e9af28f06dc8ad96c391f262f1ca0c&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2016/04/19/run_centos7_containers_on_lxc2/&#34;&gt;LXC 2.0でCentOS 7のコンテナを動かしてみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;でLXC 2.0を試しましたが、今度はLXD 2.0を試してみました。&lt;/p&gt;

&lt;p&gt;実は私は、コンテナをローカルホストでしか動かさないならLXC、リモートホストでも動かすならLXDという使い分けなのかなと漠然と思っていました。&lt;/p&gt;

&lt;p&gt;上記の記事ではrootユーザでコンテナを作成するという特権コンテナについて書きましたが、非rootユーザでコンテナを作成する非特権コンテナについては書いていませんでした。&lt;/p&gt;

&lt;p&gt;実は CentOS 7 の非特権コンテナも試していたのですが、 DHCP で IPアドレスが付与されないという現象が起きていました。私の当面の用途は開発環境構築でありホストOS側でroot権限はあることが前提なので非特権コンテナは調査しないことにしました。&lt;/p&gt;

&lt;p&gt;一方、LXDはデフォルトで非特権コンテナを作るようになっています。今回試してみたところ、 CentOS 7 のコンテナも DHCP で無事 IPアドレスが付与されました。&lt;/p&gt;

&lt;p&gt;root権限を使うのは必要最小限にするのが望ましいので、この状況を見ると今後新規に環境構築するならLXCよりもLXDを使うほうが良いかなと思います。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;a href=&#34;https://github.com/lxc/lxd&#34;&gt;https://github.com/lxc/lxd&lt;/a&gt; によると、LXD は lex-dee と発音するそうです。カタカナで書くとレックスディーもしくはレクスディーでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;記事リスト:c3e9af28f06dc8ad96c391f262f1ca0c&#34;&gt;記事リスト&lt;/h2&gt;

&lt;p&gt;いろいろ試していたら記事が長くなってきたので分割しました。例によって他の方に向けた入門記事ではなく、自分用の調査メモです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/start-using-lxd-2.0-on-ubuntu-16.04/&#34;&gt;Ubuntu 16.04 LTSでLXD 2.0をセットアップして使ってみる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/script-to-check-running-status-of-lxd-container/&#34;&gt;LXCの特定の1つのコンテナの起動状態をシェルスクリプトで確認したいときのお勧めの方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/how-to-use-fixed-ip-address-for-a-lxd-container/&#34;&gt;LXDコンテナで固定IPアドレスを使うための設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/tried-ansible-lxd-connection-plugin/&#34;&gt;AnsibleのLXDコネクションプラグインを試してみた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/tried-lxd-rest-api-with-curl/&#34;&gt;LXDのREST APIをcurlで試してみた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/tried-pylxd/&#34;&gt;LXDのREST APIクライアントライブラリpylxdを試してみた&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なお、記事によってコンテナのIPアドレスのネットワークが違う場合がありますが、何回か環境を作りなおして毎回ランダムなネットワークを使っているためなので気にしないでください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntuでホームディレクトリを暗号化するのを止めた</title>
      <link>/blog/2016/05/02/uninstall-encrypted-home-on-ubuntu/</link>
      <pubDate>Mon, 02 May 2016 12:28:08 +0900</pubDate>
      
      <guid>/blog/2016/05/02/uninstall-encrypted-home-on-ubuntu/</guid>
      <description>

&lt;h2 id=&#34;背景:810b47160307c060d35586a9f59d9467&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2016/05/01/install_ubuntu_xenial_with_pxe_boot/&#34;&gt;MacをPXEサーバにしてExpress5800/S70タイプRBにUbuntu16.04をインストールしてみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;でホームディレクトリを暗号化してみたのですが、OS起動後に鍵認証でsshしようとすると鍵は正しく指定しているのに &lt;code&gt;Permission denied (publickey).&lt;/code&gt; と拒否されてしまうケースがありました。コンソールで一度ログインするとsshでもログイン出来るようになります。&lt;/p&gt;

&lt;p&gt;これはホームディレクトリを暗号化した影響で &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt; が読めない状態になっているようです。&lt;/p&gt;

&lt;h2 id=&#34;authorized-keys-をホームディレクトリの外に置く手もある:810b47160307c060d35586a9f59d9467&#34;&gt;authorized_keys をホームディレクトリの外に置く手もある&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://askubuntu.com/questions/254776/ubuntu-server-ssh-after-reboot-permission-denied-publickey/254787#254787&#34;&gt;Ubuntu server ssh after reboot: Permission denied (publickey) - Ask Ubuntu&lt;/a&gt;によると &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt; で &lt;code&gt;AuthorizedKeysFile&lt;/code&gt; の設定を変える手もあるようです。&lt;/p&gt;

&lt;p&gt;変更前の状態は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#AuthorizedKeysFile     %h/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とデフォルト値がコメントアウトされて書かれていました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://manpages.ubuntu.com/manpages/precise/en/man5/sshd_config.5.html&#34;&gt;Ubuntu Manpage: sshd_config — OpenSSH SSH daemon configuration file&lt;/a&gt;によると &lt;code&gt;%h&lt;/code&gt; はホームディレクトリに展開されます。ユーザ名に展開される &lt;code&gt;%u&lt;/code&gt; というのもあるそうです。&lt;/p&gt;

&lt;p&gt;ここでは &lt;code&gt;/etc/%u/.ssh/authorized_keys&lt;/code&gt; に変更するのを試してみました。
先に自分のユーザID &lt;code&gt;hnakamur&lt;/code&gt; 用のディレクトリを作って所有者を変更します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir -p /etc/hnakamur/.ssh
sudo chmod -R 700 /etc/hnakamur
sudo chown -R hnakamur: /etc/hnakamur
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;cp ~/.ssh/authorized_keys /etc/hnakamur/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;その後 &lt;code&gt;sudo vi /etc/ssh/sshd_config&lt;/code&gt; を実行し以下の行を追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AuthorizedKeysFile /etc/%u/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでOSを再起動後、コンソールでログインしない状態でもsshで鍵認証でログンできることを確認しました。&lt;/p&gt;

&lt;p&gt;ただし、ログインは出来ましたが、暗号化の解除は手動で行う必要がありました。作ったはずの &lt;code&gt;~/.bash_profile&lt;/code&gt; が無いので気付きました。ホームディレクトリの中身は以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hnakamur@express:~$ ls -la
合計 8
dr-x------ 2 hnakamur hnakamur 4096  5月  2 01:31 .
drwxr-xr-x 4 root     root     4096  5月  2 01:31 ..
lrwxrwxrwx 1 hnakamur hnakamur   33  5月  2 01:31 .Private -&amp;gt; /home/.ecryptfs/hnakamur/.Private
lrwxrwxrwx 1 hnakamur hnakamur   34  5月  2 01:31 .ecryptfs -&amp;gt; /home/.ecryptfs/hnakamur/.ecryptfs
lrwxrwxrwx 1 hnakamur hnakamur   56  5月  2 01:31 Access-Your-Private-Data.desktop -&amp;gt; /usr/share/ecryptfs-utils/ecryptfs-mount-private.desktop
lrwxrwxrwx 1 hnakamur hnakamur   52  5月  2 01:31 README.txt -&amp;gt; /usr/share/ecryptfs-utils/ecryptfs-mount-private.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;README.txt&lt;/code&gt; を見てみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hnakamur@express:~$ cat README.txt
THIS DIRECTORY HAS BEEN UNMOUNTED TO PROTECT YOUR DATA.

From the graphical desktop, click on:
 &amp;quot;Access Your Private Data&amp;quot;

or

From the command line, run:
 ecryptfs-mount-private
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ecryptfs-mount-private&lt;/code&gt; を実行してログインパスワードを入力し &lt;code&gt;cd /home/hnakamur&lt;/code&gt; でホームディレクトリに入り直すと、復号化された内容が見えるようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hnakamur@express:~$ ecryptfs-mount-private
Enter your login passphrase:
Inserted auth tok with sig [d094f2376006dce9] into the user session keyring

INFO: Your private directory has been mounted.
INFO: To see this change in your current shell:
  cd /home/hnakamur

hnakamur@express:~$ ls -la
合計 8
dr-x------ 2 hnakamur hnakamur 4096  5月  2 01:31 .
drwxr-xr-x 4 root     root     4096  5月  2 01:31 ..
lrwxrwxrwx 1 hnakamur hnakamur   33  5月  2 01:31 .Private -&amp;gt; /home/.ecryptfs/hnakamur/.Private
lrwxrwxrwx 1 hnakamur hnakamur   34  5月  2 01:31 .ecryptfs -&amp;gt; /home/.ecryptfs/hnakamur/.ecryptfs
lrwxrwxrwx 1 hnakamur hnakamur   56  5月  2 01:31 Access-Your-Private-Data.desktop -&amp;gt; /usr/share/ecryptfs-utils/ecryptfs-mount-private.desktop
lrwxrwxrwx 1 hnakamur hnakamur   52  5月  2 01:31 README.txt -&amp;gt; /usr/share/ecryptfs-utils/ecryptfs-mount-private.txt
hnakamur@express:~$ cd /home/hnakamur
hnakamur@express:~$ ls -la
合計 128
drwx------ 6 hnakamur hnakamur 4096  5月  2 12:43 .
drwxr-xr-x 4 root     root     4096  5月  2 01:31 ..
lrwxrwxrwx 1 hnakamur hnakamur   33  5月  2 01:31 .Private -&amp;gt; /home/.ecryptfs/hnakamur/.Private
-rw------- 1 hnakamur hnakamur 1908  5月  2 12:43 .bash_history
-rw-r--r-- 1 hnakamur hnakamur  220  5月  2 01:31 .bash_logout
-rw-r--r-- 1 hnakamur hnakamur  100  5月  2 08:50 .bash_profile
-rw-r--r-- 1 hnakamur hnakamur 3771  5月  2 01:31 .bashrc
drwx------ 2 hnakamur hnakamur 4096  5月  2 01:36 .cache
lrwxrwxrwx 1 hnakamur hnakamur   34  5月  2 01:31 .ecryptfs -&amp;gt; /home/.ecryptfs/hnakamur/.ecryptfs
-rw------- 1 hnakamur hnakamur   41  5月  2 09:00 .lesshst
-rw-r--r-- 1 hnakamur hnakamur  675  5月  2 01:31 .profile
drwx------ 2 hnakamur hnakamur 4096  5月  2 01:38 .ssh
-rw-r--r-- 1 hnakamur hnakamur    0  5月  2 01:38 .sudo_as_admin_successful
-rw------- 1 hnakamur hnakamur 6841  5月  2 12:43 .viminfo
drwxr-xr-x 2 hnakamur hnakamur 4096  5月  2 03:13 docs
drwxr-xr-x 5 hnakamur hnakamur 4096  5月  2 08:47 gocode
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lvm暗号化を使っているのでホームディレクトリの暗号化は止めることにした:810b47160307c060d35586a9f59d9467&#34;&gt;LVM暗号化を使っているのでホームディレクトリの暗号化は止めることにした&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://ubuntuforums.org/showthread.php?t=1335046&#34;&gt;[all variants] Encrypted LVM vs Encrypted Home&lt;/a&gt;を見ると、ホームディレクトリを暗号化してもスワップや &lt;code&gt;/tmp&lt;/code&gt; などが暗号化されていないので情報漏えいのリスクがあるので、ホームディレクトリの暗号化よりもLVMの暗号化のほうが良いとのことです。&lt;/p&gt;

&lt;p&gt;そもそも自宅サーバでユーザは私だけということもあり、ホームディレクトリの暗号化は止めることにしました。&lt;/p&gt;

&lt;p&gt;以下のページを参考にしつつやってみました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.howtogeek.com/116179/how-to-disable-home-folder-encryption-after-installing-ubuntu/&#34;&gt;How to Disable Home Folder Encryption After Installing Ubuntu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://help.ubuntu.com/community/EncryptedHome&#34;&gt;EncryptedHome - Community Help Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;バックアップ用のディレクトリを作って、所有者を変えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir /home/hnakamur.backup
sudo chown hnakamur:hnakamur /home/hnakamur.backup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tar&lt;/code&gt; でバックアップして &lt;code&gt;.encryptfs&lt;/code&gt; ディレクトリは消します。シンボリックリンクもそのままコピーしたいので &lt;code&gt;tar&lt;/code&gt; を使っています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(cd /home/hnakamur; tar cf - .) | (cd /home/hnakamur.backup; tar xf -)
rm -rf /home/hnakamur.backup/.ecryptfs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ホームディレクトリを暗号化するためのパッケージをアンインストールしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get remove ecryptfs-utils libecryptfs0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記は手順ミスです。先に別の管理者ユーザを作って元のユーザ &lt;code&gt;hnakamur&lt;/code&gt; はログアウトし、別の管理ユーザで作業すべきでした。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;df -h&lt;/code&gt; で確認すると &lt;code&gt;hnakamur&lt;/code&gt; ユーザのホームディレクトリがマウントされたままになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@express:~# df -h
Filesystem                    Size  Used Avail Use% Mounted on
udev                          7.8G     0  7.8G   0% /dev
tmpfs                         1.6G  8.8M  1.6G   1% /run
/dev/mapper/express--vg-root  131G  2.1G  122G   2% /
tmpfs                         7.8G  4.0K  7.8G   1% /dev/shm
tmpfs                         5.0M     0  5.0M   0% /run/lock
tmpfs                         7.8G     0  7.8G   0% /sys/fs/cgroup
/dev/sdc1                     472M   55M  393M  13% /boot
tmpfs                         100K     0  100K   0% /run/lxcfs/controllers
/home/hnakamur/.Private       131G  2.1G  122G   2% /home/hnakamur
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この後、別のユーザを作りました。セカンダリグループに &lt;code&gt;sudo&lt;/code&gt; を指定して &lt;code&gt;sudo&lt;/code&gt; で &lt;code&gt;root&lt;/code&gt; になれるようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo useradd -m -G sudo -s /bin/bash hnakamur2
sudo mkdir -p /etc/hnakamur2/.ssh
sudo chmod -R 700 /etc/hnakamur2
sudo cp /etc/hnakamur/.ssh/authorized_keys /etc/hnakamur2/.ssh/
sudo chown -R hnakamur2: /etc/hnakamur2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パスワードが空だとsshログイン出来ないので、パスワードを設定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@express:~# passwd hnakamur2
新しい UNIX パスワードを入力してください:
新しい UNIX パスワードを再入力してください:
passwd: パスワードは正しく更新されました
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで &lt;code&gt;hnakamur2&lt;/code&gt; ユーザの作成が終わったので、Macからsshで hnakamur2 ユーザにログインします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh hnakamur2@express
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;root&lt;/code&gt; ユーザになって作業します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo -i
umount /home/hnakamur
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;df -h&lt;/code&gt; を実行してマウントが解除されたことを確認しました。
&lt;code&gt;/home/hnakamur&lt;/code&gt; の中身を確認すると以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@express:~# ll -a /home/hnakamur
合計 8
dr-x------ 2 hnakamur hnakamur 4096  5月  2 01:31 ./
drwxr-xr-x 7 root     root     4096  5月  2 14:42 ../
lrwxrwxrwx 1 hnakamur hnakamur   33  5月  2 01:31 .Private -&amp;gt; /home/.ecryptfs/hnakamur/.Private/
lrwxrwxrwx 1 hnakamur hnakamur   34  5月  2 01:31 .ecryptfs -&amp;gt; /home/.ecryptfs/hnakamur/.ecryptfs/
lrwxrwxrwx 1 hnakamur hnakamur   56  5月  2 01:31 Access-Your-Private-Data.desktop -&amp;gt; /usr/share/ecryptfs-utils/ecryptfs-mount-private.desktop
lrwxrwxrwx 1 hnakamur hnakamur   52  5月  2 01:31 README.txt -&amp;gt; /usr/share/ecryptfs-utils/ecryptfs-mount-private.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hnakamur&lt;/code&gt; のホームディレクトリを消して、バックアップした内容に戻します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm -rf /home/hnakamur
mv /home/hnakamur.backup/ /home/hnakamur
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;戻した中身を確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@express:~# ll -a /home/hnakamur/
合計 56
drwx------ 6 hnakamur hnakamur 4096  5月  2 13:04 ./
drwxr-xr-x 6 root     root     4096  5月  2 14:53 ../
lrwxrwxrwx 1 hnakamur hnakamur   33  5月  2 01:31 .Private -&amp;gt; /home/.ecryptfs/hnakamur/.Private/
-rw------- 1 hnakamur hnakamur 1908  5月  2 12:43 .bash_history
-rw-r--r-- 1 hnakamur hnakamur  220  5月  2 01:31 .bash_logout
-rw-r--r-- 1 hnakamur hnakamur  100  5月  2 08:50 .bash_profile
-rw-r--r-- 1 hnakamur hnakamur 3771  5月  2 01:31 .bashrc
drwx------ 2 hnakamur hnakamur 4096  5月  2 01:36 .cache/
-rw------- 1 hnakamur hnakamur   41  5月  2 09:00 .lesshst
-rw-r--r-- 1 hnakamur hnakamur  675  5月  2 01:31 .profile
drwx------ 2 hnakamur hnakamur 4096  5月  2 01:38 .ssh/
-rw-r--r-- 1 hnakamur hnakamur    0  5月  2 01:38 .sudo_as_admin_successful
-rw------- 1 hnakamur hnakamur 6841  5月  2 12:43 .viminfo
drwxr-xr-x 2 hnakamur hnakamur 4096  5月  2 03:13 docs/
drwxr-xr-x 5 hnakamur hnakamur 4096  5月  2 08:47 gocode/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.Private&lt;/code&gt; も不要なので消します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm /home/hnakamur/.Private
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで Mac から元のユーザ &lt;code&gt;hnakamur&lt;/code&gt; でsshログイン可能になります。
念のため &lt;code&gt;hnakamur2&lt;/code&gt; はログインしたままにしておいて、ターミナルの別端末でログインしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh hnakamur@express
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt; の &lt;code&gt;AuthorizedKeysFile&lt;/code&gt; の設定も元に戻すことにします。
&lt;code&gt;sudo vi /etc/ssh/sshd_config&lt;/code&gt; を実行し以下の行を削除します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AuthorizedKeysFile /etc/%u/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドで &lt;code&gt;sshd&lt;/code&gt; を再起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl restart sshd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/hnakamur&lt;/code&gt; 以下に置いた &lt;code&gt;hnakamur&lt;/code&gt; ユーザの鍵もディレクトリごと消します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo rm -r /etc/hnakamur
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mac のターミナルの別端末から &lt;code&gt;hnakamur&lt;/code&gt; ユーザでsshログインできることと、sudoでrootになれることを確認しました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hnakamur2&lt;/code&gt; ユーザのほうはログアウトして、 &lt;code&gt;hnakamur&lt;/code&gt; ユーザでログインした端末で &lt;code&gt;hnakamur2&lt;/code&gt; ユーザを削除します。メールスプールのディレクトリが無いというメッセージが出ますが問題ありません。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@express:~# sudo userdel -r hnakamur2
userdel: hnakamur2 のメールスプール (/var/mail/hnakamur2) がありません
root@express:~# echo $?
0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/hnakamur2&lt;/code&gt; 以下に置いた &lt;code&gt;hnakamur2&lt;/code&gt; ユーザの鍵もディレクトリごと消します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo rm -r /etc/hnakamur2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;その後&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo shutdown -r now
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で再起動して、コンソールでLVM暗号化のパスフレーズを入力して起動し、コンソールでログインすることなしに、ssh鍵認証でログインできることを確認しました。&lt;/p&gt;

&lt;p&gt;余談ですが、ちょっと不思議なのは、今まで構築したLinux環境ではsshで繋いで &lt;code&gt;sudo shutdown -h now&lt;/code&gt; や &lt;code&gt;sudo shutdown -r now&lt;/code&gt; を実行すると接続が切れていたのが、今回の環境ではプロンプトに戻らないまま残ってしまうということです。Ctrl-Cを入力すると &lt;code&gt;Host is down&lt;/code&gt; と表示されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@express:~# shutdown -r now
packet_write_poll: Connection to 192.168.0.201: Host is down
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ:810b47160307c060d35586a9f59d9467&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回のサーバのユーザは自分1人なのでホームディレクトリの暗号化は不要と判断し、解除しました。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>