<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hnakamur&#39;s blog at github</title>
    <link>/blog/</link>
    <description>Recent content on hnakamur&#39;s blog at github</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Sat, 07 May 2016 21:17:35 +0900</lastBuildDate>
    <atom:link href="/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LXDのREST APIクライアントライブラリpylxdを試してみた</title>
      <link>/blog/2016/05/07/tried-pylxd/</link>
      <pubDate>Sat, 07 May 2016 21:17:35 +0900</pubDate>
      
      <guid>/blog/2016/05/07/tried-pylxd/</guid>
      <description>

&lt;p&gt;Python Package Index (PyPI)の &lt;a href=&#34;https://pypi.python.org/pypi/pylxd/2.0.0&#34;&gt;pylxd 2.0.0&lt;/a&gt;のページにインストール方法と使い方の例が書いてあるので、これに沿って試しました。&lt;/p&gt;

&lt;h2 id=&#34;インストール:bdf999a6ff5e91d3491152b509b9755e&#34;&gt;インストール&lt;/h2&gt;

&lt;p&gt;Ubuntu 16.04だとaptでインストール可能なのでそちらでインストールしました。Python3用のpython3-pylxdパッケージとPython2用のpython-pylxdパッケージがありますが、今後Ansibleのモジュールを作ることを想定してPython2用のパッケージをインストールして試してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt install -y python-pylxd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストールしたpython-pylxdのバージョンは &lt;code&gt;2.0.0-0ubuntu1&lt;/code&gt; です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dpkg-query -W -f=&#39;${Version}\n&#39; python-pylxd
2.0.0-0ubuntu1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;試してみる:bdf999a6ff5e91d3491152b509b9755e&#34;&gt;試してみる&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ python
Python 2.7.11+ (default, Apr 17 2016, 14:00:29)
[GCC 5.3.1 20160413] on linux2
Type &amp;quot;help&amp;quot;, &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information.
&amp;gt;&amp;gt;&amp;gt; from pylxd import api
&amp;gt;&amp;gt;&amp;gt; lxd = api.API()
&amp;gt;&amp;gt;&amp;gt; lxd.container_defined(&#39;cent01&#39;)
True
&amp;gt;&amp;gt;&amp;gt; lxd.container_defined(&#39;hoge&#39;)
False
&amp;gt;&amp;gt;&amp;gt; lxd.container_list()
[u&#39;cent01&#39;, u&#39;cent02&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここから先は &lt;a href=&#34;https://github.com/lxc/pylxd/blob/master/pylxd/client.py&#34;&gt;pylxd/client.py&lt;/a&gt; と &lt;a href=&#34;https://github.com/lxc/pylxd/blob/master/pylxd/container.py&#34;&gt;pylxd/container.py&lt;/a&gt; の ソースを見ながら試しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from pylxd.client import Client
&amp;gt;&amp;gt;&amp;gt; client = Client()
&amp;gt;&amp;gt;&amp;gt; client.containers.all()
[&amp;lt;pylxd.container.Container object at 0x7fd44065db00&amp;gt;, &amp;lt;pylxd.container.Container object at 0x7fd44065db98&amp;gt;]
&amp;gt;&amp;gt;&amp;gt; client.containers.get(u&#39;cent01&#39;)
&amp;lt;pylxd.container.Container object at 0x7fd44065dc30&amp;gt;
&amp;gt;&amp;gt;&amp;gt; client.containers.get(u&#39;cent01&#39;).status
u&#39;Running&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LXDのREST APIをcurlで試してみた</title>
      <link>/blog/2016/05/07/tried-lxd-rest-api-with-curl/</link>
      <pubDate>Sat, 07 May 2016 21:17:34 +0900</pubDate>
      
      <guid>/blog/2016/05/07/tried-lxd-rest-api-with-curl/</guid>
      <description>

&lt;h2 id=&#34;lxdのrest-api:7237ac0558fc8bd24e4a1da16716b70c&#34;&gt;LXDのREST API&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/rest-api/&#34;&gt;Linux Containers - LXD - REST API&lt;/a&gt;と&lt;a href=&#34;https://github.com/lxc/lxd/blob/master/doc/rest-api.md&#34;&gt;lxd/rest-api.md at master · lxc/lxd&lt;/a&gt;にLXDのREST APIについて説明があります。&lt;/p&gt;

&lt;p&gt;また&lt;a href=&#34;https://github.com/lxc/lxd#using-the-rest-api&#34;&gt;Using the REST API&lt;/a&gt;に &lt;code&gt;curl&lt;/code&gt; コマンドでのAPI呼び出し例が書かれていました。&lt;/p&gt;

&lt;h2 id=&#34;curlでhttpsのエンドポイントにアクセスしてみたがエラー:7237ac0558fc8bd24e4a1da16716b70c&#34;&gt;curlでhttpsのエンドポイントにアクセスしてみたがエラー&lt;/h2&gt;

&lt;p&gt;まずはhttpsのURLで &lt;a href=&#34;https://github.com/lxc/lxd/blob/master/doc/rest-api.md#10&#34;&gt;/1.0&lt;/a&gt; エンドポイントを試してみたのですが、 &lt;code&gt;ALPN, server did not agree to a protocol&lt;/code&gt; というエラーになってしまいました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -k -v --cert ~/.config/lxc/client.crt --key ~/.config/lxc/client.key https://127.0.0.1:8443/1.0
*   Trying 127.0.0.1...
* Connected to 127.0.0.1 (127.0.0.1) port 8443 (#0)
* found 173 certificates in /etc/ssl/certs/ca-certificates.crt
* found 692 certificates in /etc/ssl/certs
* ALPN, offering http/1.1
* SSL connection using TLS1.2 / ECDHE_RSA_AES_128_GCM_SHA256
*        server certificate verification SKIPPED
*        server certificate status verification SKIPPED
*        common name: root@express (does not match &#39;127.0.0.1&#39;)
*        server certificate expiration date OK
*        server certificate activation date OK
*        certificate public key: RSA
*        certificate version: #3
*        subject: O=linuxcontainers.org,CN=root@express
*        start date: Tue, 03 May 2016 11:26:51 GMT
*        expire date: Fri, 01 May 2026 11:26:51 GMT
*        issuer: O=linuxcontainers.org,CN=root@express
*        compression: NULL
* ALPN, server did not agree to a protocol
&amp;gt; GET /1.0 HTTP/1.1
&amp;gt; Host: 127.0.0.1:8443
&amp;gt; User-Agent: curl/7.47.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Content-Type: application/json
&amp;lt; Date: Sat, 07 May 2016 12:25:53 GMT
&amp;lt; Content-Length: 162
&amp;lt;
{&amp;quot;type&amp;quot;:&amp;quot;sync&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;Success&amp;quot;,&amp;quot;status_code&amp;quot;:200,&amp;quot;metadata&amp;quot;:{&amp;quot;api_extensions&amp;quot;:[],&amp;quot;api_status&amp;quot;:&amp;quot;stable&amp;quot;,&amp;quot;api_version&amp;quot;:&amp;quot;1.0&amp;quot;,&amp;quot;auth&amp;quot;:&amp;quot;untrusted&amp;quot;,&amp;quot;public&amp;quot;:false}}
* Connection #0 to host 127.0.0.1 left intact
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この件は&lt;a href=&#34;https://lists.linuxcontainers.org/pipermail/lxc-users/2016-May/011603.html&#34;&gt;[lxc-users] The error &amp;ldquo;ALPN, server did not agree to a protocol&amp;rdquo; from LXD Rest API&lt;/a&gt;で質問してみました。&lt;/p&gt;

&lt;h2 id=&#34;curlでunix-domain-socket経由でアクセスしてみたら成功:7237ac0558fc8bd24e4a1da16716b70c&#34;&gt;curlでunix domain socket経由でアクセスしてみたら成功&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/toritori0318/items/193df8f749a9c4bda883&#34;&gt;curlでunix domain socket経由アクセスする - Qiita&lt;/a&gt;を参考に以下のようにアクセスしてみると成功しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s --unix-socket /var/lib/lxd/unix.socket https:/1.0 | jq .
{
  &amp;quot;type&amp;quot;: &amp;quot;sync&amp;quot;,
  &amp;quot;status&amp;quot;: &amp;quot;Success&amp;quot;,
  &amp;quot;status_code&amp;quot;: 200,
  &amp;quot;metadata&amp;quot;: {
    &amp;quot;api_extensions&amp;quot;: [],
    &amp;quot;api_status&amp;quot;: &amp;quot;stable&amp;quot;,
    &amp;quot;api_version&amp;quot;: &amp;quot;1.0&amp;quot;,
    &amp;quot;auth&amp;quot;: &amp;quot;trusted&amp;quot;,
    &amp;quot;config&amp;quot;: {
      &amp;quot;core.https_address&amp;quot;: &amp;quot;127.0.0.1:8443&amp;quot;,
      &amp;quot;core.trust_password&amp;quot;: true
    },
    &amp;quot;environment&amp;quot;: {
      &amp;quot;addresses&amp;quot;: [
        &amp;quot;127.0.0.1:8443&amp;quot;
      ],
      &amp;quot;architectures&amp;quot;: [
        &amp;quot;x86_64&amp;quot;,
        &amp;quot;i686&amp;quot;
      ],
      &amp;quot;certificate&amp;quot;: &amp;quot;-----BEGIN CERTIFICATE-----\n …(略)… \n-----END CERTIFICATE-----\n&amp;quot;,
      &amp;quot;driver&amp;quot;: &amp;quot;lxc&amp;quot;,
      &amp;quot;driver_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;kernel&amp;quot;: &amp;quot;Linux&amp;quot;,
      &amp;quot;kernel_architecture&amp;quot;: &amp;quot;x86_64&amp;quot;,
      &amp;quot;kernel_version&amp;quot;: &amp;quot;4.4.0-21-generic&amp;quot;,
      &amp;quot;server&amp;quot;: &amp;quot;lxd&amp;quot;,
      &amp;quot;server_pid&amp;quot;: 6446,
      &amp;quot;server_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;storage&amp;quot;: &amp;quot;dir&amp;quot;,
      &amp;quot;storage_version&amp;quot;: &amp;quot;&amp;quot;
    },
    &amp;quot;public&amp;quot;: false
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sudo lxd init&lt;/code&gt; でLXDをネットワーク越しに使うかの問いにnoと答えた環境では以下のような出力になりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s --unix-socket /var/lib/lxd/unix.socket http:/1.0 | jq .
{
  &amp;quot;type&amp;quot;: &amp;quot;sync&amp;quot;,
  &amp;quot;status&amp;quot;: &amp;quot;Success&amp;quot;,
  &amp;quot;status_code&amp;quot;: 200,
  &amp;quot;metadata&amp;quot;: {
    &amp;quot;api_extensions&amp;quot;: [],
    &amp;quot;api_status&amp;quot;: &amp;quot;stable&amp;quot;,
    &amp;quot;api_version&amp;quot;: &amp;quot;1.0&amp;quot;,
    &amp;quot;auth&amp;quot;: &amp;quot;trusted&amp;quot;,
    &amp;quot;config&amp;quot;: {},
    &amp;quot;environment&amp;quot;: {
      &amp;quot;addresses&amp;quot;: [],
      &amp;quot;architectures&amp;quot;: [
        &amp;quot;x86_64&amp;quot;,
        &amp;quot;i686&amp;quot;
      ],
      &amp;quot;certificate&amp;quot;: &amp;quot;-----BEGIN CERTIFICATE-----\n …(略)… \n-----END CERTIFICATE-----\n&amp;quot;,
      &amp;quot;driver&amp;quot;: &amp;quot;lxc&amp;quot;,
      &amp;quot;driver_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;kernel&amp;quot;: &amp;quot;Linux&amp;quot;,
      &amp;quot;kernel_architecture&amp;quot;: &amp;quot;x86_64&amp;quot;,
      &amp;quot;kernel_version&amp;quot;: &amp;quot;4.4.0-21-generic&amp;quot;,
      &amp;quot;server&amp;quot;: &amp;quot;lxd&amp;quot;,
      &amp;quot;server_pid&amp;quot;: 2150,
      &amp;quot;server_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;storage&amp;quot;: &amp;quot;dir&amp;quot;,
      &amp;quot;storage_version&amp;quot;: &amp;quot;&amp;quot;
    },
    &amp;quot;public&amp;quot;: false
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>AnsibleのLXDコネクションプラグインを試してみた</title>
      <link>/blog/2016/05/07/tried-ansible-lxd-connection-plugin/</link>
      <pubDate>Sat, 07 May 2016 20:32:13 +0900</pubDate>
      
      <guid>/blog/2016/05/07/tried-ansible-lxd-connection-plugin/</guid>
      <description>

&lt;p&gt;LXDを使うとなるとAnsibleのLXDコネクションプラグインが欲しいなと思って&lt;a href=&#34;https://github.com/ansible/ansible&#34;&gt;ansible/ansibleのgithubのレポジトリ&lt;/a&gt;を眺めていたら &lt;a href=&#34;https://github.com/ansible/ansible/blob/fca5ba153e9258d6a9a28c418d8339d507eee81c/lib/ansible/plugins/connection/lxd.py&#34;&gt;lib/ansible/plugins/connection/lxd.py&lt;/a&gt; に既に作られていることに気付きました。&lt;/p&gt;

&lt;p&gt;ソースを見ると &lt;code&gt;lxc&lt;/code&gt; コマンドを使った実装になっていました。aptでインストールしたansible 2.0.0.2にこのファイルだけ追加して使えないか試してみたのですが、 &lt;code&gt;AttributeError: &#39;PlayContext&#39; object has no attribute &#39;executable&#39;&lt;/code&gt; というエラーが出て使えませんでした。&lt;/p&gt;

&lt;p&gt;そこでvirtualenvで環境を作ってpipでgithubのmasterのansibleをインストールして試してみました。&lt;/p&gt;

&lt;h2 id=&#34;インストール手順:13ce47f5622032d397b4204850206b47&#34;&gt;インストール手順&lt;/h2&gt;

&lt;p&gt;インストール手順は以下の通りです。
まず、virtualenv環境でAnsibleをインストールするのに必要なパッケージをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt update
sudo apt install -y virtualenv build-essential python-dev libffi-dev libssl-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作業ディレクトリを作ってそこに移動し、virtualenvで環境を作ってansibleをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir ~/ansible-lxd-example
cd ~/ansible-lxd-example
virtualenv venv
. venv/bin/activate
pip install git+https://github.com/ansible/ansible
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使ってみる:13ce47f5622032d397b4204850206b47&#34;&gt;使ってみる&lt;/h2&gt;

&lt;p&gt;以下のような設定ファイルとテスト用のプレイブックを作りました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ansible.cfg
[defaults]
inventory = hosts
$ cat hosts
[containers]
cent01 ansible_connection=lxd
cent02 ansible_connection=lxd
$ cat test.yml
---
- hosts: containers
  remote_user: root
  tasks:
    - debug: msg=ipv4_address={{ ansible_default_ipv4.address }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行してみると、問題なく動作しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ansible-playbook test.yml

PLAY [containers] **************************************************************

TASK [setup] *******************************************************************
ok: [cent01]
ok: [cent02]

TASK [debug] *******************************************************************
ok: [cent01] =&amp;gt; {
    &amp;quot;msg&amp;quot;: &amp;quot;ipv4_address=10.155.92.101&amp;quot;
}
ok: [cent02] =&amp;gt; {
    &amp;quot;msg&amp;quot;: &amp;quot;ipv4_address=10.155.92.103&amp;quot;
}

PLAY RECAP *********************************************************************
cent01                     : ok=2    changed=0    unreachable=0    failed=0
cent02                     : ok=2    changed=0    unreachable=0    failed=0

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LXDコンテナで固定IPアドレスを使うための設定</title>
      <link>/blog/2016/05/07/how-to-use-fixed-ip-address-for-a-lxd-container/</link>
      <pubDate>Sat, 07 May 2016 18:01:51 +0900</pubDate>
      
      <guid>/blog/2016/05/07/how-to-use-fixed-ip-address-for-a-lxd-container/</guid>
      <description>

&lt;h2 id=&#34;設定まとめ:de0d43504d2d04b1f52e2f979627ae1f&#34;&gt;設定まとめ&lt;/h2&gt;

&lt;p&gt;自分が後から参照することを想定して先に設定方法をまとめます。&lt;/p&gt;

&lt;p&gt;LXDコンテナで固定IPアドレスを使うためには以下の設定が必要です。なお、設定にはroot権限が必要です。&lt;/p&gt;

&lt;p&gt;まず &lt;code&gt;/etc/dnsmasq.conf&lt;/code&gt; に以下のようにコンテナ名に対するIPアドレスを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dhcp-host=cent01,10.64.177.101
dhcp-host=cent02,10.64.177.102
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lxd-bridge&lt;/code&gt; サービスを再起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl restart lxd-bridge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IPアドレスを変更したコンテナを再起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc restart cent01
lxc restart cent02
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;調査メモ:de0d43504d2d04b1f52e2f979627ae1f&#34;&gt;調査メモ&lt;/h2&gt;

&lt;p&gt;以下は調査メモです。&lt;/p&gt;

&lt;p&gt;まず &lt;a href=&#34;https://github.com/lxc/lxd/issues/1168&#34;&gt;Persistent IP for Containers · Issue #1168 · lxc/lxd&lt;/a&gt; に固定IPアドレスを使うための情報がありました。LXDで特にサポートはないが、各コンテナでDHCPを使わずに静的IPアドレスを使用するか、あるいはホストのDHCPサーバ側で設定すれば実現できるとのことです。&lt;/p&gt;

&lt;p&gt;各コンテナで静的IPアドレスを使う方法も試してみたのですが、ホストのコンテナ内から別のコンテナをコンテナ名で参照しようとすると変更前のIPアドレスで通信しようとしてしまいうまく行きませんでした。&lt;/p&gt;

&lt;p&gt;これを実現するにはホストのDHCPサーバに各コンテナのIPアドレスを把握してもらう必要があるので、後者のDHCPサーバ側で設定するほうが良いです。&lt;/p&gt;

&lt;h3 id=&#34;lxdのブリッジインターフェースとdnsmasqの設定ファイル:de0d43504d2d04b1f52e2f979627ae1f&#34;&gt;LXDのブリッジインターフェースとdnsmasqの設定ファイル&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://insights.ubuntu.com/2016/04/07/lxd-networking-lxdbr0-explained/&#34;&gt;LXD networking: lxdbr0 explained | Ubuntu Insights&lt;/a&gt;と&lt;a href=&#34;https://gist.github.com/cronnelly/98345100afe21840267270da3283b371&#34;&gt;lxcbr0 is being replaced by lxdbr0&lt;/a&gt;によると、 LXCでは &lt;code&gt;lxcbr0&lt;/code&gt; というブリッジインターフェースを使っていましたが、LXDでは &lt;code&gt;lxdbr0&lt;/code&gt; と別のインターフェースを使うように変更されたそうです。&lt;/p&gt;

&lt;p&gt;これらの記事を見るとLXCの &lt;code&gt;lxcbr0&lt;/code&gt; はインストール時に固定のアドレスネットワークが設定されて環境によっては既存のネットワークと衝突するという問題があったので、LXD の &lt;code&gt;lxdbr0&lt;/code&gt; ではインストール時にはIPv4やIPv6のサブネットは設定せずに &lt;code&gt;sudo lxd init&lt;/code&gt; を実行したときに設定するように変更されたということのようです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo lxd init&lt;/code&gt; で生成した &lt;code&gt;lxdbr0&lt;/code&gt; 用の設定は &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; に保存されています。
ファイルの先頭に書かれていますが、変更したい場合は直接編集せずに &lt;code&gt;dpkg-reconfigure -p medium lxd&lt;/code&gt; を実行するのが良いそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /etc/default/lxd-bridge
# WARNING: This file is generated by a debconf template!
# It is recommended to update it by using &amp;quot;dpkg-reconfigure -p medium lxd&amp;quot;

# Whether to setup a new bridge or use an existing one
USE_LXD_BRIDGE=&amp;quot;true&amp;quot;

# Bridge name
# This is still used even if USE_LXD_BRIDGE is set to false
# set to an empty value to fully disable
LXD_BRIDGE=&amp;quot;lxdbr0&amp;quot;

# Update the &amp;quot;default&amp;quot; LXD profile
UPDATE_PROFILE=&amp;quot;true&amp;quot;

# Path to an extra dnsmasq configuration file
LXD_CONFILE=&amp;quot;&amp;quot;

# DNS domain for the bridge
LXD_DOMAIN=&amp;quot;lxd&amp;quot;

# IPv4
## IPv4 address (e.g. 10.0.8.1)
LXD_IPV4_ADDR=&amp;quot;10.16.29.1&amp;quot;

## IPv4 netmask (e.g. 255.255.255.0)
LXD_IPV4_NETMASK=&amp;quot;255.255.255.0&amp;quot;

## IPv4 network (e.g. 10.0.8.0/24)
LXD_IPV4_NETWORK=&amp;quot;10.16.29.1/24&amp;quot;

## IPv4 DHCP range (e.g. 10.0.8.2,10.0.8.254)
LXD_IPV4_DHCP_RANGE=&amp;quot;10.16.29.2,10.16.29.254&amp;quot;

## IPv4 DHCP number of hosts (e.g. 250)
LXD_IPV4_DHCP_MAX=&amp;quot;252&amp;quot;

## NAT IPv4 traffic
LXD_IPV4_NAT=&amp;quot;true&amp;quot;

# IPv6
## IPv6 address (e.g. 2001:470:b368:4242::1)
LXD_IPV6_ADDR=&amp;quot;fd94:d372:e27f:2987::1&amp;quot;

## IPv6 CIDR mask (e.g. 64)
LXD_IPV6_MASK=&amp;quot;64&amp;quot;

## IPv6 network (e.g. 2001:470:b368:4242::/64)
LXD_IPV6_NETWORK=&amp;quot;fd94:d372:e27f:2987::1/64&amp;quot;

## NAT IPv6 traffic
LXD_IPV6_NAT=&amp;quot;true&amp;quot;

# Run a minimal HTTP PROXY server
LXD_IPV6_PROXY=&amp;quot;false&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このブリッジインタフェースを有効にするには &lt;code&gt;lxd-bridge.service&lt;/code&gt; を開始します。サービスの定義ファイルは以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /lib/systemd/system/lxd-bridge.service
[Unit]
Description=LXD - network bridge
Documentation=man:lxd(1)
Before=lxd.service

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/lib/lxd/lxd-bridge.start
ExecStop=/usr/lib/lxd/lxd-bridge stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ExecStart&lt;/code&gt; に指定しているスクリプトの中身は以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /usr/lib/lxd/lxd-bridge.start
#!/bin/sh -e

[ ! -e /etc/default/lxd-bridge ] &amp;amp;&amp;amp; exit 0

. /etc/default/lxd-bridge

# Start by bringing up the bridge
/usr/lib/lxd/lxd-bridge start

# Switch LXD in setup mode if needed
if [ &amp;quot;${UPDATE_PROFILE:-true}&amp;quot; = &amp;quot;true&amp;quot; ] &amp;amp;&amp;amp; [ -e &amp;quot;/var/lib/lxd&amp;quot; ] &amp;amp;&amp;amp; \
    ([ ! -e &amp;quot;/var/lib/lxd-bridge/timestamp&amp;quot; ] || \
     [ &amp;quot;/etc/default/lxd-bridge&amp;quot; -nt &amp;quot;/var/lib/lxd-bridge/timestamp&amp;quot; ]); then

    mkdir -p /var/lib/lxd-bridge
    touch /var/lib/lxd-bridge/timestamp

    touch /var/lib/lxd/.setup_mode
fi

exit 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここから呼ばれる &lt;code&gt;/usr/lib/lxd/lxd-bridge&lt;/code&gt; を見てみると、initスクリプトになっていて &lt;code&gt;iptables&lt;/code&gt;, &lt;code&gt;ip6tables&lt;/code&gt;, &lt;code&gt;dnsmasq&lt;/code&gt; を実行するようになっていました。また &lt;code&gt;/usr/lib/lxd/lxd-bridge&lt;/code&gt; は上記の &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; を読み込むようになっています。&lt;/p&gt;

&lt;p&gt;起動された &lt;code&gt;dnsmasq&lt;/code&gt; を &lt;code&gt;ps&lt;/code&gt; で見ると以下のようなコマンドラインになっていました。&lt;/p&gt;

&lt;p&gt;$ ps auxww | grep [d]nsmasq
  lxd       2134  0.0  0.0  49984   388 ?        S    09:48   0:00 dnsmasq -s lxd -S /lxd/ -u lxd &amp;ndash;strict-order &amp;ndash;bind-interfaces &amp;ndash;pid-file=/run/lxd-bridge//dnsmasq.pid &amp;ndash;dhcp-no-override &amp;ndash;except-interface=lo &amp;ndash;interface=lxdbr0 &amp;ndash;dhcp-leasefile=/var/lib/lxd-bridge//dnsmasq.lxdbr0.leases &amp;ndash;dhcp-authoritative &amp;ndash;listen-address 10.16.29.1 &amp;ndash;dhcp-range 10.16.29.2,10.16.29.254 &amp;ndash;dhcp-lease-max=252 &amp;ndash;dhcp-range=fd94:d372:e27f:2987::1,ra-only &amp;ndash;listen-address fd94:d372:e27f:2987::1&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/lib/lxd/lxd-bridge&lt;/code&gt; を見ると &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; の &lt;code&gt;LXD_CONFILE&lt;/code&gt; にファイル名を指定しておけば &lt;code&gt;dnsmasq&lt;/code&gt; の &lt;code&gt;--conf-file&lt;/code&gt; オプションを使ってそのファイルを読み込むように書かれています。この方法を使おうかと思ったのですが、一方で &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; の設定にかかわらず &lt;code&gt;--dhcp-authoritative&lt;/code&gt; オプションが常に指定されるように書かれています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;man dnsmasq&lt;/code&gt; によると &lt;code&gt;--dhcp-authoritative&lt;/code&gt; オプションはネットワーク内に他にDHCPサーバが無く唯一のDHCPになっているときに指定するオプションとのことです。ホストで稼働する &lt;code&gt;dnsmasq&lt;/code&gt; が1つという前提であれば、デフォルトの設定ファイル &lt;code&gt;/etc/dnsmasq.conf&lt;/code&gt; を作ってそこに設定を書くほうが手っ取り早いので、そうすることにしました。&lt;/p&gt;

&lt;h3 id=&#34;lxd-bridge-serviceの設定変更はreloadではなくrestartが必要:de0d43504d2d04b1f52e2f979627ae1f&#34;&gt;lxd-bridge.serviceの設定変更はreloadではなくrestartが必要&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sudo systemctl reload lxd-bridge&lt;/code&gt; を実行してみると以下のようなエラーが出て失敗しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo systemctl reload lxd-bridge
Failed to reload lxd-bridge.service: Job type reload is not applicable for unit lxd-bridge.service.
See system logs and &#39;systemctl status lxd-bridge.service&#39; for details.
$ sudo systemctl status lxd-bridge
● lxd-bridge.service - LXD - network bridge
   Loaded: loaded (/lib/systemd/system/lxd-bridge.service; static; vendor preset: enabled)
   Active: active (exited) since 土 2016-05-07 13:06:06 JST; 6h ago
     Docs: man:lxd(1)
  Process: 3704 ExecStop=/usr/lib/lxd/lxd-bridge stop (code=exited, status=0/SUCCESS)
  Process: 3723 ExecStart=/usr/lib/lxd/lxd-bridge.start (code=exited, status=0/SUCCESS)
 Main PID: 3723 (code=exited, status=0/SUCCESS)
    Tasks: 1 (limit: 512)
   Memory: 412.0K
      CPU: 1.293s
   CGroup: /system.slice/lxd-bridge.service
           └─3755 dnsmasq -s lxd -S /lxd/ -u lxd --strict-order --bind-interfaces --pid-file=/run/lxd-bridge//dnsmasq.pid --dhcp-no-override --except-interface=lo --interface=lxdbr0 --dhcp-leasefile=/var/lib/lxd-bridge//dnsmasq.lxdbr0.leases --dhcp-authoritative --lis
 5月 07 18:56:28 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
 5月 07 19:06:21 express dnsmasq-dhcp[3755]: DHCPREQUEST(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7
 5月 07 19:06:21 express dnsmasq-dhcp[3755]: DHCPACK(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7 cent02
 5月 07 19:06:21 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
 5月 07 19:23:24 express dnsmasq-dhcp[3755]: DHCPREQUEST(lxdbr0) 10.155.92.101 00:16:3e:5f:01:7e
 5月 07 19:23:24 express dnsmasq-dhcp[3755]: DHCPACK(lxdbr0) 10.155.92.101 00:16:3e:5f:01:7e cent01
 5月 07 19:23:24 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
 5月 07 19:33:08 express dnsmasq-dhcp[3755]: DHCPREQUEST(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7
 5月 07 19:33:08 express dnsmasq-dhcp[3755]: DHCPACK(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7 cent02
 5月 07 19:33:08 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで、設定ファイルを変更反映するにも &lt;code&gt;sudo systemctl restart lxd-bridge&lt;/code&gt; のように再起動する必要があります。&lt;/p&gt;

&lt;h3 id=&#34;dnsmasqの再起動後-コンテナの再起動が必要:de0d43504d2d04b1f52e2f979627ae1f&#34;&gt;dnsmasqの再起動後、コンテナの再起動が必要&lt;/h3&gt;

&lt;p&gt;dnsmasqを再起動しただけではコンテナのIPアドレスは変わらないのでネットワークを再起動する必要がありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc exec cent01 systemctl restart network
lxc exec cent02 systemctl restart network
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナごと再起動でも良いと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc restart cent01
lxc restart cent02
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何回か試してみたところ、作っただけで特に何もしてないコンテナだとネットワーク再起動よりコンテナ自体を再起動するほうが速かったです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time lxc exec cent02 systemctl restart network

real    0m2.878s
user    0m0.008s
sys     0m0.000s
$ time lxc restart cent02

real    0m1.236s
user    0m0.004s
sys     0m0.004s
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LXCの特定の1つのコンテナの起動状態をシェルスクリプトで確認したいときのお勧めの方法</title>
      <link>/blog/2016/05/07/script-to-check-running-status-of-lxd-container/</link>
      <pubDate>Sat, 07 May 2016 14:12:49 +0900</pubDate>
      
      <guid>/blog/2016/05/07/script-to-check-running-status-of-lxd-container/</guid>
      <description>

&lt;h2 id=&#34;イマイチな方法1-lxc-listの出力をawkで加工:a407ff63c19d9133860d9fcb896e88f6&#34;&gt;イマイチな方法1: lxc listの出力をawkで加工&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lxc list -h&lt;/code&gt; を見ると &lt;code&gt;lxc list [resource] [filters] [--format table|json] [-c columns] [--fast]&lt;/code&gt; というコマンドラインになっていて、 &lt;code&gt;-c&lt;/code&gt; オプションで表示するカラムを指定可能です。&lt;/p&gt;

&lt;p&gt;例えば　以下のようにすれば &lt;code&gt;cent01&lt;/code&gt; コンテナの起動状態だけを表示できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c s cent01
+---------+
|  STATE  |
+---------+
| RUNNING |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、デフォルトの &lt;code&gt;--format table&lt;/code&gt; だとASCII文字の罫線が表示されるので、状態を抜き出すにはawkで加工する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c s cent01 | awk &#39;NR==4{print $2}&#39;
RUNNING
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;イマイチな方法2-lxc-list-format-jsonの出力をjqで加工:a407ff63c19d9133860d9fcb896e88f6&#34;&gt;イマイチな方法2: lxc list &amp;ndash;format jsonの出力をjqで加工&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;--format json&lt;/code&gt; でJSON形式で出力できるのですが、この場合は &lt;code&gt;-c&lt;/code&gt; オプションで項目を限定することは出来ませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list --format json -c s cent01
[{&amp;quot;architecture&amp;quot;:&amp;quot;x86_64&amp;quot;,&amp;quot;config&amp;quot;:{&amp;quot;volatile.base_image&amp;quot;:&amp;quot;a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2&amp;quot;,&amp;quot;volatile.eth0.hwaddr&amp;quot;:&amp;quot;00:16:3e:5f:01:7e&amp;quot;,&amp;quot;volatile.last_state.idmap&amp;quot;:&amp;quot;[{\&amp;quot;Isuid\&amp;quot;:true,\&amp;quot;Isgid\&amp;quot;:false,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\
&amp;quot;:65536},{\&amp;quot;Isuid\&amp;quot;:false,\&amp;quot;Isgid\&amp;quot;:true,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\&amp;quot;:65536}]&amp;quot;},&amp;quot;created_at&amp;quot;:&amp;quot;2016-05-06T18:56:46+09:00&amp;quot;,&amp;quot;devices&amp;quot;:{&amp;quot;root&amp;quot;:{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;disk&amp;quot;}},&amp;quot;ephemeral&amp;quot;:false,&amp;quot;expanded_config&amp;quot;:{&amp;quot;volatile.base_image&amp;quot;:&amp;quot;a027d59858d663fb2bc12b5ba767e9
2196a4aee8dbb2a607db53d718b91eb5d2&amp;quot;,&amp;quot;volatile.eth0.hwaddr&amp;quot;:&amp;quot;00:16:3e:5f:01:7e&amp;quot;,&amp;quot;volatile.last_state.idmap&amp;quot;:&amp;quot;[{\&amp;quot;Isuid\&amp;quot;:true,\&amp;quot;Isgid\&amp;quot;:false,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\&amp;quot;:65536},{\&amp;quot;Isuid\&amp;quot;:false,\&amp;quot;Isgid\&amp;quot;:true,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\&amp;quot;:65536}
]&amp;quot;},&amp;quot;expanded_devices&amp;quot;:{&amp;quot;eth0&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;eth0&amp;quot;,&amp;quot;nictype&amp;quot;:&amp;quot;bridged&amp;quot;,&amp;quot;parent&amp;quot;:&amp;quot;lxdbr0&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;nic&amp;quot;},&amp;quot;root&amp;quot;:{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;disk&amp;quot;}},&amp;quot;name&amp;quot;:&amp;quot;cent01&amp;quot;,&amp;quot;profiles&amp;quot;:[&amp;quot;default&amp;quot;],&amp;quot;stateful&amp;quot;:false,&amp;quot;status&amp;quot;:&amp;quot;Running&amp;quot;,&amp;quot;status_code&amp;quot;:103,&amp;quot;state&amp;quot;:null,&amp;quot;snapshots&amp;quot;:null}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sudo apt install jq&lt;/code&gt; で &lt;code&gt;jq&lt;/code&gt; コマンドをインストールして、それで状態を抜き出すことは可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list --format json cent01 | jq -r &#39;.[0].status&#39;
Running
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;お勧めの方法-lxc-infoの出力をawkで加工:a407ff63c19d9133860d9fcb896e88f6&#34;&gt;お勧めの方法: lxc infoの出力をawkで加工&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lxc list&lt;/code&gt; の場合は指定した文字列は完全一致ではなくて前方一致で表示されました。上記の例のように &lt;code&gt;cent01&lt;/code&gt; と &lt;code&gt;cent02&lt;/code&gt; の2つのコンテナがあるときに、 &lt;code&gt;lxc list -c s cent0&lt;/code&gt; と実行すると以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c s cent0
+---------+
|  STATE  |
+---------+
| RUNNING |
+---------+
| RUNNING |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだとどの行がどのコンテナかわからないのでコンテナ名の列も付ける必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c ns cent0
+--------+---------+
|  NAME  |  STATE  |
+--------+---------+
| cent01 | RUNNING |
+--------+---------+
| cent02 | RUNNING |
+--------+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この結果をawkで加工するのでも良いのですが、もっと良いのは &lt;code&gt;lxc info&lt;/code&gt; コマンドを使うことです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc info cent01
コンテナ名: cent01
アーキテクチャ: x86_64
作成日時: 2016/05/06 09:56 UTC
状態: Running
タイプ: persistent
プロファイル: default
Pid: 29354
IPアドレス:
  eth0: inet    10.155.92.101   vethG4XSE4
  eth0: inet6   fe80::216:3eff:fe5f:17e vethG4XSE4
  lo:   inet    127.0.0.1
  lo:   inet6   ::1
リソース:
  プロセス数: 10
  メモリ消費量:
    メモリ (現在値): 23.60MB
    メモリ (ピーク): 43.08MB
  ネットワーク使用状況:
    eth0:
      受信バイト数: 24.16kB
      送信バイト数: 8.06kB
      受信パケット: 232
      送信パケット: 88
    lo:
      受信バイト数: 0 bytes
      送信バイト数: 0 bytes
      受信パケット: 0
      送信パケット: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存在しないコンテナ名を指定するとエラーになります。これは標準エラー出力に出力されています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc info hoge
エラー: not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;シェルスクリプトで加工するには英語出力のほうが良いので &lt;code&gt;LANG=C&lt;/code&gt; 付きで実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ LANG=C lxc info cent01
Name: cent01
Architecture: x86_64
Created: 2016/05/06 09:56 UTC
Status: Running
Type: persistent
Profiles: default
Pid: 29354
Ips:
  eth0: inet    10.155.92.101   vethG4XSE4
  eth0: inet6   fe80::216:3eff:fe5f:17e vethG4XSE4
  lo:   inet    127.0.0.1
  lo:   inet6   ::1
Resources:
  Processes: 10
  Memory usage:
    Memory (current): 23.60MB
    Memory (peak): 43.08MB
  Network usage:
    eth0:
      Bytes received: 24.58kB
      Bytes sent: 8.56kB
      Packets received: 235
      Packets sent: 93
    lo:
      Bytes received: 0 bytes
      Bytes sent: 0 bytes
      Packets received: 0
      Packets sent: 0
$ LANG=C lxc info hoge
error: not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結局以下のように実行するのがお勧めです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ LANG=C lxc info cent01 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;
Running
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存在しない場合は空文字列になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ LANG=C lxc info hoge 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判定例はこんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ [ x`LANG=C lxc info cent01 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;` == xRunning ] &amp;amp;&amp;amp; echo &amp;quot;container is running&amp;quot;
container is running
$ [ x`LANG=C lxc info hoge 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;` == xRunning ] &amp;amp;&amp;amp; echo &amp;quot;container is running&amp;quot;
$
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04 LTSでLXD 2.0をセットアップして使ってみる</title>
      <link>/blog/2016/05/07/start-using-lxd-2.0-on-ubuntu-16.04/</link>
      <pubDate>Sat, 07 May 2016 14:12:49 +0900</pubDate>
      
      <guid>/blog/2016/05/07/start-using-lxd-2.0-on-ubuntu-16.04/</guid>
      <description>

&lt;h2 id=&#34;参考記事:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;参考記事&lt;/h2&gt;

&lt;p&gt;公式ドキュメントの&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/getting-started-cli/&#34;&gt;Linux Containers - LXD - はじめに - コマンドライン&lt;/a&gt;によくまとまっているのですが、より詳細には &lt;a href=&#34;http://insights.ubuntu.com/2016/03/14/the-lxd-2-0-story-prologue/&#34;&gt;The LXD 2.0 Story (Prologue) | Ubuntu Insights&lt;/a&gt; にリストアップされている記事がわかりやすかったです。&lt;/p&gt;

&lt;h3 id=&#34;ubuntu-16-04-serverでのlxdの初期セットアップ:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;Ubuntu 16.04 serverでのLXDの初期セットアップ&lt;/h3&gt;

&lt;p&gt;Ubuntu 16.04 serverならLXDはインストール済みなので、 &lt;code&gt;apt-get install lxd&lt;/code&gt; と &lt;code&gt;newgrp lxd&lt;/code&gt; は不要でした。&lt;/p&gt;

&lt;p&gt;LXCではコンテナ一覧表示は &lt;code&gt;lxc-ls&lt;/code&gt;、コンテナ作成は &lt;code&gt;lxc-create&lt;/code&gt; のように別々のコマンドになっていましたが、 LXDではそれぞれ &lt;code&gt;lxc list&lt;/code&gt;, &lt;code&gt;lxc launch&lt;/code&gt; と &lt;code&gt;lxc&lt;/code&gt; コマンドのサブコマンドになっています。&lt;/p&gt;

&lt;p&gt;また &lt;code&gt;lxd&lt;/code&gt; というプログラムもあります。 &lt;code&gt;man lxd&lt;/code&gt; と &lt;code&gt;man lxc&lt;/code&gt; してみると &lt;code&gt;lxd&lt;/code&gt; はコンテナのハイパーバイザのデーモンで、 &lt;code&gt;lxc&lt;/code&gt; はコンテナのハイパーバイザのクライアントです。&lt;/p&gt;

&lt;p&gt;まずバージョンを確認してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxd --version
2.0.0
$ lxc --version
2.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、 &lt;code&gt;lxc&lt;/code&gt; のほうは &lt;code&gt;lxc version&lt;/code&gt; と &lt;code&gt;version&lt;/code&gt; サブコマンドも用意されていますが、 &lt;code&gt;lxd version&lt;/code&gt; は &lt;code&gt;error: Unknown arguments&lt;/code&gt; とエラーになりました。&lt;/p&gt;

&lt;p&gt;コンテナ一覧を表示してみます。まだ1つもコンテナを作っていないので一覧は空です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
Generating a client certificate. This may take a minute...
If this is your first time using LXD, you should also run: sudo lxd init

+------+-------+------+------+------+-----------+
| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |
+------+-------+------+------+------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lxc list&lt;/code&gt; の出力の1行目にある通り、初回実行時にはクライアント証明書が生成されます。 &lt;code&gt;~/.config/lxc/client.key&lt;/code&gt; に秘密鍵、 &lt;code&gt;~/.config/lxc/client.crt&lt;/code&gt; に証明書が作られました。&lt;/p&gt;

&lt;p&gt;また、 &lt;code&gt;lxc list&lt;/code&gt; の出力の2行目に LXDを初めて使うときは &lt;code&gt;sudo lxd init&lt;/code&gt; を実行するようにも書かれていますので、実行します。&lt;/p&gt;

&lt;p&gt;すると、いくつか質問されるので入力していきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lxd init
sudo: unable to resolve host ubuntu-xenial
Name of the storage backend to use (dir or zfs): dir
Would you like LXD to be available over the network (yes/no)? no
Do you want to configure the LXD bridge (yes/no)? yes
Warning: Stopping lxd.service, but it can still be activated by:
  lxd.socket
LXD has been successfully configured.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1つ目はストレージバックアップの選択です。選択肢は &lt;code&gt;dir&lt;/code&gt; か &lt;code&gt;zfs&lt;/code&gt; ですが、上記では &lt;code&gt;dir&lt;/code&gt; にしました。&lt;/p&gt;

&lt;p&gt;2つ目はLXDをネットワーク越しで利用するかどうかです。上記では &lt;code&gt;no&lt;/code&gt; にしました。
すると上記の警告にあるとおり &lt;code&gt;lxd.service&lt;/code&gt; が停止されました。 &lt;code&gt;sudo systemctl status lxd&lt;/code&gt; で確認すると &lt;code&gt;Active:&lt;/code&gt; の右が &lt;code&gt;inactive (dead)&lt;/code&gt; になっていました。&lt;/p&gt;

&lt;p&gt;一方で、 &lt;code&gt;lxd.socket&lt;/code&gt; は稼働しています。 &lt;code&gt;sudo systemctl status lxd.socket&lt;/code&gt; で確認すると &lt;code&gt;Active:&lt;/code&gt; の右が &lt;code&gt;active (running)&lt;/code&gt; になっていました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/lib/systemd/system/lxd.socket&lt;/code&gt; を見ると &lt;code&gt;/var/lib/lxd/unix.socket&lt;/code&gt; というファイル名でUnixドメインソケットが作られていることがわかりました。&lt;/p&gt;

&lt;p&gt;3つ目はLXDのブリッジを設定するかどうかです。上記は &lt;code&gt;yes&lt;/code&gt; にしました。すると CUI でダイアログが次々開いて DHCPで発行するIPv4やIPv6のアドレスの範囲などを聞かれるので、順次入力していきます。ランダムなアドレスの範囲が事前入力されているので、特に変更不要な場合はenterキーを連打していけばOKでした。&lt;/p&gt;

&lt;p&gt;再度 &lt;code&gt;lxc list&lt;/code&gt; を実行してみると、今度はクライアント証明書を生成したとか、 &lt;code&gt;sudo lxc init&lt;/code&gt; を実行せよとかの文言は表示されなくなりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+------+-------+------+------+------+-----------+
| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |
+------+-------+------+------+------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;別パターンの初期化の検証:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;別パターンの初期化の検証&lt;/h4&gt;

&lt;p&gt;このパターンではLXDをネットワーク越しに使うかの質問に &lt;code&gt;yes&lt;/code&gt; と答えました。すると、バインドするアドレスとポートを聞かれます。ポートは &lt;code&gt;8443&lt;/code&gt; がお勧めと書かれていますが、enterキー空打ちではだめで、ちゃんと値を入力する必要がありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lxd init
sudo: unable to resolve host ubuntu-xenial
Name of the storage backend to use (dir or zfs): dir
Would you like LXD to be available over the network (yes/no)? yes
Address to bind LXD to (not including port): 0.0.0.0
Port to bind LXD to (8443 recommended):
Invalid input, try again.

Port to bind LXD to (8443 recommended): 8443
Trust password for new clients:
Again:
Do you want to configure the LXD bridge (yes/no)? no
LXD has been successfully configured.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この設定の後に &lt;code&gt;sudo systemctl status lxd&lt;/code&gt; を実行すると &lt;code&gt;Active:&lt;/code&gt; の右は &lt;code&gt;active (running)&lt;/code&gt; になっていました。&lt;/p&gt;

&lt;p&gt;また、上記ではLXDブリッジを設定するかの質問に &lt;code&gt;no&lt;/code&gt; と答えてみました。この場合は CUIのダイアログは開かれず、すぐに &lt;code&gt;LXD has been successfully configured.&lt;/code&gt; が表示されて完了しました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ip a&lt;/code&gt; で確認すると、この場合も &lt;code&gt;lxdbr0&lt;/code&gt; というネットワークインターフェース自体は作成されていました。ただし、IPアドレスは設定されていない状態です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ip a
...(略)...
4: lxdbr0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN group default qlen 1000
    link/ether 0a:b4:d4:fa:b3:71 brd ff:ff:ff:ff:ff:ff
    inet6 fe80::8b4:d4ff:fefa:b371/64 scope link
       valid_lft forever preferred_lft forever
    inet6 fe80::1/64 scope link
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、その後 &lt;code&gt;lxc launch&lt;/code&gt; でコンテナを起動した後再度確認すると &lt;code&gt;lxdbr0&lt;/code&gt; の左の番号が &lt;code&gt;4:&lt;/code&gt; から &lt;code&gt;5:&lt;/code&gt; に変わっていて、IPv4アドレスも設定されていました。また &lt;code&gt;lxc.service&lt;/code&gt; も起動していました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo ss -antp&lt;/code&gt; で確認したところ、LXDをネットワーク越しに使う設定を &lt;code&gt;yes&lt;/code&gt; にしたときは &lt;code&gt;lxd&lt;/code&gt; のプロセスが指定したポート（上記の例では8443番ポート）をLISTENしていますが、 &lt;code&gt;no&lt;/code&gt; にしたときはLISTENしていませんでした。&lt;/p&gt;

&lt;h3 id=&#34;リモートとローカルのイメージ一覧表示:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;リモートとローカルのイメージ一覧表示&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;lxc image&lt;/code&gt; サブコマンドでイメージを取り扱います。 &lt;code&gt;lxc image -h&lt;/code&gt; と入力すると使用方法が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lxc image list&lt;/code&gt; の説明の部分を以下に引用します。 &lt;code&gt;LANG&lt;/code&gt; 環境変数が &lt;code&gt;ja_JP.UTF8&lt;/code&gt; ならヘルプメッセージは日本語で表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc image list [remote:] [filter]
    LXD のイメージストア内のイメージを一覧表示します。プロパティでフィルタ
    を行う場合は、フィルタは &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; の形になります。フィルタはイメー
    ジハッシュの一部やイメージエイリアス名の一部も指定できます。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;英語のヘルプメッセージを見たい場合は &lt;code&gt;LANG=C&lt;/code&gt; をつけて &lt;code&gt;LANG=C lxc image&lt;/code&gt; のように実行すればOKです。 &lt;code&gt;lxc image list&lt;/code&gt; の英語ヘルプメッセージを以下に引用します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc image list [remote:] [filter]
    List images in the LXD image store. Filters may be of the
    &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; form for property based filtering, or part of the image
    hash or part of the image alias name.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リモートのイメージ一覧は &lt;code&gt;lxc image list images:&lt;/code&gt; で表示できます。最後の &lt;code&gt;:&lt;/code&gt; はリモートの指定か区別するために必要です。&lt;/p&gt;

&lt;p&gt;ローカルのイメージ一覧は &lt;code&gt;lxc image list&lt;/code&gt; で表示できます。1つもコンテナを作っていない時は空になります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[remote:]&lt;/code&gt; の部分に指定可能なリモートの一覧は &lt;code&gt;lxc remote list&lt;/code&gt; で確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc remote list
+-----------------+------------------------------------------+---------------+--------+--------+
|      NAME       |                   URL                    |   PROTOCOL    | PUBLIC | STATIC |
+-----------------+------------------------------------------+---------------+--------+--------+
| images          | https://images.linuxcontainers.org       | lxd           | YES    | NO     |
+-----------------+------------------------------------------+---------------+--------+--------+
| local (default) | unix://                                  | lxd           | NO     | YES    |
+-----------------+------------------------------------------+---------------+--------+--------+
| ubuntu          | https://cloud-images.ubuntu.com/releases | simplestreams | YES    | YES    |
+-----------------+------------------------------------------+---------------+--------+--------+
| ubuntu-daily    | https://cloud-images.ubuntu.com/daily    | simplestreams | YES    | YES    |
+-----------------+------------------------------------------+---------------+--------+--------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フィルタを指定してリモートのcentosのイメージ一覧を表示すると以下の3つがヒットしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc image list images: centos
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
|          ALIAS          | FINGERPRINT  | PUBLIC |            DESCRIPTION            |  ARCH  |  SIZE   |         UPLOAD DATE         |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| centos/6/amd64 (1 more) | 81c42e7d8c4e | yes    | Centos 6 (amd64) (20160507_02:16) | x86_64 | 52.23MB | May 7, 2016 at 3:15am (UTC) |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| centos/6/i386 (1 more)  | 74c61c775024 | yes    | Centos 6 (i386) (20160507_02:16)  | i686   | 52.16MB | May 7, 2016 at 3:16am (UTC) |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| centos/7/amd64 (1 more) | 9c8a52ca68e4 | yes    | Centos 7 (amd64) (20160507_02:16) | x86_64 | 62.93MB | May 7, 2016 at 3:16am (UTC) |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;centos-7のコンテナを起動してみる:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;CentOS 7のコンテナを起動してみる&lt;/h3&gt;

&lt;p&gt;起動に使用するのは &lt;code&gt;lxc launch&lt;/code&gt; サブコマンドです。 &lt;code&gt;lxc launch -h&lt;/code&gt; でヘルプが見られます。&lt;/p&gt;

&lt;p&gt;ここでは &lt;code&gt;images&lt;/code&gt; のリモートの &lt;code&gt;centos/7/amd64&lt;/code&gt; のエイリアスのイメージを起動して &lt;code&gt;cent01&lt;/code&gt; というコンテナ名を付けてみます。どれぐらい時間がかかるか計測するため &lt;code&gt;time&lt;/code&gt; コマンドを付けて実行してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time lxc launch images:centos/7/amd64 cent01
Creating cent01
Retrieving image: 100%
Starting cent01

real    0m58.036s
user    0m0.056s
sys     0m0.036s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Retrieving image: 100%&lt;/code&gt; と表示されているように初回はイメージのダウンロードを行うので少し時間がかかります。私の環境では1分弱でした。&lt;/p&gt;

&lt;p&gt;起動直後に &lt;code&gt;lxc list&lt;/code&gt; を実行すると、 IPv6アドレスは付与されていますが、 IPv4アドレスはまだ空です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  | IPV4 |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING |      | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数秒立ってから再度実行するとIPv4アドレスが付与されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  |         IPV4         |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING | 10.64.177.167 (eth0) | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この時点でローカルのイメージ一覧を表示してみると、CentOS 7のイメージが追加されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc image list
+-------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| ALIAS | FINGERPRINT  | PUBLIC |            DESCRIPTION            |  ARCH  |  SIZE   |         UPLOAD DATE         |
+-------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
|       | 9c8a52ca68e4 | no     | Centos 7 (amd64) (20160507_02:16) | x86_64 | 62.93MB | May 7, 2016 at 7:13am (UTC) |
+-------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じイメージで2つめのコンテナを起動してみると今度はローカルのイメージを使うので起動時間は短くてすみました。私の環境では約10秒でした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time lxc launch images:centos/7/amd64 cent02
Creating cent02
Starting cent02

real    0m10.189s
user    0m0.044s
sys     0m0.008s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動直後にコンテナ一覧を確認すると、今起動した &lt;code&gt;cent02&lt;/code&gt; コンテナのIPv4アドレスはやはり空です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  |         IPV4         |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING | 10.64.177.167 (eth0) | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent02 | RUNNING |                      | fd36:b946:6537:931e:216:3eff:fe18:680a (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数秒立ってから再度確認すると &lt;code&gt;centos02&lt;/code&gt; コンテナにもIPv4アドレスが付与されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  |         IPV4         |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING | 10.64.177.167 (eth0) | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent02 | RUNNING | 10.64.177.34 (eth0)  | fd36:b946:6537:931e:216:3eff:fe18:680a (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;コンテナ内でコマンドを実行する:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;コンテナ内でコマンドを実行する&lt;/h3&gt;

&lt;p&gt;例えば &lt;code&gt;cent01&lt;/code&gt; コンテナで &lt;code&gt;bash&lt;/code&gt; を起動するには &lt;code&gt;lxc exec cent01 bash&lt;/code&gt; と実行します。するとコンテナ内で root ユーザになってプロンプトが表示されるので、好きなコマンドを入力して実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc exec cent01 bash
[root@cent01 ~]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
37: eth0@if38: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP qlen 1000
    link/ether 00:16:3e:5f:01:7e brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 10.155.92.101/24 brd 10.155.92.255 scope global dynamic eth0
       valid_lft 2508sec preferred_lft 2508sec
    inet6 fe80::216:3eff:fe5f:17e/64 scope link
       valid_lft forever preferred_lft forever
[root@cent01 ~]# ping -c 3 cent02
PING cent02.lxd (10.64.177.34) 56(84) bytes of data.
64 bytes from cent02.lxd (10.64.177.34): icmp_seq=1 ttl=64 time=0.034 ms
64 bytes from cent02.lxd (10.64.177.34): icmp_seq=2 ttl=64 time=0.068 ms
64 bytes from cent02.lxd (10.64.177.34): icmp_seq=3 ttl=64 time=0.081 ms

--- cent02.lxd ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1998ms
rtt min/avg/max/mdev = 0.034/0.061/0.081/0.019 ms
[root@cent01 ~]# exit
exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記の &lt;code&gt;ping&lt;/code&gt; の例でも分かる通り、コンテナ内から別のコンテナの名前を指定して通信可能です。 &lt;code&gt;ping&lt;/code&gt; の出力を見ると &lt;code&gt;.lxd&lt;/code&gt; というトップレベルドメインがつけられていて、 &lt;code&gt;ping -c 3 cent02.lxd&lt;/code&gt; でも大丈夫でした。この &lt;code&gt;.lxd&lt;/code&gt; という値は &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; の &lt;code&gt;LXD_DOMAIN=&amp;quot;lxd&amp;quot;&lt;/code&gt; という設定で指定されています。&lt;/p&gt;

&lt;p&gt;Control-Dを押すか、&lt;code&gt;exit&lt;/code&gt; に続いてenterキーで &lt;code&gt;bash&lt;/code&gt; から抜けます。&lt;/p&gt;

&lt;p&gt;単一のコマンドを実行したい場合は &lt;code&gt;bash&lt;/code&gt; の代わりにコマンドを書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc exec cent01 ls /
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドにオプションを指定するとエラーになりますが、コマンドの前に &lt;code&gt;--&lt;/code&gt; を入れれば大丈夫です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc exec cent01 ls -a /
error: flag provided but not defined: -a
$ lxc exec cent01 -- ls -a /
.  ..  .autorelabel  bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ホストosを再起動するとコンテナは自動起動されます:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;ホストOSを再起動するとコンテナは自動起動されます&lt;/h2&gt;

&lt;p&gt;LXCではホストOS起動時にコンテナを自動起動するには設定ファイルの編集が必要でしたが、LXDは特に設定は不要でした。　
ホストOSを再起動して &lt;code&gt;lxc list&lt;/code&gt; を実行してみると上記で作成した2つのコンテナのSTATEがRUNNINGになっていました。&lt;/p&gt;

&lt;h2 id=&#34;コンテナの停止と削除:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;コンテナの停止と削除&lt;/h2&gt;

&lt;p&gt;停止は &lt;code&gt;lxc stop コンテナ名&lt;/code&gt; 、削除は &lt;code&gt;lxc delete コンテナ名&lt;/code&gt; で出来ます。が、 CentOS 7 のコンテナを停止するには以下の事前準備が必要でした。&lt;/p&gt;

&lt;h3 id=&#34;centos-7-のコンテナを停止可能にするための設定:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;CentOS 7 のコンテナを停止可能にするための設定&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;cent01&lt;/code&gt; のところは実際のコンテナ名に置き換えて、各コンテナで実行が必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc exec cent01 -- sh -c &#39;ln -s /usr/lib/systemd/system/halt.target /etc/systemd/system/sigpwr.target &amp;amp;&amp;amp; systemctl daemon-reload&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この回避方法は &lt;a href=&#34;https://lists.linuxcontainers.org/pipermail/lxc-users/2014-February/006304.html&#34;&gt;[lxc-users] lxc-stop doesn&amp;rsquo;t stop centos, waits for the timeout&lt;/a&gt; で紹介されていました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lists.linuxcontainers.org/pipermail/lxc-users/2016-May/011602.html&#34;&gt;[lxc-users] lxc stop does not stop a CentOS 7 container&lt;/a&gt; で &lt;code&gt;images:&lt;/code&gt; で公開しているイメージにこの修正を取り込めないか問い合わせ中です。&lt;/p&gt;

&lt;h2 id=&#34;コンテナやイメージのファイルの在り処:aa686028c3d8246ae8dfc1e7fe034b7c&#34;&gt;コンテナやイメージのファイルの在り処&lt;/h2&gt;

&lt;p&gt;コンテナのファイルは &lt;code&gt;/var/lib/lxd/containers/&lt;/code&gt; にありました。操作しているユーザのuidとgidは1000なのですが、コンテナのディレクトリは100000と異なっていました。どこかでマッピングを持っているのだと思いますが、未調査です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ls -l /var/lib/lxd/containers/
合計 24
drwxr-xr-x+ 4 100000 100000  4096  5月  6 18:56 cent01
drwxr-xr-x+ 4 100000 100000  4096  5月  7 03:18 cent02
-rw-r--r--  1 root   root   10756  5月  7 19:47 lxc-monitord.log
drwxr-xr-x+ 4 100000 100000  4096  5月  3 20:46 my-ubuntu
$ sudo ls -l /var/lib/lxd/containers/cent01
合計 12
-rw-r--r--  1 root   root    628  1月  1  1970 metadata.yaml
dr-xr-xr-x 18 100000 100000 4096  5月  6 18:56 rootfs
drwxr-xr-x  2 root   root   4096  5月  6 18:56 templates
1$ sudo ls -l /var/lib/lxd/containers/cent01/rootfs/
合計 64
lrwxrwxrwx  1 100000 100000    7  5月  6 11:25 bin -&amp;gt; usr/bin
dr-xr-xr-x  2 100000 100000 4096  8月 12  2015 boot
drwxr-xr-x  4 100000 100000 4096  5月  6 11:25 dev
drwxr-xr-x 55 100000 100000 4096  5月  7 12:13 etc
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 home
lrwxrwxrwx  1 100000 100000    7  5月  6 11:25 lib -&amp;gt; usr/lib
lrwxrwxrwx  1 100000 100000    9  5月  6 11:25 lib64 -&amp;gt; usr/lib64
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 media
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 mnt
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 opt
dr-xr-xr-x  2 100000 100000 4096  8月 12  2015 proc
dr-xr-x---  3 100000 100000 4096  5月  7 03:42 root
drwxr-xr-x  7 100000 100000 4096  5月  6 11:25 run
lrwxrwxrwx  1 100000 100000    8  5月  6 11:25 sbin -&amp;gt; usr/sbin
drwxr-xr-x  2 100000 100000 4096  5月  6 11:25 selinux
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 srv
dr-xr-xr-x  2 100000 100000 4096  8月 12  2015 sys
drwxrwxrwt  7 100000 100000 4096  5月  7 12:54 tmp
drwxr-xr-x 13 100000 100000 4096  5月  6 11:25 usr
drwxr-xr-x 19 100000 100000 4096  5月  6 18:56 var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イメージのファイルは &lt;code&gt;/var/lib/lxd/images/&lt;/code&gt; にありました。 &lt;code&gt;lxc image list&lt;/code&gt; で表示されるフィンガープリント名のファイルとフィンガープリントに &lt;code&gt;.rootfs&lt;/code&gt; を追加した名前のファイルがあります。調べてみるとtar.xz形式のファイルになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ls -l /var/lib/lxd/images/
合計 205244
-rw-r--r-- 1 root root       588  5月  6 18:54 a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2
-rw-r--r-- 1 root root  65931516  5月  6 18:55 a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs
-rw-r--r-- 1 root root       792  5月  3 20:32 f4c4c60a6b752a381288ae72a1689a9da00f8e03b732c8d1b8a8fcd1a8890800
-rw-r--r-- 1 root root 144223868  5月  3 20:46 f4c4c60a6b752a381288ae72a1689a9da00f8e03b732c8d1b8a8fcd1a8890800.rootfs
$ sudo file /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2
/var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2: XZ compressed data
$ sudo file /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs
/var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs: XZ compressed data
$ sudo tar tvf /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2
-rw-r--r-- 0/0             239 1970-01-01 09:00 templates/hosts.tpl
-rw-r--r-- 0/0             628 1970-01-01 09:00 metadata.yaml
-rw-r--r-- 0/0              21 1970-01-01 09:00 templates/hostname.tpl
$ sudo tar tvf /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs | head
dr-xr-xr-x 0/0               0 2016-05-06 11:25 ./
drwxr-xr-x 0/0               0 2016-05-06 11:25 ./dev/
crw-rw-rw- 0/0             5,2 2016-05-06 11:25 ./dev/ptmx
prw------- 0/0               0 2016-05-06 11:25 ./dev/initctl
crw-rw-rw- 0/0             1,7 2016-05-06 11:25 ./dev/full
crw------- 0/0             5,1 2016-05-06 11:25 ./dev/console
crw-rw-rw- 0/0             4,4 2016-05-06 11:25 ./dev/tty4
crw-rw-rw- 0/0             4,3 2016-05-06 11:25 ./dev/tty3
crw-rw-rw- 0/0             4,2 2016-05-06 11:25 ./dev/tty2
crw-rw-rw- 0/0             4,1 2016-05-06 11:25 ./dev/tty1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/var/lib/lxd/&lt;/code&gt; には他にもディレクトリやファイルが存在しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l /var/lib/lxd
合計 84
drwx--x--x 5 root root  4096  5月  7 12:54 containers
drwx--x--x 5 root root  4096  5月  7 12:54 devices
drwxr-xr-x 2 root root  4096  5月  7 19:41 devlxd
drwx------ 2 root root  4096  5月  7 06:13 images
-rw-r--r-- 1 root root 43008  5月  7 19:46 lxd.db
drwx------ 4 root root  4096  5月  3 20:46 security
-rw-r--r-- 1 root root  2004  5月  3 20:26 server.crt
-rw------- 1 root root  3247  5月  3 20:26 server.key
drwx--x--x 5 root root  4096  5月  7 12:54 shmounts
drwx------ 2 root root  4096  5月  3 20:26 snapshots
srw-rw---- 1 root lxd      0  5月  7 12:51 unix.socket
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04 LTSでLXD 2.0を試してみた</title>
      <link>/blog/2016/05/07/tried-lxd-2.0-on-ubuntu-16.04/</link>
      <pubDate>Sat, 07 May 2016 14:12:49 +0900</pubDate>
      
      <guid>/blog/2016/05/07/tried-lxd-2.0-on-ubuntu-16.04/</guid>
      <description>

&lt;h2 id=&#34;はじめに:c3e9af28f06dc8ad96c391f262f1ca0c&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2016/04/19/run_centos7_containers_on_lxc2/&#34;&gt;LXC 2.0でCentOS 7のコンテナを動かしてみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;でLXC 2.0を試しましたが、今度はLXD 2.0を試してみました。&lt;/p&gt;

&lt;p&gt;実は私は、コンテナをローカルホストでしか動かさないならLXC、リモートホストでも動かすならLXDという使い分けなのかなと漠然と思っていました。&lt;/p&gt;

&lt;p&gt;上記の記事ではrootユーザでコンテナを作成するという特権コンテナについて書きましたが、非rootユーザでコンテナを作成する非特権コンテナについては書いていませんでした。&lt;/p&gt;

&lt;p&gt;実は CentOS 7 の非特権コンテナも試していたのですが、 DHCP で IPアドレスが付与されないという現象が起きていました。私の当面の用途は開発環境構築でありホストOS側でroot権限はあることが前提なので非特権コンテナは調査しないことにしました。&lt;/p&gt;

&lt;p&gt;一方、LXDはデフォルトで非特権コンテナを作るようになっています。今回試してみたところ、 CentOS 7 のコンテナも DHCP で無事 IPアドレスが付与されました。&lt;/p&gt;

&lt;p&gt;root権限を使うのは必要最小限にするのが望ましいので、この状況を見ると今後新規に環境構築するならLXCよりもLXDを使うほうが良いかなと思います。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;a href=&#34;https://github.com/lxc/lxd&#34;&gt;https://github.com/lxc/lxd&lt;/a&gt; によると、LXD は lex-dee と発音するそうです。カタカナで書くとレックスディーもしくはレクスディーでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;記事リスト:c3e9af28f06dc8ad96c391f262f1ca0c&#34;&gt;記事リスト&lt;/h2&gt;

&lt;p&gt;いろいろ試していたら記事が長くなってきたので分割しました。例によって他の方に向けた入門記事ではなく、自分用の調査メモです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/start-using-lxd-2.0-on-ubuntu-16.04/&#34;&gt;Ubuntu 16.04 LTSでLXD 2.0をセットアップして使ってみる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/script-to-check-running-status-of-lxd-container/&#34;&gt;LXCの特定の1つのコンテナの起動状態をシェルスクリプトで確認したいときのお勧めの方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/how-to-use-fixed-ip-address-for-a-lxd-container/&#34;&gt;LXDコンテナで固定IPアドレスを使うための設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/tried-ansible-lxd-connection-plugin/&#34;&gt;AnsibleのLXDコネクションプラグインを試してみた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/tried-lxd-rest-api-with-curl/&#34;&gt;LXDのREST APIをcurlで試してみた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/tried-pylxd/&#34;&gt;LXDのREST APIクライアントライブラリpylxdを試してみた&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なお、記事によってコンテナのIPアドレスのネットワークが違う場合がありますが、何回か環境を作りなおして毎回ランダムなネットワークを使っているためなので気にしないでください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntuでホームディレクトリを暗号化するのを止めた</title>
      <link>/blog/2016/05/02/uninstall-encrypted-home-on-ubuntu/</link>
      <pubDate>Mon, 02 May 2016 12:28:08 +0900</pubDate>
      
      <guid>/blog/2016/05/02/uninstall-encrypted-home-on-ubuntu/</guid>
      <description>

&lt;h2 id=&#34;背景:810b47160307c060d35586a9f59d9467&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2016/05/01/install_ubuntu_xenial_with_pxe_boot/&#34;&gt;MacをPXEサーバにしてExpress5800/S70タイプRBにUbuntu16.04をインストールしてみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;でホームディレクトリを暗号化してみたのですが、OS起動後に鍵認証でsshしようとすると鍵は正しく指定しているのに &lt;code&gt;Permission denied (publickey).&lt;/code&gt; と拒否されてしまうケースがありました。コンソールで一度ログインするとsshでもログイン出来るようになります。&lt;/p&gt;

&lt;p&gt;これはホームディレクトリを暗号化した影響で &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt; が読めない状態になっているようです。&lt;/p&gt;

&lt;h2 id=&#34;authorized-keys-をホームディレクトリの外に置く手もある:810b47160307c060d35586a9f59d9467&#34;&gt;authorized_keys をホームディレクトリの外に置く手もある&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://askubuntu.com/questions/254776/ubuntu-server-ssh-after-reboot-permission-denied-publickey/254787#254787&#34;&gt;Ubuntu server ssh after reboot: Permission denied (publickey) - Ask Ubuntu&lt;/a&gt;によると &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt; で &lt;code&gt;AuthorizedKeysFile&lt;/code&gt; の設定を変える手もあるようです。&lt;/p&gt;

&lt;p&gt;変更前の状態は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#AuthorizedKeysFile     %h/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とデフォルト値がコメントアウトされて書かれていました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://manpages.ubuntu.com/manpages/precise/en/man5/sshd_config.5.html&#34;&gt;Ubuntu Manpage: sshd_config — OpenSSH SSH daemon configuration file&lt;/a&gt;によると &lt;code&gt;%h&lt;/code&gt; はホームディレクトリに展開されます。ユーザ名に展開される &lt;code&gt;%u&lt;/code&gt; というのもあるそうです。&lt;/p&gt;

&lt;p&gt;ここでは &lt;code&gt;/etc/%u/.ssh/authorized_keys&lt;/code&gt; に変更するのを試してみました。
先に自分のユーザID &lt;code&gt;hnakamur&lt;/code&gt; 用のディレクトリを作って所有者を変更します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir -p /etc/hnakamur/.ssh
sudo chmod -R 700 /etc/hnakamur
sudo chown -R hnakamur: /etc/hnakamur
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;cp ~/.ssh/authorized_keys /etc/hnakamur/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;その後 &lt;code&gt;sudo vi /etc/ssh/sshd_config&lt;/code&gt; を実行し以下の行を追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AuthorizedKeysFile /etc/%u/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでOSを再起動後、コンソールでログインしない状態でもsshで鍵認証でログンできることを確認しました。&lt;/p&gt;

&lt;p&gt;ただし、ログインは出来ましたが、暗号化の解除は手動で行う必要がありました。作ったはずの &lt;code&gt;~/.bash_profile&lt;/code&gt; が無いので気付きました。ホームディレクトリの中身は以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hnakamur@express:~$ ls -la
合計 8
dr-x------ 2 hnakamur hnakamur 4096  5月  2 01:31 .
drwxr-xr-x 4 root     root     4096  5月  2 01:31 ..
lrwxrwxrwx 1 hnakamur hnakamur   33  5月  2 01:31 .Private -&amp;gt; /home/.ecryptfs/hnakamur/.Private
lrwxrwxrwx 1 hnakamur hnakamur   34  5月  2 01:31 .ecryptfs -&amp;gt; /home/.ecryptfs/hnakamur/.ecryptfs
lrwxrwxrwx 1 hnakamur hnakamur   56  5月  2 01:31 Access-Your-Private-Data.desktop -&amp;gt; /usr/share/ecryptfs-utils/ecryptfs-mount-private.desktop
lrwxrwxrwx 1 hnakamur hnakamur   52  5月  2 01:31 README.txt -&amp;gt; /usr/share/ecryptfs-utils/ecryptfs-mount-private.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;README.txt&lt;/code&gt; を見てみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hnakamur@express:~$ cat README.txt
THIS DIRECTORY HAS BEEN UNMOUNTED TO PROTECT YOUR DATA.

From the graphical desktop, click on:
 &amp;quot;Access Your Private Data&amp;quot;

or

From the command line, run:
 ecryptfs-mount-private
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ecryptfs-mount-private&lt;/code&gt; を実行してログインパスワードを入力し &lt;code&gt;cd /home/hnakamur&lt;/code&gt; でホームディレクトリに入り直すと、復号化された内容が見えるようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hnakamur@express:~$ ecryptfs-mount-private
Enter your login passphrase:
Inserted auth tok with sig [d094f2376006dce9] into the user session keyring

INFO: Your private directory has been mounted.
INFO: To see this change in your current shell:
  cd /home/hnakamur

hnakamur@express:~$ ls -la
合計 8
dr-x------ 2 hnakamur hnakamur 4096  5月  2 01:31 .
drwxr-xr-x 4 root     root     4096  5月  2 01:31 ..
lrwxrwxrwx 1 hnakamur hnakamur   33  5月  2 01:31 .Private -&amp;gt; /home/.ecryptfs/hnakamur/.Private
lrwxrwxrwx 1 hnakamur hnakamur   34  5月  2 01:31 .ecryptfs -&amp;gt; /home/.ecryptfs/hnakamur/.ecryptfs
lrwxrwxrwx 1 hnakamur hnakamur   56  5月  2 01:31 Access-Your-Private-Data.desktop -&amp;gt; /usr/share/ecryptfs-utils/ecryptfs-mount-private.desktop
lrwxrwxrwx 1 hnakamur hnakamur   52  5月  2 01:31 README.txt -&amp;gt; /usr/share/ecryptfs-utils/ecryptfs-mount-private.txt
hnakamur@express:~$ cd /home/hnakamur
hnakamur@express:~$ ls -la
合計 128
drwx------ 6 hnakamur hnakamur 4096  5月  2 12:43 .
drwxr-xr-x 4 root     root     4096  5月  2 01:31 ..
lrwxrwxrwx 1 hnakamur hnakamur   33  5月  2 01:31 .Private -&amp;gt; /home/.ecryptfs/hnakamur/.Private
-rw------- 1 hnakamur hnakamur 1908  5月  2 12:43 .bash_history
-rw-r--r-- 1 hnakamur hnakamur  220  5月  2 01:31 .bash_logout
-rw-r--r-- 1 hnakamur hnakamur  100  5月  2 08:50 .bash_profile
-rw-r--r-- 1 hnakamur hnakamur 3771  5月  2 01:31 .bashrc
drwx------ 2 hnakamur hnakamur 4096  5月  2 01:36 .cache
lrwxrwxrwx 1 hnakamur hnakamur   34  5月  2 01:31 .ecryptfs -&amp;gt; /home/.ecryptfs/hnakamur/.ecryptfs
-rw------- 1 hnakamur hnakamur   41  5月  2 09:00 .lesshst
-rw-r--r-- 1 hnakamur hnakamur  675  5月  2 01:31 .profile
drwx------ 2 hnakamur hnakamur 4096  5月  2 01:38 .ssh
-rw-r--r-- 1 hnakamur hnakamur    0  5月  2 01:38 .sudo_as_admin_successful
-rw------- 1 hnakamur hnakamur 6841  5月  2 12:43 .viminfo
drwxr-xr-x 2 hnakamur hnakamur 4096  5月  2 03:13 docs
drwxr-xr-x 5 hnakamur hnakamur 4096  5月  2 08:47 gocode
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lvm暗号化を使っているのでホームディレクトリの暗号化は止めることにした:810b47160307c060d35586a9f59d9467&#34;&gt;LVM暗号化を使っているのでホームディレクトリの暗号化は止めることにした&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://ubuntuforums.org/showthread.php?t=1335046&#34;&gt;[all variants] Encrypted LVM vs Encrypted Home&lt;/a&gt;を見ると、ホームディレクトリを暗号化してもスワップや &lt;code&gt;/tmp&lt;/code&gt; などが暗号化されていないので情報漏えいのリスクがあるので、ホームディレクトリの暗号化よりもLVMの暗号化のほうが良いとのことです。&lt;/p&gt;

&lt;p&gt;そもそも自宅サーバでユーザは私だけということもあり、ホームディレクトリの暗号化は止めることにしました。&lt;/p&gt;

&lt;p&gt;以下のページを参考にしつつやってみました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.howtogeek.com/116179/how-to-disable-home-folder-encryption-after-installing-ubuntu/&#34;&gt;How to Disable Home Folder Encryption After Installing Ubuntu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://help.ubuntu.com/community/EncryptedHome&#34;&gt;EncryptedHome - Community Help Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;バックアップ用のディレクトリを作って、所有者を変えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir /home/hnakamur.backup
sudo chown hnakamur:hnakamur /home/hnakamur.backup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tar&lt;/code&gt; でバックアップして &lt;code&gt;.encryptfs&lt;/code&gt; ディレクトリは消します。シンボリックリンクもそのままコピーしたいので &lt;code&gt;tar&lt;/code&gt; を使っています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(cd /home/hnakamur; tar cf - .) | (cd /home/hnakamur.backup; tar xf -)
rm -rf /home/hnakamur.backup/.ecryptfs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ホームディレクトリを暗号化するためのパッケージをアンインストールしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get remove ecryptfs-utils libecryptfs0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記は手順ミスです。先に別の管理者ユーザを作って元のユーザ &lt;code&gt;hnakamur&lt;/code&gt; はログアウトし、別の管理ユーザで作業すべきでした。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;df -h&lt;/code&gt; で確認すると &lt;code&gt;hnakamur&lt;/code&gt; ユーザのホームディレクトリがマウントされたままになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@express:~# df -h
Filesystem                    Size  Used Avail Use% Mounted on
udev                          7.8G     0  7.8G   0% /dev
tmpfs                         1.6G  8.8M  1.6G   1% /run
/dev/mapper/express--vg-root  131G  2.1G  122G   2% /
tmpfs                         7.8G  4.0K  7.8G   1% /dev/shm
tmpfs                         5.0M     0  5.0M   0% /run/lock
tmpfs                         7.8G     0  7.8G   0% /sys/fs/cgroup
/dev/sdc1                     472M   55M  393M  13% /boot
tmpfs                         100K     0  100K   0% /run/lxcfs/controllers
/home/hnakamur/.Private       131G  2.1G  122G   2% /home/hnakamur
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この後、別のユーザを作りました。セカンダリグループに &lt;code&gt;sudo&lt;/code&gt; を指定して &lt;code&gt;sudo&lt;/code&gt; で &lt;code&gt;root&lt;/code&gt; になれるようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo useradd -m -G sudo -s /bin/bash hnakamur2
sudo mkdir -p /etc/hnakamur2/.ssh
sudo chmod -R 700 /etc/hnakamur2
sudo cp /etc/hnakamur/.ssh/authorized_keys /etc/hnakamur2/.ssh/
sudo chown -R hnakamur2: /etc/hnakamur2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パスワードが空だとsshログイン出来ないので、パスワードを設定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@express:~# passwd hnakamur2
新しい UNIX パスワードを入力してください:
新しい UNIX パスワードを再入力してください:
passwd: パスワードは正しく更新されました
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで &lt;code&gt;hnakamur2&lt;/code&gt; ユーザの作成が終わったので、Macからsshで hnakamur2 ユーザにログインします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh hnakamur2@express
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;root&lt;/code&gt; ユーザになって作業します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo -i
umount /home/hnakamur
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;df -h&lt;/code&gt; を実行してマウントが解除されたことを確認しました。
&lt;code&gt;/home/hnakamur&lt;/code&gt; の中身を確認すると以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@express:~# ll -a /home/hnakamur
合計 8
dr-x------ 2 hnakamur hnakamur 4096  5月  2 01:31 ./
drwxr-xr-x 7 root     root     4096  5月  2 14:42 ../
lrwxrwxrwx 1 hnakamur hnakamur   33  5月  2 01:31 .Private -&amp;gt; /home/.ecryptfs/hnakamur/.Private/
lrwxrwxrwx 1 hnakamur hnakamur   34  5月  2 01:31 .ecryptfs -&amp;gt; /home/.ecryptfs/hnakamur/.ecryptfs/
lrwxrwxrwx 1 hnakamur hnakamur   56  5月  2 01:31 Access-Your-Private-Data.desktop -&amp;gt; /usr/share/ecryptfs-utils/ecryptfs-mount-private.desktop
lrwxrwxrwx 1 hnakamur hnakamur   52  5月  2 01:31 README.txt -&amp;gt; /usr/share/ecryptfs-utils/ecryptfs-mount-private.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hnakamur&lt;/code&gt; のホームディレクトリを消して、バックアップした内容に戻します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm -rf /home/hnakamur
mv /home/hnakamur.backup/ /home/hnakamur
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;戻した中身を確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@express:~# ll -a /home/hnakamur/
合計 56
drwx------ 6 hnakamur hnakamur 4096  5月  2 13:04 ./
drwxr-xr-x 6 root     root     4096  5月  2 14:53 ../
lrwxrwxrwx 1 hnakamur hnakamur   33  5月  2 01:31 .Private -&amp;gt; /home/.ecryptfs/hnakamur/.Private/
-rw------- 1 hnakamur hnakamur 1908  5月  2 12:43 .bash_history
-rw-r--r-- 1 hnakamur hnakamur  220  5月  2 01:31 .bash_logout
-rw-r--r-- 1 hnakamur hnakamur  100  5月  2 08:50 .bash_profile
-rw-r--r-- 1 hnakamur hnakamur 3771  5月  2 01:31 .bashrc
drwx------ 2 hnakamur hnakamur 4096  5月  2 01:36 .cache/
-rw------- 1 hnakamur hnakamur   41  5月  2 09:00 .lesshst
-rw-r--r-- 1 hnakamur hnakamur  675  5月  2 01:31 .profile
drwx------ 2 hnakamur hnakamur 4096  5月  2 01:38 .ssh/
-rw-r--r-- 1 hnakamur hnakamur    0  5月  2 01:38 .sudo_as_admin_successful
-rw------- 1 hnakamur hnakamur 6841  5月  2 12:43 .viminfo
drwxr-xr-x 2 hnakamur hnakamur 4096  5月  2 03:13 docs/
drwxr-xr-x 5 hnakamur hnakamur 4096  5月  2 08:47 gocode/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.Private&lt;/code&gt; も不要なので消します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm /home/hnakamur/.Private
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで Mac から元のユーザ &lt;code&gt;hnakamur&lt;/code&gt; でsshログイン可能になります。
念のため &lt;code&gt;hnakamur2&lt;/code&gt; はログインしたままにしておいて、ターミナルの別端末でログインしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh hnakamur@express
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt; の &lt;code&gt;AuthorizedKeysFile&lt;/code&gt; の設定も元に戻すことにします。
&lt;code&gt;sudo vi /etc/ssh/sshd_config&lt;/code&gt; を実行し以下の行を削除します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AuthorizedKeysFile /etc/%u/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドで &lt;code&gt;sshd&lt;/code&gt; を再起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl restart sshd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/hnakamur&lt;/code&gt; 以下に置いた &lt;code&gt;hnakamur&lt;/code&gt; ユーザの鍵もディレクトリごと消します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo rm -r /etc/hnakamur
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mac のターミナルの別端末から &lt;code&gt;hnakamur&lt;/code&gt; ユーザでsshログインできることと、sudoでrootになれることを確認しました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hnakamur2&lt;/code&gt; ユーザのほうはログアウトして、 &lt;code&gt;hnakamur&lt;/code&gt; ユーザでログインした端末で &lt;code&gt;hnakamur2&lt;/code&gt; ユーザを削除します。メールスプールのディレクトリが無いというメッセージが出ますが問題ありません。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@express:~# sudo userdel -r hnakamur2
userdel: hnakamur2 のメールスプール (/var/mail/hnakamur2) がありません
root@express:~# echo $?
0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/hnakamur2&lt;/code&gt; 以下に置いた &lt;code&gt;hnakamur2&lt;/code&gt; ユーザの鍵もディレクトリごと消します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo rm -r /etc/hnakamur2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;その後&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo shutdown -r now
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で再起動して、コンソールでLVM暗号化のパスフレーズを入力して起動し、コンソールでログインすることなしに、ssh鍵認証でログインできることを確認しました。&lt;/p&gt;

&lt;p&gt;余談ですが、ちょっと不思議なのは、今まで構築したLinux環境ではsshで繋いで &lt;code&gt;sudo shutdown -h now&lt;/code&gt; や &lt;code&gt;sudo shutdown -r now&lt;/code&gt; を実行すると接続が切れていたのが、今回の環境ではプロンプトに戻らないまま残ってしまうということです。Ctrl-Cを入力すると &lt;code&gt;Host is down&lt;/code&gt; と表示されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@express:~# shutdown -r now
packet_write_poll: Connection to 192.168.0.201: Host is down
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ:810b47160307c060d35586a9f59d9467&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回のサーバのユーザは自分1人なのでホームディレクトリの暗号化は不要と判断し、解除しました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04でNo-IPのダイナミックDNSサービスを使ってみた</title>
      <link>/blog/2016/05/02/use-no-ip-dynamic-dns-on-ubuntu-16.04/</link>
      <pubDate>Mon, 02 May 2016 09:39:31 +0900</pubDate>
      
      <guid>/blog/2016/05/02/use-no-ip-dynamic-dns-on-ubuntu-16.04/</guid>
      <description>

&lt;h2 id=&#34;背景:135c9c6bc59340025271c600f28573f2&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2016/05/01/install_ubuntu_xenial_with_pxe_boot/&#34;&gt;MacをPXEサーバにしてExpress5800/S70タイプRBにUbuntu16.04をインストールしてみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;で自宅サーバを起動したのですが、固定グローバルIPアドレスは持っていないので、ダイナミックDNS (DDNS) サービスを使うことにしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://viral-community.com/other-it/ddns-praise-service-2065/&#34;&gt;DDNSの無料サービスでオススメな３つの「ieServer」「mydns」「No-IP」の特徴と利用手順をまとめてみた&lt;/a&gt;を参考に「No-IP」を使ってみました。&lt;/p&gt;

&lt;h2 id=&#34;アカウント登録:135c9c6bc59340025271c600f28573f2&#34;&gt;アカウント登録&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.noip.com/&#34;&gt;https://www.noip.com/&lt;/a&gt; でメールアドレス、ユーザ名、パスワードを入力してサインアップし、確認のHTMLメールが届いたら[Activate Account]ボタンをクリックすればOKです。&lt;/p&gt;

&lt;h2 id=&#34;ホストの登録:135c9c6bc59340025271c600f28573f2&#34;&gt;ホストの登録&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.noip.com/&#34;&gt;https://www.noip.com/&lt;/a&gt; の右上の[Sign In]を押し、ユーザ名かメールアドレスとパスワードを入力してサインインします。サインイン後は &lt;a href=&#34;https://my.noip.com/&#34;&gt;https://my.noip.com/&lt;/a&gt; に遷移します。&lt;/p&gt;

&lt;p&gt;ホストの登録は新サイトの画面左の[Dashboard]を選んで、画面中央の[Quick Add]で[Hostname]を希望のホスト名を入力、[Doman]で使いたいドメインを選択して[Add Hostname]ボタンを押せばOKです。&lt;/p&gt;

&lt;p&gt;あるいは画面左の[Dynamic DNS]の[Hostnames]メニューを選び、[Add Hostname]ボタンを押す方法でもOKです。この場合は[Add Hostname]というタイトルのポップアップが開きます。&lt;/p&gt;

&lt;p&gt;[Hostname]に希望のホスト名を入力し、[Domain]は使いたいドメインを選びます。
[Record Type]はAのままでOKで、[IPv4 Address]にも自動で現在のグローバルIPアドレスが入力されているのでそのままでOKです。[Add Hostname]ボタンを押すと追加完了です。&lt;/p&gt;

&lt;p&gt;なお、試していませんが、[Record Type]の[More Records]ボタンを押すと、以下の4つのラジオボタンが表示されました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DNS Host (A)&lt;/li&gt;
&lt;li&gt;DNS Alias (CNAME)&lt;/li&gt;
&lt;li&gt;Web Redirect&lt;/li&gt;
&lt;li&gt;AAAA (IPv6)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また、その下には &amp;ldquo;Manage your Round Robin, TXT, SRV and DKIM records.&amp;rdquo; という文が書かれており、 &amp;ldquo;Manage&amp;rdquo; の部分がリンクになっていました。これを押すと &lt;a href=&#34;https://www.noip.com/members/dns/&#34;&gt;https://www.noip.com/members/dns/&lt;/a&gt; のManage Hostsページに遷移しました。 no-ip は管理画面をリニューアル中で、こちらは旧画面のようです。 &lt;a href=&#34;https://my.noip.com/#!/&#34;&gt;https://my.noip.com/#!/&lt;/a&gt; の画面上部にある [Use Old Site] というリンクでも旧サイトのManage Hostsページが開きました。&lt;/p&gt;

&lt;p&gt;新サイトの[Dynamic DNS]の[Hostnames]メニューで画面右に &amp;ldquo;Free Hostnames expire every 30 days. Enhanced Hostnames never expire. Upgrade to Enhanced&amp;rdquo; と書いてあるのですが、 &lt;a href=&#34;http://www.noip.com/support/faq/frequently-asked-questions/why-did-my-free-hostname-expire-or-get-deleted/&#34;&gt;Why did my free hostname expire or get deleted? | Support | No-IP&lt;/a&gt; の説明によれば無料サービスでも30日毎に更新していれば消えないようです。&lt;/p&gt;

&lt;h2 id=&#34;ipアドレス自動更新用のクライアントnoip2をセットアップ:135c9c6bc59340025271c600f28573f2&#34;&gt;IPアドレス自動更新用のクライアントnoip2をセットアップ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.noip.com/&#34;&gt;http://www.noip.com/&lt;/a&gt; の画面上部の [Download] リンクをクリックすると、アクセスしているブラウザからOSを自動判定して、そのOS用のクライアントのダウンロードページが開きます。私の場合は Dynamic DNS Update Client (DUC) for Mac のページが開きました。&lt;/p&gt;

&lt;p&gt;下の方にスクロールして [Other Downloads] の [Linux] をクリックして &lt;a href=&#34;https://www.noip.com/download?page=linux&#34;&gt;Dynamic DNS Update Client (DUC) for Linux - No-IP&lt;/a&gt; を開きます。&lt;/p&gt;

&lt;p&gt;Installation のセクションに &amp;ldquo;UBUNTU USERS: You may install this with the apt-get command, see this guide&amp;rdquo; という文があり guide のリンクをクリックすると &lt;a href=&#34;http://www.noip.com/support/knowledgebase/installing-the-linux-dynamic-update-client-on-ubuntu/&#34;&gt;How to Install the Linux Dynamic Update Client on Ubuntu&lt;/a&gt; に遷移しました。このページの手順に従ってセットアップすればOKでした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo -s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でパスワードを入力してrootになって以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /usr/local/src
wget http://www.no-ip.com/client/linux/noip-duc-linux.tar.gz
tar xf noip-duc-linux.tar.gz
cd noip-2.1.9-1/
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;noip-2.1.9-1 のディレクトリ内を見るとソースファイルは noip2.c の1つでした。中を見てみるとライセンスはGPLv2 or laterです。ざっと見た感じでは不正な通信はしてなさそうでした。&lt;/p&gt;

&lt;p&gt;インストール後以下のコマンドを実行して設定ファイルを作成します。以下のコマンドは全てrootで実行しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/bin/noip2 -C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プロンプトが表示されたらNo-IPのユーザ名、パスワードと登録したホスト名を入力します。すると /usr/local/etc/no-ip2.conf に設定ファイルが作られます。viで中を見てみると一部テキスト、一部バイナリのファイルでした。&lt;/p&gt;

&lt;p&gt;あとは &lt;code&gt;/usr/local/bin/noip2&lt;/code&gt; でデーモンが起動するのですが、systemdのサービスとして登録したいので、unitファイルを作りました。&lt;/p&gt;

&lt;p&gt;ソースのディレクトリにdebian, gentoo, redhat用のinit.d用のスクリプトとmac用の自動起動スクリプトがありました。 &lt;code&gt;redhat.noip.sh&lt;/code&gt; を見ると、起動は &lt;code&gt;/usr/local/bin/noip2&lt;/code&gt; で、終了は &lt;code&gt;killproc noip2 -TERM&lt;/code&gt; で行っていました。&lt;/p&gt;

&lt;p&gt;Ubuntuで試したら &lt;code&gt;killproc&lt;/code&gt; は無かったので &lt;code&gt;killall&lt;/code&gt; で代用しました。&lt;/p&gt;

&lt;p&gt;以下のコマンドでunitファイルを作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; /etc/systemd/system/noip2.service
[Unit]
Description=No-IP.com DDNS client
After=network.target auditd.service

[Service]
ExecStart=/usr/local/bin/noip2
ExecStop=/usr/bin/killall -TERM /usr/local/bin/noip2
Restart=on-failure
Type=forking

[Install]
WantedBy=multi-user.target
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作成したファイルをsystemdに読み込ませます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl daemon-reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドでサービスの起動とOS起動時の自動起動設定を行います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl start noip2
systemctl enable noip2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、 &lt;code&gt;mac.osx.startup&lt;/code&gt; では &lt;code&gt;noip2 -S&lt;/code&gt; の出力からpidを取得して &lt;code&gt;noip -K $pid&lt;/code&gt; で停止していました。こんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for i in `noip2 -S 2&amp;gt;&amp;amp;1 | grep Process | awk &#39;{print $2}&#39; | tr -d &#39;,&#39;`
      do
        noip2 -K $i
      done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;journalctlでログを見てみると以下のようなログが出ていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo journalctl | grep noip2
 5月 02 10:54:07 express noip2[1082]: v2.1.9 daemon started with NAT enabled
 5月 02 10:54:07 express noip2[1082]: xxxx.ddns.net was already set to xx.xx.xx.xx.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際はxxxx.ddns.net はNo-IPで登録したホスト名と選択したドメインでxx.xx.xx.xxは自宅サーバのグローバルIPアドレスが出力されていましたが、セキュリティ上伏せています。&lt;/p&gt;

&lt;h2 id=&#34;ポートフォワーディング設定:135c9c6bc59340025271c600f28573f2&#34;&gt;ポートフォワーディング設定&lt;/h2&gt;

&lt;h3 id=&#34;ubuntuサーバを固定ipに設定:135c9c6bc59340025271c600f28573f2&#34;&gt;Ubuntuサーバを固定IPに設定&lt;/h3&gt;

&lt;p&gt;変更前の &lt;code&gt;/etc/network/interfaces&lt;/code&gt; は以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

source /etc/network/interfaces.d/*

# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto enp0s25
iface enp0s25 inet dhcp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;enp0s25&lt;/code&gt; の設定を &lt;a href=&#34;https://help.ubuntu.com/lts/serverguide/network-configuration.html#static-ip-addressing&#34;&gt;Static IP Address Assignment&lt;/a&gt; を参考に固定IPにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

source /etc/network/interfaces.d/*

# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto enp0s25
iface enp0s25 inet static
    address 192.168.0.201
    netmask 255.255.255.0
    gateway 192.168.0.1
    dns-nameservers 192.168.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;systemctl restart networking
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で反映しました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ip a&lt;/code&gt; で確認すると、変更前にDHCPで発行されたIPアドレス &lt;code&gt;192.168.0.9&lt;/code&gt; と上記で設定した固定アドレス &lt;code&gt;192.168.0.201&lt;/code&gt; の両方が表示されました。&lt;/p&gt;

&lt;p&gt;sshで作業していたのですが、以下のコマンドで消そうとしたらハマりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@express:/etc/network# ip a del 192.168.0.9 dev enp0s25
Warning: Executing wildcard deletion to stay compatible with old scripts.
         Explicitly specify the prefix length (192.168.0.9/32) to avoid this warning.
         This special behaviour is likely to disappear in further releases,
         fix your scripts!
packet_write_wait: Connection to 192.168.0.9: Broken pipe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンソールからログインして &lt;code&gt;ip a&lt;/code&gt; で確認すると &lt;code&gt;enp0s25&lt;/code&gt; の &lt;code&gt;inet&lt;/code&gt; の行は両方共消えていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl restart networking
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でネットワークを再起動して &lt;code&gt;ip a&lt;/code&gt; を実行すると &lt;code&gt;inet&lt;/code&gt; の行は固定IPの1行になりました。&lt;/p&gt;

&lt;p&gt;上で表示されたWarningによると、正しくは以下のようにするべきだったようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip a del 192.168.0.9/32 dev enp0s25
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;airmacユーティリティでポートフォワーディング設定:135c9c6bc59340025271c600f28573f2&#34;&gt;AirMacユーティリティでポートフォワーディング設定&lt;/h3&gt;

&lt;p&gt;Finderで「アプリケーション/ユーティリティ/AirMac ユーティリティ」を起動し、
Time Capsuleをクリックして開くポップアップの「編集」ボタンを押します。&lt;/p&gt;

&lt;p&gt;「ネットワーク」タブで「ルーターモード」を「DHCPとNAX」にしておきます。
先程固定IPを &lt;code&gt;192.168.0.201&lt;/code&gt; にしたのは「DHCPの範囲」が &lt;code&gt;192.168.0.2〜192.168.0.200&lt;/code&gt; なので範囲外の値を選んだからです。なお、この範囲は「ネットワークオプション…」ボタンを押して変更可能です。&lt;/p&gt;

&lt;p&gt;ポート設定の下の「+」ボタンを押すとポップアップが開くのでポートフォワーディングの設定を追加します。
ファイアウォール・エントリー・タイプは「IPv4ポートマッピング」固定で、ドロップダウンが disabled の状態になっていました。&lt;/p&gt;

&lt;p&gt;プライベートIPアドレスは上記で設定したExpress5800の固定IPを入力します。&lt;/p&gt;

&lt;p&gt;パブリックUDPポート、パブリックTCPポート、プライベートUDPポート、プライベートTCPポートにはフォワーデング元と先のポートを転送したい内容に応じて設定します。今回はTCPでsshのポートを指定しました。
なお、この記事では書いてないですが、パスワードアタック攻撃を回避するため事前にsshdは鍵認証のみ許可しパスワード認証は許可しない設定に変更しています。&lt;/p&gt;

&lt;p&gt;ちなみに&lt;a href=&#34;https://support.apple.com/kb/TA24799?locale=ja_JP&amp;amp;viewlocale=ja_JP&#34;&gt;ポートの範囲を指定して転送できるように AirMac Extreme (802.11n) ベースステーションを設定する&lt;/a&gt;によるとポートの入力欄は空白を開けずに &lt;code&gt;XXX-YYY&lt;/code&gt; のように書けば範囲も指定できるそうです。&lt;/p&gt;

&lt;p&gt;設定を追加したら「保存」ボタンを押してポップアップを閉じ、「アップデート」ボタンで反映します。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:135c9c6bc59340025271c600f28573f2&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;これでインターネットから自宅サーバにsshでログイン出来るようになって便利になりました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MacをPXEサーバにしてExpress5800/S70タイプRBにUbuntu16.04をインストールしてみた</title>
      <link>/blog/2016/05/01/install_ubuntu_xenial_with_pxe_boot/</link>
      <pubDate>Sun, 01 May 2016 22:36:19 +0900</pubDate>
      
      <guid>/blog/2016/05/01/install_ubuntu_xenial_with_pxe_boot/</guid>
      <description>

&lt;h2 id=&#34;背景:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;Goで書いたプログラムをMacBook Pro上で負荷試験をしていたら、ビーチボールカーソルが回りっぱなしになって大変でした。そういえば、負荷試験するときは極力余計なプロセスを止めて外界の影響を受けない状態でやるべきという話を思い出しました。&lt;/p&gt;

&lt;p&gt;そこで5年前に買ったけど、ここ2年は全く電源を入れていなかった自宅サーバを再び活用することにしました。起動してみるとCentOS 6.4が入っていました。せっかくなので人生初のPXEブートでUbuntu 16.04をインストールしてみました。ということで自分用メモです。&lt;/p&gt;

&lt;h2 id=&#34;サーバハードウェア構成:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;サーバハードウェア構成&lt;/h2&gt;

&lt;p&gt;ハードウェアの情報は有志のまとめWikiに詳しく載っています。
&lt;a href=&#34;http://pc.usy.jp/wiki/index.php?NEC%20Express5800%A1%BFS70%20%A5%BF%A5%A4%A5%D7RB&#34;&gt;NEC Express5800／S70 タイプRB - usyWiki&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;私のExpress5800の構成は以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Express5800/S70タイプRB&lt;/li&gt;
&lt;li&gt;CPU: Intel Pentium G6950 (2.8GHz)&lt;/li&gt;
&lt;li&gt;RAM: 16GBに増設済み&lt;/li&gt;
&lt;li&gt;SSD: Intel SSDSA2M160G2GC (換装済み)&lt;/li&gt;
&lt;li&gt;BIOS: Phoenix&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;macをpxeサーバにする:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;MacをPXEサーバにする&lt;/h2&gt;

&lt;p&gt;今まではこの方法を知らなくてPXEブートを諦めていたのですが、 &lt;a href=&#34;http://qiita.com/honeniq/items/d020368ea31b2f052a12&#34;&gt;MacをPXEサーバーにする - Qiita&lt;/a&gt; と &lt;a href=&#34;http://c-rtx.com/2015/09/21/macosx-pxe-server/&#34;&gt;MacOSXをPXEブートサーバーにしてLinuxのインストールに使う | C-RTX BLOG&lt;/a&gt; の記事のおかげで私にも出来ました。ありがとうございます！&lt;/p&gt;

&lt;h3 id=&#34;環境:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;環境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;MacBook Pro (Retina, Mid 2012)&lt;/li&gt;
&lt;li&gt;OS X El Capitan&lt;/li&gt;
&lt;li&gt;tftpd (OS X 標準)&lt;/li&gt;
&lt;li&gt;bootpd (OS X 標準)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;構成図:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;構成図&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;+--------+  Ethernet   +-------------+  Wi-Fi   +----------+ 
| Server | ----------&amp;gt; | MacBook Pro | -------&amp;gt; | Wi-Fi AP | -----&amp;gt; Internet
+--------+             +-------------+          +----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tftpdの起動とnetbootのファイル配置:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;tftpdの起動とnetbootのファイル配置&lt;/h3&gt;

&lt;p&gt;tftpd起動&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo launchctl load -w /System/Library/LaunchDaemons/tftp.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;osx上でのtftpについて私はよく知らないのですが、起動後&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo ps auxww | grep tftp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてもヒットしませんでした。&lt;/p&gt;

&lt;p&gt;以下のように実際に繋いでみて試すか、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tftp
tftp&amp;gt; quit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lsofで確認すれば大丈夫でした。後者は &lt;a href=&#34;http://qiita.com/tukiyo3/items/c9ca4bc6c62e78e80ae3&#34;&gt;Macでtftpサーバを起動 - Qiita&lt;/a&gt; を参考にしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lsof -i:69
COMMAND PID USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
launchd   1 root   42u  IPv6 0x4d07726546506a3f      0t0  UDP *:tftp
launchd   1 root   47u  IPv4 0x4d0772654650a3ff      0t0  UDP *:tftp
launchd   1 root   48u  IPv4 0x4d0772654650a3ff      0t0  UDP *:tftp
launchd   1 root   49u  IPv6 0x4d07726546506a3f      0t0  UDP *:tftp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ubuntuのセットアップが終わった後は以下のコマンドでtftpdを停止します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo launchctl unload /System/Library/LaunchDaemons/tftp.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/private/tftpboot/ 以下にUbuntuのネットワークインストールに必要なファイルを配置します。&lt;/p&gt;

&lt;p&gt;最初は &lt;a href=&#34;http://archive.ubuntu.com/ubuntu/dists/xenial/main/installer-amd64/current/images/netboot/&#34;&gt;http://archive.ubuntu.com/ubuntu/dists/xenial/main/installer-amd64/current/images/netboot/&lt;/a&gt; から pxelinux.0 をダウンロードして置いていたのですが、ブートしてみると他のファイルも必要なことがわかりました。&lt;/p&gt;

&lt;p&gt;試行錯誤した結果、 &lt;a href=&#34;https://www.ubuntulinux.jp/ubuntu/mirrors&#34;&gt;日本国内のダウンロードサイト | Ubuntu Japanese Team&lt;/a&gt; に載っているミラーの1つの &lt;a href=&#34;ftp://ftp.kddilabs.jp/Linux/packages/ubuntu/archive/dists/xenial/main/installer-amd64/current/images/netboot/&#34;&gt;ftp://ftp.kddilabs.jp/Linux/packages/ubuntu/archive/dists/xenial/main/installer-amd64/current/images/netboot/&lt;/a&gt; から netboot.tar.gz をダウンロードして展開すれば大丈夫でした。&lt;/p&gt;

&lt;h3 id=&#34;bootpd:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;bootpd&lt;/h3&gt;

&lt;p&gt;私がよくわかっていなくて、ここはちょっと苦労しました。まず、インターネット共有を切にした状態では /etc/bootpd.plist は以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
&amp;lt;dict&amp;gt;
	&amp;lt;key&amp;gt;bootp_enabled&amp;lt;/key&amp;gt;
	&amp;lt;false/&amp;gt;
	&amp;lt;key&amp;gt;detect_other_dhcp_server&amp;lt;/key&amp;gt;
	&amp;lt;false/&amp;gt;
	&amp;lt;key&amp;gt;dhcp_enabled&amp;lt;/key&amp;gt;
	&amp;lt;false/&amp;gt;
	&amp;lt;key&amp;gt;dhcp_ignore_client_identifier&amp;lt;/key&amp;gt;
	&amp;lt;true/&amp;gt;
	&amp;lt;key&amp;gt;use_server_config_for_dhcp_options&amp;lt;/key&amp;gt;
	&amp;lt;false/&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「システム環境設定」→「共有」と進んで「インターネット共有」のチェックボックスをオンにしようとしたのですが、画面中央に「接続を共有するためのポートを選択していないため、インターネット共有を開始できません。」と表示されていてオンにならない状態でした。&lt;/p&gt;

&lt;p&gt;試行錯誤した結果、MacをWi-FiでWi-Fi AP (Time Capsule)に繋ぎつつ&lt;a href=&#34;http://www.apple.com/jp/shop/product/MD463ZM/A/apple-thunderbolt%E3%82%AE%E3%82%AC%E3%83%93%E3%83%83%E3%83%88ethernet%E3%82%A2%E3%83%80%E3%83%97%E3%82%BF?afid=p238%7CsKTonmsKf-dc_mtid_18707vxu38484_pcrid_96182712077_&amp;amp;cid=aos-jp-kwg-pla-btb-product-MD463ZM/A&#34;&gt;Apple Thunderbolt - ギガビットEthernetアダプタ - Apple (日本)&lt;/a&gt;でも有線で繋いだ状態で、「共有する接続経路」で「Wi-Fi」を選び、「相手のコンピュータでのポート」で「Thunderbolt Ethernet」にチェックをつけた状態で「インターネット共有」にチェックをつけるとうまくいきました。&lt;/p&gt;

&lt;p&gt;この時はよく分かってなかったのですが、参考にした記事にもある通り、Express 5800のLANケーブルはMacに繋ぐのが正しいです。上記の構成図も正しい構成のほうを書いています。&lt;/p&gt;

&lt;p&gt;この状態で5秒ぐらいすると /etc/bootpd.plist が以下のように変更されました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
&amp;lt;dict&amp;gt;
	&amp;lt;key&amp;gt;Subnets&amp;lt;/key&amp;gt;
	&amp;lt;array&amp;gt;
		&amp;lt;dict&amp;gt;
			&amp;lt;key&amp;gt;_creator&amp;lt;/key&amp;gt;
			&amp;lt;string&amp;gt;com.apple.NetworkSharing&amp;lt;/string&amp;gt;
			&amp;lt;key&amp;gt;allocate&amp;lt;/key&amp;gt;
			&amp;lt;true/&amp;gt;
			&amp;lt;key&amp;gt;dhcp_domain_name_server&amp;lt;/key&amp;gt;
			&amp;lt;array&amp;gt;
				&amp;lt;string&amp;gt;192.168.2.1&amp;lt;/string&amp;gt;
			&amp;lt;/array&amp;gt;
			&amp;lt;key&amp;gt;dhcp_router&amp;lt;/key&amp;gt;
			&amp;lt;string&amp;gt;192.168.2.1&amp;lt;/string&amp;gt;
			&amp;lt;key&amp;gt;interface&amp;lt;/key&amp;gt;
			&amp;lt;string&amp;gt;bridge100&amp;lt;/string&amp;gt;
			&amp;lt;key&amp;gt;lease_max&amp;lt;/key&amp;gt;
			&amp;lt;integer&amp;gt;86400&amp;lt;/integer&amp;gt;
			&amp;lt;key&amp;gt;lease_min&amp;lt;/key&amp;gt;
			&amp;lt;integer&amp;gt;86400&amp;lt;/integer&amp;gt;
			&amp;lt;key&amp;gt;name&amp;lt;/key&amp;gt;
			&amp;lt;string&amp;gt;192.168.2/24&amp;lt;/string&amp;gt;
			&amp;lt;key&amp;gt;net_address&amp;lt;/key&amp;gt;
			&amp;lt;string&amp;gt;192.168.2.0&amp;lt;/string&amp;gt;
			&amp;lt;key&amp;gt;net_mask&amp;lt;/key&amp;gt;
			&amp;lt;string&amp;gt;255.255.255.0&amp;lt;/string&amp;gt;
			&amp;lt;key&amp;gt;net_range&amp;lt;/key&amp;gt;
			&amp;lt;array&amp;gt;
				&amp;lt;string&amp;gt;192.168.2.2&amp;lt;/string&amp;gt;
				&amp;lt;string&amp;gt;192.168.2.254&amp;lt;/string&amp;gt;
			&amp;lt;/array&amp;gt;
		&amp;lt;/dict&amp;gt;
	&amp;lt;/array&amp;gt;
	&amp;lt;key&amp;gt;bootp_enabled&amp;lt;/key&amp;gt;
	&amp;lt;false/&amp;gt;
	&amp;lt;key&amp;gt;detect_other_dhcp_server&amp;lt;/key&amp;gt;
	&amp;lt;array&amp;gt;
		&amp;lt;string&amp;gt;bridge100&amp;lt;/string&amp;gt;
	&amp;lt;/array&amp;gt;
	&amp;lt;key&amp;gt;dhcp_enabled&amp;lt;/key&amp;gt;
	&amp;lt;array&amp;gt;
		&amp;lt;string&amp;gt;bridge100&amp;lt;/string&amp;gt;
	&amp;lt;/array&amp;gt;
	&amp;lt;key&amp;gt;dhcp_ignore_client_identifier&amp;lt;/key&amp;gt;
	&amp;lt;true/&amp;gt;
	&amp;lt;key&amp;gt;ignore_allow_deny&amp;lt;/key&amp;gt;
	&amp;lt;array&amp;gt;
		&amp;lt;string&amp;gt;bridge100&amp;lt;/string&amp;gt;
	&amp;lt;/array&amp;gt;
	&amp;lt;key&amp;gt;use_server_config_for_dhcp_options&amp;lt;/key&amp;gt;
	&amp;lt;false/&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Subnets キーの &lt;code&gt;&amp;lt;/dict&amp;gt;&lt;/code&gt; の前に以下の設定を追加します。 &lt;code&gt;cHhlbGludXguMAA=&lt;/code&gt; は &lt;code&gt;pxelinux.0&lt;/code&gt; をBase64エンコーディングした値です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;		&amp;lt;key&amp;gt;dhcp_option_66&amp;lt;/key&amp;gt;
		&amp;lt;string&amp;gt;192.168.2.1&amp;lt;/string&amp;gt;
		&amp;lt;key&amp;gt;dhcp_option_67&amp;lt;/key&amp;gt;
		&amp;lt;data&amp;gt;cHhlbGludXguMAA=&amp;lt;/data&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで追記した内容を反映させる際に、「システム環境設定」の「共有」で「インターネット共有」をオフ→オンにすると設定ファイルが元に戻されてしまってダメでした。&lt;/p&gt;

&lt;p&gt;/etc/bootpd.plist を書き換えた後、以下のようにコマンドで bootpd を再起動すると大丈夫でした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo launchctl unload /System/Library/LaunchDaemons/bootps.plist
sudo launchctl load -w /System/Library/LaunchDaemons/bootps.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/etc/bootpub を作成・編集して固定アサインの設定もやっておきました。
が、今思えば私はこれはいらないかなと思います。後述の通り、ネットワークブートが終わったらLANケーブルを繋ぎ変えて、Wi-Fi APのDHCPを使ってIPアドレスを取得してその後のインストールを行うので。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# hostname      hwtype  hwaddr              ipaddr          bootfile
client1         1       01:02:03:04:05:06   192.168.2.11    pxelinux.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hwaddrの値は実際には事前に Express 5800 で &lt;code&gt;ip a&lt;/code&gt; で調べたMACアドレスに書き換えました。PXEブート中にもMACアドレスが表示されていたのでそれを見て書き換えるのでも良さそうです。&lt;/p&gt;

&lt;p&gt;Macで &lt;code&gt;ifconfig&lt;/code&gt; を実行すると &lt;code&gt;bridge100&lt;/code&gt; というのが作られていました。最初は &lt;code&gt;bridge0&lt;/code&gt; というのが作られたのですが、このときは接続を間違えていて ServerをWi-Fi APに有線でつなぎ、MacはWi-Fi APにWi-Fiと有線でつないでいました。&lt;/p&gt;

&lt;p&gt;その後上記の構成図の配線に修正したりしているうちに &lt;code&gt;bridge0&lt;/code&gt; とは別に &lt;code&gt;bridge100&lt;/code&gt; というのが作られていました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ifconfig&lt;/code&gt; の結果は以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ifconfig
...(snip)...
bridge100: flags=8863&amp;lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&amp;gt; mtu 1500
        options=3&amp;lt;RXCSUM,TXCSUM&amp;gt;
        ether ba:f6:b1:71:3c:64
        inet 192.168.2.1 netmask 0xffffff00 broadcast 192.168.2.255
        inet6 fe80::b8f6:b1ff:fe71:3c64%bridge100 prefixlen 64 scopeid 0x12
        Configuration:
                id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0
                maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200
                root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0
                ipfilter disabled flags 0x2
        member: en4 flags=3&amp;lt;LEARNING,DISCOVER&amp;gt;
                ifmaxaddr 0 port 17 priority 0 path cost 0
        nd6 options=1&amp;lt;PERFORMNUD&amp;gt;
        media: autoselect
        status: active
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;os-xのファイアウォールを切る必要はない:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;OS Xのファイアウォールを切る必要はない&lt;/h3&gt;

&lt;p&gt;初回はたぶんファイアウォールは切る必要があるだろうと思って切っておきました。&lt;/p&gt;

&lt;p&gt;「システム環境設定」→「セキュリティとプライバシー」→「ファイアウォール」タブ
左下の「変更するにはカギをクリックします」を押してパスワードを入力し、
「ファイアウォールを切にする」ボタンを押してオフにしました。&lt;/p&gt;

&lt;p&gt;Ubuntuのインストールが終わったら「ファイアウォールを入にする」ボタンを押して
オンに戻しておきます。&lt;/p&gt;

&lt;p&gt;が、2回目の検証でファイアウォールを切らなくても大丈夫なことがわかりました。&lt;/p&gt;

&lt;h3 id=&#34;phoenix-biosでpxeブートを有効にする:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;Phoenix BIOSでPXEブートを有効にする&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://changineer.info/server/server_hardware_management/server_hardware_bios.html#Phoenix_BIOS_8211BIOS_PXE_boot&#34;&gt;BIOS 設定方法&lt;/a&gt;を参考にしました。&lt;/p&gt;

&lt;p&gt;Express 5800を再起動し、起動時に[F2]キーを押してPhoenix BIOSの設定画面に入ります。カーソルキーの左右で[Boot]メニューを選びます。私はPXEブートを無効にしていたので、[PCI BEV]は画面下部の[Excluded from boot order:]のほうにありました。カーソルキーの上下で[PCI BEV]を選んでxキーを押し、画面上部の[Boot priority order:]のほうに移動します。
その後テンキーの+を押して[PCI BEV]を1番上に持ってきます。購入時に同梱されていた日本語キーボードを使っているのですがフルキーの-は効くのですが+ (Shift+;)は効きませんでした。&lt;/p&gt;

&lt;p&gt;なお、一旦有効にした後は[PCI BEV]の項目は[PCI BEV: IBA GE Slot 00C8 v1352]という表示になっていました。&lt;/p&gt;

&lt;p&gt;変更したら[F10]を押してBIOSの設定を保存して終了します。&lt;/p&gt;

&lt;p&gt;Ubuntuの設定が終わったら[PCI BEV]を[Excluded from boot order:]のほうに戻しておきます。&lt;/p&gt;

&lt;h3 id=&#34;pxeブートでubuntuのインストール:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;PXEブートでUbuntuのインストール&lt;/h3&gt;

&lt;p&gt;Express 5800を再起動すると、Ubuntuのインストーラが起動しました。
予めMacで &lt;code&gt;tail -f /var/log/system.log | grep DHCP&lt;/code&gt; を実行しておくとDHCPのログが確認できました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tail -f /var/log/system.log | grep DHCP
May  2 00:55:44 machostname bootpd[8589]: DHCP REQUEST [bridge100]: 1,01:02:03:04:05:06
May  2 00:56:37 machostname bootpd[8589]: DHCP DISCOVER [bridge100]: 1,01:02:03:04:05:06
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際には &lt;code&gt;machostname&lt;/code&gt; の部分はMacBook Proのホスト名が、 &lt;code&gt;01:02:03:04:05:06&lt;/code&gt; の部分は Express 5800 のネットワークカードのMACアドレスが出力されていますが、セキュリティ上伏せています。&lt;/p&gt;

&lt;p&gt;後は普通にUbuntuのインストーラに沿ってインストールすれば良いのですが、インストーラが起動した後はMacを経由せずに通信するほうが効率が良いので、Express 5800とMacをつないでいるLANケーブルをMacから外してWi-Fi APに繋ぎ直します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------+  Ethernet   +----------+ 
| Server | ----------&amp;gt; | Wi-Fi AP | -----&amp;gt; Internet
+--------+             +----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストーラの「Ubuntu アーカイブのミラーを選択」のところで「戻る」を選び、
「Ubuntu インストーラメインメニュー」で「ネットワークの設定」を選びます。
するとDHCPでIPアドレスを再取得してくれます。&lt;/p&gt;

&lt;h3 id=&#34;ubuntuのセットアップ:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;Ubuntuのセットアップ&lt;/h3&gt;

&lt;p&gt;以下はUbuntuのセットアップのメモです。&lt;/p&gt;

&lt;p&gt;ホームパーティションの暗号化とパーティショニングの暗号化LVMを選んでみました。
後者を選ぶと暗号化用のパスフレーズを求められるので設定します。設定するとサーバの起動時にパスフレーズの入力が必要になります。&lt;/p&gt;

&lt;p&gt;インストールするソフトウェアの選択では以下の3つを選びました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;標準システムユーティリティ&lt;/li&gt;
&lt;li&gt;OpenSSH server&lt;/li&gt;
&lt;li&gt;Basic Ubuntu server&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GRUBブートローダはSSDのデバイスにインストールしました。&lt;/p&gt;

&lt;p&gt;タイムゾーンは日本にし、システム時間はUTCにしました。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;PXEブート便利です！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go-daemonとgoのos.StartProcess()のコードを読んでみた</title>
      <link>/blog/2016/04/23/go-daemon-and-golang-os-startprocess-code-reading/</link>
      <pubDate>Sat, 23 Apr 2016 16:45:09 +0900</pubDate>
      
      <guid>/blog/2016/04/23/go-daemon-and-golang-os-startprocess-code-reading/</guid>
      <description>

&lt;h2 id=&#34;発端-goでデーモンを書くのは無理と思っていたら実は出来るらしい:2b5c8b3f2d099ab733ab91c60a7ca6a5&#34;&gt;発端: Goでデーモンを書くのは無理と思っていたら実は出来るらしい&lt;/h2&gt;

&lt;p&gt;Goでデーモンを書くのは無理と以前どこかで読んだ気がします。
ところが、Pythonで書かれた&lt;a href=&#34;https://github.com/graphite-project&#34;&gt;Graphite Project&lt;/a&gt;の&lt;a href=&#34;https://github.com/graphite-project/carbon&#34;&gt;carbon&lt;/a&gt;をGo言語で実装した&lt;a href=&#34;https://github.com/lomik/go-carbon&#34;&gt;lomik/go-carbon&lt;/a&gt;の Features に Run as daemon と書かれていました。どうやって実現しているのか気になって調べてみたのでメモです。&lt;/p&gt;

&lt;h2 id=&#34;go-carbonでデーモン化するための設定:2b5c8b3f2d099ab733ab91c60a7ca6a5&#34;&gt;go-carbonでデーモン化するための設定&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lomik/go-carbon#configuration&#34;&gt;Configuration&lt;/a&gt;に書いてありますが、設定ファイルの &lt;code&gt;[common]&lt;/code&gt; セクションの &lt;code&gt;user&lt;/code&gt; を指定して、起動オプションに &lt;code&gt;-daemon&lt;/code&gt; を指定すればデーモンとして起動します。&lt;/p&gt;

&lt;h2 id=&#34;コードリーディング:2b5c8b3f2d099ab733ab91c60a7ca6a5&#34;&gt;コードリーディング&lt;/h2&gt;

&lt;p&gt;デーモンとして起動するためのコードは以下のようになっています。
&lt;a href=&#34;https://github.com/lomik/go-carbon/blob/v0.7.1/carbon-agent.go#L103-L137&#34;&gt;https://github.com/lomik/go-carbon/blob/v0.7.1/carbon-agent.go#L103-L137&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if *isDaemon {
		runtime.LockOSThread()

		context := new(daemon.Context)
		if *pidfile != &amp;quot;&amp;quot; {
			context.PidFileName = *pidfile
			context.PidFilePerm = 0644
		}

		if runAsUser != nil {
			uid, err := strconv.ParseInt(runAsUser.Uid, 10, 0)
			if err != nil {
				log.Fatal(err)
			}

			gid, err := strconv.ParseInt(runAsUser.Gid, 10, 0)
			if err != nil {
				log.Fatal(err)
			}

			context.Credential = &amp;amp;syscall.Credential{
				Uid: uint32(uid),
				Gid: uint32(gid),
			}
		}

		child, _ := context.Reborn()

		if child != nil {
			return
		}
		defer context.Release()

		runtime.UnlockOSThread()
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;daemon.Context&lt;/code&gt; は &lt;a href=&#34;https://github.com/sevlyar/go-daemon&#34;&gt;github.com/sevlyar/go-daemon&lt;/a&gt;のfork版の &lt;a href=&#34;https://github.com/lomik/go-daemon&#34;&gt;github.com/lomik/go-daemon&lt;/a&gt;で定義されています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lomik/go-daemon/blob/205ceae1aeac90abdbcae9fca16ba44b407c598d/daemon_posix.go#L20-L61&#34;&gt;Contextの定義&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// A Context describes daemon context.
type Context struct {
	// If PidFileName is non-empty, parent process will try to create and lock
	// pid file with given name. Child process writes process id to file.
	PidFileName string
	// Permissions for new pid file.
	PidFilePerm os.FileMode

	// If LogFileName is non-empty, parent process will create file with given name
	// and will link to fd 2 (stderr) for child process.
	LogFileName string
	// Permissions for new log file.
	LogFilePerm os.FileMode

	// If WorkDir is non-empty, the child changes into the directory before
	// creating the process.
	WorkDir string
	// If Chroot is non-empty, the child changes root directory
	Chroot string

	// If Env is non-nil, it gives the environment variables for the
	// daemon-process in the form returned by os.Environ.
	// If it is nil, the result of os.Environ will be used.
	Env []string
	// If Args is non-nil, it gives the command-line args for the
	// daemon-process. If it is nil, the result of os.Args will be used
	// (without program name).
	Args []string

	// Credential holds user and group identities to be assumed by a daemon-process.
	Credential *syscall.Credential
	// If Umask is non-zero, the daemon-process call Umask() func with given value.
	Umask int

	// Struct contains only serializable public fields (!!!)
	abspath  string
	pidFile  *LockFile
	logFile  *os.File
	nullFile *os.File

	rpipe, wpipe *os.File
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go-carbonのcarbon-agent.goから呼び出していた &lt;code&gt;Context.Reborn()&lt;/code&gt; の定義はこちらです。
&lt;a href=&#34;https://github.com/lomik/go-daemon/blob/205ceae1aeac90abdbcae9fca16ba44b407c598d/daemon_posix.go#L63-L76&#34;&gt;Context.Reborn()&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Reborn runs second copy of current process in the given context.
// function executes separate parts of code in child process and parent process
// and provides demonization of child process. It look similar as the
// fork-daemonization, but goroutine-safe.
// In success returns *os.Process in parent process and nil in child process.
// Otherwise returns error.
func (d *Context) Reborn() (child *os.Process, err error) {
	if !WasReborn() {
		child, err = d.parent()
	} else {
		err = d.child()
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてここで読んでいる &lt;code&gt;Context.parent()&lt;/code&gt; の定義がこちらです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lomik/go-daemon/blob/205ceae1aeac90abdbcae9fca16ba44b407c598d/daemon_posix.go#L97-L130&#34;&gt;Context.parent()&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (d *Context) parent() (child *os.Process, err error) {
	if err = d.prepareEnv(); err != nil {
		return
	}

	defer d.closeFiles()
	if err = d.openFiles(); err != nil {
		return
	}

	attr := &amp;amp;os.ProcAttr{
		Dir:   d.WorkDir,
		Env:   d.Env,
		Files: d.files(),
		Sys: &amp;amp;syscall.SysProcAttr{
			//Chroot:     d.Chroot,
			Credential: d.Credential,
			Setsid:     true,
		},
	}

	if child, err = os.StartProcess(d.abspath, d.Args, attr); err != nil {
		if d.pidFile != nil {
			d.pidFile.Remove()
		}
		return
	}

	d.rpipe.Close()
	encoder := json.NewEncoder(d.wpipe)
	err = encoder.Encode(d)

	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Goの標準ライブラリで &lt;code&gt;os.StartProcess()&lt;/code&gt; というのがあったんですね。APIドキュメントはこちらです。&lt;a href=&#34;https://golang.org/pkg/os/#StartProcess&#34;&gt;os.StartProcess()&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/os/doc.go#L20-L29&#34;&gt;os.StartProcess()の実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// StartProcess starts a new process with the program, arguments and attributes
// specified by name, argv and attr.
//
// StartProcess is a low-level interface. The os/exec package provides
// higher-level interfaces.
//
// If there is an error, it will be of type *PathError.
func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error) {
	return startProcess(name, argv, attr)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/os/exec.go#L34-L56&#34;&gt;os.ProcAttrの定義&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ProcAttr holds the attributes that will be applied to a new process
// started by StartProcess.
type ProcAttr struct {
	// If Dir is non-empty, the child changes into the directory before
	// creating the process.
	Dir string
	// If Env is non-nil, it gives the environment variables for the
	// new process in the form returned by Environ.
	// If it is nil, the result of Environ will be used.
	Env []string
	// Files specifies the open files inherited by the new process.  The
	// first three entries correspond to standard input, standard output, and
	// standard error.  An implementation may support additional entries,
	// depending on the underlying operating system.  A nil entry corresponds
	// to that file being closed when the process starts.
	Files []*File

	// Operating system-specific process creation attributes.
	// Note that setting this field means that your program
	// may not execute properly or even compile on some
	// operating systems.
	Sys *syscall.SysProcAttr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここからはOS依存になりますが、Linuxの実装を見ていきます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_linux.go#L21-L41&#34;&gt;SysProcAttrのLinuxでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type SysProcAttr struct {
	Chroot      string         // Chroot.
	Credential  *Credential    // Credential.
	Ptrace      bool           // Enable tracing.
	Setsid      bool           // Create session.
	Setpgid     bool           // Set process group ID to Pgid, or, if Pgid == 0, to new pid.
	Setctty     bool           // Set controlling terminal to fd Ctty (only meaningful if Setsid is set)
	Noctty      bool           // Detach fd 0 from controlling terminal
	Ctty        int            // Controlling TTY fd
	Foreground  bool           // Place child&#39;s process group in foreground. (Implies Setpgid. Uses Ctty as fd of controlling TTY)
	Pgid        int            // Child&#39;s process group ID if Setpgid.
	Pdeathsig   Signal         // Signal that the process will get when its parent dies (Linux only)
	Cloneflags  uintptr        // Flags for clone calls (Linux only)
	UidMappings []SysProcIDMap // User ID mappings for user namespaces.
	GidMappings []SysProcIDMap // Group ID mappings for user namespaces.
	// GidMappingsEnableSetgroups enabling setgroups syscall.
	// If false, then setgroups syscall will be disabled for the child process.
	// This parameter is no-op if GidMappings == nil. Otherwise for unprivileged
	// users this should be set to false for mappings work.
	GidMappingsEnableSetgroups bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_unix.go#L112-L118&#34;&gt;syscall.CredentialのLinuxなどでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Credential holds user and group identities to be assumed
// by a child process started by StartProcess.
type Credential struct {
	Uid    uint32   // User ID.
	Gid    uint32   // Group ID.
	Groups []uint32 // Supplementary group IDs.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/os/exec_posix.go#L21-L50&#34;&gt;os.startProcess()のLinuxなどでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error) {
	// If there is no SysProcAttr (ie. no Chroot or changed
	// UID/GID), double-check existence of the directory we want
	// to chdir into.  We can make the error clearer this way.
	if attr != nil &amp;amp;&amp;amp; attr.Sys == nil &amp;amp;&amp;amp; attr.Dir != &amp;quot;&amp;quot; {
		if _, err := Stat(attr.Dir); err != nil {
			pe := err.(*PathError)
			pe.Op = &amp;quot;chdir&amp;quot;
			return nil, pe
		}
	}

	sysattr := &amp;amp;syscall.ProcAttr{
		Dir: attr.Dir,
		Env: attr.Env,
		Sys: attr.Sys,
	}
	if sysattr.Env == nil {
		sysattr.Env = Environ()
	}
	for _, f := range attr.Files {
		sysattr.Files = append(sysattr.Files, f.Fd())
	}

	pid, h, e := syscall.StartProcess(name, argv, sysattr)
	if e != nil {
		return nil, &amp;amp;PathError{&amp;quot;fork/exec&amp;quot;, name, e}
	}
	return newProcess(pid, h), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_unix.go#L120-L127&#34;&gt;os.ProcAttrのLinuxなどでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ProcAttr holds attributes that will be applied to a new process started
// by StartProcess.
type ProcAttr struct {
	Dir   string    // Current working directory.
	Env   []string  // Environment.
	Files []uintptr // File descriptors.
	Sys   *SysProcAttr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_unix.go#L238-L242&#34;&gt;syscall.StartProcess()のLinuxなどでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// StartProcess wraps ForkExec for package os.
func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle uintptr, err error) {
	pid, err = forkExec(argv0, argv, attr)
	return pid, 0, err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_unix.go#L132-L231&#34;&gt;syscall.forkExec()のLinuxなどでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error) {
	var p [2]int
	var n int
	var err1 Errno
	var wstatus WaitStatus

	if attr == nil {
		attr = &amp;amp;zeroProcAttr
	}
	sys := attr.Sys
	if sys == nil {
		sys = &amp;amp;zeroSysProcAttr
	}

	p[0] = -1
	p[1] = -1

	// Convert args to C form.
	argv0p, err := BytePtrFromString(argv0)
	if err != nil {
		return 0, err
	}
	argvp, err := SlicePtrFromStrings(argv)
	if err != nil {
		return 0, err
	}
	envvp, err := SlicePtrFromStrings(attr.Env)
	if err != nil {
		return 0, err
	}

	if (runtime.GOOS == &amp;quot;freebsd&amp;quot; || runtime.GOOS == &amp;quot;dragonfly&amp;quot;) &amp;amp;&amp;amp; len(argv[0]) &amp;gt; len(argv0) {
		argvp[0] = argv0p
	}

	var chroot *byte
	if sys.Chroot != &amp;quot;&amp;quot; {
		chroot, err = BytePtrFromString(sys.Chroot)
		if err != nil {
			return 0, err
		}
	}
	var dir *byte
	if attr.Dir != &amp;quot;&amp;quot; {
		dir, err = BytePtrFromString(attr.Dir)
		if err != nil {
			return 0, err
		}
	}

	// Acquire the fork lock so that no other threads
	// create new fds that are not yet close-on-exec
	// before we fork.
	ForkLock.Lock()

	// Allocate child status pipe close on exec.
	if err = forkExecPipe(p[:]); err != nil {
		goto error
	}

	// Kick off child.
	pid, err1 = forkAndExecInChild(argv0p, argvp, envvp, chroot, dir, attr, sys, p[1])
	if err1 != 0 {
		err = Errno(err1)
		goto error
	}
	ForkLock.Unlock()

	// Read child error status from pipe.
	Close(p[1])
	n, err = readlen(p[0], (*byte)(unsafe.Pointer(&amp;amp;err1)), int(unsafe.Sizeof(err1)))
	Close(p[0])
	if err != nil || n != 0 {
		if n == int(unsafe.Sizeof(err1)) {
			err = Errno(err1)
		}
		if err == nil {
			err = EPIPE
		}

		// Child failed; wait for it to exit, to make sure
		// the zombies don&#39;t accumulate.
		_, err1 := Wait4(pid, &amp;amp;wstatus, 0, nil)
		for err1 == EINTR {
			_, err1 = Wait4(pid, &amp;amp;wstatus, 0, nil)
		}
		return 0, err
	}

	// Read got EOF, so pipe closed on exec, so exec succeeded.
	return pid, nil

error:
	if p[0] &amp;gt;= 0 {
		Close(p[0])
		Close(p[1])
	}
	ForkLock.Unlock()
	return 0, err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いよいよ核心に迫ります。
&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_linux.go#L47-L325&#34;&gt;syscall.forkAndExecInChild()のLinuxでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Fork, dup fd onto 0..len(fd), and exec(argv0, argvv, envv) in child.
// If a dup or exec fails, write the errno error to pipe.
// (Pipe is close-on-exec so if exec succeeds, it will be closed.)
// In the child, this function must not acquire any locks, because
// they might have been locked at the time of the fork.  This means
// no rescheduling, no malloc calls, and no new stack segments.
// For the same reason compiler does not race instrument it.
// The calls to RawSyscall are okay because they are assembly
// functions that do not grow the stack.
//go:norace
func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr *ProcAttr, sys *SysProcAttr, pipe int) (pid int, err Errno) {
	// Declare all variables at top in case any
	// declarations require heap allocation (e.g., err1).
	var (
		r1     uintptr
		err1   Errno
		err2   Errno
		nextfd int
		i      int
		p      [2]int
	)

	// Record parent PID so child can test if it has died.
	ppid, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)

	// Guard against side effects of shuffling fds below.
	// Make sure that nextfd is beyond any currently open files so
	// that we can&#39;t run the risk of overwriting any of them.
	fd := make([]int, len(attr.Files))
	nextfd = len(attr.Files)
	for i, ufd := range attr.Files {
		if nextfd &amp;lt; int(ufd) {
			nextfd = int(ufd)
		}
		fd[i] = int(ufd)
	}
	nextfd++

	// Allocate another pipe for parent to child communication for
	// synchronizing writing of User ID/Group ID mappings.
	if sys.UidMappings != nil || sys.GidMappings != nil {
		if err := forkExecPipe(p[:]); err != nil {
			return 0, err.(Errno)
		}
	}

	// About to call fork.
	// No more allocation or calls of non-assembly functions.
	runtime_BeforeFork()
	r1, _, err1 = RawSyscall6(SYS_CLONE, uintptr(SIGCHLD)|sys.Cloneflags, 0, 0, 0, 0, 0)
	if err1 != 0 {
		runtime_AfterFork()
		return 0, err1
	}

	if r1 != 0 {
		// parent; return PID
		runtime_AfterFork()
		pid = int(r1)

		if sys.UidMappings != nil || sys.GidMappings != nil {
			Close(p[0])
			err := writeUidGidMappings(pid, sys)
			if err != nil {
				err2 = err.(Errno)
			}
			RawSyscall(SYS_WRITE, uintptr(p[1]), uintptr(unsafe.Pointer(&amp;amp;err2)), unsafe.Sizeof(err2))
			Close(p[1])
		}

		return pid, 0
	}

	// Fork succeeded, now in child.

	// Wait for User ID/Group ID mappings to be written.
	if sys.UidMappings != nil || sys.GidMappings != nil {
		if _, _, err1 = RawSyscall(SYS_CLOSE, uintptr(p[1]), 0, 0); err1 != 0 {
			goto childerror
		}
		r1, _, err1 = RawSyscall(SYS_READ, uintptr(p[0]), uintptr(unsafe.Pointer(&amp;amp;err2)), unsafe.Sizeof(err2))
		if err1 != 0 {
			goto childerror
		}
		if r1 != unsafe.Sizeof(err2) {
			err1 = EINVAL
			goto childerror
		}
		if err2 != 0 {
			err1 = err2
			goto childerror
		}
	}

	// Enable tracing if requested.
	if sys.Ptrace {
		_, _, err1 = RawSyscall(SYS_PTRACE, uintptr(PTRACE_TRACEME), 0, 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Session ID
	if sys.Setsid {
		_, _, err1 = RawSyscall(SYS_SETSID, 0, 0, 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Set process group
	if sys.Setpgid || sys.Foreground {
		// Place child in process group.
		_, _, err1 = RawSyscall(SYS_SETPGID, 0, uintptr(sys.Pgid), 0)
		if err1 != 0 {
			goto childerror
		}
	}

	if sys.Foreground {
		pgrp := int32(sys.Pgid)
		if pgrp == 0 {
			r1, _, err1 = RawSyscall(SYS_GETPID, 0, 0, 0)
			if err1 != 0 {
				goto childerror
			}

			pgrp = int32(r1)
		}

		// Place process group in foreground.
		_, _, err1 = RawSyscall(SYS_IOCTL, uintptr(sys.Ctty), uintptr(TIOCSPGRP), uintptr(unsafe.Pointer(&amp;amp;pgrp)))
		if err1 != 0 {
			goto childerror
		}
	}

	// Chroot
	if chroot != nil {
		_, _, err1 = RawSyscall(SYS_CHROOT, uintptr(unsafe.Pointer(chroot)), 0, 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// User and groups
	if cred := sys.Credential; cred != nil {
		ngroups := uintptr(len(cred.Groups))
		if ngroups &amp;gt; 0 {
			groups := unsafe.Pointer(&amp;amp;cred.Groups[0])
			_, _, err1 = RawSyscall(SYS_SETGROUPS, ngroups, uintptr(groups), 0)
			if err1 != 0 {
				goto childerror
			}
		}
		_, _, err1 = RawSyscall(SYS_SETGID, uintptr(cred.Gid), 0, 0)
		if err1 != 0 {
			goto childerror
		}
		_, _, err1 = RawSyscall(SYS_SETUID, uintptr(cred.Uid), 0, 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Chdir
	if dir != nil {
		_, _, err1 = RawSyscall(SYS_CHDIR, uintptr(unsafe.Pointer(dir)), 0, 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Parent death signal
	if sys.Pdeathsig != 0 {
		_, _, err1 = RawSyscall6(SYS_PRCTL, PR_SET_PDEATHSIG, uintptr(sys.Pdeathsig), 0, 0, 0, 0)
		if err1 != 0 {
			goto childerror
		}

		// Signal self if parent is already dead. This might cause a
		// duplicate signal in rare cases, but it won&#39;t matter when
		// using SIGKILL.
		r1, _, _ = RawSyscall(SYS_GETPPID, 0, 0, 0)
		if r1 != ppid {
			pid, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)
			_, _, err1 := RawSyscall(SYS_KILL, pid, uintptr(sys.Pdeathsig), 0)
			if err1 != 0 {
				goto childerror
			}
		}
	}

	// Pass 1: look for fd[i] &amp;lt; i and move those up above len(fd)
	// so that pass 2 won&#39;t stomp on an fd it needs later.
	if pipe &amp;lt; nextfd {
		_, _, err1 = RawSyscall(_SYS_dup, uintptr(pipe), uintptr(nextfd), 0)
		if err1 != 0 {
			goto childerror
		}
		RawSyscall(SYS_FCNTL, uintptr(nextfd), F_SETFD, FD_CLOEXEC)
		pipe = nextfd
		nextfd++
	}
	for i = 0; i &amp;lt; len(fd); i++ {
		if fd[i] &amp;gt;= 0 &amp;amp;&amp;amp; fd[i] &amp;lt; int(i) {
			_, _, err1 = RawSyscall(_SYS_dup, uintptr(fd[i]), uintptr(nextfd), 0)
			if err1 != 0 {
				goto childerror
			}
			RawSyscall(SYS_FCNTL, uintptr(nextfd), F_SETFD, FD_CLOEXEC)
			fd[i] = nextfd
			nextfd++
			if nextfd == pipe { // don&#39;t stomp on pipe
				nextfd++
			}
		}
	}

	// Pass 2: dup fd[i] down onto i.
	for i = 0; i &amp;lt; len(fd); i++ {
		if fd[i] == -1 {
			RawSyscall(SYS_CLOSE, uintptr(i), 0, 0)
			continue
		}
		if fd[i] == int(i) {
			// dup2(i, i) won&#39;t clear close-on-exec flag on Linux,
			// probably not elsewhere either.
			_, _, err1 = RawSyscall(SYS_FCNTL, uintptr(fd[i]), F_SETFD, 0)
			if err1 != 0 {
				goto childerror
			}
			continue
		}
		// The new fd is created NOT close-on-exec,
		// which is exactly what we want.
		_, _, err1 = RawSyscall(_SYS_dup, uintptr(fd[i]), uintptr(i), 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// By convention, we don&#39;t close-on-exec the fds we are
	// started with, so if len(fd) &amp;lt; 3, close 0, 1, 2 as needed.
	// Programs that know they inherit fds &amp;gt;= 3 will need
	// to set them close-on-exec.
	for i = len(fd); i &amp;lt; 3; i++ {
		RawSyscall(SYS_CLOSE, uintptr(i), 0, 0)
	}

	// Detach fd 0 from tty
	if sys.Noctty {
		_, _, err1 = RawSyscall(SYS_IOCTL, 0, uintptr(TIOCNOTTY), 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Set the controlling TTY to Ctty
	if sys.Setctty {
		_, _, err1 = RawSyscall(SYS_IOCTL, uintptr(sys.Ctty), uintptr(TIOCSCTTY), 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Time to exec.
	_, _, err1 = RawSyscall(SYS_EXECVE,
		uintptr(unsafe.Pointer(argv0)),
		uintptr(unsafe.Pointer(&amp;amp;argv[0])),
		uintptr(unsafe.Pointer(&amp;amp;envv[0])))

childerror:
	// send error code on pipe
	RawSyscall(SYS_WRITE, uintptr(pipe), uintptr(unsafe.Pointer(&amp;amp;err1)), unsafe.Sizeof(err1))
	for {
		RawSyscall(SYS_EXIT, 253, 0, 0)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linuxシステムコールの呼び出しのうち気になったところだけをピックアップします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/clone.2.html&#34;&gt;clone(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/setsid.2.html&#34;&gt;setsid(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/chroot.2.html&#34;&gt;chroot(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/setgid.2.html&#34;&gt;setgid(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/setuid.2.html&#34;&gt;setuid(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/chdir.2.html&#34;&gt;chdir(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://www.oreilly.co.jp/books/9784873115856/&#34;&gt;O&amp;rsquo;Reilly Japan - Linuxプログラミングインタフェース&lt;/a&gt;の「デーモン」の章を見ると、デーモン化の手順として7つの項目が上げられていますが、それら全てを行っているわけではないようです。&lt;/p&gt;

&lt;p&gt;例えばumaskのクリアは、上のコードをざっと見た感じではやってなさそうな感じです。&lt;/p&gt;

&lt;p&gt;また、ファイルディスクリプタ0, 1, 2をクローズはしていますが、 /dev/null をオープンはしていないようです。「通常は /dev/null をオープンする」と書いてあるので問題はなさそうです。&lt;/p&gt;

&lt;p&gt;端末デバイスからの切り離しは &lt;a href=&#34;http://man7.org/linux/man-pages/man2/ioctl.2.html&#34;&gt;ioctl(2) - Linux manual page&lt;/a&gt; に &lt;code&gt;TIOCNOTTY&lt;/code&gt; を指定して行っています。 &lt;code&gt;TIOCNOTTY&lt;/code&gt; については &lt;a href=&#34;http://man7.org/linux/man-pages/man4/tty.4.html&#34;&gt;tty(4) - Linux manual page&lt;/a&gt; に説明がありました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;syscall.SysProcAttr&lt;/code&gt; の &lt;code&gt;Setctty&lt;/code&gt; に &lt;code&gt;true&lt;/code&gt; を指定していた場合は、 &lt;a href=&#34;http://man7.org/linux/man-pages/man2/ioctl.2.html&#34;&gt;ioctl(2) - Linux manual page&lt;/a&gt; に &lt;code&gt;TIOCSCTTY&lt;/code&gt; を指定して制御端末の設定を行っています。 &lt;code&gt;TIOCSCTTY&lt;/code&gt; については &lt;a href=&#34;http://man7.org/linux/man-pages/man4/tty.4.html&#34;&gt;tty(4) - Linux manual page&lt;/a&gt; に説明がありました。&lt;/p&gt;

&lt;p&gt;ということで、&lt;a href=&#34;http://www.oreilly.co.jp/books/9784873115856/&#34;&gt;O&amp;rsquo;Reilly Japan - Linuxプログラミングインタフェース&lt;/a&gt;のデーモン化の手順の全てではないですが、かなりの部分は &lt;a href=&#34;https://golang.org/pkg/os/#StartProcess&#34;&gt;os - The Go Programming Language&lt;/a&gt; で実現できるということがわかりました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LXC 2.0でCentOS 7のコンテナを動かしてみた</title>
      <link>/blog/2016/04/19/run_centos7_containers_on_lxc2/</link>
      <pubDate>Tue, 19 Apr 2016 06:37:15 +0900</pubDate>
      
      <guid>/blog/2016/04/19/run_centos7_containers_on_lxc2/</guid>
      <description>

&lt;h2 id=&#34;はじめに:980fa4ed506550f6214721b9e91288b0&#34;&gt;はじめに&lt;/h2&gt;

&lt;h3 id=&#34;なぜdockerではなくlxcを使うのか:980fa4ed506550f6214721b9e91288b0&#34;&gt;なぜDockerではなくLXCを使うのか&lt;/h3&gt;

&lt;p&gt;コンテナと言えばDockerが有名です。Docker 1.9からネットワーク機能が大幅に良くなっていて、Docker Composeでコンテナを作成するとコンテナ名で名前解決できるようになっています。&lt;/p&gt;

&lt;p&gt;また公式のCentOS 7コンテナも良くなっていて、Dockerfileに &lt;code&gt;CMD [&amp;quot;/bin/init&amp;quot;]&lt;/code&gt; と書いておけば普通に systemd が起動するようになっています。&lt;/p&gt;

&lt;p&gt;そして &lt;code&gt;docker run&lt;/code&gt; に &lt;code&gt;--privileged&lt;/code&gt; オプションを付けて実行すれば実行時に &lt;code&gt;/etc/&lt;/code&gt; などの下のファイルを書き換えることも出来ます。&lt;/p&gt;

&lt;p&gt;しかしこのような使い方は&lt;a href=&#34;https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/&#34;&gt;Best practices for writing Dockerfiles&lt;/a&gt;と全く合いません。Dockerのベストプラクティスでは1コンテナ1プロセス、コンテナは最小限で使い捨て、ログやデータはコンテナ外部に保存するというスタンスなのです。&lt;/p&gt;

&lt;p&gt;一方、本番環境でDockerを使わずAnsibleでプロビジョニングする前提であれば、開発環境もAnsibleでプロビジョニングしたいところです。サーバが1台ならVagrant + VirtualBoxで良いのですが、複数台となると仮想マシンではメモリがたくさん必要になりますのでコンテナを使いたいところです。LXCなら従来のLinuxサーバと同じ感覚で利用できます。&lt;/p&gt;

&lt;h3 id=&#34;2016-05-07-追記:980fa4ed506550f6214721b9e91288b0&#34;&gt;2016-05-07 追記&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://hnakamur.github.io/blog/2016/05/07/tried-lxd-2.0-on-ubuntu-16.04/&#34;&gt;Ubuntu 16.04 LTSでLXD 2.0を試してみた&lt;/a&gt;を書きました。試してみて思ったのは、今から使うならLXC 2.0よりもLXD 2.0のほうが良いということです。この記事よりもこちらをお勧めします。&lt;/p&gt;

&lt;h3 id=&#34;ubuntu-14-04-16-04でlxc-2-0を使う:980fa4ed506550f6214721b9e91288b0&#34;&gt;Ubuntu 14.04/16.04でLXC 2.0を使う&lt;/h3&gt;

&lt;p&gt;LXCもコンテナなのでLinuxカーネルはホストとコンテナで同じものが使われます。CentOS 7単独の環境に近づけるにはホストもCentOS 7にしたいところです。が、現時点ではCentOS 7ではLXCはepelにバージョン1.0.8があるだけです。&lt;/p&gt;

&lt;p&gt;LXCはCanonical LtdがUbuntu上で開発しているので、Ubuntu上で使うほうがトラブルは少なくて済むと予想します。ということで、LinuxカーネルのバージョンがCentOS 7と違ってしまうというデメリットはあるのですが、ホストはUbuntuを使うことにします。&lt;/p&gt;

&lt;p&gt;Ubuntu 14.04のカーネルのほうがCentOS 7のカーネルより新しいので、アプリケーション開発に使う分にはLinuxカーネルのバージョン違いで影響が出ることはほぼ無いと思います。&lt;/p&gt;

&lt;p&gt;2016-04-06にLXC 2.0がリリースされました。&lt;a href=&#34;https://linuxcontainers.org/ja/lxc/news/&#34;&gt;Linux Containers - LXC - ニュース&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これは長期サポート(Long-term support; LTS) リリースです。ということで、今から使うなら2.0が良いと思います。&lt;/p&gt;

&lt;h2 id=&#34;lxcのセットアップ:980fa4ed506550f6214721b9e91288b0&#34;&gt;LXCのセットアップ&lt;/h2&gt;

&lt;p&gt;セットアップ用のスクリプトとVagrantfileを書きました。
&lt;a href=&#34;https://github.com/hnakamur/setup_lxc_on_vagrant&#34;&gt;hnakamur/setup_lxc_on_vagrant: Vagrantfile to set up LXC 2.x on Ubuntu 14.04 or 16.04&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これを使うと以下の手順でセットアップ出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp Vagrantfile.ubuntu1404 Vagrantfile
vagrant up &amp;amp;&amp;amp; vagrant reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;セットアップした後ネットワークの再起動が必要なので &lt;code&gt;vagrant up&lt;/code&gt; に加えて &lt;code&gt;vagrant reload&lt;/code&gt; を実行しています。&lt;/p&gt;

&lt;p&gt;セットアップは&lt;a href=&#34;https://github.com/hnakamur/setup_lxc_on_vagrant/blob/master/setup_lxc.sh&#34;&gt;setup_lxc.sh&lt;/a&gt;というシェルスクリプトになっているので設定内容が気になる方はこちらを参照してください。Vagrantを使わないUbuntu 14.04/16.04環境でもこのスクリプトを実行すればLXCをセットアップできます。&lt;/p&gt;

&lt;p&gt;Vagrantの仮想マシンの再起動が終わったら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で仮想マシンに入ってLXCを使います。&lt;/p&gt;

&lt;h2 id=&#34;コンテナ作成:980fa4ed506550f6214721b9e91288b0&#34;&gt;コンテナ作成&lt;/h2&gt;

&lt;p&gt;例えばweb01という名前のCentOS 7コンテナを作成するには以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc-create -n web01 -t download -- -d centos -r 7 -a amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-t&lt;/code&gt; はテンプレートを指定するオプションです。centosというテンプレートもあるのですが、それを使うとコンテナの挙動に問題があった (これについては今後別記事で書く予定です) ので、downloadテンプレートを使っています。&lt;/p&gt;

&lt;p&gt;初回はコンテナのイメージファイルをダウンロードするので時間がかかります。イメージファイルのサイズは約60MBとそれほど大きくもないのですが、私の環境では20分程度かかる場合もありました。&lt;/p&gt;

&lt;h2 id=&#34;コンテナ起動:980fa4ed506550f6214721b9e91288b0&#34;&gt;コンテナ起動&lt;/h2&gt;

&lt;p&gt;web01というコンテナを起動するには以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc-start -n web01
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;コンテナ一覧表示:980fa4ed506550f6214721b9e91288b0&#34;&gt;コンテナ一覧表示&lt;/h2&gt;

&lt;p&gt;以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc-ls -f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出力例はこんな感じになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~$ sudo lxc-ls -f
NAME    STATE   AUTOSTART GROUPS IPV4       IPV6
web01   RUNNING 0         -      10.0.3.244  -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動直後に実行するとIPv4の列が-になっています。数秒立ってから再度実行するとIPアドレスがDHCPで設定されて表示されます。&lt;/p&gt;

&lt;h3 id=&#34;コンテナ名でdnsを引けるか確認:980fa4ed506550f6214721b9e91288b0&#34;&gt;コンテナ名でDNSを引けるか確認&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~$ dig +short web01
10.0.3.244
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、LXCのdnsmasqで引けるようにするために&lt;a href=&#34;http://www.clear-code.com/blog/2014/7/30.html#.2Fetc.2Fresolve.conf.E3.81.ABnameserver.E3.82.92.E8.BF.BD.E5.8A.A0.E3.81.99.E3.82.8B&#34;&gt;LXCコンテナに名前でアクセスする方法 - ククログ(2014-07-30)&lt;/a&gt;を参考に &lt;a href=&#34;https://github.com/hnakamur/setup_lxc_on_vagrant/blob/8dac97e2c0dafe3bad275f733a549f7b03477cb4/setup_lxc.sh#L40-L43&#34;&gt;https://github.com/hnakamur/setup_lxc_on_vagrant/blob/8dac97e2c0dafe3bad275f733a549f7b03477cb4/setup_lxc.sh#L40-L43&lt;/a&gt; で設定しています。情報共有ありがとうございます！&lt;/p&gt;

&lt;h2 id=&#34;コンテナ内に入る:980fa4ed506550f6214721b9e91288b0&#34;&gt;コンテナ内に入る&lt;/h2&gt;

&lt;p&gt;web01というコンテナ内に入るには以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc-attach -n web01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナ内でシェルのプロンプトが表示されますので、好きなコマンドを実行してください。 &lt;code&gt;exit&lt;/code&gt; で抜けます。実行例を以下に示します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~$ sudo lxc-attach -n web01
bash-4.2# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
9: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether fe:74:45:50:85:27 brd ff:ff:ff:ff:ff:ff
    inet 10.0.3.11/24 brd 10.0.3.255 scope global dynamic eth0
       valid_lft 3219sec preferred_lft 3219sec
    inet6 fe80::fc74:45ff:fe50:8527/64 scope link
       valid_lft forever preferred_lft forever
bash-4.2# exitvagrant@vagrant-ubuntu-trusty-64:~$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;↑exitの後returnキーを押しても改行されませんでした。&lt;/p&gt;

&lt;h2 id=&#34;コンテナを停止する:980fa4ed506550f6214721b9e91288b0&#34;&gt;コンテナを停止する&lt;/h2&gt;

&lt;p&gt;以下のようにして停止します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lxc-stop -n web01
vagrant@vagrant-ubuntu-trusty-64:~$ sudo lxc-ls -f
NAME    STATE   AUTOSTART GROUPS IPV4       IPV6
web01   STOPPED 0         -      -          -
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lxc-stopですぐに停止するには以下の設定が必要:980fa4ed506550f6214721b9e91288b0&#34;&gt;lxc-stopですぐに停止するには以下の設定が必要&lt;/h3&gt;

&lt;p&gt;downloadテンプレートで作成したCentOS 7コンテナはそのままだと、lxc-stopで停止するのに1分間待たされます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lists.linuxcontainers.org/pipermail/lxc-users/2014-February/006304.html&#34;&gt;[lxc-users] lxc-stop doesn&amp;rsquo;t stop centos, waits for the timeout&lt;/a&gt;を参考に、コンテナ内で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ln -s /usr/lib/systemd/system/halt.target /etc/systemd/system/sigpwr.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行すれば、lxc-stopですぐに停止できました。&lt;/p&gt;

&lt;h2 id=&#34;コンテナを削除する:980fa4ed506550f6214721b9e91288b0&#34;&gt;コンテナを削除する&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~$ sudo lxc-destroy -n web01
Destroyed container web01
vagrant@vagrant-ubuntu-trusty-64:~$ sudo lxc-ls -f
vagrant@vagrant-ubuntu-trusty-64:~$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ホストでlxcサービス起動時にコンテナを自動起動する:980fa4ed506550f6214721b9e91288b0&#34;&gt;ホストでLXCサービス起動時にコンテナを自動起動する&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;/var/lib/lxc/${コンテナ名}/config&lt;/code&gt; ファイルに以下の行を追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc.start.auto = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;複数コンテナ間の依存関係を指定して起動の順序を制御するなど高度な指定については加藤泰文さんの&lt;a href=&#34;http://gihyo.jp/admin/serial/01/linux_containers/0025?page=1&#34;&gt;第25回　LXCの構築・活用 [11] ─lxc-autostartコマンドによるコンテナの自動起動：LXCで学ぶコンテナ入門 －軽量仮想化環境を実現する技術｜gihyo.jp … 技術評論社&lt;/a&gt;の記事をご参照ください。私は複雑な指定は試してないです。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:980fa4ed506550f6214721b9e91288b0&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;Ubuntu 14.04上でLXC 2.0をセットアップして使う手順についてまとめました。&lt;/p&gt;

&lt;p&gt;コンテナの作成とプロビジョニングについてはAnsible playbookのサンプルも作ったので今後別記事で書く予定です。また、この記事では触れなかったハマりネタもいくつかあったのでそれも今度書こうと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「サーバ/インフラエンジニア養成読本 DevOps編」の献本を頂きました</title>
      <link>/blog/2016/02/22/software_design_plus_devops_review/</link>
      <pubDate>Mon, 22 Feb 2016 21:30:52 +0900</pubDate>
      
      <guid>/blog/2016/02/22/software_design_plus_devops_review/</guid>
      <description>

&lt;p&gt;「最速攻略！ Ansible 2によるサーバ構築」という特集を書かれた新原 雅司さんから「サーバ/インフラエンジニア養成読本 DevOps編」の献本を頂きました。ありがとうございます！&lt;/p&gt;

&lt;h2 id=&#34;特集1-最速攻略-ansible-2によるサーバ構築:cb20c5254d0c2ec81599ae79716d5283&#34;&gt;特集1 「最速攻略！ Ansible 2によるサーバ構築」&lt;/h2&gt;

&lt;p&gt;私はレビュアとして参加させていただきました。「最速攻略！ Ansible 2によるサーバ構築」の特集は 50 ページの充実した内容となっています。Ansible 2を特集記事で扱うのは紙媒体の書籍としては、おそらく世界初とのことです。&lt;/p&gt;

&lt;p&gt;特集は4つの章から構成されています。&lt;/p&gt;

&lt;p&gt;「第1章 Ansibleの基本」ではAnsibleの概要や動作環境、インストール方法、基本的な使い方が説明されています。&lt;/p&gt;

&lt;p&gt;「第2章 Playbookの基本」では YAML の基本文法から始まって Ansible のモジュールを実行する記法について説明されています。&lt;/p&gt;

&lt;p&gt;「第3章 Ansible [実践]」では LAPP (Linux + Apache + PHP + PostgreSQL) サーバを構築して、デプロイも行うという実践的な内容が説明されています。PHPのバージョンは 7.0 が使われていますので、PHP 7.0 の環境を構築するのに参考になるでしょう。&lt;/p&gt;

&lt;p&gt;「第4章 Playbook ベストプラクティス」では、 playbook が大きくなってきた時のために複数のディレクトリに分割する方法や、 &lt;code&gt;ansible-galaxy&lt;/code&gt;, &lt;code&gt;ansible-vault&lt;/code&gt; コマンドについて説明されています。&lt;/p&gt;

&lt;p&gt;また、コラムが2つあって、1つはCapistranoスタイルのデプロイをAnsibleで行うためのAnsistranoというロールについて紹介しています。もう1つはAnsible 2の新機能について紹介しています。&lt;/p&gt;

&lt;h2 id=&#34;巻頭企画-devopsとinfrastructure-as-codeの概要:cb20c5254d0c2ec81599ae79716d5283&#34;&gt;巻頭企画 「DevOpsとInfrastructure as Codeの概要」&lt;/h2&gt;

&lt;p&gt;Ansibleの特集以外ですが、巻頭企画では吉羽 龍太郎さんの「DevOpsとInfrastructure as Codeの概要」という記事でDevOpsとInfrastructure as Codeについてそれぞれ1章を使って全体像と導入のポイントが説明されています。背景から入って、導入にあたって見当すべき事項や導入する際の進め方の順序が丁寧に解説されていて勉強になります。&lt;/p&gt;

&lt;h2 id=&#34;特集2-circleciによる継続的インテグレーション入門:cb20c5254d0c2ec81599ae79716d5283&#34;&gt;特集2 「CircleCIによる継続的インテグレーション入門」&lt;/h2&gt;

&lt;p&gt;特集2は前田 章さんの「CircleCIによる継続的インテグレーション入門」です。 CircleCI の入門から始まって継続的インテグレーションそして継続的デリバリーを行うまでを具体的な手順とともに説明しています。&lt;/p&gt;

&lt;p&gt;筆者の前田さんが所属するKaizen Platform, Inc.で実際に行っている継続的デリバリーとプロビジョニングの方法を例に説明されていて、使っているブランチモデルも紹介されていますので、参考になります。&lt;/p&gt;

&lt;h2 id=&#34;特集3-dockerによる仮想環境構築とkubernetesによるdockerクラスタ管理:cb20c5254d0c2ec81599ae79716d5283&#34;&gt;特集3 「Dockerによる仮想環境構築とKubernetesによるDockerクラスタ管理」&lt;/h2&gt;

&lt;p&gt;特集3は馬場俊彰さんの「Dockerによる仮想環境構築とKubernetesによるDockerクラスタ管理」です。Dockerの基本の説明から始まって、基本的な使い方とホストのボリュームやポートをバインドするような応用的な使い方を説明しています。&lt;/p&gt;

&lt;p&gt;その後、クラスタ管理ツールの概要を説明し、そのうちの1つであるKubernetesについての概要説明が続きます。次に、RedisクラスターをKubernetesを使って構築するという題材で実際に動かしてみる手順が説明されています。その後、Kubernetesで稼働している各プログラムについて解説されていて、理解を深めることが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:cb20c5254d0c2ec81599ae79716d5283&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;「サーバ/インフラエンジニア養成読本 DevOps編」はDevOpsやInfrastructure as Codeの概要について学び、Ansible 2、CircleCI、Docker、Kubernetesについて実際に動かしつつ理解を深めることが出来るというお勧めの一冊となっています。&lt;/p&gt;

&lt;p&gt;新原さんの&lt;a href=&#34;http://shin1x1.hatenablog.com/entry/gihyo-devops-ansible2&#34;&gt;「サーバ/インフラエンジニア養成読本 DevOps編」にて Ansible 2 について書きました。 - Shin x Hatena Blog&lt;/a&gt; の記事に目次がありますので、そちらもご覧の上、ぜひ購入をご検討ください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache Traffic Server を GDB で動かす</title>
      <link>/blog/2016/02/12/run-apache-traffic-server-with-gdb/</link>
      <pubDate>Fri, 12 Feb 2016 00:02:11 +0900</pubDate>
      
      <guid>/blog/2016/02/12/run-apache-traffic-server-with-gdb/</guid>
      <description>

&lt;h2 id=&#34;はじめに:16844cae3677ced667c896b951ca0019&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://gihyo.jp/magazine/wdpress/archive/2012/vol69&#34;&gt;WEB+DB PRESS Vol.69｜技術評論社&lt;/a&gt; にあった &lt;a href=&#34;http://dev.ariel-networks.com/wp/archives/author/inoue&#34;&gt;アリエル・ネットワーク㈱の井上さん&lt;/a&gt;による「大規模コードリーディング」の特集を読んで、静的解析 (コードを読んで理解する手法) と動的解析 (実行時の動作を予測しながら構造を理解する方法) を行ったり来たり繰り返すのが良いと理解しました。&lt;/p&gt;

&lt;p&gt;というわけで、 &lt;a href=&#34;/blog/blog/2016/02/11/apache-traffic-server-code-reading/&#34;&gt;Apache Traffic Server のコードリーディング · hnakamur&amp;rsquo;s blog at github&lt;/a&gt; でコードを読みつつ、デバッガ上で動かしてみました。手順は整理してないですが、とりあえず自分向けメモです。&lt;/p&gt;

&lt;h2 id=&#34;試した環境:16844cae3677ced667c896b951ca0019&#34;&gt;試した環境&lt;/h2&gt;

&lt;p&gt;試した環境は &lt;a href=&#34;https://github.com/hnakamur/trafficserver-ansible-playbook&#34;&gt;hnakamur/trafficserver-ansible-playbook&lt;/a&gt; で構築したものです。Apache Traffic Server のバージョンは 6.1.1 です。&lt;/p&gt;

&lt;h2 id=&#34;事前準備:16844cae3677ced667c896b951ca0019&#34;&gt;事前準備&lt;/h2&gt;

&lt;h3 id=&#34;debuginfo-パッケージのインストール:16844cae3677ced667c896b951ca0019&#34;&gt;debuginfo パッケージのインストール&lt;/h3&gt;

&lt;p&gt;gdb でプログラムを実行するにはプログラムのパッケージと依存パッケージの debuginfo が必要です。これは、たぶん以下のコマンドでインストールできます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install -y yum-utils
sudo debuginfo-install -y trafficserver
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;debuginfo-パッケージのインストールの試行錯誤メモ:16844cae3677ced667c896b951ca0019&#34;&gt;debuginfo パッケージのインストールの試行錯誤メモ&lt;/h3&gt;

&lt;p&gt;この項は上のコマンドを知る前に試した手順のメモです。&lt;/p&gt;

&lt;p&gt;まずデバッグ情報のパッケージが必要だと思ったので、以下のコマンドでインストールしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install -y trafficserver-debuginfo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl start trafficserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行して trafficserver のサービスを起動した状態で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ps auxww | grep traffic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行して &lt;code&gt;traffic_server&lt;/code&gt; のコマンドラインをメモします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/bin/traffic_server -M --bind_stdout /var/log/trafficserver/traffic.out --bind_stderr /var/log/trafficserver/traffic.out --httpport 80:fd=9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていました。 &lt;a href=&#34;https://docs.trafficserver.apache.org/en/latest/appendices/command-line/traffic_server.en.html&#34;&gt;traffic_server — Apache Traffic Server 6.2.0 documentation&lt;/a&gt; を見ると &lt;code&gt;-M&lt;/code&gt; は &lt;code&gt;--remote_management&lt;/code&gt; のショートオプションです。 &lt;code&gt;systemctl start trafficserver&lt;/code&gt; でサービスを起動すると &lt;code&gt;traffic_cop&lt;/code&gt; と &lt;code&gt;traffic_manager&lt;/code&gt; 経由で &lt;code&gt;traffic_server&lt;/code&gt; が起動するのですが、その場合に必要になるオプションのようです。 gdb で実行するときは &lt;code&gt;-M&lt;/code&gt; は外します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl stop trafficserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でサービスを停止します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb /usr/bin/traffic_server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で gdb を起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;break HttpSM::set_next_state
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとブレークポイントを設定します。ブレークポイントは Apache Traffic Server のソースコードを読んで、自分が止めたい場所にお好みで設定します。&lt;/p&gt;

&lt;p&gt;gdb のプロンプトで以下のように入力して、 Apache Traffic Server を実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;run --bind_stdout /var/log/trafficserver/traffic.out --bind_stderr /var/log/trafficserver/traffic.out --httpport 80:fd=9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ところがdebuginfoが足りず、以下のようなエラーになってしまいました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Inferior 1 (process 17590) exited with code 01]
Missing separate debuginfos, use: debuginfo-install glibc-2.17-106.el7_2.1.x86_64 hwloc-libs-1.7-5.el7.x86_64 keyutils-libs-1.5.8-3.el7.x86_64 krb5-libs-1.13.2-10.el7.x86_64 libcom_err-1.42.9-7.el7.x86_64 libgcc-4.8.5-4.el7.x86_64 libpciaccess-0.13.4-2.el7.x86_64 libselinux-2.2.2-6.el7.x86_64 libstdc++-4.8.5-4.el7.x86_64 libxml2-2.9.1-6.el7_2.2.x86_64 nss-softokn-freebl-3.16.2.3-13.el7_1.x86_64 numactl-libs-2.0.9-5.el7_1.x86_64 openssl-libs-1.0.1e-51.el7_2.2.x86_64 pcre-8.32-15.el7.x86_64 tcl-8.5.13-8.el7.x86_64 xz-libs-5.1.2-12alpha.el7.x86_64 zlib-1.2.7-15.el7.x86_64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;use:&lt;/code&gt; の後をコピペして実行して途中で (y/n) で聞かれたら y を押すと、必要な debuginfo をイントール出来ました。&lt;/p&gt;

&lt;p&gt;調べてみると、最初から以下のコマンドを実行しておけば依存するライブラリの debuginfo もインストールできるようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo debuginfo-install -y trafficserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、 &lt;code&gt;debuginfo-install&lt;/code&gt; コマンドは &lt;code&gt;yum-utils&lt;/code&gt; パッケージに入っているので予めインストールしておきます。&lt;/p&gt;

&lt;h2 id=&#34;実行例:16844cae3677ced667c896b951ca0019&#34;&gt;実行例&lt;/h2&gt;

&lt;p&gt;まず、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb /usr/bin/traffic_server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で gdb を起動し &lt;code&gt;HttpSM::set_next_state&lt;/code&gt; にブレークポイントを設定して traffic_server を実行しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# gdb /usr/bin/traffic_server
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-80.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &amp;quot;show copying&amp;quot;
and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;x86_64-redhat-linux-gnu&amp;quot;.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;...
Reading symbols from /usr/bin/traffic_server...Reading symbols from /usr/lib/debug/usr/bin/traffic_server.debug...done.
done.
(gdb) break HttpSM::set_next_state
Breakpoint 1 at 0x151510: file HttpSM.cc, line 6940.
(gdb) run --bind_stdout /var/log/trafficserver/traffic.out --bind_stderr /var/log/trafficserver/traffic.out --httpport 80:fd=9
Starting program: /usr/bin/traffic_server --bind_stdout /var/log/trafficserver/traffic.out --bind_stderr /var/log/trafficserver/traffic.out --httpport 80:fd=9
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
traffic_server: using root directory &#39;/usr&#39;
[New Thread 0x7ffff3bde700 (LWP 19929)]
[New Thread 0x7ffff1249700 (LWP 19930)]
[New Thread 0x7ffff1047700 (LWP 19931)]
[New Thread 0x7ffff0a3c700 (LWP 19932)]
[New Thread 0x7fffebefe700 (LWP 19933)]
[New Thread 0x7fffebcfc700 (LWP 19934)]
[New Thread 0x7fffebafa700 (LWP 19935)]
[New Thread 0x7fffeb8f8700 (LWP 19936)]
[New Thread 0x7fffeb6f6700 (LWP 19937)]
[New Thread 0x7fffeb4f4700 (LWP 19938)]
[New Thread 0x7fffeb2f2700 (LWP 19939)]
[New Thread 0x7fffeb0f0700 (LWP 19940)]
[New Thread 0x7fffeac5d700 (LWP 19941)]
[New Thread 0x7fffea95a700 (LWP 19942)]
[New Thread 0x7fffea859700 (LWP 19943)]
[New Thread 0x7fffea657700 (LWP 19944)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで別の端末で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sv http://192.168.33.131/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行しました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HttpSM&lt;/code&gt; というクラス名は &lt;code&gt;Http State Machine&lt;/code&gt; の略と思われます。 HTTP を処理する状態遷移マシンになっています。以下のセッションでは HttpSM クラスの t_state メンバ変数の next_action を表示して、状態の遷移を確認してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) where
#0  HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
#1  0x000055555569aa96 in HttpSM::state_read_client_request_header (this=0x7fffea0d0080, event=&amp;lt;optimized out&amp;gt;, data=&amp;lt;optimized out&amp;gt;)
    at HttpSM.cc:771
#2  0x00005555556a7600 in HttpSM::main_handler (this=0x7fffea0d0080, event=100, data=0x7fffe0017e38) at HttpSM.cc:2561
#3  0x00005555556a0f13 in HttpSM::state_api_callout (this=0x7fffea0d0080, event=&amp;lt;optimized out&amp;gt;, data=&amp;lt;optimized out&amp;gt;)
    at HttpSM.cc:1464
#4  0x00005555556a19a8 in do_api_callout (this=0x7fffea0d0080) at HttpSM.cc:391
#5  HttpSM::state_add_to_list (this=0x7fffea0d0080, event=&amp;lt;optimized out&amp;gt;) at HttpSM.cc:418
#6  0x00005555556a719b in HttpSM::attach_client_session (this=0x7fffea0d0080, client_vc=0x555556592d40, buffer_reader=0x555556575ea8)
    at HttpSM.cc:544
#7  0x0000555555682ec5 in HttpClientSession::new_transaction (this=0x555556592d40) at HttpClientSession.cc:141
#8  0x000055555565e901 in ProxyClientSession::state_api_callout (this=0x555556592d40, event=&amp;lt;optimized out&amp;gt;)
    at ProxyClientSession.cc:123
#9  0x00005555556824b2 in HttpClientSession::new_connection (this=0x555556592d40, new_vc=&amp;lt;optimized out&amp;gt;, iobuf=&amp;lt;optimized out&amp;gt;,
    reader=&amp;lt;optimized out&amp;gt;, backdoor=&amp;lt;optimized out&amp;gt;) at HttpClientSession.cc:220
#10 0x000055555567d969 in HttpSessionAccept::accept (this=0x55555621cab0, netvc=0x7fffe0017d20, iobuf=&amp;lt;optimized out&amp;gt;,
    reader=0x555556575ea8) at HttpSessionAccept.cc:74
#11 0x000055555565e683 in ProtocolProbeTrampoline::ioCompletionEvent (this=0x5555563bc880, event=&amp;lt;optimized out&amp;gt;,
    edata=&amp;lt;optimized out&amp;gt;) at ProtocolProbeSessionAccept.cc:123
#12 0x000055555581de76 in handleEvent (data=0x7fffe0017e38, event=100, this=&amp;lt;optimized out&amp;gt;)
    at ../../iocore/eventsystem/I_Continuation.h:153
#13 read_signal_and_update (vc=0x7fffe0017d20, event=100) at UnixNetVConnection.cc:150
#14 read_from_net (nh=0x7ffff31e0b90, vc=0x7fffe0017d20, thread=0x7ffff31dd010) at UnixNetVConnection.cc:390
#15 0x000055555580e6b0 in NetHandler::mainNetEvent (this=0x7ffff31e0b90, event=&amp;lt;optimized out&amp;gt;, e=&amp;lt;optimized out&amp;gt;) at UnixNet.cc:518
#16 0x000055555583c2d0 in handleEvent (data=0x555556172dc0, event=5, this=&amp;lt;optimized out&amp;gt;) at I_Continuation.h:153
#17 EThread::process_event (this=this@entry=0x7ffff31dd010, e=0x555556172dc0, calling_code=calling_code@entry=5) at UnixEThread.cc:128
#18 0x000055555583cdab in EThread::execute (this=0x7ffff31dd010) at UnixEThread.cc:252
#19 0x000055555560af60 in main (argv=&amp;lt;optimized out&amp;gt;) at Main.cc:1918
(gdb) p t_state.next_action
$1 = HttpTransact::SM_ACTION_API_READ_REQUEST_HDR
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$2 = HttpTransact::SM_ACTION_API_PRE_REMAP
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$3 = HttpTransact::SM_ACTION_REMAP_REQUEST
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$4 = HttpTransact::SM_ACTION_API_POST_REMAP
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$5 = HttpTransact::SM_ACTION_CACHE_LOOKUP
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$6 = HttpTransact::SM_ACTION_API_READ_CACHE_HDR
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$7 = HttpTransact::SM_ACTION_API_CACHE_LOOKUP_COMPLETE
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$8 = HttpTransact::SM_ACTION_DNS_LOOKUP
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$9 = HttpTransact::SM_ACTION_API_OS_DNS
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$10 = HttpTransact::SM_ACTION_CACHE_ISSUE_WRITE
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$11 = HttpTransact::SM_ACTION_ORIGIN_SERVER_OPEN
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$12 = HttpTransact::SM_ACTION_SERVER_READ
(gdb) c
Continuing.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gdb-でよく使うコマンドのメモ:16844cae3677ced667c896b951ca0019&#34;&gt;gdb でよく使うコマンドのメモ&lt;/h2&gt;

&lt;p&gt;ブレークポイント一覧表示あたりをよく忘れるのでメモ。ググってみると &lt;a href=&#34;http://wombat.cc.tsukuba.ac.jp/~furuse/jikken/text-07/text-07.html&#34;&gt;マイクロデータベース管理システムの実装&lt;/a&gt; にわかりやすくまとまっていました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;b: break。ブレークポイント設定。b の後に「クラス名::メソッド名」、「関数名」、「ファイル名:行番号」のように止めたい箇所を指定します。&lt;/li&gt;
&lt;li&gt;i b: info breakpointsの略。ブレークポイント一覧表示。&lt;/li&gt;
&lt;li&gt;del [ブレークポイント番号]。ブレークポイント削除。番号を省略すると全て削除。&lt;/li&gt;
&lt;li&gt;where: ブレークポイントで止まったときにコールスタックを表示します。&lt;/li&gt;
&lt;li&gt;p: print。ブレークポイントで止まったときに変数の値を表示します。&lt;/li&gt;
&lt;li&gt;c: continue。実行継続。ブレークポイントを設定していればそこで止まります。&lt;/li&gt;
&lt;li&gt;n: next。ステップオーバー。関数呼び出しの際には中に入らずにステップ実行します。&lt;/li&gt;
&lt;li&gt;s: step。ステップイン。関数呼び出しの際にの中に入ってステップ実行します。&lt;/li&gt;
&lt;li&gt;q: quit。実行終了。まだ実行中だと &lt;code&gt;Quit anyway? (y or n)&lt;/code&gt; と聞かれるので y を押して終了します。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ブレークポイントで止まっていない場合も、実行中に Ctrl-C で gdb のプロンプトが出るので、そこで上記のコマンドを実行できます。その後 c で実行再開できます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache Traffic Server のコードリーディング</title>
      <link>/blog/2016/02/11/apache-traffic-server-code-reading/</link>
      <pubDate>Thu, 11 Feb 2016 23:11:50 +0900</pubDate>
      
      <guid>/blog/2016/02/11/apache-traffic-server-code-reading/</guid>
      <description>

&lt;p&gt;Apache Traffic Server のコードリーディングを少しやってみたので、将来の自分に向けてメモ。&lt;/p&gt;

&lt;h2 id=&#34;コードリーディングの方法についての参考文献:0af5e1c76a1f6c4753d48d00c2585a54&#34;&gt;コードリーディングの方法についての参考文献&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://gihyo.jp/magazine/wdpress/archive/2012/vol69&#34;&gt;WEB+DB PRESS Vol.69｜技術評論社&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://dev.ariel-networks.com/wp/archives/author/inoue&#34;&gt;アリエル・ネットワーク㈱の井上さん&lt;/a&gt;による「大規模コードリーディング」の特集&lt;/li&gt;
&lt;li&gt;私は&lt;a href=&#34;http://gihyo.jp/book/2013/978-4-7741-5783-2&#34;&gt;WEB+DB PRESS総集編［Vol.1～72］：書籍案内｜技術評論社&lt;/a&gt;を買ってたので、これに入っています。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gihyo.jp/book/2015/978-4-7741-7538-6&#34;&gt;WEB+DB PRESS総集編［Vol.1～84］：書籍案内｜技術評論社&lt;/a&gt;というのも出ていました。将来チェックするときはより新しい総集編が出ているかチェックしましょう。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/satorutakeuchi18/viewing-source-code&#34;&gt;大規模ソースコードの読み方&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ツール:0af5e1c76a1f6c4753d48d00c2585a54&#34;&gt;ツール&lt;/h2&gt;

&lt;p&gt;以下の 2 つのツールを使ってみました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.doxygen.jp/&#34;&gt;Doxygen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.tamacom.com/global-j.html&#34;&gt;GNU GLOBAL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apache Traffic Server は C++ で書かれています。 C 言語に対応したツールなら他にもあるのですが、 C++ に対応していてちゃんと動いたのはこの 2 つでした。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://gccxml.github.io/HTML/Index.html&#34;&gt;GCC-XML&lt;/a&gt; とその後継の &lt;a href=&#34;https://github.com/CastXML/CastXML#readme&#34;&gt;CastXML/CastXML: C-family Abstract Syntax Tree XML Output&lt;/a&gt; はうまくいかなくて諦めました。&lt;/p&gt;

&lt;h3 id=&#34;doxygen:0af5e1c76a1f6c4753d48d00c2585a54&#34;&gt;Doxygen&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.doxygen.jp/starting.html&#34;&gt;Doxygen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://onlineconsultant.jp/pukiwiki/?Doxygen%2FGraphviz%E3%81%A7%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E3%82%92%E8%87%AA%E5%8B%95%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B&#34;&gt;Doxygen/Graphvizでドキュメントを自動生成する -でじうぃき&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;あたりを参考にしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/apache/trafficserver&#34;&gt;https://github.com/apache/trafficserver&lt;/a&gt; を &lt;code&gt;git clone&lt;/code&gt; したディレクトリで作業しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;doxygen -g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で &lt;code&gt;Doxyfile&lt;/code&gt; を生成して、以下のように編集しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--- Doxyfile.generated	2016-02-11 23:27:47.000000000 +0900
+++ Doxyfile	2016-01-22 20:52:30.000000000 +0900
@@ -32,13 +32,13 @@
 # title of most generated pages and in a few other places.
 # The default value is: My Project.
 
-PROJECT_NAME           = &amp;quot;My Project&amp;quot;
+PROJECT_NAME           = &amp;quot;Apache Traffic Server&amp;quot;
 
 # The PROJECT_NUMBER tag can be used to enter a project or revision number. This
 # could be handy for archiving the generated documentation or if some version
 # control system is used.
 
-PROJECT_NUMBER         =
+PROJECT_NUMBER         = 6.0
 
 # Using the PROJECT_BRIEF tag one can provide an optional one line description
 # for a project that appears at the top of each page and should give viewer a
@@ -58,7 +58,7 @@
 # entered, it will be relative to the location where doxygen was started. If
 # left blank the current directory will be used.
 
-OUTPUT_DIRECTORY       =
+OUTPUT_DIRECTORY       = ../trafficserver-doxygen
 
 # If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-
 # directories (in 2 levels) under the output directory of each output format and
@@ -802,7 +802,7 @@
 # be searched for input files as well.
 # The default value is: NO.
 
-RECURSIVE              = NO
+RECURSIVE              = YES
 
 # The EXCLUDE tag can be used to specify files and/or directories that should be
 # excluded from the INPUT source files. This way you can easily exclude a
@@ -933,13 +933,13 @@
 # also VERBATIM_HEADERS is set to NO.
 # The default value is: NO.
 
-SOURCE_BROWSER         = NO
+SOURCE_BROWSER         = YES
 
 # Setting the INLINE_SOURCES tag to YES will include the body of functions,
 # classes and enums directly into the documentation.
 # The default value is: NO.
 
-INLINE_SOURCES         = NO
+INLINE_SOURCES         = YES
 
 # Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
 # special comment blocks from generated source code fragments. Normal C, C++ and
@@ -1865,7 +1865,7 @@
 # captures the structure of the code including all documentation.
 # The default value is: NO.
 
-GENERATE_XML           = NO
+GENERATE_XML           = YES
 
 # The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
 # relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
@@ -2250,7 +2250,7 @@
 # The default value is: NO.
 # This tag requires that the tag HAVE_DOT is set to YES.
 
-CALL_GRAPH             = NO
+CALL_GRAPH             = YES
 
 # If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
 # dependency graph for every global function or class method.
@@ -2262,7 +2262,7 @@
 # The default value is: NO.
 # This tag requires that the tag HAVE_DOT is set to YES.
 
-CALLER_GRAPH           = NO
+CALLER_GRAPH           = YES
 
 # If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
 # hierarchy of all classes instead of a textual one.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Doxyfile&lt;/code&gt; を編集したら、以下のように実行するとドキュメントが生成されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;doxygen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記では &lt;code&gt;GENERATE_XML&lt;/code&gt; を &lt;code&gt;YES&lt;/code&gt; にしていますが、通常は &lt;code&gt;NO&lt;/code&gt; で良いです。生成された HTML に不満がある場合は &lt;code&gt;YES&lt;/code&gt; にして xml ファイルを生成し好みに加工すれば良いということです。&lt;/p&gt;

&lt;p&gt;CALL_GRAPH と CALLER_GRAPH を作るには GraphViz をインストールしておく必要があります。メソッドの呼び出し図ではなくファイルのインクルード関係図っぽかったです (図のあるページへのたどり着き方を見失ってしまって現在確認できず)。&lt;/p&gt;

&lt;h3 id=&#34;gnu-global:0af5e1c76a1f6c4753d48d00c2585a54&#34;&gt;GNU GLOBAL&lt;/h3&gt;

&lt;p&gt;コードリーディング用にはこちらのほうが使いやすかったです。Homebrewからインストールしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install global
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/apache/trafficserver&#34;&gt;https://github.com/apache/trafficserver&lt;/a&gt; を &lt;code&gt;git clone&lt;/code&gt; したディレクトリで以下のコマンドを実行して &lt;code&gt;HTML&lt;/code&gt; ディレクトリにドキュメントが生成しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;htags -sa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-s&lt;/code&gt; をつけると関数などの定義箇所で名前がリンクになり、クリックすると参照箇所一覧のページに飛べます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; はアルファベットの索引を作るオプションです。&lt;/p&gt;

&lt;p&gt;以下のように &lt;code&gt;-n&lt;/code&gt; も追加するとソースリストに行番号が追加されます。ただし、コピペしようとコードを選択すると行番号も混ざってしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;htags -sa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ソースコードのフォントを Monaco にするには &lt;code&gt;HTML/styles.css&lt;/code&gt; に以下のコードを追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pre {
        font-family: Monaco;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;時々参照箇所へのリンクが違うクラスに飛んだりすることがあったので、その場合は &lt;a href=&#34;https://github.com/monochromegane/the_platinum_searcher&#34;&gt;the_platinum_searcher&lt;/a&gt; で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pt -G &#39;\.(h|cc)$&#39; 文字列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;や&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pt -e -G &#39;\.(h|cc)$&#39; 正規表現
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で検索しました。&lt;/p&gt;

&lt;h2 id=&#34;コードリーディングのメモ:0af5e1c76a1f6c4753d48d00c2585a54&#34;&gt;コードリーディングのメモ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/trafficserver-code-reading&#34;&gt;hnakamur/trafficserver-code-reading: This is my code reading memo for Apache Traffic Server&lt;/a&gt; に置きました。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>