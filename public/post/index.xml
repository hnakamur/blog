<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on hnakamur&#39;s blog at github</title>
    <link>/blog/post/</link>
    <description>Recent content in Posts on hnakamur&#39;s blog at github</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Fri, 08 Jan 2016 01:12:13 +0900</lastBuildDate>
    <atom:link href="/blog/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>rsyslogで信頼性のあるログ転送について調べたメモ</title>
      <link>/blog/2016/01/08/reliable_log_forward_with_rsyslog/</link>
      <pubDate>Fri, 08 Jan 2016 01:12:13 +0900</pubDate>
      
      <guid>/blog/2016/01/08/reliable_log_forward_with_rsyslog/</guid>
      <description>

&lt;p&gt;事の発端は fluentd を使ってみようかと思って &lt;a href=&#34;http://changineer.info/server/logging/fluentd-td-agent.html&#34;&gt;fluentd(td-agent)のインストールと設定&lt;/a&gt; を読んだことで す。fluentd のデメリットのところを読んで、ちょっと気になりました。&lt;/p&gt;

&lt;p&gt;Goで書かれた&lt;a href=&#34;https://github.com/moriyoshi/ik&#34;&gt;moriyoshi/ik&lt;/a&gt;も気になったのですが、最近話聞かないし最終コミットも3ヶ月前だったので、今回は見送りました。&lt;/p&gt;

&lt;p&gt;そこで、rsyslogでのログ転送について調査してみようと思いました。&lt;/p&gt;

&lt;p&gt;rsyslog自体についてはこちらのスライド&lt;a href=&#34;http://www.slideshare.net/ttkzw/logstudy01-rsyslog-primer&#34;&gt;#logstudy 01 rsyslog入門&lt;/a&gt;が分かりやすかったです。&lt;/p&gt;

&lt;h2 id=&#34;syslog形式での出力サポート:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;syslog形式での出力サポート&lt;/h2&gt;

&lt;h3 id=&#34;nginx:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;nginx&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://nginx.org/en/docs/syslog.html&#34;&gt;Logging to syslog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;apache-http-server:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;Apache HTTP server&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.fnal.gov/docs/products/apache/syslog_logs_notes.html&#34;&gt;Sending our web logs to syslog&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;ErrorLogやCustomLogに以下の様な感じで書く。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CustomLog &amp;quot;|/usr/bin/tee -a /var/log/www/access.log | /usr/bin/logger -thttpd -plocal6.notice&amp;quot; combined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;teeでファイルに出力しつつloggerコマンドでsyslogにも出力。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/oratta/20101121/1290341166&#34;&gt;syslogで複数のapacheサーバのログを集積する - orattaの日記&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;こちらもCustomLogでloggerコマンドを呼び出す方式。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dsas.blog.klab.org/archives/51500856.html&#34;&gt;DSAS開発者の部屋:Apacheのアクセスログをsyslog経由で出力するためのモジュールを作りました&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Apache 2.2以降で使えるカスタムモジュール&lt;/li&gt;
&lt;li&gt;Cのsyslog関数を使っている&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://httpd.apache.org/docs/trunk/mod/mod_syslog.html&#34;&gt;mod_syslog - Apache HTTP Server Version 2.5&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Apache 2.5からは標準モジュールになったらしい&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;apache-traffic-server:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;Apache Traffic Server&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://trafficserver.readthedocs.org/en/latest/admin-guide/files/records.config.en.html#proxy-config-syslog-facility&#34;&gt;proxy.config.syslog_facility&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://trafficserver.readthedocs.org/en/latest/admin-guide/files/records.config.en.html#proxy-config-diags-output-emergency&#34;&gt;proxy.config.diags.output.emergency&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;cのsyslog出力関数:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;Cのsyslog出力関数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://linux.die.net/man/3/syslog&#34;&gt;syslog(3): send messages to system logger - Linux man page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;goのsyslogクライアントライブラリ:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;Goのsyslogクライアントライブラリ&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/log/syslog/&#34;&gt;syslog - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;loggerコマンド-シェルスクリプトから出力したい時に使用:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;loggerコマンド (シェルスクリプトから出力したい時に使用)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://linux.die.net/man/1/logger&#34;&gt;logger(1) - Linux man page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;信頼性のあるログ転送のためのrelpプロトコル:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;信頼性のあるログ転送のためのRELPプロトコル&lt;/h2&gt;

&lt;p&gt;UDPで転送するとパケットロスしてログが消失する恐れがあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.slideshare.net/ttkzw/logstudy01-rsyslog-primer&#34;&gt;#logstudy 01 rsyslog入門&lt;/a&gt;の&lt;a href=&#34;http://www.slideshare.net/ttkzw/logstudy01-rsyslog-primer/81&#34;&gt;81枚目のスライド&lt;/a&gt;によると、TCPで転送しておけば、転送先のsyslogサーバがダウンしたら、キューイングして、復活したら再送するそうです。&lt;/p&gt;

&lt;p&gt;これで十分そうな気もしたのですが、syslog forwardでググっていると&lt;a href=&#34;http://ubuntuforums.org/showthread.php?t=2151986&#34;&gt;[SOLVED] Rsyslog forward log to other syslog server&lt;/a&gt;というページからリンクされている&lt;a href=&#34;http://blog.gerhards.net/2008/04/on-unreliability-of-plain-tcp-syslog.html&#34;&gt;Rainer&amp;rsquo;s Blog: On the (un)reliability of plain tcp syslog&amp;hellip;&lt;/a&gt;という記事を見つけました。&lt;/p&gt;

&lt;p&gt;さらにそこからリンクされている&lt;a href=&#34;http://blog.gerhards.net/2008/05/why-you-cant-build-reliable-tcp.html&#34;&gt;Rainer&amp;rsquo;s Blog: why you can&amp;rsquo;t build a reliable TCP protocol without app-level acks&amp;hellip;&lt;/a&gt;という記事も読んでみました。&lt;/p&gt;

&lt;p&gt;一言で言うと、信頼性の有るログ転送を実現するためには、TCPレベルでACKがあってもだめで、アプリケーションレベルのACKが必要ということです。&lt;/p&gt;

&lt;p&gt;アプリケーションレベルのACKが無いと、サーバのバッファスペースが溢れてもクライアントが気づけないというのが問題の本質のようです。&lt;/p&gt;

&lt;p&gt;これを解決するために作られたのが、&lt;a href=&#34;http://blog.gerhards.net/2008/03/relp-reliable-event-logging-protocol.html&#34;&gt;Rainer&amp;rsquo;s Blog: RELP - the reliable event logging protocol&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.librelp.com/&#34;&gt;librelp - a reliable logging library&lt;/a&gt;というのがCの実装で、ソースを見るとライセンスはGPLv3でした。&lt;/p&gt;

&lt;p&gt;RELPはrsyslogdにすでに取り込まれていました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.rsyslog.com/doc/v8-stable/tutorials/reliable_forwarding.html&#34;&gt;Reliable Forwarding of syslog Messages with Rsyslog — rsyslog 8.14.0 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.rsyslog.com/doc/v8-stable/configuration/modules/imrelp.html?highlight=relp&#34;&gt;imrelp: RELP Input Module — rsyslog 8.14.0 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.rsyslog.com/doc/v8-stable/configuration/modules/omrelp.html?highlight=relp&#34;&gt;omrelp: RELP Output Module — rsyslog 8.14.0 documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ただし、imrelpの &lt;code&gt;Ruleset&lt;/code&gt; パラメータはrsyslogdのバージョン7.5.0以降が必要らしいです。CentOS 7のrsyslogdは &lt;code&gt;yum info rsyslogd&lt;/code&gt; によると 7.4.7 なのでこれは使えないようです。&lt;/p&gt;

&lt;p&gt;CentOS 7では &lt;code&gt;rsyslog-relp.x86_64 : RELP protocol support for rsyslog&lt;/code&gt; というパッケージをインストールすればRELPが使えるようです (まだ試してないです)。&lt;/p&gt;

&lt;h2 id=&#34;参考-goで書かれたrsyslogサーバ:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;参考: goで書かれたrsyslogサーバ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mcuadros/go-syslog&#34;&gt;mcuadros/go-syslog&lt;/a&gt;というgoで書かれたrsyslogサーバも見つけました。&lt;/p&gt;

&lt;p&gt;UDP、TCP、Unixソケットでの受信が出来るそうです。READMEに&amp;rdquo;using RFC3164, RFC6587 or RFC5424&amp;rdquo;とありますが、どこまで対応しているかは未調査です。&lt;/p&gt;

&lt;p&gt;RELPは非対応のようです。ソースコードで大文字小文字無視でrelpで検索してヒットしなかったので。&lt;/p&gt;

&lt;p&gt;軽く試してみた結果をgistに貼りました。
&lt;a href=&#34;https://gist.github.com/hnakamur/75385e5572262b5ce9f6&#34;&gt;https://gist.github.com/hnakamur/75385e5572262b5ce9f6&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ambiguous width cjk patchを当てたhomebrew用tmux</title>
      <link>/blog/2015/12/29/homebrew-tmux-ambiguous-width-cjk-patch/</link>
      <pubDate>Tue, 29 Dec 2015 00:53:53 +0900</pubDate>
      
      <guid>/blog/2015/12/29/homebrew-tmux-ambiguous-width-cjk-patch/</guid>
      <description>

&lt;p&gt;ほぼ&lt;a href=&#34;http://qiita.com/macoshita/items/2ee3c15f362103d1e373&#34;&gt;Homebrewでサクッとpatchを当てる - Qiita&lt;/a&gt;のそのままですが、tmuxのバージョンを2.1に上げたものを&lt;a href=&#34;https://github.com/hnakamur/homebrew-custom&#34;&gt;hnakamur/homebrew-custom&lt;/a&gt;に置きました。&lt;/p&gt;

&lt;h2 id=&#34;パッチ適用版tmuxのインストール:eba8e691682467f98f06f7afd1e6bf50&#34;&gt;パッチ適用版tmuxのインストール&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;brew tap hnakamur/custom
brew install tmux-patched
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tmux-confへの設定追加:eba8e691682467f98f06f7afd1e6bf50&#34;&gt;tmux.confへの設定追加&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/macoshita/items/2ee3c15f362103d1e373#comment-ab2f10f09aefe1f3d8b6&#34;&gt;Homebrewでサクッとpatchを当てる - Qiitaのコメント&lt;/a&gt;にある通り、 &lt;code&gt;~/.tmux.conf&lt;/code&gt; に以下の設定が必要でした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set -g pane-border-ascii on
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>CentOS 7用にPython2最新版のrpmを作ってみた</title>
      <link>/blog/2015/12/19/build_latest_python2_rpm_for_centos7/</link>
      <pubDate>Sat, 19 Dec 2015 11:51:30 +0900</pubDate>
      
      <guid>/blog/2015/12/19/build_latest_python2_rpm_for_centos7/</guid>
      <description>

&lt;h2 id=&#34;はじめに:053f4a73ac9fb47562c779868bba4af5&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/12/16/calling_copr_api_with_curl/&#34;&gt;coprのAPIをcurlで呼び出す · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;にも書きましたが、CentOS 7のPythonは古くてhttps通信時にInsecurePlatformWarningが出てしまいます。&lt;/p&gt;

&lt;p&gt;そこで、&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-python-2.7.8-3.el7/&#34;&gt;Software CollectionsのPython27のpythonパッケージ&lt;/a&gt;を改変してPython2の最新版2.7.11のrpmを作ってみました。
&lt;a href=&#34;https://www.softwarecollections.org/en/&#34;&gt;Software Collections&lt;/a&gt;のrpmをベースにしていますので、CentOS 7にインストールされているPythonとは共存可能となっています。&lt;/p&gt;

&lt;h2 id=&#34;python2の最新版rpmの利用方法:053f4a73ac9fb47562c779868bba4af5&#34;&gt;Python2の最新版rpmの利用方法&lt;/h2&gt;

&lt;p&gt;先に利用方法を書いておきます。&lt;/p&gt;

&lt;h3 id=&#34;インストール手順:053f4a73ac9fb47562c779868bba4af5&#34;&gt;インストール手順&lt;/h3&gt;

&lt;p&gt;dockerのcentos:7コンテナにインストールする例で説明します。まず以下のコマンドでコンテナを起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -it centos:7 /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に以下のコマンドを実行してPython2をインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sL -o /etc/yum.repos.d/hnakamur-hnscl-python2.repo https://copr.fedoraproject.org/coprs/hnakamur/hnscl-python2/repo/epel-7/hnakamur-hnscl-python2-epel-7.repo
curl -sL -o /etc/yum.repos.d/hnakamur-hnscl-python2-python.repo https://copr.fedoraproject.org/coprs/hnakamur/hnscl-python2-python/repo/epel-7/hnakamur-hnscl-python2-python-epel-7.repo
yum -y install hn-python2-python
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使い方:053f4a73ac9fb47562c779868bba4af5&#34;&gt;使い方&lt;/h3&gt;

&lt;p&gt;以下のコマンドでPython2最新版用のシェルを起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scl enable hn-python2 bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは通常通りpythonコマンドを実行すればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# which python
/opt/hn/hn-python2/root/usr/bin/python
# python -V
Python 2.7.11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使い終わったら &lt;code&gt;exit&lt;/code&gt; で上記で起動したシェルを抜けてください。&lt;/p&gt;

&lt;p&gt;ちなみに、Software Collectionsで提供されているPython 2.7のインストール方法は&lt;a href=&#34;https://www.softwarecollections.org/en/scls/rhscl/python27/&#34;&gt;Python 2.7 — Software Collections&lt;/a&gt;です。&lt;/p&gt;

&lt;h2 id=&#34;python2の最新版rpmを作った時のメモ:053f4a73ac9fb47562c779868bba4af5&#34;&gt;Python2の最新版rpmを作った時のメモ&lt;/h2&gt;

&lt;p&gt;以下はrpmを作った時のメモです。&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/&#34;&gt;Packaging Guide — Software Collections&lt;/a&gt;を読みながら試行錯誤してrpmを作りました。&lt;/p&gt;

&lt;h3 id=&#34;software-collectionsのメタパッケージ:053f4a73ac9fb47562c779868bba4af5&#34;&gt;Software Collectionsのメタパッケージ&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-Package_Layout&#34;&gt;Packaging Guide — Software Collections&lt;/a&gt;で説明されていますが、Software Collectionsではメタパッケージというのを作成します。&lt;/p&gt;

&lt;p&gt;例えば今回ベースにしたPython 2.7だと&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-1.1-20.el7/&#34;&gt;python27&lt;/a&gt;というのがメタパッケージで、　Python2本体のパッケージは&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-python-2.7.8-3.el7/&#34;&gt;Software CollectionsのPython27のpythonパッケージ&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;Software Collectionsを自作する場合は、パッケージ名が衝突しないように「組織名-」という接頭辞をつけるようにと&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-The_Software_Collections_Prefix&#34;&gt;2.4. The Software Collection Prefix&lt;/a&gt;に書かれています。公式のソフトウェアコレクションは接頭辞無しで &lt;code&gt;python27&lt;/code&gt; のようなコレクション名になっています。&lt;/p&gt;

&lt;p&gt;また、&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-The_File_System_Hierarchy&#34;&gt;2.2. The File System Hierarchy&lt;/a&gt;に書かれているように、ソフトウェアコレクションのrpmに含まれるファイルは &lt;code&gt;/opt/提供者名/ソフトウェアコレクション名/&lt;/code&gt; というディレクトリ構成を取ります。公式のソフトウェアコレクションは &lt;code&gt;/opt/rh/ソフトウェアコレクション名/&lt;/code&gt; というディレクトリになっています。rhはredhatの略だと思います。&lt;/p&gt;

&lt;p&gt;今回は &lt;code&gt;hn-python2&lt;/code&gt; というメタパッケージ名とし、ディレクトリは &lt;code&gt;/opt/hn/python2/&lt;/code&gt; としました。&lt;/p&gt;

&lt;h3 id=&#34;software-collectionsのメタパッケージのビルド:053f4a73ac9fb47562c779868bba4af5&#34;&gt;Software Collectionsのメタパッケージのビルド&lt;/h3&gt;

&lt;p&gt;ビルド用のファイルは&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-rpm&#34;&gt;hnakamur/hnscl-python2-rpm&lt;/a&gt;に置いてあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-The_Software_Collection_Root_Directory&#34;&gt;2.3. The Software Collection Root Directory&lt;/a&gt;によるとspecファイルに以下のように書けばよいそうです。providerの箇所は提供者ごとの値に変えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%global _scl_prefix /opt/provider
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ですが、実際に試してみるとこの設定だけだと、ビルドされたrpm内のファイルパスだったりファイルの中身に &lt;code&gt;/opt/rh/&lt;/code&gt; というパスが残ってしまいました。試行錯誤の結果以下のように書くことで全て &lt;code&gt;/opt/hn/&lt;/code&gt; に変わりました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-rpm/blob/06a6fa366bd485d722139f0637ce2def364eaef3/SPECS/hn-python2.spec#L1-L22&#34;&gt;hn-python2-spec&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%global scl_name_prefix hn-
%global scl_name_base python
%global scl_name_version 2
%global scl %{scl_name_prefix}%{scl_name_base}%{scl_name_version}

# NOTE: You must set _scl_prefix before &#39;%scl_package %scl&#39;.
%global _scl_prefix /opt/hn
# NOTE: The following variables must be re-evaluated after changing _scl_prefix above.
# I got these settings after trials and errors.
# I don&#39;t know this is the right way to set directories with my _scl_prefix.
%global _scl_scripts            %{_scl_prefix}/%{scl}
%global _scl_root               %{_scl_prefix}/%{scl}/root
%global _prefix                 %{_scl_root}/usr
%global _sysconfdir             %{_scl_root}/etc
%global _sharedstatedir         %{_scl_root}/var/lib
%global _localstatedir          %{_scl_root}/var
%global _datadir                %{_scl_root}/share
%global _docdir                 %{_datadir}/doc
%global _mandir                 %{_datadir}/man


%scl_package %scl
...(snip)...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;python本体のパッケージのビルド:053f4a73ac9fb47562c779868bba4af5&#34;&gt;Python本体のパッケージのビルド&lt;/h3&gt;

&lt;p&gt;ビルド用のファイルは&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm&#34;&gt;hnakamur/hnscl-python2-python-rpm&lt;/a&gt;に置いてあります。&lt;/p&gt;

&lt;p&gt;インストールディレクトリを &lt;code&gt;/opt/hn/&lt;/code&gt; 以下にするため、試行錯誤した結果specファイルに以下のように書けばOKでした。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/blob/3a13fe74587d6beca871d28a68149a2273488672/SPECS/python.spec#L1-L31&#34;&gt;python.spec&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%global scl_name_prefix hn-
%global scl_name_base python
%global scl_name_version 2
%global scl %{scl_name_prefix}%{scl_name_base}%{scl_name_version}

# NOTE: You must set _scl_prefix before &#39;%scl_package %scl&#39;.
%global _scl_prefix /opt/hn
# NOTE: The following variables must be re-evaluated after changing _scl_prefix above.
%global _scl_scripts            %{_scl_prefix}/%{scl}
%global _scl_root               %{_scl_prefix}/%{scl}/root
%global _prefix                 %{_scl_root}/usr
%global _sysconfdir             %{_scl_root}/etc
%global _sharedstatedir         %{_scl_root}/var/lib
%global _localstatedir          %{_scl_root}/var

%global _includedir             %{_prefix}/include
%if &amp;quot;%{_lib}&amp;quot; == &amp;quot;lib64&amp;quot;
%global _libdir                 %{_prefix}/lib64
%else
%global _libdir                 %{_prefix}/lib
%endif
%global _datadir                %{_prefix}/share
%global _docdir                 %{_prefix}/share/doc
%global _datarootdir            %{_prefix}/share
%global _infodir                %{_prefix}/share/info
%global _mandir                 %{_prefix}/share/man
%global _defaultdocdir          %{_prefix}/share/doc

%global _exec_prefix            %{_prefix}
%global _bindir                 %{_exec_prefix}/bin
%global _sbindir                %{_exec_prefix}/sbin
...(snip)...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;python本体のspecファイルのパッチ更新:053f4a73ac9fb47562c779868bba4af5&#34;&gt;Python本体のspecファイルのパッチ更新&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/blob/3a13fe74587d6beca871d28a68149a2273488672/SPECS/python.spec&#34;&gt;python.spec&lt;/a&gt;には約60個のパッチが含まれています。&lt;/p&gt;

&lt;p&gt;Pythonのソースのバージョンを上げたのでパッチが当たらなくなるケースが出てきました。patchを実行した時に生成される &lt;code&gt;*.rej&lt;/code&gt; ファイルを見て、なんとなくこんな感じだろという軽いノリでパッチを一通り更新しました。&lt;/p&gt;

&lt;p&gt;作業手順は&lt;a href=&#34;/blog/blog/2015/12/16/how_to_debug_errors_in_rpm_build_using_mock/&#34;&gt;mockを使ったrpmビルドが失敗した時の調査方法 · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;に書いた手順で、mockのchroot環境内でパッチを修正して &lt;code&gt;rpmbuild -bp specファイル名&lt;/code&gt; でパッチを当てるというのをひたすら繰り返した感じです。&lt;/p&gt;

&lt;p&gt;パッチ1つごとの修正を&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/commits/master&#34;&gt;Commits · hnakamur/hnscl-python2-python-rpm&lt;/a&gt;のだいたい1つのコミットにしています。ただ、後からさらに修正が必要だったものは別コミットになっていますが。&lt;/p&gt;

&lt;p&gt;また、CentOSのPythonのspecファイルではリリースビルドとデバッグビルドを作ってテストも実行するようになっています。これがかなり時間がかるので、ビルドが通らない段階では&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/commit/ebb31040e3e5bfe0ceb62cd4eb67793bd1a333b0&#34;&gt;リリースビルドだけにしてテストは実行しないようにしていました&lt;/a&gt;。ビルドが落ち着いてきたところで&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/commit/8a293e3dbd25f6cb6638b00efc07ce5cf962a397&#34;&gt;この変更をgit revert&lt;/a&gt;してビルド・テストするようにしました。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:053f4a73ac9fb47562c779868bba4af5&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-python-2.7.8-3.el7/&#34;&gt;Software CollectionsのPython27のpythonパッケージ&lt;/a&gt;を改変して作ったPython2の最新版2.7.11のrpmについて説明しました。&lt;/p&gt;

&lt;p&gt;CentOS 7でもPython2の最新版が手軽に利用可能になるので、ぜひご活用ください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>direnvでgo1.5.2とgo1.6beta1を切り替える設定</title>
      <link>/blog/2015/12/19/switch_go1.5.2_and_go1.6beta1_with_direnv/</link>
      <pubDate>Sat, 19 Dec 2015 01:45:25 +0900</pubDate>
      
      <guid>/blog/2015/12/19/switch_go1.5.2_and_go1.6beta1_with_direnv/</guid>
      <description>

&lt;h2 id=&#34;はじめに:9e8ccdd514d51c0448f3d2e7fa828293&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;go1.6beta1がリリースされました。go1.5.2と切り替えて使いたいので、&lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;direnv/direnv&lt;/a&gt;用の設定を書きました。&lt;/p&gt;

&lt;h2 id=&#34;設定内容:9e8ccdd514d51c0448f3d2e7fa828293&#34;&gt;設定内容&lt;/h2&gt;

&lt;p&gt;以下の様な配置で使うことにしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;go1.5.2

&lt;ul&gt;
&lt;li&gt;goのインストールディレクトリ: /usr/local/go&lt;/li&gt;
&lt;li&gt;GOPATH: ~/gocode&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;go1.6beta1

&lt;ul&gt;
&lt;li&gt;goのインストールディレクトリ: /usr/local/go1.6beta1&lt;/li&gt;
&lt;li&gt;GOPATH: ~/gocode1.6&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まず、~/.bash_profileや~/.bashからはgoへのPATH設定やGOPATHの設定は削除します。&lt;/p&gt;

&lt;p&gt;次に以下のファイルを作成します。&lt;/p&gt;

&lt;p&gt;~/gocode/.envrc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GOPATH=$HOME/gocode
export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin
export GO15VENDOREXPERIMENT=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;~/gocode1.6/.envrc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GOROOT=/usr/local/go1.6beta1
export GOPATH=$HOME/gocode1.6
export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記の2つのファイルを有効にします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;direnv allow ~/gocode
direnv allow ~/gocode1.6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使い方:9e8ccdd514d51c0448f3d2e7fa828293&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;go1.5.2を使うときは ~/gocode/ 配下のディレクトリにcdします。
すると~/gocode/.envrcがsourceされてgo1.5.2用の設定が有効になります。&lt;/p&gt;

&lt;p&gt;go1.6beta1を使うときは ~/gocode1.6/ 配下のディレクトリにcdします。
すると~/gocode/.envrcで有効にされたgo1.5.2用の設定はアンロードされて、~/gocode1.6/.envrcがsourceされgo1.6beta1用の設定が有効になります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mockやcoprでrpmをビルドする際にサードパーティのレポジトリを追加する方法</title>
      <link>/blog/2015/12/18/add_third_party_to_build_on_mock_and_copr/</link>
      <pubDate>Fri, 18 Dec 2015 01:43:28 +0900</pubDate>
      
      <guid>/blog/2015/12/18/add_third_party_to_build_on_mock_and_copr/</guid>
      <description>

&lt;h2 id=&#34;はじめに:10b0aafa200b57354ec517996e32ab18&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Mock&#34;&gt;Mock&lt;/a&gt;や&lt;a href=&#34;https://copr.fedoraproject.org/&#34;&gt;copr&lt;/a&gt;でrpmをビルドする際にCentOS標準のレポジトリ以外のサードパーティのレポジトリのrpmに依存したい場合があります。この記事ではサードパーティのレポジトリの追加方法を説明します。&lt;/p&gt;

&lt;p&gt;この記事では&lt;a href=&#34;https://www.varnish-cache.org/vmod/header-manipulation&#34;&gt;libvmod-header&lt;/a&gt;をビルドするために&lt;a href=&#34;https://www.varnish-cache.org/installation/redhat&#34;&gt;varnish-cache.orgのRedHat用インストール手順&lt;/a&gt;で提供されているEL7用のレポジトリを追加する例で説明します。&lt;/p&gt;

&lt;p&gt;ビルドするために私が作成したDockerfileとシェルスクリプトは&lt;a href=&#34;https://github.com/hnakamur/libvmod-header-rpm&#34;&gt;hnakamur/libvmod-header-rpm&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h2 id=&#34;mockでのrpmビルド時にサードパーティのレポジトリを追加する方法:10b0aafa200b57354ec517996e32ab18&#34;&gt;Mockでのrpmビルド時にサードパーティのレポジトリを追加する方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lists.fedorahosted.org/pipermail/softwarecollections/2012-November/000018.html&#34;&gt;Building SCL packages with mock&lt;/a&gt;で紹介されていた方法です。&lt;/p&gt;

&lt;p&gt;CentOS 7用のrpmをビルドする場合 &lt;code&gt;/etc/mock/epel-7-x86_64.cfg&lt;/code&gt; をコピーして &lt;code&gt;/etc/mock/epel-7-varnish-x86_64.cfg&lt;/code&gt; のように別名で保存します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/mock/epel-7-varnish-x86_64.cfg&lt;/code&gt; の最後に &lt;code&gt;config_opts[&#39;yum.conf&#39;]&lt;/code&gt; の設定があります。変更前は以下のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config_opts[&#39;root&#39;] = &#39;epel-7-x86_64&#39;
config_opts[&#39;target_arch&#39;] = &#39;x86_64&#39;
config_opts[&#39;legal_host_arches&#39;] = (&#39;x86_64&#39;,)
config_opts[&#39;chroot_setup_cmd&#39;] = &#39;install @buildsys-build&#39;
config_opts[&#39;dist&#39;] = &#39;el7&#39;  # only useful for --resultdir variable subst
config_opts[&#39;releasever&#39;] = &#39;7&#39;

config_opts[&#39;yum.conf&#39;] = &amp;quot;&amp;quot;&amp;quot;
[main]
keepcache=1
debuglevel=2
reposdir=/dev/null
logfile=/var/log/yum.log
retries=20
obsoletes=1
gpgcheck=0
assumeyes=1
syslog_ident=mock
syslog_device=

# repos
[base]
name=BaseOS
mirrorlist=http://mirrorlist.centos.org/?release=7&amp;amp;arch=x86_64&amp;amp;repo=os
failovermethod=priority
gpgkey=file:///etc/pki/mock/RPM-GPG-KEY-CentOS-7
gpgcheck=1

[updates]
name=updates
enabled=1
mirrorlist=http://mirrorlist.centos.org/?release=7&amp;amp;arch=x86_64&amp;amp;repo=updates
failovermethod=priority
gpgkey=file:///etc/pki/mock/RPM-GPG-KEY-CentOS-7
gpgcheck=1

[epel]
name=epel
mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=epel-7&amp;amp;arch=x86_64
failovermethod=priority
gpgkey=file:///etc/pki/mock/RPM-GPG-KEY-EPEL-7
gpgcheck=1

[extras]
name=extras
mirrorlist=http://mirrorlist.centos.org/?release=7&amp;amp;arch=x86_64&amp;amp;repo=extras
failovermethod=priority
gpgkey=file:///etc/pki/mock/RPM-GPG-KEY-EPEL-7
gpgcheck=1

[testing]
name=epel-testing
enabled=0
mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=testing-epel7&amp;amp;arch=x86_64
failovermethod=priority


[local]
name=local
baseurl=http://kojipkgs.fedoraproject.org/repos/epel7-build/latest/x86_64/
cost=2000
enabled=0

[epel-debug]
name=epel-debug
mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=epel-debug-7&amp;amp;arch=x86_64
failovermethod=priority
enabled=0
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;失敗例1:10b0aafa200b57354ec517996e32ab18&#34;&gt;失敗例1&lt;/h3&gt;

&lt;p&gt;varnish-cache.orgではEL7用のレポジトリ定義が &lt;a href=&#34;https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm&#34;&gt;https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm&lt;/a&gt; で配布されています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;config_opts[&#39;chroot_setup_cmd&#39;] = &#39;install @buildsys-build&#39;&lt;/code&gt; にこのrpmのURLを追加して
&lt;code&gt;config_opts[&#39;chroot_setup_cmd&#39;] = &#39;install @buildsys-build https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm&#39;&lt;/code&gt; にするというのを試してみましたが、これは失敗でした。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo mock -r epel-7-varnish-x86_64 --init&lt;/code&gt; で &lt;code&gt;varnish-4.1&lt;/code&gt; というレポジトリのrpmがインストールされるところまではOKでした。
が、 &lt;code&gt;sudo mock -r epel-7-varnish-x86_64 --install varnish&lt;/code&gt; としてvarnishをインストールすると、このレポジトリからvarnish 4.1.0がインストールされずにepelから4.0.3がインストールされてしまいました。&lt;/p&gt;

&lt;h3 id=&#34;うまくいく方法:10b0aafa200b57354ec517996e32ab18&#34;&gt;うまくいく方法&lt;/h3&gt;

&lt;p&gt;ということでmockで作成するchroot環境では &lt;code&gt;config_opts[&#39;yum.conf&#39;]&lt;/code&gt; に予めレポジトリ定義を書いておく必要があるようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm&#34;&gt;https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm&lt;/a&gt; に含まれる &lt;code&gt;etc/yum.repos.d/varnish-4.1.repo&lt;/code&gt; には以下の様なレポジトリ定義が含まれています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[varnish-4.1]
name=Varnish Cache 4.1 for Enterprise Linux
baseurl=https://repo.varnish-cache.org/redhat/varnish-4.1/el7/$basearch
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-VARNISH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/pki/rpm-gpg/RPM-GPG-KEY-VARNISH&lt;/code&gt; というgpgkeyが折角用意されているので使いたいのですが良い方法が思いつきませんでした。 &lt;code&gt;config_opts[&#39;chroot_setup_cmd&#39;]&lt;/code&gt; にセットアップ時に実行されるコマンドを書けるのですが、先頭に &lt;code&gt;yum&lt;/code&gt; を追加して実行されるので任意のコマンドを実行できるわけではないです。&lt;/p&gt;

&lt;p&gt;今回は諦めてgpgkeyを使うのは諦めて、下記の内容を &lt;code&gt;config_opts[&#39;yum.conf&#39;]&lt;/code&gt; の最後に追加するようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[varnish-4.1]
name=Varnish Cache 4.1 for Enterprise Linux
baseurl=https://repo.varnish-cache.org/redhat/varnish-4.1/el7/$basearch
enabled=1
gpgcheck=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スクリプトでは以下のようにしています。
&lt;a href=&#34;https://github.com/hnakamur/libvmod-header-rpm/blob/5d5b2e580b11944ee630c6fbc2bea81b9fa7bb9a/scripts/build.sh#L47-L75&#34;&gt;https://github.com/hnakamur/libvmod-header-rpm/blob/5d5b2e580b11944ee630c6fbc2bea81b9fa7bb9a/scripts/build.sh#L47-L75&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;create_varnish_repo_file() {
  varnish_repo_file=varnish-4.1.repo
  if [ ! -f $varnish_repo_file ]; then
    # NOTE: Although https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm at https://www.varnish-cache.org/installation/redhat
    #       has the gpgkey in it, I don&#39;t use it since I don&#39;t know how to add it to /etc/mock/*.cfg
    cat &amp;gt; ${varnish_repo_file} &amp;lt;&amp;lt;EOF
[${varnish_repo_id}]
name=${varnish_repo_name}
baseurl=${varnish_repo_baseurl}
enabled=1
gpgcheck=0
EOF
  fi
}

create_mock_chroot_cfg() {
  create_varnish_repo_file

  # Insert ${scl_repo_file} before closing &amp;quot;&amp;quot;&amp;quot; of config_opts[&#39;yum.conf&#39;]
  # See: http://unix.stackexchange.com/a/193513/135274
  #
  # NOTE: Support of adding repository was added to mock,
  #       so you can use it in the future.
  # See: https://github.com/rpm-software-management/ci-dnf-stack/issues/30
  (cd ${topdir} \
    &amp;amp;&amp;amp; echo | sed -e &#39;$d;N;P;/\n&amp;quot;&amp;quot;&amp;quot;$/i\
&#39; -e &#39;/\n&amp;quot;&amp;quot;&amp;quot;$/r &#39;${varnish_repo_file} -e &#39;/\n&amp;quot;&amp;quot;&amp;quot;$/a\
&#39; -e D /etc/mock/${base_chroot}.cfg - | sudo sh -c &amp;quot;cat &amp;gt; /etc/mock/${mock_chroot}.cfg&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sedでパターンにマッチした行の後にファイルを挿入するのは &lt;code&gt;/パターン/r ファイル名&lt;/code&gt;ですが、マッチした行の前に挿入するのはトリッキーです。
ここでは &lt;a href=&#34;http://unix.stackexchange.com/a/193513/135274&#34;&gt;http://unix.stackexchange.com/a/193513/135274&lt;/a&gt; で紹介されていた &lt;code&gt;echo | sed -e &#39;$d;N;P;/\nPointer/r file1&#39; -e D file2 -&lt;/code&gt; という手法を使っています。
ただし、ファイルを挿入する前後に改行を入れたかったので &lt;code&gt;i&lt;/code&gt; や &lt;code&gt;a&lt;/code&gt; も使っています。&lt;/p&gt;

&lt;p&gt;これで &lt;code&gt;sudo mock -r epel-7-varnish-x86_64 --rebuild ${SRPMのパス}&lt;/code&gt; でrpmをビルドできます。&lt;/p&gt;

&lt;h2 id=&#34;coprでのrpmビルド時にサードパーティのレポジトリを追加する方法:10b0aafa200b57354ec517996e32ab18&#34;&gt;coprでのrpmビルド時にサードパーティのレポジトリを追加する方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;の&amp;rdquo;Create new project&amp;rdquo;のAPIにreposパラメータがありますので、ここに &lt;code&gt;*.repo&lt;/code&gt; ファイルの &lt;code&gt;baseurl&lt;/code&gt; の値、 &lt;code&gt;https://repo.varnish-cache.org/redhat/varnish-4.1/el7/$basearch&lt;/code&gt; を指定すればOKです。&lt;/p&gt;

&lt;p&gt;実際のスクリプトでは以下の箇所です。
&lt;a href=&#34;https://github.com/hnakamur/libvmod-header-rpm/blob/5d5b2e580b11944ee630c6fbc2bea81b9fa7bb9a/scripts/build.sh#L108-L119&#34;&gt;https://github.com/hnakamur/libvmod-header-rpm/blob/5d5b2e580b11944ee630c6fbc2bea81b9fa7bb9a/scripts/build.sh#L108-L119&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Create the project on copr.
    # We call copr APIs with curl to work around the InsecurePlatformWarning problem
    # since system python in CentOS 7 is old.
    # I read the source code of https://pypi.python.org/pypi/copr/1.62.1
    # since the API document at https://copr.fedoraproject.org/api/ is old.
    curl -s -X POST -u &amp;quot;${COPR_LOGIN}:${COPR_TOKEN}&amp;quot; \
      --data-urlencode &amp;quot;name=${project_name}&amp;quot; \
      --data-urlencode &amp;quot;${base_chroot}=y&amp;quot; \
      --data-urlencode &amp;quot;repos=${varnish_repo_baseurl}&amp;quot; \
      --data-urlencode &amp;quot;description=$copr_project_description&amp;quot; \
      --data-urlencode &amp;quot;instructions=$copr_project_instructions&amp;quot; \
      https://copr.fedoraproject.org/api/coprs/${COPR_USERNAME}/new/
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>mockを使ったrpmビルドが失敗した時の調査方法</title>
      <link>/blog/2015/12/16/how_to_debug_errors_in_rpm_build_using_mock/</link>
      <pubDate>Wed, 16 Dec 2015 01:10:33 +0900</pubDate>
      
      <guid>/blog/2015/12/16/how_to_debug_errors_in_rpm_build_using_mock/</guid>
      <description>

&lt;h2 id=&#34;はじめに:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/&#34;&gt;nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;でspecファイルを書いている最中はmockでのrpmのビルドに失敗することがよくあります。&lt;/p&gt;

&lt;p&gt;私は「なんとなくこんな感じか？」と書いて動かしてみてエラーを見て修正していくスタイルなので、失敗時の調査は重要です。&lt;/p&gt;

&lt;h2 id=&#34;ビルドログ:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;ビルドログ&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sudo mock -r epel-7-x86_64 --rebuild ${srpmファイル名}&lt;/code&gt; のように実行してビルドした場合、 &lt;code&gt;/var/lib/mock/epel-7-x86_64/result/&lt;/code&gt; に &lt;code&gt;build.log&lt;/code&gt; というファイルができるのでそれを見ます。&lt;/p&gt;

&lt;h2 id=&#34;mockコマンドでchroot環境内に入る:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;mockコマンドでchroot環境内に入る&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://linux.die.net/man/1/mock&#34;&gt;mock(1)のmanページ&lt;/a&gt;によると &lt;code&gt;sudo mock -r epel-7-x86_64 --shell&lt;/code&gt; でchroot環境内に入ることが出来ます。 &lt;code&gt;exit&lt;/code&gt; で抜けます。&lt;/p&gt;

&lt;p&gt;mockで作られるchroot環境はビルドに必要な最低限のパッケージしかインストールされておらず、 &lt;code&gt;vim&lt;/code&gt; や &lt;code&gt;less&lt;/code&gt; も使えません。 &lt;code&gt;yum&lt;/code&gt; で入れようにも &lt;code&gt;yum&lt;/code&gt; も無いと言われてしまいます。&lt;/p&gt;

&lt;p&gt;chroot環境に入る前に &lt;code&gt;sudo mock -r epel-7-x86_64 --install vim less&lt;/code&gt; のようにしてインストールしておけばchroot内でvimやlessが使えます。&lt;/p&gt;

&lt;p&gt;あるいはchroot外で &lt;code&gt;/var/lib/mock/epel-7-x86_64/root/&lt;/code&gt; 配下のファイルをvimやlessで見るという手もあります。&lt;/p&gt;

&lt;h2 id=&#34;chroot環境内のrpmビルドディレクトリ:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;chroot環境内のrpmビルドディレクトリ&lt;/h2&gt;

&lt;p&gt;chroot環境内では &lt;code&gt;/builddir/build/&lt;/code&gt; 以下に &lt;code&gt;BUILD&lt;/code&gt;, &lt;code&gt;BUILDDIR&lt;/code&gt;, &lt;code&gt;SOURCES&lt;/code&gt;, &lt;code&gt;SPECS&lt;/code&gt; などのディレクトリが作られているので、これらの中を見ればビルド失敗時の状況を調べられます。&lt;/p&gt;

&lt;h2 id=&#34;chroot環境内でファイルを修正してビルドを再実行:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;chroot環境内でファイルを修正してビルドを再実行&lt;/h2&gt;

&lt;p&gt;mockを使ったrpmビルドはchroot環境を作成してその中で行われるのですが、毎回chroot環境を作るところからやっていると時間がかかって効率が悪いです。&lt;/p&gt;

&lt;p&gt;ですので、chroot環境内のspecファイルや &lt;code&gt;SOURCES&lt;/code&gt; ディレクトリ下のファイルを直接修正して、その後 &lt;code&gt;rpmbuild -bb ${specファイル名}&lt;/code&gt; でrpmのビルドを再度試します。&lt;/p&gt;

&lt;h2 id=&#34;修正したファイルをdockerコンテナ外に取り出す:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;修正したファイルをdockerコンテナ外に取り出す&lt;/h2&gt;

&lt;p&gt;修正のきりが良い所で、chroot環境内の修正したファイルを &lt;code&gt;docker cp&lt;/code&gt; コマンドでdockerコンテナ内からコンテナ外に取り出します。&lt;/p&gt;

&lt;p&gt;まずdockerホストで &lt;code&gt;docker ps&lt;/code&gt; コマンドでコンテナIDかコンテナ名を調べます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
363ad4f85fda        nginxrpm            &amp;quot;/bin/bash&amp;quot;         18 hours ago        Up 18 hours                             romantic_fermi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に &lt;code&gt;docker cp&lt;/code&gt; コマンドでファイルをコピーします。例えばこんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker cp romantic_fermi:/var/lib/mock/epel-7-x86_64/root/builddir/build/SPECS/nginx.spec SPECS/nginx.spec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取り出した修正ファイルはgitにコミットして、さらに修正作業を続けていきます。&lt;/p&gt;

&lt;p&gt;修正が一通り終わったら、クリーンな状態からビルドが成功することを確認するため、dockerコンテナを一度破棄して&lt;a href=&#34;http://localhost:1313/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/&#34;&gt;nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました · hnakamur&amp;rsquo;s blog at github&lt;/a&gt; の手順で再度ビルドしてみます。これでエラーが出なければOKです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;mockを使ったrpmのビルドが失敗した場合の調査方法を紹介しました。もっと良い方法などありましたら、ぜひ教えてください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>coprのAPIをcurlで呼び出す</title>
      <link>/blog/2015/12/16/calling_copr_api_with_curl/</link>
      <pubDate>Wed, 16 Dec 2015 00:06:39 +0900</pubDate>
      
      <guid>/blog/2015/12/16/calling_copr_api_with_curl/</guid>
      <description>

&lt;h2 id=&#34;はじめに:d97aa5d91864f67b35847063abc7f579&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://fedorahosted.org/copr/&#34;&gt;copr&lt;/a&gt;を利用するには以下の3つの手段があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ウェブ管理画面を使う

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://fedorahosted.org/copr/wiki/ScreenshotsTutorial&#34;&gt;スクリーンショットつきのチュートリアル&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://apps.fedoraproject.org/packages/copr-cli&#34;&gt;copr-cli&lt;/a&gt;というコマンドラインツールを使う

&lt;ul&gt;
&lt;li&gt;内部的に下記の&lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;を呼び出しています&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;を使う&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;copr-cliを使わずにcurlでapiを呼ぶ理由:d97aa5d91864f67b35847063abc7f579&#34;&gt;copr-cliを使わずにcurlでAPIを呼ぶ理由&lt;/h2&gt;

&lt;p&gt;折角copr-cliというコマンドラインツールが用意されているのでそれを活用すれば良いのですが、以下のような問題に遭遇したのでAPIをcurlで呼ぶようにしてみました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CentOS 7でyumでインストールできるcopr-cliはバージョンが古くてsrpmのアップロード機能が未サポート&lt;/li&gt;
&lt;li&gt;CentOS 7のPythonが古いのでInsecurePlatformWarningが出てしまう&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;centos-7でyumでインストールできるcopr-cliはバージョンが古くてsrpmのアップロード機能が未サポート:d97aa5d91864f67b35847063abc7f579&#34;&gt;CentOS 7でyumでインストールできるcopr-cliはバージョンが古くてsrpmのアップロード機能が未サポート&lt;/h3&gt;

&lt;p&gt;正確にはcopr-cliが利用している&lt;a href=&#34;https://apps.fedoraproject.org/packages/python-copr/&#34;&gt;python-copr&lt;/a&gt;のバージョンの問題です。
&lt;a href=&#34;https://apps.fedoraproject.org/packages/python-copr/changelog&#34;&gt;python-coprのChangelog&lt;/a&gt;を見ると1.58-1でsrpmをアップロードする機能が追加されています。&lt;/p&gt;

&lt;p&gt;一方、CentOS 7のepelにあるpython-coprは1.57-1です。srpmをアップロードする機能を使わないとなると、インターネット上にsrpmを置いてURLを指定する必要があり面倒です。&lt;/p&gt;

&lt;h3 id=&#34;centos-7のpythonが古いのでinsecureplatformwarningが出てしまう:d97aa5d91864f67b35847063abc7f579&#34;&gt;CentOS 7のPythonが古いのでInsecurePlatformWarningが出てしまう&lt;/h3&gt;

&lt;p&gt;copr-cliはpipからインストールすれば1.58-1が使えて解決と思ったのですが、今度はPythonのバージョンが古くてhttps通信時にInsecurePlatformWarningが出ました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning&#34;&gt;Security: Verified HTTPS with SSL/TLS — urllib3 dev documentation&lt;/a&gt;を見るとPythonを2.7.9以上にするのが一番理想なのですが、CentOS 7に入っているPythonは2.7.5です。
softwarecollection.orgの&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-python-2.7.8-3.el7/&#34;&gt;python27-python&lt;/a&gt;でも2.7.8です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://urllib3.readthedocs.org/en/latest/security.html#without-modifying-code&#34;&gt;Without modifying code&lt;/a&gt;の手順で警告を無視するというあまり良くない方法も使ってみたのですが、手元のDocker環境ではよかったもののTravis CIだとエラーになってしまうという現象が起きました。&lt;/p&gt;

&lt;h2 id=&#34;copr-apiの認証方法:d97aa5d91864f67b35847063abc7f579&#34;&gt;copr APIの認証方法&lt;/h2&gt;

&lt;p&gt;というわけでcopr-cliを使わずにcurlでCoprのAPIを呼び出す方法を調べました。&lt;/p&gt;

&lt;p&gt;まずは認証ですが、&lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;の先頭にcopr-cli用の設定ファイル形式でAPIトークンの情報が表示されています。が、APIの認証方法は記載されていません。&lt;/p&gt;

&lt;p&gt;しかたがないので、python-coprのソースを読んでみるとcopr/client/client.pyに以下のようなコードがありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...(snip)...
    def _fetch(self, url, data=None, username=None, method=None,
               skip_auth=False, on_error_response=None, headers=None):
...(snip)...
        if not skip_auth:
            kwargs[&amp;quot;auth&amp;quot;] = (self.login, self.token)
...(snip)...
        try:
            response = requests.request(
                method=method.upper(),
                url=url,
                **kwargs
            )
...(snip)...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.python-requests.org/en/latest/&#34;&gt;PythonのRequestsライブラリ&lt;/a&gt;の&lt;a href=&#34;http://docs.python-requests.org/en/latest/user/authentication/#basic-authentication&#34;&gt;Basic Authentication&lt;/a&gt;のドキュメントを見ると、上記のコードは &lt;code&gt;self.login&lt;/code&gt; の値をユーザ名、 &lt;code&gt;self.token&lt;/code&gt; の値をパスワードとしてBASIC認証していることがわかりました。&lt;/p&gt;

&lt;h2 id=&#34;apiの呼び出し例:d97aa5d91864f67b35847063abc7f579&#34;&gt;APIの呼び出し例&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/&#34;&gt;hnakamur/nginx-rpm&lt;/a&gt;の&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/358d646a22c9c516a9247595e296b256d61a86f6/scripts/build.sh#L72-L95&#34;&gt;scripts/build.sh&lt;/a&gt;のコードで説明します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;build_rpm_on_copr() {
  build_srpm

  # Check the project is already created on copr.
  status=`curl -s -o /dev/null -w &amp;quot;%{http_code}&amp;quot; https://copr.fedoraproject.org/api/coprs/${COPR_USERNAME}/${copr_project_name}/detail/`
  if [ $status = &amp;quot;404&amp;quot; ]; then
    # Create the project on copr.
    # We call copr APIs with curl to work around the InsecurePlatformWarning problem
    # since system python in CentOS 7 is old.
    # I read the source code of https://pypi.python.org/pypi/copr/1.62.1
    # since the API document at https://copr.fedoraproject.org/api/ is old.
    curl -s -X POST -u &amp;quot;${COPR_LOGIN}:${COPR_TOKEN}&amp;quot; \
      --data-urlencode &amp;quot;name=${copr_project_name}&amp;quot; \
      --data-urlencode &amp;quot;${mock_chroot}=y&amp;quot; \
      --data-urlencode &amp;quot;description=$copr_project_description&amp;quot; \
      --data-urlencode &amp;quot;instructions=$copr_project_instructions&amp;quot; \
      https://copr.fedoraproject.org/api/coprs/${COPR_USERNAME}/new/
  fi
  # Add a new build on copr with uploading a srpm file.
  curl -s -X POST -u &amp;quot;${COPR_LOGIN}:${COPR_TOKEN}&amp;quot; \
    -F &amp;quot;${mock_chroot}=y&amp;quot; \
    -F &amp;quot;pkgs=@${topdir}/SRPMS/${srpm_file};type=application/x-rpm&amp;quot; \
    https://copr.fedoraproject.org/api/coprs/${COPR_USERNAME}/${copr_project_name}/new_build_upload/
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最初の &lt;code&gt;https://copr.fedoraproject.org/api/coprs/${COPR_USERNAME}/${copr_project_name}/detail/&lt;/code&gt; はプロジェクトの詳細情報取得です。これはログイン不要です。&lt;/p&gt;

&lt;p&gt;次の &lt;code&gt;https://copr.fedoraproject.org/api/coprs/${COPR_USERNAME}/new/&lt;/code&gt; にPOSTしているのがプロジェクト作成です。&lt;/p&gt;

&lt;p&gt;最後の &lt;code&gt;https://copr.fedoraproject.org/api/coprs/${COPR_USERNAME}/${copr_project_name}/new_build_upload/&lt;/code&gt; がsrpmをアップロードしてビルド開始のAPIです。&lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;には &lt;code&gt;/new_build/&lt;/code&gt; は記載がありますが、 &lt;code&gt;/new_build_upload/&lt;/code&gt; は記載が無いです。python-coprのcopr/client/client.pyのソースで見つけました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...(snip)...
    def create_new_build(self, projectname, pkgs, username=None,
                         timeout=None, memory=None, chroots=None,
                         progress_callback=None):
...(snip)...
        if urlparse(pkgs[0]).scheme != &amp;quot;&amp;quot;:
            api_endpoint = &amp;quot;new_build&amp;quot;
            data[&amp;quot;pkgs&amp;quot;] = &amp;quot; &amp;quot;.join(pkgs)
        else:
            try:
                api_endpoint = &amp;quot;new_build_upload&amp;quot;
                f = open(pkgs[0], &amp;quot;rb&amp;quot;)
                data[&amp;quot;pkgs&amp;quot;] = (os.path.basename(f.name), f, &amp;quot;application/x-rpm&amp;quot;)
            except IOError as e:
                raise CoprRequestException(e)

        url = &amp;quot;{0}/coprs/{1}/{2}/{3}/&amp;quot;.format(
            self.api_url, username, projectname, api_endpoint
        )
...(snip)...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ:d97aa5d91864f67b35847063abc7f579&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;のAPIドキュメントが不完全ですが、python-coprのソースを参考にしてcurlでCopr APIを呼び出すことが出来ました。&lt;/p&gt;

&lt;p&gt;これによりCentOS 7でcopr-cliやPythonのバージョンが古いことによる問題を回避できるので良かったです。curlでのcopr APIの呼び出しも上記のようにシンプルに書けるのでこれで十分だと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました</title>
      <link>/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/</link>
      <pubDate>Tue, 15 Dec 2015 04:19:16 +0900</pubDate>
      
      <guid>/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/</guid>
      <description>

&lt;h2 id=&#34;はじめに:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/11/26/use_travis_and_copr_to_build_and_host_rpm/&#34;&gt;Travis CIとcopr.fedoraproject.orgを使ってrpmをビルド・配布するのを試してみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;と&lt;a href=&#34;/blog/blog/2015/12/05/build_rpm_with_mock/&#34;&gt;mockコマンドでrpmをビルドする · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;の環境でいくつかrpmをビルド・配布してみたのですが、手元の環境でビルドを成功させるまでに試行錯誤するのと、coprにsrpmをアップロードしてビルド・配布するのが別の環境だと面倒なことに気付きました。&lt;/p&gt;

&lt;p&gt;そこで、1つのdockerコンテナで両方を行えるようにしました。&lt;/p&gt;

&lt;h2 id=&#34;travis-ciは外しました:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;Travis CIは外しました&lt;/h2&gt;

&lt;p&gt;また、Travis CIは使わないようにしました。理由は2つあります。1つめの理由はgithubのプロジェクトごとにTravis CIのプロジェクトを作ってcopr APIのログイン名、ユーザ名、トークンを環境変数で設定するのが面倒だったからです。これ自体はTravisのAPIを使えば解決する問題かもしれません。&lt;/p&gt;

&lt;p&gt;2つめの理由は、結局手元の環境でビルドを試すので、そこからそのままcoprにsrpmを上げるほうが手っ取り早いことに気づいたからです。これは初回にrpmのspecファイルを作成するときも、その後specファイルのバージョンを更新して新しいバージョンのrpmを作成するときもそうです。&lt;/p&gt;

&lt;h2 id=&#34;nginxのカスタムrpmをビルド-配布するためのdockerコンテナ:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;nginxのカスタムrpmをビルド・配布するためのdockerコンテナ&lt;/h2&gt;

&lt;p&gt;githubレポジトリ&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm&#34;&gt;hnakamur/nginx-rpm&lt;/a&gt;に公開しています。対応するcoprのプロジェクトは&lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nginx/&#34;&gt;hnakamur/nginx Copr&lt;/a&gt;です。&lt;/p&gt;

&lt;h2 id=&#34;ビルド前の準備:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;ビルド前の準備&lt;/h2&gt;

&lt;h3 id=&#34;copr-apiトークンを-envrcにコピー:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;copr APIトークンを.envrcにコピー&lt;/h3&gt;

&lt;p&gt;coprを使うにはFedoraアカウントが必要です。&lt;a href=&#34;https://admin.fedoraproject.org/accounts/user/new&#34;&gt;Sign up for a Fedora account&lt;/a&gt; から登録してください。&lt;/p&gt;

&lt;p&gt;Fedoraアカウントにログインした状態で &lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;を開くと、ページの先頭にAPI Tokenというセクションがあり、以下のような内容が表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[copr-cli]
login = ログインID
username = ユーザ名
token = トークン
copr_url = https://copr.fedoraproject.org
# expiration date: 2016-05-12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドを実行して上記のgithubレポジトリを手元にコピーします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/hnakamur/nginx-rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.envrc.example&lt;/code&gt; を &lt;code&gt;.envrc&lt;/code&gt; にコピーして、上で表示したログインID、ユーザ名、トークンを &lt;code&gt;.envrc&lt;/code&gt; 内の &lt;code&gt;COPR_LOGIN&lt;/code&gt;, &lt;code&gt;COPR_USERNAME&lt;/code&gt;, &lt;code&gt;COPR_TOKEN&lt;/code&gt; 環境変数に設定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# NOTE: Copy this file to .envrc and edit the values
# Go https://copr.fedoraproject.org/api/ and login in and see the values to set.
export COPR_LOGIN=_your_login_here_
export COPR_USERNAME=_your_username_here_
export COPR_TOKEN=_your_token_here_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;セキュリティを考慮してこれらの値はdockerのイメージには埋め込まず、実行時にdockerの &lt;code&gt;-e&lt;/code&gt; オプションで渡すようにしています。具体的には &lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/docker_wrapper.sh&#34;&gt;docker_wrapper.sh&lt;/a&gt; の &lt;code&gt;docker run&lt;/code&gt; の行を参照してください。&lt;/p&gt;

&lt;h3 id=&#34;specファイルの調整:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;specファイルの調整&lt;/h3&gt;

&lt;p&gt;specファイルは &lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/SPECS/nginx.spec&#34;&gt;SPECS/nginx&lt;/a&gt; にあります。各自のニーズに応じて適宜調整します。現時点では &lt;a href=&#34;http://nginx.org/packages/centos/7/SRPMS/&#34;&gt;http://nginx.org/packages/centos/7/SRPMS/&lt;/a&gt; で配布されているCentOS 7用のsrpmをベースに以下の3つのモジュールを組み込んだものになっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/openresty/lua-nginx-module&#34;&gt;openresty/lua-nginx-module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yaoweibin/nginx_upstream_check_module&#34;&gt;yaoweibin/nginx_upstream_check_module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/replay/ngx_http_consistent_hash&#34;&gt;replay/ngx_http_consistent_hash&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;nginx.orgで配布されているsrpm内のnginx.specからの差分は &lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/compare/7e234d2a222778c0a46204dba4e2dcaae8bf7894...ce4e842731a9b90034f9e00796e16839d8bda826&#34;&gt;https://github.com/hnakamur/nginx-rpm/compare/7e234d2a222778c0a46204dba4e2dcaae8bf7894...ce4e842731a9b90034f9e00796e16839d8bda826&lt;/a&gt; で見られます。&lt;/p&gt;

&lt;h3 id=&#34;sources-ファイルの調整:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;SOURCES/*ファイルの調整&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/tree/master/SOURCES&#34;&gt;SOURCES/&lt;/a&gt;にsrpmで必要なソースファイルを置いています。必要に応じて調整してください。今は &lt;a href=&#34;http://nginx.org/packages/centos/7/SRPMS/&#34;&gt;http://nginx.org/packages/centos/7/SRPMS/&lt;/a&gt; で配布されているCentOS 7用のsrpmから頂いたものをそのまま使用しています。&lt;/p&gt;

&lt;p&gt;なお、nginx自体のソースコード(例: nginx-1.9.9.tar.gz)や各エクステンションのソースコードは含めず、ビルド時にダウンロードするようにしています。これはgitレポジトリの肥大化を防ぐためです。&lt;/p&gt;

&lt;h3 id=&#34;ビルドスクリプトの調整:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;ビルドスクリプトの調整&lt;/h3&gt;

&lt;p&gt;ビルドスクリプト&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/scripts/build.sh&#34;&gt;scripts/build.sh&lt;/a&gt;も適宜調整します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;copr_project_name、copr_project_description、copr_project_instructions、rpm_nameをお好みで編集してください。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;download_source_files&lt;/code&gt; 関数はspecファイルの &lt;code&gt;/^Source[0-9]*:&lt;/code&gt; にマッチするパターンで値がhttpから始まるURLについてダウンロードするようにしています。そしてURLの最後のスラッシュ以降をファイル名として採用しています。このルールから外れる場合は、この関数を適宜変更してください。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;dockerfileとdockerのラッパースクリプトを調整:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;Dockerfileとdockerのラッパースクリプトを調整&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt;と&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/docker_wrapper.sh&#34;&gt;docker_wrapper.sh&lt;/a&gt;を適宜調整してください。&lt;/p&gt;

&lt;p&gt;通常は&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/fa051c195e030c2e7f247fa258c6fad1ef9f0dde/docker_wrapper.sh&#34;&gt;docker_wrapper.sh&lt;/a&gt;のdockerimageを好きな名前に変えるぐらいで大丈夫だと思います。&lt;/p&gt;

&lt;h2 id=&#34;dockerイメージを作成:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;dockerイメージを作成&lt;/h2&gt;

&lt;p&gt;以下のコマンドを実行してdockerイメージをビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./docker_wrapper.sh build
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dockerイメージを起動してmockでrpmをビルド:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;dockerイメージを起動してmockでrpmをビルド&lt;/h2&gt;

&lt;p&gt;以下のコマンドを実行してdockerイメージを起動してbashプロンプトを表示します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source .envrc
./docker_wrapper.sh bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに私は&lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;direnv/direnv&lt;/a&gt;を使っているので、 &lt;code&gt;source .envrc&lt;/code&gt; の行は自分で入力しなくても&lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;direnv/direnv&lt;/a&gt;が実行してくれるので便利です。direnvについては&lt;a href=&#34;http://blog.hde.co.jp/entry/2015/02/27/182117&#34;&gt;改めて、direnvを使いましょう！ - HDE BLOG&lt;/a&gt;などの記事を参照してください。&lt;/p&gt;

&lt;p&gt;dockerイメージのbashプロンプトで以下のコマンドを実行してmockでrpmをビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./build.sh mock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mockはchroot環境を作ってそこでrpmをビルドするようになっているので、chroot環境の作成にちょっと時間がかかります。&lt;/p&gt;

&lt;p&gt;dockerコンテナという独立空間が既にあるのにmockでchroot環境を作るのは無駄なんですが、coprがmockを使っているためmockでビルドが成功することを確認してからcoprにsrpmをアップロードするほうが、coprでのビルド失敗を減らせて良いですのでこうしています。&lt;/p&gt;

&lt;h2 id=&#34;coprにsrpmをアップロードして-rpmをビルド-配布:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;coprにsrpmをアップロードして、rpmをビルド・配布&lt;/h2&gt;

&lt;p&gt;mockでrpmのビルドが成功することを確認できたら、dockerコンテナ内で以下のコマンドを実行してsrpmをcoprにアップロードします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./build.sh copr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/scripts/build.sh&#34;&gt;scripts/build.sh&lt;/a&gt;の &lt;code&gt;copr_project_name&lt;/code&gt; で指定した名前のプロジェクトがcopr上に存在しない場合はまず作成してからsrpmをアップロードするようになっています。&lt;/p&gt;

&lt;p&gt;coprのプロジェクト &lt;code&gt;https://copr.fedoraproject.org/coprs/${COPR_USER_NAME}/${copr_project_name}/&lt;/code&gt; でビルドが完了すれば、rpmのレポジトリとして利用可能です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;mockとcoprを使ってnginxのカスタムrpmをビルド・配布する環境について説明しました。&lt;/p&gt;

&lt;p&gt;mockを使ってクリーンな環境でビルドできるので、今回のスクリプトでdockerコンテナを使う必要性は特にありません。Dockerfileでセットアップしたのと同等のCentOS7環境があれば &lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/scripts/build.sh&#34;&gt;scripts/build.sh&lt;/a&gt;を使ってsrpmのビルド、rpmのビルド、srpmのcoprへのアップロードを行えます。&lt;/p&gt;

&lt;p&gt;mockでのrpmのビルドが失敗した場合の調査方法とかcoprのAPIをcopr-cliではなくcurlで呼び出している話とか、いくつか書きたい話があるので日を改めて別記事として書こうと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rpmのspecファイルのSourceにGitHubの任意のコミットのtarballのURLを指定するときの良い書き方</title>
      <link>/blog/2015/12/06/good_rpm_spec_source_url_syntax_for_tarball_on_github/</link>
      <pubDate>Sun, 06 Dec 2015 00:07:23 +0900</pubDate>
      
      <guid>/blog/2015/12/06/good_rpm_spec_source_url_syntax_for_tarball_on_github/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Packaging:SourceURL?rd=Packaging/SourceURL#Commit_Revision&#34;&gt;Packaging:SourceURL - FedoraProject&lt;/a&gt;で知ったtipsの紹介です。&lt;/p&gt;

&lt;p&gt;GitHubでプロジェクトの[Download ZIP]ボタンを押すと、ソースをZIP形式でダウンロードできます。
コミット数が多いプロジェクトだと &lt;code&gt;git clone&lt;/code&gt; するよりも高速に取得できるので履歴が不要な場合には便利な方法です。&lt;/p&gt;

&lt;p&gt;例えば&lt;a href=&#34;https://github.com/openresty/lua-nginx-module&#34;&gt;openresty/lua-nginx-module&lt;/a&gt;なら &lt;code&gt;https://github.com/openresty/lua-nginx-module/archive/master.zip&lt;/code&gt; というURLになるのですが、 &lt;code&gt;.zip&lt;/code&gt; を &lt;code&gt;.tar.gz&lt;/code&gt; に変えればtar.gz形式でダウンロードできます。&lt;/p&gt;

&lt;p&gt;また、 &lt;code&gt;master&lt;/code&gt; の部分はブランチ名、タグ名、コミットハッシュを指定することも出来るので任意のコミットのソースを取得可能です。&lt;/p&gt;

&lt;p&gt;好みのファイル名でダウンロードするのは、通常ならダウンロードするツール側で対応すれば良い話です。例えば&lt;a href=&#34;http://linux.die.net/man/1/curl&#34;&gt;curl(1): transfer URL - Linux man page&lt;/a&gt;を使う場合は &lt;code&gt;-o&lt;/code&gt; オプションで &lt;code&gt;-o ファイル名&lt;/code&gt; のように指定すれば良いだけです。&lt;/p&gt;

&lt;p&gt;ただ、RPMのspecファイルの &lt;code&gt;Source:&lt;/code&gt; に指定するときはちょっと厄介です。
&lt;a href=&#34;https://fedoraproject.org/wiki/How_to_create_an_RPM_package#SPEC_file_overview&#34;&gt;SPEC file overview&lt;/a&gt;の &lt;code&gt;Source0&lt;/code&gt; の説明を読むと、URLのベースネーム (最後のスラッシュの後の部分) が &lt;code&gt;~/rpmbuild/SOURCES&lt;/code&gt; ディレクトリ配下に置くファイル名になるようにするべきとあります。&lt;/p&gt;

&lt;p&gt;しかし、上述のようにGitHubでソースのtarballのURLのベースネームは &lt;code&gt;コミットハッシュなど.tar.gz&lt;/code&gt; という形式となっています。これだと複数のソースをダウンロードした時に、どれがどれかわかりにくいですし、 &lt;code&gt;バージョン番号.tar.gz&lt;/code&gt; の場合だとファイル名が衝突する恐れもあります。&lt;/p&gt;

&lt;p&gt;解決策ですが、元のURLに &lt;code&gt;#/&lt;/code&gt; をつけてその後に好きなファイル名を指定すればOKです。具体的には &lt;code&gt;https://github.com/ユーザ名/プロジェクト名/archive/コミットハッシュなど.tar.gz#/プロジェクト名-コミットハッシュなど.tar.gz&lt;/code&gt; のように書きます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Packaging:SourceURL?rd=Packaging/SourceURL#Commit_Revision&#34;&gt;Packaging:SourceURL - FedoraProject&lt;/a&gt;にはbitbucket.orgとgitlab.comの場合の書き方も紹介されていますので、必要に応じてご参照ください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mockコマンドでrpmをビルドする</title>
      <link>/blog/2015/12/05/build_rpm_with_mock/</link>
      <pubDate>Sat, 05 Dec 2015 22:10:26 +0900</pubDate>
      
      <guid>/blog/2015/12/05/build_rpm_with_mock/</guid>
      <description>

&lt;h2 id=&#34;2015-12-15-追記:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;2015-12-15 追記&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/&#34;&gt;nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;という記事を書きましたのでそちらもご参照ください。&lt;/p&gt;

&lt;h2 id=&#34;以下元記事です:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;以下元記事です&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/11/26/use_travis_and_copr_to_build_and_host_rpm/&#34;&gt;Travis CIとcopr.fedoraproject.orgを使ってrpmをビルド・配布するのを試してみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;でrpmを外部のサーバでビルドできるようになりましたが、試行錯誤中はこの手順だと時間がかかりますので、手元の環境でビルドしたいところです。&lt;/p&gt;

&lt;h2 id=&#34;rpmbuild:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;rpmbuild&lt;/h2&gt;

&lt;p&gt;私は最近までrpmbuildでrpmをビルドしていました。以下のコマンドでspecファイルの &lt;code&gt;BuildRequires&lt;/code&gt; に書いたrpmをまとめてインストールすることが出来ることも最近知りました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum-builddep -y specファイルのパス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけでも十分便利ですが、1つの環境でいろんなrpmをビルドするような使い方をしていると不満が出てきます。ビルドに必要なパッケージを &lt;code&gt;BuildRequires&lt;/code&gt; に書き忘れていても、別のrpmのビルドの際にインストールされていてビルドが通ってしまい気づかない恐れがあるからです。&lt;/p&gt;

&lt;h2 id=&#34;mock:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;mock&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Mock&#34;&gt;Mock - FedoraProject&lt;/a&gt;を使えば、chrootでクリーンな環境でrpmをビルドしてくれるので、上記のように &lt;code&gt;BuildRequires&lt;/code&gt; に必要なパッケージを書き忘れた場合はビルドエラーになり間違いに気づくことができます。&lt;/p&gt;

&lt;p&gt;また、実行環境と異なるCPUアーキテクチャやRHELのバージョン用のrpmもビルドできます。 &lt;a href=&#34;http://linux.die.net/man/1/mock&#34;&gt;mock(1): build SRPMs in chroot - Linux man page&lt;/a&gt;によると &lt;code&gt;-r&lt;/code&gt; オプションで &lt;code&gt;/etc/mock/&amp;lt;chroot&amp;gt;.cfg&lt;/code&gt; の &lt;code&gt;&amp;lt;chroot&amp;gt;&lt;/code&gt; の部分を指定すればよいそうです。&lt;/p&gt;

&lt;p&gt;CentOS 7で &lt;code&gt;/etc/mock&lt;/code&gt; を見てみたところ、以下のような環境が用意されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[vagrant@localhost ~]$ ls /etc/mock/
default.cfg            fedora-21-armhfp.cfg   fedora-22-i386.cfg     fedora-23-ppc64.cfg         fedora-rawhide-ppc64le.cfg
epel-5-i386.cfg        fedora-21-i386.cfg     fedora-22-ppc64.cfg    fedora-23-ppc64le.cfg       fedora-rawhide-s390.cfg
epel-5-ppc.cfg         fedora-21-ppc64.cfg    fedora-22-ppc64le.cfg  fedora-23-s390.cfg          fedora-rawhide-s390x.cfg
epel-5-x86_64.cfg      fedora-21-ppc64le.cfg  fedora-22-s390.cfg     fedora-23-s390x.cfg         fedora-rawhide-sparc.cfg
epel-6-i386.cfg        fedora-21-s390.cfg     fedora-22-s390x.cfg    fedora-23-x86_64.cfg        fedora-rawhide-x86_64.cfg
epel-6-ppc64.cfg       fedora-21-s390x.cfg    fedora-22-x86_64.cfg   fedora-rawhide-aarch64.cfg  logging.ini
epel-6-x86_64.cfg      fedora-21-x86_64.cfg   fedora-23-aarch64.cfg  fedora-rawhide-armhfp.cfg   site-defaults.cfg
epel-7-x86_64.cfg      fedora-22-aarch64.cfg  fedora-23-armhfp.cfg   fedora-rawhide-i386.cfg
fedora-21-aarch64.cfg  fedora-22-armhfp.cfg   fedora-23-i386.cfg     fedora-rawhide-ppc64.cfg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Using_Mock_to_test_package_builds#Caching_in_mock_0.8.x_and_later&#34;&gt;Caching in mock 0.8.x and later&lt;/a&gt;を見るとmockの今のバージョンでは &lt;code&gt;mock&lt;/code&gt; を実行してchroot環境を作ってyumでダウンロードしたrpmはホスト環境にキャッシュされるそうです。&lt;/p&gt;

&lt;p&gt;ですので、複数のrpmをビルドしたり、同じrpmを試行錯誤で何度もビルドする場合に、キャッシュによる高速化が期待できます。&lt;/p&gt;

&lt;p&gt;まとめると、mockの利点は以下の2つです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;chrootによりクリーンな環境でビルドできるのでspecファイルの間違いに気づきやすい&lt;/li&gt;
&lt;li&gt;yumのキャッシュがあるのでビルドの際の &lt;code&gt;yum install&lt;/code&gt; が高速化される&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;coprもmockを使用しています:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;coprもmockを使用しています&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://copr.fedoraproject.org/&#34;&gt;copr&lt;/a&gt;でビルドした結果のmockchaing.log.gzを見ると、以下の様な行がありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[2015-12-05 11:13:20,751][  INFO][PID:19554] executing: /usr/bin/mockchain -r epel-7-x86_64 -l /var/tmp/mockremote-ZTm5H/build/ -a https://copr-be.cloud.fedoraproject.org/results/hnakamur/nginx/epel-7-x86_64 -a https://copr-be.cloud.fedoraproject.org/results/hnakamur/nginx/epel-7-x86_64/devel -m &#39;--define=copr_username hnakamur&#39; -m &#39;--define=copr_projectname nginx&#39; -m &#39;--define=vendor Fedora Project COPR (hnakamur/nginx)&#39; /tmp/build_package_repo/nginx/nginx-1.9.7-1.el7.ngx.src.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://linux.die.net/man/1/mockchain&#34;&gt;mockchain(1): chain package builder - Linux man page&lt;/a&gt;によると複数のrpmを一括ビルドするためのコマンドだそうです。&lt;/p&gt;

&lt;h3 id=&#34;mockを使うためのセットアップ:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;mockを使うためのセットアップ&lt;/h3&gt;

&lt;p&gt;epelを入れればmockはyumでインストール可能です。他にもsrpmを作るためにrpm-buildなどもyumでインストールする必要があるので、Vagrant用とDocker用にそれぞれセットアップ手順をまとめたものを作りました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hnakamur/centos-mock-vagrant&#34;&gt;hnakamur/centos-mock-vagrant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hnakamur/centos-mock-docker&#34;&gt;hnakamur/centos-mock-docker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vagrant環境のほうは単に &lt;code&gt;vagrant up&lt;/code&gt; で起動して &lt;code&gt;vagrant ssh&lt;/code&gt; でログインし、 &lt;code&gt;sudo su - mockbuild&lt;/code&gt; で &lt;code&gt;mockbuild&lt;/code&gt; ユーザになって作業します。&lt;/p&gt;

&lt;p&gt;Docker環境でmockを利用する場合、mockがunshareシステムコールを呼ぶので &lt;code&gt;SYS_ADMIN&lt;/code&gt; ケーパビリティが必要になります。そこで &lt;code&gt;docker run&lt;/code&gt; の際に &lt;code&gt;--cap-add=SYS_ADMIN&lt;/code&gt; オプションが必要です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker build -t mock .&lt;/code&gt; で &lt;code&gt;mock&lt;/code&gt; という名前でdockerイメージをビルドした場合、
&lt;code&gt;docker run --cap-add=SYS_ADMIN -it mock&lt;/code&gt; でbashプロンプトが起動しますので、 &lt;code&gt;su - mockbuild&lt;/code&gt; で &lt;code&gt;mockbuild&lt;/code&gt; ユーザになって作業します。&lt;/p&gt;

&lt;p&gt;mockのyumキャッシュを有効活用するには、複数のビルド間に環境を破棄せずに維持したほうが良いです。dockerのほうはbashを抜けると環境が消えてしまうので、もう少しDockerfileを工夫したようが良さそうです。&lt;/p&gt;

&lt;p&gt;とりあえず私はVagrantの環境の方を使っています。&lt;/p&gt;

&lt;h3 id=&#34;mockでのビルド:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;mockでのビルド&lt;/h3&gt;

&lt;p&gt;まずsrpmファイルを作ります。
上記の環境ですと、&lt;code&gt;mockbuild&lt;/code&gt; ユーザの &lt;code&gt;/home/mockbuild/rpmbuild/&lt;/code&gt; の下に &lt;code&gt;SPECS&lt;/code&gt; や &lt;code&gt;SOURCES&lt;/code&gt; ディレクトリが作ってありますので、そこにspecファイルやソースを置いて以下のコマンドを実行して作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpmbuild -bs specファイルのパス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記の環境では &lt;code&gt;/home/mockbuild/rpmbuild/SRPMS/&lt;/code&gt; にsrpmファイルが生成されます。
その後、以下のようにmockコマンドを実行してビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mock --rebuild srpmファイルのパス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ビルドで生成されたrpmとsrpmファイルは &lt;code&gt;/var/lib/mock/&amp;lt;chroot&amp;gt;/result/&lt;/code&gt; に置かれます。
また、ビルドの作業ディレクトリは &lt;code&gt;/var/lib/mock/&amp;lt;chroot&amp;gt;/root/builddir/build/&lt;/code&gt; 以下に &lt;code&gt;BUILD&lt;/code&gt;, &lt;code&gt;BUILDROOT&lt;/code&gt;, &lt;code&gt;RPMS&lt;/code&gt;, &lt;code&gt;SOURCES&lt;/code&gt;, &lt;code&gt;SPECS&lt;/code&gt;, &lt;code&gt;SRPMS&lt;/code&gt; ディレクトリが作成されていますので、ビルドが失敗した場合はこの中を見て調査できます。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;実は&lt;a href=&#34;https://fedoraproject.org/wiki/Mock&#34;&gt;Mock - FedoraProject&lt;/a&gt;や&lt;a href=&#34;https://copr.fedoraproject.org/&#34;&gt;Project List&lt;/a&gt;はしばらく前に存在を知っていたのですが、ググっても情報が少ないしよくわからないのでスルーしていました。今回ついに使ってみたのですが、非常に便利なツールとサービスだということがわかりました。もっと前から使っておけばよかったです。&lt;/p&gt;

&lt;p&gt;みなさんも&lt;a href=&#34;https://fedoraproject.org/wiki/Mock&#34;&gt;Mock - FedoraProject&lt;/a&gt;と&lt;a href=&#34;https://copr.fedoraproject.org/&#34;&gt;Project List&lt;/a&gt;を活用して、快適なrpmビルド・配布環境を手に入れましょう！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Travis CIとcopr.fedoraproject.orgを使ってrpmをビルド・配布するのを試してみた</title>
      <link>/blog/2015/11/26/use_travis_and_copr_to_build_and_host_rpm/</link>
      <pubDate>Thu, 26 Nov 2015 22:33:57 +0900</pubDate>
      
      <guid>/blog/2015/11/26/use_travis_and_copr_to_build_and_host_rpm/</guid>
      <description>

&lt;h2 id=&#34;2015-12-15-追記:feab3b17551715c7fe87c510b9d66160&#34;&gt;2015-12-15 追記&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/&#34;&gt;nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;という記事を書きましたのでそちらもご参照ください。&lt;/p&gt;

&lt;h2 id=&#34;はじめに:feab3b17551715c7fe87c510b9d66160&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;CentOSを使っていると、パッケージのバージョンが古いのでspecファイルを改変してrpmをビルドすることがちょくちょくあります。
一度ビルドした後は、自作rpmのレポジトリサーバを立ててそこに置いておくのが本来は良いんだろうなと思います。
ですが、サーバの運用の手間を考えると面倒だなと思って、AnsibleやDockerでのプロビジョニング中にビルドするようにしていました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://copr.fedoraproject.org/coprs/&#34;&gt;fedora projectのcoprというサービス&lt;/a&gt;を使うと、自分でサーバを用意しなくても
自作rpmのビルドとホスティングが出来ることを知り、試してみました。&lt;/p&gt;

&lt;h3 id=&#34;今回試したサンプル:feab3b17551715c7fe87c510b9d66160&#34;&gt;今回試したサンプル&lt;/h3&gt;

&lt;p&gt;githubのレポジトリは&lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm&#34;&gt;hnakamur/nodejs-rpm&lt;/a&gt;にあります。Node.jsをビルドするrpmです。&lt;/p&gt;

&lt;p&gt;specファイルは&lt;a href=&#34;https://github.com/kazuhisya/nodejs-rpm&#34;&gt;kazuhisya/nodejs-rpm&lt;/a&gt;のをほぼ流用しています。ありがとうございます！
一点変更したのはダウンロードするNode.jsのソースのtarballを &lt;code&gt;node-v*.tar.gz&lt;/code&gt; ではなく &lt;code&gt;node-v*.tar.xz&lt;/code&gt; にしています。&lt;/p&gt;

&lt;h2 id=&#34;coprについて:feab3b17551715c7fe87c510b9d66160&#34;&gt;coprについて&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://fedorahosted.org/copr/&#34;&gt;copr&lt;/a&gt;に説明があります。FAQの&lt;a href=&#34;https://fedorahosted.org/copr/wiki/UserDocs#HowisCoprpronounced&#34;&gt;How is Copr pronounced?&lt;/a&gt;によると、銅(copper)と同じでカッパーと発音するそうです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://fedorahosted.org/copr/wiki/UserDocs#Howlongdoyoukeepthebuilds&#34;&gt;How long do you keep the builds?&lt;/a&gt;によるとプロジェクトごとに最後に成功したビルドだけが保持されて、古いバージョンのビルドや失敗したビルドは14日後に削除されるそうです。&lt;/p&gt;

&lt;p&gt;ですので、古いバージョンも残しておきたい場合は、coprは使えません。その場合は自前でレポジトリサーバを立てて運用するしかなさそうです。&lt;/p&gt;

&lt;h3 id=&#34;参考-coprのウェブ管理画面にsrpmをアップロードしてrpmをビルドする手順:feab3b17551715c7fe87c510b9d66160&#34;&gt;参考: coprのウェブ管理画面にsrpmをアップロードしてrpmをビルドする手順&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://fedorahosted.org/copr/wiki/ScreenshotsTutorial&#34;&gt;ScreenshotsTutorial – copr&lt;/a&gt;にcoprのウェブ管理画面からsrpmをアップロードしてrpmをビルドする手順がスクリーンショット満載で説明されています。&lt;/p&gt;

&lt;h2 id=&#34;今回試したビルド手順の流れ:feab3b17551715c7fe87c510b9d66160&#34;&gt;今回試したビルド手順の流れ&lt;/h2&gt;

&lt;p&gt;今回試したビルド手順の流れは以下の通りです。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;githubのプロジェクトにspecファイルを置きます。&lt;/li&gt;
&lt;li&gt;git pushしたときにTravis CIでdockerコンテナを動かしてsrpmを作ってcoprに投入します。&lt;/li&gt;
&lt;li&gt;coprでrpmをビルドしてホスティングしてもらいます。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;事前準備:feab3b17551715c7fe87c510b9d66160&#34;&gt;事前準備&lt;/h2&gt;

&lt;h3 id=&#34;fedora-account-登録:feab3b17551715c7fe87c510b9d66160&#34;&gt;Fedora account 登録&lt;/h3&gt;

&lt;p&gt;まずは &lt;a href=&#34;https://admin.fedoraproject.org/accounts/user/new&#34;&gt;Sign up for a Fedora account&lt;/a&gt; からアカウント登録します。手順はメモしてなかったので省略します。&lt;/p&gt;

&lt;p&gt;私のアカウントのログイン後の「アカウントの詳細」のページを見ると「あなたの役割」のところにSigned CLA GroupとSigners of the Fedora Project Contributor Agreementという項目があり、共にステータスが「承認されました」となっているので、これらの申請の手順が必要だったと思います。&lt;/p&gt;

&lt;p&gt;承認されるまでしばらく時間がかかって、その間にrpmをビルドしてみたら署名されないことがありました。今ではプロジェクトごとに鍵が自動生成されてrpmが署名されるようになっています。&lt;/p&gt;

&lt;h3 id=&#34;travis-ciのプロジェクト作成:feab3b17551715c7fe87c510b9d66160&#34;&gt;Travis CIのプロジェクト作成&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/hnakamur/nodejs-rpm&#34;&gt;Travis CI上にhnakamur/nodejs-rpmプロジェクト&lt;/a&gt;を作成して、githubのレポジトリ&lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm&#34;&gt;hnakamur/nodejs-rpm&lt;/a&gt;に対応付けておきます。手順はメモしてなかったので省略します。&lt;/p&gt;

&lt;h3 id=&#34;travis-ciでdockerでコンテナを動かしてsrpmを作る:feab3b17551715c7fe87c510b9d66160&#34;&gt;Travis CIでdockerでコンテナを動かしてsrpmを作る&lt;/h3&gt;

&lt;p&gt;Travis CIでdockerを使う方法は &lt;a href=&#34;https://docs.travis-ci.com/user/docker/&#34;&gt;Using Docker in Builds - Travis CI&lt;/a&gt; で説明されています。&lt;/p&gt;

&lt;p&gt;試行錯誤の結果、以下のような &lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm/blob/0ed19cd5504fcb11875f12184bdb3ccd27caa6aa/.travis.yml&#34;&gt;.travis.yml&lt;/a&gt;を作成しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo: required

services:
  - docker

branches:
  only:
    - master
    - LTS

install:
  - docker build -t hnakamur/nodejsrpm .

script:
  - case $TRAVIS_BRANCH in master) project=nodejs5;; LTS) project=nodejs;; esac
  - docker run hnakamur/nodejsrpm &amp;quot;$COPR_LOGIN&amp;quot; &amp;quot;$COPR_USERNAME&amp;quot; &amp;quot;$COPR_TOKEN&amp;quot; &amp;quot;$project&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm&#34;&gt;hnakamur/nodejs-rpm&lt;/a&gt;では、mainブランチでNode.jsのv5.x (Stable)、LTSブランチでNode.jsのv4.x (LTS)のspecファイルを保持しています。&lt;/p&gt;

&lt;p&gt;coprは上記の通り1つのプロジェクトで複数バージョンは保持できないので、 &lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nodejs5/&#34;&gt;hnakamur/nodejs5 Copr&lt;/a&gt; と &lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nodejs/&#34;&gt;hnakamur/nodejs Copr&lt;/a&gt; の2つのプロジェクトを作ることにしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.travis-ci.com/user/environment-variables/#Default-Environment-Variables&#34;&gt;Environment Variables - Travis CI&lt;/a&gt;によると &lt;code&gt;TRAVIS_BRANCH&lt;/code&gt; 環境変数でgitのブランチが取得できます。ブランチ名に応じてプロジェクト名を切り替え、 &lt;code&gt;docker run&lt;/code&gt; で呼び出すスクリプトの引数に渡しています。&lt;/p&gt;

&lt;p&gt;COPR_LOGIN、COPR_USERNAME、COPR_TOKENの3つの環境変数ですが、Fedora accountにログインした状態で &lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;にアクセスし表示された値を使います。表示されているのはcoprのコマンドラインクライアント &lt;a href=&#34;https://pypi.python.org/pypi/copr-cli&#34;&gt;copr-cli&lt;/a&gt;用の設定ファイル &lt;code&gt;~/.config/copr&lt;/code&gt; の内容です。&lt;/p&gt;

&lt;p&gt;APIのアクセストークンなどは秘密にすべき情報なのでgithubのレポジトリ内のファイルには含めてはいけません。&lt;/p&gt;

&lt;p&gt;そこでこれらの値は&lt;a href=&#34;https://travis-ci.org/hnakamur/nodejs-rpm&#34;&gt;Travis CI上のhnakamur/nodejs-rpmプロジェクト&lt;/a&gt;で&lt;a href=&#34;https://docs.travis-ci.com/user/environment-variables/#Defining-Variables-in-Repository-Settings&#34;&gt;Defining Variables in Repository Settings&lt;/a&gt;の手順に従って設定しておきます。&lt;/p&gt;

&lt;p&gt;プロジェクトの管理画面の右上の[Settings]/[Settings]メニュー (このメニューはプロジェクトの管理者にのみ表示されます)を選んでCOPR_LOGIN、COPR_USERNAME、COPR_TOKENの3つの環境変数を追加します。COPR_LOGINとCOPR_TOKENの2つは[Display value in build log]を[ON]にしてログに出力しないようにしました。&lt;/p&gt;

&lt;p&gt;docker runで実行されるスクリプトの内容は以下の通りです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm/blob/0ed19cd5504fcb11875f12184bdb3ccd27caa6aa/copr-build.sh&#34;&gt;https://github.com/hnakamur/nodejs-rpm/blob/0ed19cd5504fcb11875f12184bdb3ccd27caa6aa/copr-build.sh&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
set -e
copr_login=$1
copr_username=$2
copr_token=$3
project_name=$4

spec_file=/root/rpmbuild/SPECS/nodejs.spec

mkdir -p /root/.config
cat &amp;gt; /root/.config/copr &amp;lt;&amp;lt;EOF
[copr-cli]
login = ${copr_login}
username = ${copr_username}
token = ${copr_token}
copr_url = https://copr.fedoraproject.org
EOF

status=`curl -s -o /dev/null -w &amp;quot;%{http_code}&amp;quot; https://copr.fedoraproject.org/api/coprs/${copr_username}/${project_name}/detail/`
if [ $status = &amp;quot;404&amp;quot; ]; then
  copr-cli create --chroot epel-7-x86_64 --description &#39;node.js repository&#39; ${project_name}
fi
version=`awk &#39;$1==&amp;quot;Version:&amp;quot; {print $2}&#39; ${spec_file}`
release=$(rpm --eval `awk &#39;$1==&amp;quot;Release:&amp;quot; {print $2}&#39; ${spec_file}`)
srpm_file=/root/rpmbuild/SRPMS/nodejs-${version}-${release}.src.rpm
copr-cli build --nowait ${project_name} ${srpm_file}

rm /root/.config/copr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、引数で渡された情報を元にcopr-cliの設定ファイル &lt;code&gt;/root/.config/copr&lt;/code&gt; を生成します。
次にcoprのAPIでプロジェクトが作成済みかチェックし、作成されていなければ作成します。
その後、 &lt;code&gt;copr-cli build&lt;/code&gt; でsrpmをcoprにアップロードしてビルドを開始します。&lt;/p&gt;

&lt;p&gt;curlでhttpステータスだけを出力する方法は &lt;a href=&#34;http://superuser.com/questions/272265/getting-curl-to-output-http-status-code/442395#442395&#34;&gt;Getting curl to output HTTP status code? - Super User&lt;/a&gt; で知りました。ありがとうございます！&lt;/p&gt;

&lt;p&gt;ビルド完了までTravis側で待つようにするのはムダだと思ったので &lt;code&gt;copr-cli build&lt;/code&gt; には &lt;code&gt;--nowait&lt;/code&gt; オプションを指定しました。代わりに &lt;a href=&#34;https://apps.fedoraproject.org/notifications/&#34;&gt;Fedora Notifications&lt;/a&gt;でメール通知を有効にして、ビルド終了時には &lt;code&gt;notifications@fedoraproject.org&lt;/code&gt; からメールが届くようにして使っています。&lt;/p&gt;

&lt;h3 id=&#34;srpmのビルドとcopr-cliのインストール:feab3b17551715c7fe87c510b9d66160&#34;&gt;srpmのビルドとcopr-cliのインストール&lt;/h3&gt;

&lt;p&gt;話が前後しますが、srpmのビルドとcopr-cliのインストールは &lt;code&gt;docker build&lt;/code&gt; で行っています。
&lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm/blob/0ed19cd5504fcb11875f12184bdb3ccd27caa6aa/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt;の内容は以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM centos:7
MAINTAINER Hiroaki Nakamura &amp;lt;hnakamur@gmail.com&amp;gt;

RUN yum -y install rpmdevtools rpm-build \
 &amp;amp;&amp;amp; rpmdev-setuptree

RUN yum -y install epel-release \
 &amp;amp;&amp;amp; yum -y install python-pip \
 &amp;amp;&amp;amp; pip install copr-cli

ADD nodejs.spec /root/rpmbuild/SPECS/
ADD node-js.*patch /root/rpmbuild/SOURCES/

RUN version=`awk &#39;$1==&amp;quot;Version:&amp;quot; {print $2}&#39; /root/rpmbuild/SPECS/nodejs.spec` \
 &amp;amp;&amp;amp; curl -sL -o /root/rpmbuild/SOURCES/node-v${version}.tar.xz https://nodejs.org/dist/v${version}/node-v${version}.tar.xz \
 &amp;amp;&amp;amp; rpmbuild -bs /root/rpmbuild/SPECS/nodejs.spec

ADD copr-build.sh /root/
ENTRYPOINT [&amp;quot;/bin/bash&amp;quot;, &amp;quot;/root/copr-build.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;copr-cliはCentOS 7だとepelから &lt;code&gt;yum install&lt;/code&gt; でインストール可能なのですが、バージョンが古いため &lt;code&gt;copr-cli build&lt;/code&gt; でsrpmファイルのパスを指定してアップロードする機能が無いようです。サイトにアップロードしておいてURLを指定することは可能なのですが、それだと面倒なので &lt;code&gt;pip&lt;/code&gt; を使って最新版の &lt;code&gt;copr-cli&lt;/code&gt; をインストールしています。&lt;/p&gt;

&lt;p&gt;長く運用するサーバならrpmでインストールされるパスと同じパスにpipでインストールしてしまうのは良くないかもしれませんが、ビルド終了したら破棄するコンテナなので気にせず上書きインストールとしています。&lt;/p&gt;

&lt;h2 id=&#34;rpmを使う手順:feab3b17551715c7fe87c510b9d66160&#34;&gt;rpmを使う手順&lt;/h2&gt;

&lt;p&gt;例えば&lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nodejs/&#34;&gt;hnakamur/nodejs Copr&lt;/a&gt;だと右の方の[Quick Enable]という欄に &lt;code&gt;dnf copr enable hnakamur/nodejs&lt;/code&gt; というコマンドで有効にできるという説明があります。&lt;/p&gt;

&lt;p&gt;その下のリンクをたどると&lt;a href=&#34;https://fedorahosted.org/copr/wiki/HowToEnableRepo&#34;&gt;HowToEnableRepo – copr&lt;/a&gt;に
yumの場合は &lt;code&gt;yum copr enable user/project&lt;/code&gt; となるとあります。ただし、 &lt;code&gt;yum-plugin-copr&lt;/code&gt; という &lt;code&gt;yum&lt;/code&gt; のプラグインが必要です。&lt;/p&gt;

&lt;p&gt;これはepelとかには無いようで、&lt;a href=&#34;https://copr.fedoraproject.org/coprs/alonid/yum-plugin-copr/&#34;&gt;alonid/yum-plugin-copr Copr&lt;/a&gt;にありました。が、これをインストールするにはこのプロジェクトを有効にする必要があるので面倒です。&lt;/p&gt;

&lt;p&gt;コマンドを使わなくても&lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nodejs/&#34;&gt;hnakamur/nodejs Copr&lt;/a&gt;のActive Releasesセクションの表のRepo Downloadの列にある[Epel 7]というボタンを押すと以下のようにレポジトリの設定ファイルが表示されます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nodejs/repo/epel-7/hnakamur-nodejs-epel-7.repo&#34;&gt;https://copr.fedoraproject.org/coprs/hnakamur/nodejs/repo/epel-7/hnakamur-nodejs-epel-7.repo&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[hnakamur-nodejs]
name=Copr repo for nodejs owned by hnakamur
baseurl=https://copr-be.cloud.fedoraproject.org/results/hnakamur/nodejs/epel-7-$basearch/
skip_if_unavailable=True
gpgcheck=1
gpgkey=https://copr-be.cloud.fedoraproject.org/results/hnakamur/nodejs/pubkey.gpg
enabled=1
enabled_metadata=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なので、これを &lt;code&gt;/etc/yum.repos.d/hnakamur-nodejs-epel-7.repo&lt;/code&gt; に保存して &lt;code&gt;yum install nodejs&lt;/code&gt; でインストールすればOKです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:feab3b17551715c7fe87c510b9d66160&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;これでスペックファイルを書いてgithubにプッシュすれば、coprでrpmをビルドして公開されるようになり便利になりました。&lt;/p&gt;

&lt;p&gt;ただし問題もあって、coprのビルドはときどき失敗してしまうようです。スペックファイルの中身を変えずにREADMEに無意味な空行を入れるなどして再度pushしてビルドを再実行すると成功したりしました。&lt;/p&gt;

&lt;h2 id=&#34;さらに気になっていること:feab3b17551715c7fe87c510b9d66160&#34;&gt;さらに気になっていること&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://fedorahosted.org/copr/wiki/ScreenshotsTutorial&#34;&gt;ScreenshotsTutorial – copr&lt;/a&gt;の[New Build]タブのスクリーンショットには[From URLs]と[Upload SRPM]という2つのタブしかないですが、実際の画面ではそれに加えて [Git and Tito]、[Mock SCM]というタブがあります。&lt;/p&gt;

&lt;p&gt;これらを使うとTravis CIを使わずにビルドできるかもしれないと期待しているのですが、使い方の説明を見つけられておらず使い方がわからない状態です。ということで一旦この記事を書きました。&lt;/p&gt;

&lt;h2 id=&#34;2015-12-06-追記:feab3b17551715c7fe87c510b9d66160&#34;&gt;2015-12-06 追記&lt;/h2&gt;

&lt;p&gt;rpmのビルドが通るまでの試行錯誤中は毎回coprでビルドするより手元の環境でビルドするほうが快適です。そのための手順を&lt;a href=&#34;/blog/blog/2015/12/05/build_rpm_with_mock/&#34;&gt;mockコマンドでrpmをビルドする · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;に書きましたので、ご参照ください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mattn/gomにGoのvendoringサポートが追加されました</title>
      <link>/blog/2015/10/22/gom_got_go_vendoring_support/</link>
      <pubDate>Thu, 22 Oct 2015 01:22:10 +0900</pubDate>
      
      <guid>/blog/2015/10/22/gom_got_go_vendoring_support/</guid>
      <description>

&lt;p&gt;以前&lt;a href=&#34;http://deeeet.com/writing/2015/06/26/golang-dependency-vendoring/&#34;&gt;Go言語のDependency/Vendoringの問題と今後．gbあるいはGo1.5 | SOTA&lt;/a&gt;を読んだのですが、その時は様子見にしていました。&lt;/p&gt;

&lt;p&gt;しかし、仕事でGoを書くとなるとやはりVendoringは必要だろうと思い、遅ればせながら今回&lt;a href=&#34;https://getgb.io/examples/getting-started/&#34;&gt;gb&lt;/a&gt;, &lt;a href=&#34;https://github.com/tools/godep&#34;&gt;tools/godep&lt;/a&gt;, &lt;a href=&#34;https://github.com/mattn/gom&#34;&gt;mattn/gom&lt;/a&gt;を試してみました。&lt;/p&gt;

&lt;h2 id=&#34;gbの不満:96cfedbb6d327eac2c80a70b44a7b99d&#34;&gt;gbの不満&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://getgb.io/examples/getting-started/&#34;&gt;gb&lt;/a&gt;の例を見ると、自分のプロジェクトのトップディレクトリに &lt;code&gt;src/cmd&lt;/code&gt; あるいは &lt;code&gt;src/github.com/ユーザID/プロジェクト名&lt;/code&gt; というディレクトリを作ってそこにソースを置く必要があるようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://getgb.io/faq/#cannot-build-src-root&#34;&gt;FAQ&lt;/a&gt;にも&lt;a href=&#34;http://getgb.io/faq/#cannot-build-src-root&#34;&gt;Why can&amp;rsquo;t I place source in $PROJECT/src?&lt;/a&gt;という項があるので、これは仕様のようです。&lt;/p&gt;

&lt;p&gt;でもこれだと、自分のプロジェクトを他のプロジェクトで使いたい時に &lt;code&gt;go get&lt;/code&gt; で使えないですよね。
FAQに &amp;ldquo;Can I use gb if I am working on a Go library?&amp;rdquo; とか &amp;ldquo;Copying code is gross! Can I use git submodules?&amp;rdquo; とかあるんですが、git submoduleにせよgit subtreeにせよ面倒だなと思いました。&lt;/p&gt;

&lt;h2 id=&#34;godepsの不満:96cfedbb6d327eac2c80a70b44a7b99d&#34;&gt;godepsの不満&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tools/godep&#34;&gt;tools/godep&lt;/a&gt; の&amp;rdquo;Go 1.5 vendor/ experiment&amp;rdquo;の項を読んで試してみたところ、&lt;code&gt;go build&lt;/code&gt; が使用する環境変数 &lt;code&gt;GO15VENDOREXPERIMENT&lt;/code&gt; を &lt;code&gt;export GO15VENDOREXPERIMENT=1&lt;/code&gt; のように設定しておくと、そうでないときは &lt;code&gt;Godeps/_workspace/&lt;/code&gt; に置かれる依存ライブラリが &lt;code&gt;vendor/&lt;/code&gt; 以下に置かれるようになることがわかりました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vendor/&lt;/code&gt; を &lt;code&gt;.gitignore&lt;/code&gt; で除外してコミットしたいので、後から &lt;code&gt;Godeps/Godeps.json&lt;/code&gt; から &lt;code&gt;vendor/&lt;/code&gt; を再構成する必要があります。READMEには書いてないですが、 &lt;code&gt;godep get&lt;/code&gt; でダウンロードして、 &lt;code&gt;godep save&lt;/code&gt; で &lt;code&gt;vendor/&lt;/code&gt; に反映できることがわかりました。&lt;/p&gt;

&lt;p&gt;ただ、 &lt;code&gt;godep get&lt;/code&gt; でダウンロードする先は環境変数 &lt;code&gt;GOPATH&lt;/code&gt; で指しているディレクトリなんですよね。 &lt;code&gt;godep save&lt;/code&gt; は &lt;code&gt;$GOPATH&lt;/code&gt; から &lt;code&gt;vendor/&lt;/code&gt; に反映するコマンドです。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;code&gt;godep restore&lt;/code&gt; というコマンドもありますが、これは &lt;code&gt;vendor/&lt;/code&gt; から &lt;code&gt;$GOPATH&lt;/code&gt; に反映します。GoにVendoringサポートがなかったときは、これで &lt;code&gt;$GOPATH&lt;/code&gt; に反映してから &lt;code&gt;go build&lt;/code&gt; という手順も妥当な気がしますが、Vendoringがある今となってはグローバルの &lt;code&gt;$GOPATH&lt;/code&gt; 配下は触らずに &lt;code&gt;vendor/&lt;/code&gt; 以下を直接更新したいところです。&lt;/p&gt;

&lt;p&gt;とりあえずイシュー&lt;a href=&#34;https://github.com/tools/godep/issues/299&#34;&gt;Download dependency to vendor/ directory with godep get when GO15VENDOREXPERIMENT=1 · Issue #299 · tools/godep&lt;/a&gt; を立ててみたところ、同じことを考えていたというコメントがついていました。&lt;/p&gt;

&lt;h2 id=&#34;gomならバッチリ:96cfedbb6d327eac2c80a70b44a7b99d&#34;&gt;gomならバッチリ！&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mattn/gom&#34;&gt;mattn/gom&lt;/a&gt;を見ると&lt;a href=&#34;https://github.com/mattn/gom/issues/51&#34;&gt;Consider adding GO15VENDOREXPERIMENT support · Issue #51 · mattn/gom&lt;/a&gt;というイシューがあったので、対応するコードを書いて &lt;a href=&#34;https://github.com/mattn/gom/pull/57&#34;&gt;Support go15vendorexperiment by mattn · Pull Request #57 · mattn/gom&lt;/a&gt;で追加修正の上マージしていただきました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gom install&lt;/code&gt; では内部的に &lt;code&gt;go get&lt;/code&gt; を呼び出しているので、ターゲットディレクトリを &lt;code&gt;vendor/&lt;/code&gt; にしても &lt;code&gt;vendor/src/github.com/...&lt;/code&gt; のように &lt;code&gt;src&lt;/code&gt; フォルダが作られてしまいます。上の修正では対処療法的に &lt;code&gt;gom install&lt;/code&gt; 内で &lt;code&gt;vendor/*&lt;/code&gt; を &lt;code&gt;vendor/src/*&lt;/code&gt; に移動して、終わったら &lt;code&gt;vendor/src/*&lt;/code&gt; を &lt;code&gt;vendor/*&lt;/code&gt; に移動して対応しています。&lt;/p&gt;

&lt;p&gt;正確には最初の移動では &lt;code&gt;vendor/&lt;/code&gt; 以下の &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;pkg&lt;/code&gt;, &lt;code&gt;src&lt;/code&gt; は除外しています。&lt;/p&gt;

&lt;p&gt;これで、 &lt;code&gt;export GO15VENDOREXPERIMENT=1&lt;/code&gt; さえしておけば、 &lt;code&gt;gom install&lt;/code&gt; で &lt;code&gt;$GOPATH&lt;/code&gt; 配下は変更せずに直接 &lt;code&gt;vendor/&lt;/code&gt; 以下を更新できるようになりました。&lt;/p&gt;

&lt;p&gt;READMEには書いてないですが、 &lt;code&gt;gom lock&lt;/code&gt; を実行すれば &lt;code&gt;Gomfile.lock&lt;/code&gt; が作られて、以降の &lt;code&gt;gom install&lt;/code&gt; では依存ライブラリのバージョンを正確に反映できます。&lt;/p&gt;

&lt;p&gt;ということで、gomならバッチリ私の希望を満たしてくれることがわかりました。
mattnさん、便利なツールをありがとうございます！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MySQL APT repositoryからMySQL 5.7.xをインストールするスクリプト</title>
      <link>/blog/2015/09/22/noninteractive_install_from_mysql_apt_repository_on_ubuntu_trusty/</link>
      <pubDate>Tue, 22 Sep 2015 22:35:21 +0900</pubDate>
      
      <guid>/blog/2015/09/22/noninteractive_install_from_mysql_apt_repository_on_ubuntu_trusty/</guid>
      <description>

&lt;p&gt;Ubuntu 14.04 (Trusty)に&lt;a href=&#34;http://dev.mysql.com/downloads/repo/apt/&#34;&gt;MySQL APT Repository&lt;/a&gt;からMySQL 5.7 (Development Release)を
インストールするスクリプトを書きました。&lt;/p&gt;

&lt;p&gt;Vagrantfileと共に&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty&#34;&gt;hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty&lt;/a&gt;に置いてあります。&lt;/p&gt;

&lt;h2 id=&#34;使い方:7b72d99f6277ee322df194c41a872720&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://dev.mysql.com/downloads/repo/apt/&#34;&gt;MySQL :: Download MySQL APT Repository&lt;/a&gt;をブラウザで見てmysql-apt-config_x.x.x-1ubuntu14.04_all.debのファイルのバージョンを確認し、スクリプト内の &lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L4&#34;&gt;mysql_apt_deb_file&lt;/a&gt;変数の値をを適宜修正してください。&lt;/p&gt;

&lt;p&gt;スクリプト内の&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L8&#34;&gt;mysql_root_password&lt;/a&gt;変数の値を設定したいMySQLのrootユーザのパスワードに変更してください。&lt;/p&gt;

&lt;p&gt;あとはスクリプトを実行すればOKです。&lt;/p&gt;

&lt;h2 id=&#34;スクリプトの実装メモ:7b72d99f6277ee322df194c41a872720&#34;&gt;スクリプトの実装メモ&lt;/h2&gt;

&lt;h3 id=&#34;noninteractiveなmysql-apt-configのインストール:7b72d99f6277ee322df194c41a872720&#34;&gt;noninteractiveなmysql-apt-configのインストール&lt;/h3&gt;

&lt;p&gt;単に &lt;code&gt;sudo dpkg -i mysql-apt-config_0.3.7-1ubuntu14.04_all.deb&lt;/code&gt; のように実行すると、途中でCUIのダイアログが開いてMySQLサーバのバージョンなどを聞かれてしまいます。自動インストール用のスクリプトではインタラクティブに聞かれてほしくないので &lt;code&gt;export DEBIAN_FRONTEND=noninteractive&lt;/code&gt; を指定する必要があります。
&lt;a href=&#34;http://manpages.ubuntu.com/manpages/trusty/man7/debconf.7.html&#34;&gt;Ubuntu Manpage: debconf - Debian package configuration system&lt;/a&gt;に説明があります。&lt;/p&gt;

&lt;p&gt;またその後 &lt;code&gt;sudo dpkg ...&lt;/code&gt; だと環境変数を引き継がないので &lt;code&gt;sudo -E dpkg ...&lt;/code&gt; のように &lt;code&gt;-E&lt;/code&gt; オプションを指定しています。&lt;a href=&#34;http://stackoverflow.com/questions/7739645/install-mysql-on-ubuntu-without-password-prompt#comment37966911_7740393&#34;&gt;bash - install mysql on ubuntu without password prompt - Stack Overflow&lt;/a&gt;で知りました。&lt;/p&gt;

&lt;p&gt;実行するのが1回だけなら &lt;code&gt;sudo DEBIAN_FRONTEND=noninteractive dpkg ...&lt;/code&gt; のほうがシンプルで良いと思います。が、今回は後でmysql-community-serverをインストールするときにも必要なので上記の方式にしました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;export DEBIAN_FRONTEND=noninteractive&lt;/code&gt; だけで良い場合もありますが、ダイアログで選ぶ値を予め設定しておく必要がある場合もあります。
&lt;a href=&#34;http://unix.stackexchange.com/questions/158052/how-to-configure-the-mysql-apt-repo-on-ubuntu-on-a-non-interactive-shell?newreg=31ba47900d6f4e01ba1625f43da05f82&#34;&gt;dpkg - How to configure the MySQL APT repo on Ubuntu, on a non-interactive shell? - Unix &amp;amp; Linux Stack Exchange&lt;/a&gt;で mysql-apt-config のインストールには &lt;code&gt;echo mysql-apt-config mysql-apt-config/enable-repo select mysql-5.7-dmr | sudo debconf-set-selections&lt;/code&gt; としておけば良いらしいという情報を得ました。&lt;/p&gt;

&lt;p&gt;ですが、調査のために mysql-apt-config を手動インストールしてその前後で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo debconf-get-selections | grep mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;して設定される項目を見てみると違う名前になっていました。スクリプトでは&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L16-L21&#34;&gt;手動インストールで設定される項目に合わせて設定するようにしました。&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;noninteractiveなmysql-community-serverのインストール:7b72d99f6277ee322df194c41a872720&#34;&gt;noninteractiveなmysql-community-serverのインストール&lt;/h3&gt;

&lt;p&gt;こちらも同様に &lt;code&gt;export DEBIAN_FRONTEND=noninteractive&lt;/code&gt; のあと &lt;code&gt;sudo -E apt-get -y install ...&lt;/code&gt; でインストールしています。設定値は
&lt;a href=&#34;http://stackoverflow.com/questions/7739645/install-mysql-on-ubuntu-without-password-prompt/20037235#20037235&#34;&gt;bash - install mysql on ubuntu without password prompt - Stack Overflow&lt;/a&gt;を参考にしつつ、まず手動インストールして &lt;code&gt;sudo debconf-get-selections | grep mysql&lt;/code&gt; で設定値を確認し、&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L28-L29&#34;&gt;それに合わせて設定するようにしました。&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;noninteractiveなmysql-secure-installationの実行:7b72d99f6277ee322df194c41a872720&#34;&gt;noninteractiveなmysql_secure_installationの実行&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://labs.cybridge.jp/cybridge/development/1312.html&#34;&gt;コードで実行！ mysql_secure_installation プロビジョニング | サイブリッジラボブログ&lt;/a&gt;にも書かれていますが、MySQL 5.5の頃はインタラクティブな入力を要求するシェルスクリプトだったので、中身を読んで等価な処理をすることができました。私も以前&lt;a href=&#34;https://github.com/hnakamur/ansible-playbooks/blob/490b782d57ed93442c981dab5612ff396027ba98/roles/mysql/server/files/mysql_secure_installation.sh&#34;&gt;等価なスクリプト&lt;/a&gt;を書いていました。&lt;/p&gt;

&lt;p&gt;しかし、5.7ではmysql_secure_installationはバイナリになってしまいました。 &lt;code&gt;man mysql_secure_installation&lt;/code&gt; で確認したところ、&lt;code&gt;--password&lt;/code&gt; もしくは &lt;code&gt;-p&lt;/code&gt; オプションはあるが無視して必ずパスワードプロンプトを出すと書いてありました。自動インストール用スクリプトでは困るのですが、&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L34-L35&#34;&gt;./.mysql_root_password.cnf&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[client]
password=${mysql_root_password}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といった内容のファイルを作って &lt;code&gt;--defaults-extra-file&lt;/code&gt; オプションで指定すれば回避できました。&lt;/p&gt;

&lt;p&gt;プロンプトが出て入力する部分は&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L38-L45&#34;&gt;標準入力にリダイレクトで流し込めば&lt;/a&gt; OKでした。ただし、MySQLのrootユーザのパスワードを変えるパターンは試してないです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L51-L101&#34;&gt;上記の入力に対する出力結果&lt;/a&gt;をコメントとして残しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MySQLのrootユーザのパスワードは変えない&lt;/li&gt;
&lt;li&gt;パスワードの強度チェッカーはインストールしない&lt;/li&gt;
&lt;li&gt;anonymousユーザは削除する&lt;/li&gt;
&lt;li&gt;リモートからのrootユーザのログインは許可しない&lt;/li&gt;
&lt;li&gt;testデータベースは削除&lt;/li&gt;
&lt;li&gt;権限をリロード&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という設定となっています。&lt;/p&gt;

&lt;p&gt;標準入力に流し込むのではなく &lt;code&gt;--use-default&lt;/code&gt; オプションを使うという手もあります。
&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L109-L163&#34;&gt;&amp;ndash;use-defaultの場合の出力結果&lt;/a&gt;もコメントとして残しています。 この場合の設定内容は以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MySQLのrootユーザのパスワードは変えない&lt;/li&gt;
&lt;li&gt;パスワードの強度チェッカーをSTRONGの強度に設定する&lt;/li&gt;
&lt;li&gt;anonymousユーザは削除する&lt;/li&gt;
&lt;li&gt;リモートからのrootユーザのログインは許可しない&lt;/li&gt;
&lt;li&gt;testデータベースは削除&lt;/li&gt;
&lt;li&gt;権限をリロード&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L123&#34;&gt;パスワードチェッカーのSTRONGの強度の説明&lt;/a&gt;によると、8文字以上で、文字種は数値、英字大文字、英字小文字、記号を全て含める必要があり、辞書に登録されている単語は弾くようです。実際には試してないので違うかもしれません。&lt;/p&gt;

&lt;h3 id=&#34;参考-debconf-set-selections-で設定した項目の削除方法:7b72d99f6277ee322df194c41a872720&#34;&gt;参考: debconf-set-selections で設定した項目の削除方法&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;debconf-set-selections&lt;/code&gt; で設定した項目は &lt;code&gt;debconf-get-selections&lt;/code&gt; で確認できますが、削除はどうするのかとググってみたら &lt;a href=&#34;http://serverfault.com/questions/332459/how-do-i-delete-values-from-the-debconf-database/332490#332490&#34;&gt;debian - How do I delete values from the debconf database? - Server Fault&lt;/a&gt; に説明を見つけました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo PURGE | debconf-communicate パッケージ名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにすると「パッケージ名」に対する全ての設定を削除できました (スクリプトでは使っていませんが、試行錯誤中に試しました)。
&lt;a href=&#34;https://www.debian.org/doc/packaging-manuals/debconf_specification.html#AEN106&#34;&gt;Configuration management&lt;/a&gt; にPURGEと他のコマンドについて説明があるとのことです。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:7b72d99f6277ee322df194c41a872720&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;というわけで何とか自動化出来ました。個人的にはインストール用のコマンドはコマンドラインオプションか環境変数を設定したらノンインタラクティブで実行できるように作っておいて欲しいなあと思います。インタラクティブにしたい場合もインタラクティブモードで起動するようなコマンドラインオプションをつけて、ダイアログで選択が終わったらそれに対応するコマンドラインオプションを指定して起動したかのように処理をするような作りにすればいいのではないでしょうか。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Goでグローバルなバッファを使いまわしてスタックトレースを取得するライブラリを書いてみた</title>
      <link>/blog/2015/08/31/go_stacktrace_library_with_global_buffer/</link>
      <pubDate>Mon, 31 Aug 2015 00:43:56 +0900</pubDate>
      
      <guid>/blog/2015/08/31/go_stacktrace_library_with_global_buffer/</guid>
      <description>

&lt;h2 id=&#34;背景と経緯:328f76ded598aa8f65807ce0ea1c89b5&#34;&gt;背景と経緯&lt;/h2&gt;

&lt;p&gt;Goでもエラー処理にpanicを使えばスタックトレースが出力されます。でも、ライブラリでは &lt;code&gt;panic&lt;/code&gt; するとエラー処理して続行したいときに困るのでpanicではなく &lt;code&gt;return err&lt;/code&gt; を使うのが普通です。すると今度はスタックトレースが取れないのが残念だと思っていました。エラーが出た箇所でログ出力はするとして、やはりスタックトレースがあるほうがその関数までの呼出経路がわかってデバッグが捗ります。&lt;/p&gt;

&lt;p&gt;標準ライブラリを見てみると、&lt;a href=&#34;http://golang.org/pkg/runtime/debug/#PrintStack&#34;&gt;runtime.debug.PrintStack()&lt;/a&gt; という便利そうな関数を見つけました。が、これは出力先が標準エラー出力固定となっています。私はログファイルに出したいんですよね。&lt;/p&gt;

&lt;p&gt;そこでドキュメントの関数のリンクをクリックしてソースを見てみます。
&lt;a href=&#34;http://golang.org/src/runtime/debug/stack.go?s=516:533#L15&#34;&gt;src/runtime/debug/stack.go - The Go Programming Language&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func PrintStack() {
  os.Stderr.Write(stack())
}

// Stack returns a formatted stack trace of the goroutine that calls it.
// For each routine, it includes the source line information and PC value,
// then attempts to discover, for Go functions, the calling function or
// method and the text of the line containing the invocation.
//
// Deprecated: Use package runtime&#39;s Stack instead.
func Stack() []byte {
  return stack()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;お、&lt;code&gt;Stack()&lt;/code&gt; のほうを使えば &lt;code&gt;[]byte&lt;/code&gt; で取得できるじゃないですか。あれ、でもdeprecatedなので &lt;a href=&#34;http://golang.org/pkg/runtime/#Stack&#34;&gt;runtime.Stack&lt;/a&gt; のほうを使えとあります。シグネチャ見ると &lt;code&gt;func Stack(buf []byte, all bool) int&lt;/code&gt; となっていて、こちらからバッファを渡す必要があるんですね。&lt;/p&gt;

&lt;p&gt;関数定義 &lt;a href=&#34;http://golang.org/src/runtime/mprof.go?s=15278:15314#L552&#34;&gt;src/runtime/mprof.go - The Go Programming Language&lt;/a&gt;を見てみると、バッファサイズが足りない場合は、途中までしか書かれないようです。またどれだけのサイズがあれば大丈夫かを調べる方法もないようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Stack(buf []byte, all bool) int {
  if all {
    stopTheWorld(&amp;quot;stack trace&amp;quot;)
  }

  n := 0
  if len(buf) &amp;gt; 0 {
    gp := getg()
    sp := getcallersp(unsafe.Pointer(&amp;amp;buf))
    pc := getcallerpc(unsafe.Pointer(&amp;amp;buf))
    systemstack(func() {
      g0 := getg()
      g0.writebuf = buf[0:0:len(buf)]
      goroutineheader(gp)
      traceback(pc, sp, 0, gp)
      if all {
        tracebackothers(gp)
      }
      n = len(g0.writebuf)
      g0.writebuf = nil
    })
  }

  if all {
    startTheWorld()
  }
  return n
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実はさっきの &lt;code&gt;stack()&lt;/code&gt; の定義&lt;a href=&#34;http://golang.org/src/runtime/debug/stack.go?s=516:533#L40&#34;&gt;src/runtime/debug/stack.go - The Go Programming Language&lt;/a&gt;を見ると&lt;a href=&#34;http://golang.org/pkg/runtime/#Caller&#34;&gt;runtime.Caller&lt;/a&gt;というより低レベルな関数があってこれを使って自前で実装すれば好きに作れそうではあります。&lt;/p&gt;

&lt;p&gt;しかし、私は手抜きで済ませたいので大きめのバッファをグローバルに予め確保しておいてそれを&lt;a href=&#34;http://golang.org/pkg/runtime/#Stack&#34;&gt;runtime.Stack&lt;/a&gt;に渡す方式にしました。
バッファを予め確保しておくのは、エラーが起きてからメモリ確保しようとして失敗するケースを避けたいからです。&lt;/p&gt;

&lt;p&gt;と言いつつ、&lt;a href=&#34;http://golang.org/pkg/runtime/#Stack&#34;&gt;runtime.Stack&lt;/a&gt;内でメモリ割り当てが発生するかまでは確認していません。&lt;/p&gt;

&lt;h2 id=&#34;実装と使い方:328f76ded598aa8f65807ce0ea1c89b5&#34;&gt;実装と使い方&lt;/h2&gt;

&lt;p&gt;というわけで実装してみました。レポジトリは&lt;a href=&#34;https://github.com/hnakamur/stacktrace&#34;&gt;hnakamur/stacktrace&lt;/a&gt;で、ライセンスはMITです。&lt;/p&gt;

&lt;p&gt;使用例はこちらです。&lt;a href=&#34;https://github.com/hnakamur/stacktrace/blob/ed0a2c8b61528e59f349f6c108a84a6b9dd8e981/example/main.go&#34;&gt;example.go&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
  &amp;quot;errors&amp;quot;
  &amp;quot;log&amp;quot;

  &amp;quot;github.com/hnakamur/stacktrace&amp;quot;
)

func logErrorWithStackTrace(msg interface{}) {
  log.Printf(&amp;quot;error: %s\nstacktrace: %s\n&amp;quot;, msg, stacktrace.LockBufAndGetStackWithSkip(2))
  defer stacktrace.UnlockBuf()
}

func b() {
  err := errors.New(&amp;quot;some error&amp;quot;)
  logErrorWithStackTrace(err)
}

func a() {
  b()
}

func main() {
  a()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずお好みのロギングライブラリ用にスタックトレースを取得してログ出力する関数を定義します。この例の場合は &lt;code&gt;logErrorWithStackTrace&lt;/code&gt; です。メモリ割り当て回数を最低限にしたかったので、 &lt;code&gt;stacktrace.LockBufAndGetStackWithSkip()&lt;/code&gt; はグローバルバッファをロックした状態でそのまま返すようにしています。ですので使い終わったら、&lt;code&gt;stacktrace.UnlockBuf()&lt;/code&gt; でロックを解放する必要があります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;stacktrace.LockBufAndGetStackWithSkip()&lt;/code&gt; の引数で2を渡しているのはスタックトレースから &lt;code&gt;stacktrace.LockBufAndGetStackWithSkip&lt;/code&gt; と &lt;code&gt;logErrorWithStackTrace&lt;/code&gt; の2つを除外するためです。&lt;/p&gt;

&lt;p&gt;出力例は以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go run main.go
2015/08/31 01:24:42 error: some error
stacktrace: goroutine 1 [running]:
main.b()
        /Users/hnakamur/gocode/src/github.com/hnakamur/stacktrace/example/main.go:17 +0xce
main.a()
        /Users/hnakamur/gocode/src/github.com/hnakamur/stacktrace/example/main.go:21 +0x14
main.main()
        /Users/hnakamur/gocode/src/github.com/hnakamur/stacktrace/example/main.go:25 +0x14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでスタックトレース付きのエラーログを簡単に出力できて快適ですね！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>自分のグローバルアドレスをOpenDNSとdigコマンドで調べる方法を試してみた</title>
      <link>/blog/2015/08/12/get_my_global_ip_address_with_opendns/</link>
      <pubDate>Wed, 12 Aug 2015 07:14:59 +0900</pubDate>
      
      <guid>/blog/2015/08/12/get_my_global_ip_address_with_opendns/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://unix.stackexchange.com/questions/22615/how-can-i-get-my-external-ip-address-in-bash/81699&#34;&gt;linux - How can I get my external IP address in bash? - Unix &amp;amp; Linux Stack Exchange&lt;/a&gt;を読んで試してみたのでメモです。&lt;/p&gt;

&lt;p&gt;この記事を読むまでは &lt;code&gt;curl -s http://ifconfig.me&lt;/code&gt; しか知りませんでした。&lt;/p&gt;

&lt;p&gt;処理時間を比べてみました（出力結果のIPアドレスは伏せ字XXX.XXX.XXX.XXXにしています）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time dig +short myip.opendns.com @resolver1.opendns.com
XXX.XXX.XXX.XXX

real    0m0.061s
user    0m0.010s
sys     0m0.016s
$ time curl -s http://whatismyip.akamai.com
XXX.XXX.XXX.XXX
real    0m0.571s
user    0m0.011s
sys     0m0.009s
$ time curl -s http://ifconfig.me
XXX.XXX.XXX.XXX

real    0m0.581s
user    0m0.011s
sys     0m0.007s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;私が試した環境では、whatismyip.akamai.comとifconfig.meにhttpで問い合わせる方法は約0.6秒弱ですが、OpenDNSにdigで問い合わせる方法だと約0.06秒と一桁速いということがわかりました。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>