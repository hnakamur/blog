<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on hnakamur&#39;s blog at github</title>
    <link>/blog/post/</link>
    <description>Recent content in Posts on hnakamur&#39;s blog at github</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Sun, 01 May 2016 22:36:19 +0900</lastBuildDate>
    <atom:link href="/blog/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>MacをPXEサーバにしてExpress5800/S70タイプRBにUbuntu16.04をインストールしてみた</title>
      <link>/blog/2016/05/01/install_ubuntu_xenial_with_pxe_boot/</link>
      <pubDate>Sun, 01 May 2016 22:36:19 +0900</pubDate>
      
      <guid>/blog/2016/05/01/install_ubuntu_xenial_with_pxe_boot/</guid>
      <description>

&lt;h2 id=&#34;背景:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;Goで書いたプログラムをMacBook Pro上で負荷試験をしていたら、ビーチボールカーソルが回りっぱなしになって大変でした。そういえば、負荷試験するときは極力余計なプロセスを止めて外界の影響を受けない状態でやるべきという話を思い出しました。&lt;/p&gt;

&lt;p&gt;そこで5年前に買ったけど、ここ2年は全く電源を入れていなかった自宅サーバを再び活用することにしました。起動してみるとCentOS 6.4が入っていました。せっかくなので人生初のPXEブートでUbuntu 16.04をインストールしてみました。ということで自分用メモです。&lt;/p&gt;

&lt;h2 id=&#34;サーバハードウェア構成:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;サーバハードウェア構成&lt;/h2&gt;

&lt;p&gt;ハードウェアの情報は有志のまとめWikiに詳しく載っています。
&lt;a href=&#34;http://pc.usy.jp/wiki/index.php?NEC%20Express5800%A1%BFS70%20%A5%BF%A5%A4%A5%D7RB&#34;&gt;NEC Express5800／S70 タイプRB - usyWiki&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;私のExpress5800の構成は以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Express5800/S70タイプRB&lt;/li&gt;
&lt;li&gt;CPU: Intel Pentium G6950 (2.8GHz)&lt;/li&gt;
&lt;li&gt;RAM: 16GBに増設済み&lt;/li&gt;
&lt;li&gt;SSD: Intel SSDSA2M160G2GC (換装済み)&lt;/li&gt;
&lt;li&gt;BIOS: Phoenix&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;macをpxeサーバにする:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;MacをPXEサーバにする&lt;/h2&gt;

&lt;p&gt;今まではこの方法を知らなくてPXEブートを諦めていたのですが、 &lt;a href=&#34;http://qiita.com/honeniq/items/d020368ea31b2f052a12&#34;&gt;MacをPXEサーバーにする - Qiita&lt;/a&gt; と &lt;a href=&#34;http://c-rtx.com/2015/09/21/macosx-pxe-server/&#34;&gt;MacOSXをPXEブートサーバーにしてLinuxのインストールに使う | C-RTX BLOG&lt;/a&gt; の記事のおかげで私にも出来ました。ありがとうございます！&lt;/p&gt;

&lt;h3 id=&#34;環境:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;環境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;MacBook Pro (Retina, Mid 2012)&lt;/li&gt;
&lt;li&gt;OS X El Capitan&lt;/li&gt;
&lt;li&gt;tftpd (OS X 標準)&lt;/li&gt;
&lt;li&gt;bootpd (OS X 標準)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;構成図:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;構成図&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;+--------+  Ethernet   +-------------+  Wi-Fi   +----------+ 
| Server | ----------&amp;gt; | MacBook Pro | -------&amp;gt; | Wi-Fi AP | -----&amp;gt; Internet
+--------+             +-------------+          +----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tftpdの起動とnetbootのファイル配置:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;tftpdの起動とnetbootのファイル配置&lt;/h3&gt;

&lt;p&gt;tftpd起動&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo launchctl load -w /System/Library/LaunchDaemons/tftp.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;osx上でのtftpについて私はよく知らないのですが、起動後&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo ps auxww | grep tftp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてもヒットしませんでした。&lt;/p&gt;

&lt;p&gt;以下のように実際に繋いでみて試すか、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tftp
tftp&amp;gt; quit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lsofで確認すれば大丈夫でした。後者は &lt;a href=&#34;http://qiita.com/tukiyo3/items/c9ca4bc6c62e78e80ae3&#34;&gt;Macでtftpサーバを起動 - Qiita&lt;/a&gt; を参考にしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lsof -i:69
COMMAND PID USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
launchd   1 root   42u  IPv6 0x4d07726546506a3f      0t0  UDP *:tftp
launchd   1 root   47u  IPv4 0x4d0772654650a3ff      0t0  UDP *:tftp
launchd   1 root   48u  IPv4 0x4d0772654650a3ff      0t0  UDP *:tftp
launchd   1 root   49u  IPv6 0x4d07726546506a3f      0t0  UDP *:tftp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ubuntuのセットアップが終わった後は以下のコマンドでtftpdを停止します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo launchctl unload /System/Library/LaunchDaemons/tftp.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/private/tftpboot/ 以下にUbuntuのネットワークインストールに必要なファイルを配置します。&lt;/p&gt;

&lt;p&gt;最初は &lt;a href=&#34;http://archive.ubuntu.com/ubuntu/dists/xenial/main/installer-amd64/current/images/netboot/&#34;&gt;http://archive.ubuntu.com/ubuntu/dists/xenial/main/installer-amd64/current/images/netboot/&lt;/a&gt; から pxelinux.0 をダウンロードして置いていたのですが、ブートしてみると他のファイルも必要なことがわかりました。&lt;/p&gt;

&lt;p&gt;試行錯誤した結果、 &lt;a href=&#34;https://www.ubuntulinux.jp/ubuntu/mirrors&#34;&gt;日本国内のダウンロードサイト | Ubuntu Japanese Team&lt;/a&gt; に載っているミラーの1つの &lt;a href=&#34;ftp://ftp.kddilabs.jp/Linux/packages/ubuntu/archive/dists/xenial/main/installer-amd64/current/images/netboot/&#34;&gt;ftp://ftp.kddilabs.jp/Linux/packages/ubuntu/archive/dists/xenial/main/installer-amd64/current/images/netboot/&lt;/a&gt; から netboot.tar.gz をダウンロードして展開すれば大丈夫でした。&lt;/p&gt;

&lt;h3 id=&#34;bootpd:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;bootpd&lt;/h3&gt;

&lt;p&gt;私がよくわかっていなくて、ここはちょっと苦労しました。まず、インターネット共有を切にした状態では /etc/bootpd.plist は以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
&amp;lt;dict&amp;gt;
	&amp;lt;key&amp;gt;bootp_enabled&amp;lt;/key&amp;gt;
	&amp;lt;false/&amp;gt;
	&amp;lt;key&amp;gt;detect_other_dhcp_server&amp;lt;/key&amp;gt;
	&amp;lt;false/&amp;gt;
	&amp;lt;key&amp;gt;dhcp_enabled&amp;lt;/key&amp;gt;
	&amp;lt;false/&amp;gt;
	&amp;lt;key&amp;gt;dhcp_ignore_client_identifier&amp;lt;/key&amp;gt;
	&amp;lt;true/&amp;gt;
	&amp;lt;key&amp;gt;use_server_config_for_dhcp_options&amp;lt;/key&amp;gt;
	&amp;lt;false/&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「システム環境設定」→「共有」と進んで「インターネット共有」のチェックボックスをオンにしようとしたのですが、画面中央に「接続を共有するためのポートを選択していないため、インターネット共有を開始できません。」と表示されていてオンにならない状態でした。&lt;/p&gt;

&lt;p&gt;試行錯誤した結果、MacをWi-FiでWi-Fi AP (Time Capsule)に繋ぎつつ&lt;a href=&#34;http://www.apple.com/jp/shop/product/MD463ZM/A/apple-thunderbolt%E3%82%AE%E3%82%AC%E3%83%93%E3%83%83%E3%83%88ethernet%E3%82%A2%E3%83%80%E3%83%97%E3%82%BF?afid=p238%7CsKTonmsKf-dc_mtid_18707vxu38484_pcrid_96182712077_&amp;amp;cid=aos-jp-kwg-pla-btb-product-MD463ZM/A&#34;&gt;Apple Thunderbolt - ギガビットEthernetアダプタ - Apple (日本)&lt;/a&gt;でも有線で繋いだ状態で、「共有する接続経路」で「Wi-Fi」を選び、「相手のコンピュータでのポート」で「Thunderbolt Ethernet」にチェックをつけた状態で「インターネット共有」にチェックをつけるとうまくいきました。&lt;/p&gt;

&lt;p&gt;この時はよく分かってなかったのですが、参考にした記事にもある通り、Express 5800のLANケーブルはMacに繋ぐのが正しいです。上記の構成図も正しい構成のほうを書いています。&lt;/p&gt;

&lt;p&gt;この状態で5秒ぐらいすると /etc/bootpd.plist が以下のように変更されました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
&amp;lt;dict&amp;gt;
	&amp;lt;key&amp;gt;Subnets&amp;lt;/key&amp;gt;
	&amp;lt;array&amp;gt;
		&amp;lt;dict&amp;gt;
			&amp;lt;key&amp;gt;_creator&amp;lt;/key&amp;gt;
			&amp;lt;string&amp;gt;com.apple.NetworkSharing&amp;lt;/string&amp;gt;
			&amp;lt;key&amp;gt;allocate&amp;lt;/key&amp;gt;
			&amp;lt;true/&amp;gt;
			&amp;lt;key&amp;gt;dhcp_domain_name_server&amp;lt;/key&amp;gt;
			&amp;lt;array&amp;gt;
				&amp;lt;string&amp;gt;192.168.2.1&amp;lt;/string&amp;gt;
			&amp;lt;/array&amp;gt;
			&amp;lt;key&amp;gt;dhcp_router&amp;lt;/key&amp;gt;
			&amp;lt;string&amp;gt;192.168.2.1&amp;lt;/string&amp;gt;
			&amp;lt;key&amp;gt;interface&amp;lt;/key&amp;gt;
			&amp;lt;string&amp;gt;bridge100&amp;lt;/string&amp;gt;
			&amp;lt;key&amp;gt;lease_max&amp;lt;/key&amp;gt;
			&amp;lt;integer&amp;gt;86400&amp;lt;/integer&amp;gt;
			&amp;lt;key&amp;gt;lease_min&amp;lt;/key&amp;gt;
			&amp;lt;integer&amp;gt;86400&amp;lt;/integer&amp;gt;
			&amp;lt;key&amp;gt;name&amp;lt;/key&amp;gt;
			&amp;lt;string&amp;gt;192.168.2/24&amp;lt;/string&amp;gt;
			&amp;lt;key&amp;gt;net_address&amp;lt;/key&amp;gt;
			&amp;lt;string&amp;gt;192.168.2.0&amp;lt;/string&amp;gt;
			&amp;lt;key&amp;gt;net_mask&amp;lt;/key&amp;gt;
			&amp;lt;string&amp;gt;255.255.255.0&amp;lt;/string&amp;gt;
			&amp;lt;key&amp;gt;net_range&amp;lt;/key&amp;gt;
			&amp;lt;array&amp;gt;
				&amp;lt;string&amp;gt;192.168.2.2&amp;lt;/string&amp;gt;
				&amp;lt;string&amp;gt;192.168.2.254&amp;lt;/string&amp;gt;
			&amp;lt;/array&amp;gt;
		&amp;lt;/dict&amp;gt;
	&amp;lt;/array&amp;gt;
	&amp;lt;key&amp;gt;bootp_enabled&amp;lt;/key&amp;gt;
	&amp;lt;false/&amp;gt;
	&amp;lt;key&amp;gt;detect_other_dhcp_server&amp;lt;/key&amp;gt;
	&amp;lt;array&amp;gt;
		&amp;lt;string&amp;gt;bridge100&amp;lt;/string&amp;gt;
	&amp;lt;/array&amp;gt;
	&amp;lt;key&amp;gt;dhcp_enabled&amp;lt;/key&amp;gt;
	&amp;lt;array&amp;gt;
		&amp;lt;string&amp;gt;bridge100&amp;lt;/string&amp;gt;
	&amp;lt;/array&amp;gt;
	&amp;lt;key&amp;gt;dhcp_ignore_client_identifier&amp;lt;/key&amp;gt;
	&amp;lt;true/&amp;gt;
	&amp;lt;key&amp;gt;ignore_allow_deny&amp;lt;/key&amp;gt;
	&amp;lt;array&amp;gt;
		&amp;lt;string&amp;gt;bridge100&amp;lt;/string&amp;gt;
	&amp;lt;/array&amp;gt;
	&amp;lt;key&amp;gt;use_server_config_for_dhcp_options&amp;lt;/key&amp;gt;
	&amp;lt;false/&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Subnets キーの &lt;code&gt;&amp;lt;/dict&amp;gt;&lt;/code&gt; の前に以下の設定を追加します。 &lt;code&gt;cHhlbGludXguMAA=&lt;/code&gt; は &lt;code&gt;pxelinux.0&lt;/code&gt; をBase64エンコーディングした値です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;		&amp;lt;key&amp;gt;dhcp_option_66&amp;lt;/key&amp;gt;
		&amp;lt;string&amp;gt;192.168.2.1&amp;lt;/string&amp;gt;
		&amp;lt;key&amp;gt;dhcp_option_67&amp;lt;/key&amp;gt;
		&amp;lt;data&amp;gt;cHhlbGludXguMAA=&amp;lt;/data&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで追記した内容を反映させる際に、「システム環境設定」の「共有」で「インターネット共有」をオフ→オンにすると設定ファイルが元に戻されてしまってダメでした。&lt;/p&gt;

&lt;p&gt;/etc/bootpd.plist を書き換えた後、以下のようにコマンドで bootpd を再起動すると大丈夫でした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo launchctl unload /System/Library/LaunchDaemons/bootps.plist
sudo launchctl load -w /System/Library/LaunchDaemons/bootps.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/etc/bootpub を作成・編集して固定アサインの設定もやっておきました。
が、今思えば私はこれはいらないかなと思います。後述の通り、ネットワークブートが終わったらLANケーブルを繋ぎ変えて、Wi-Fi APのDHCPを使ってIPアドレスを取得してその後のインストールを行うので。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# hostname      hwtype  hwaddr              ipaddr          bootfile
client1         1       01:02:03:04:05:06   192.168.2.11    pxelinux.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hwaddrの値は実際には事前に Express 5800 で &lt;code&gt;ip a&lt;/code&gt; で調べたMACアドレスに書き換えました。PXEブート中にもMACアドレスが表示されていたのでそれを見て書き換えるのでも良さそうです。&lt;/p&gt;

&lt;p&gt;Macで &lt;code&gt;ifconfig&lt;/code&gt; を実行すると &lt;code&gt;bridge100&lt;/code&gt; というのが作られていました。最初は &lt;code&gt;bridge0&lt;/code&gt; というのが作られたのですが、このときは接続を間違えていて ServerをWi-Fi APに有線でつなぎ、MacはWi-Fi APにWi-Fiと有線でつないでいました。&lt;/p&gt;

&lt;p&gt;その後上記の構成図の配線に修正したりしているうちに &lt;code&gt;bridge0&lt;/code&gt; とは別に &lt;code&gt;bridge100&lt;/code&gt; というのが作られていました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ifconfig&lt;/code&gt; の結果は以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ifconfig
...(snip)...
bridge100: flags=8863&amp;lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&amp;gt; mtu 1500
        options=3&amp;lt;RXCSUM,TXCSUM&amp;gt;
        ether ba:f6:b1:71:3c:64
        inet 192.168.2.1 netmask 0xffffff00 broadcast 192.168.2.255
        inet6 fe80::b8f6:b1ff:fe71:3c64%bridge100 prefixlen 64 scopeid 0x12
        Configuration:
                id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0
                maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200
                root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0
                ipfilter disabled flags 0x2
        member: en4 flags=3&amp;lt;LEARNING,DISCOVER&amp;gt;
                ifmaxaddr 0 port 17 priority 0 path cost 0
        nd6 options=1&amp;lt;PERFORMNUD&amp;gt;
        media: autoselect
        status: active
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;os-xのファイアウォールを切る必要はない:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;OS Xのファイアウォールを切る必要はない&lt;/h3&gt;

&lt;p&gt;初回はたぶんファイアウォールは切る必要があるだろうと思って切っておきました。&lt;/p&gt;

&lt;p&gt;「システム環境設定」→「セキュリティとプライバシー」→「ファイアウォール」タブ
左下の「変更するにはカギをクリックします」を押してパスワードを入力し、
「ファイアウォールを切にする」ボタンを押してオフにしました。&lt;/p&gt;

&lt;p&gt;Ubuntuのインストールが終わったら「ファイアウォールを入にする」ボタンを押して
オンに戻しておきます。&lt;/p&gt;

&lt;p&gt;が、2回目の検証でファイアウォールを切らなくても大丈夫なことがわかりました。&lt;/p&gt;

&lt;h3 id=&#34;phoenix-biosでpxeブートを有効にする:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;Phoenix BIOSでPXEブートを有効にする&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://changineer.info/server/server_hardware_management/server_hardware_bios.html#Phoenix_BIOS_8211BIOS_PXE_boot&#34;&gt;BIOS 設定方法&lt;/a&gt;を参考にしました。&lt;/p&gt;

&lt;p&gt;Express 5800を再起動し、起動時に[F2]キーを押してPhoenix BIOSの設定画面に入ります。カーソルキーの左右で[Boot]メニューを選びます。私はPXEブートを無効にしていたので、[PCI BEV]は画面下部の[Excluded from boot order:]のほうにありました。カーソルキーの上下で[PCI BEV]を選んでxキーを押し、画面上部の[Boot priority order:]のほうに移動します。
その後テンキーの+を押して[PCI BEV]を1番上に持ってきます。購入時に同梱されていた日本語キーボードを使っているのですがフルキーの-は効くのですが+ (Shift+;)は効きませんでした。&lt;/p&gt;

&lt;p&gt;なお、一旦有効にした後は[PCI BEV]の項目は[PCI BEV: IBA GE Slot 00C8 v1352]という表示になっていました。&lt;/p&gt;

&lt;p&gt;変更したら[F10]を押してBIOSの設定を保存して終了します。&lt;/p&gt;

&lt;p&gt;Ubuntuの設定が終わったら[PCI BEV]を[Excluded from boot order:]のほうに戻しておきます。&lt;/p&gt;

&lt;h3 id=&#34;pxeブートでubuntuのインストール:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;PXEブートでUbuntuのインストール&lt;/h3&gt;

&lt;p&gt;Express 5800を再起動すると、Ubuntuのインストーラが起動しました。
予めMacで &lt;code&gt;tail -f /var/log/system.log | grep DHCP&lt;/code&gt; を実行しておくとDHCPのログが確認できました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tail -f /var/log/system.log | grep DHCP
May  2 00:55:44 machostname bootpd[8589]: DHCP REQUEST [bridge100]: 1,01:02:03:04:05:06
May  2 00:56:37 machostname bootpd[8589]: DHCP DISCOVER [bridge100]: 1,01:02:03:04:05:06
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際には &lt;code&gt;machostname&lt;/code&gt; の部分はMacBook Proのホスト名が、 &lt;code&gt;01:02:03:04:05:06&lt;/code&gt; の部分は Express 5800 のネットワークカードのMACアドレスが出力されていますが、セキュリティ上伏せています。&lt;/p&gt;

&lt;p&gt;後は普通にUbuntuのインストーラに沿ってインストールすれば良いのですが、インストーラが起動した後はMacを経由せずに通信するほうが効率が良いので、Express 5800とMacをつないでいるLANケーブルをMacから外してWi-Fi APに繋ぎ直します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------+  Ethernet   +----------+ 
| Server | ----------&amp;gt; | Wi-Fi AP | -----&amp;gt; Internet
+--------+             +----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストーラの「Ubuntu アーカイブのミラーを選択」のところで「戻る」を選び、
「Ubuntu インストーラメインメニュー」で「ネットワークの設定」を選びます。
するとDHCPでIPアドレスを再取得してくれます。&lt;/p&gt;

&lt;h3 id=&#34;ubuntuのセットアップ:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;Ubuntuのセットアップ&lt;/h3&gt;

&lt;p&gt;以下はUbuntuのセットアップのメモです。&lt;/p&gt;

&lt;p&gt;ホームパーティションの暗号化とパーティショニングの暗号化LVMを選んでみました。
後者を選ぶと暗号化用のパスフレーズを求められるので設定します。設定するとサーバの起動時にパスフレーズの入力が必要になります。&lt;/p&gt;

&lt;p&gt;インストールするソフトウェアの選択では以下の3つを選びました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;標準システムユーティリティ&lt;/li&gt;
&lt;li&gt;OpenSSH server&lt;/li&gt;
&lt;li&gt;Basic Ubuntu server&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GRUBブートローダはSSDのデバイスにインストールしました。&lt;/p&gt;

&lt;p&gt;タイムゾーンは日本にし、システム時間はUTCにしました。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:7c8148b4a0be8b5912c049d4f8205326&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;PXEブート便利です！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go-daemonとgoのos.StartProcess()のコードを読んでみた</title>
      <link>/blog/2016/04/23/go-daemon-and-golang-os-startprocess-code-reading/</link>
      <pubDate>Sat, 23 Apr 2016 16:45:09 +0900</pubDate>
      
      <guid>/blog/2016/04/23/go-daemon-and-golang-os-startprocess-code-reading/</guid>
      <description>

&lt;h2 id=&#34;発端-goでデーモンを書くのは無理と思っていたら実は出来るらしい:2b5c8b3f2d099ab733ab91c60a7ca6a5&#34;&gt;発端: Goでデーモンを書くのは無理と思っていたら実は出来るらしい&lt;/h2&gt;

&lt;p&gt;Goでデーモンを書くのは無理と以前どこかで読んだ気がします。
ところが、Pythonで書かれた&lt;a href=&#34;https://github.com/graphite-project&#34;&gt;Graphite Project&lt;/a&gt;の&lt;a href=&#34;https://github.com/graphite-project/carbon&#34;&gt;carbon&lt;/a&gt;をGo言語で実装した&lt;a href=&#34;https://github.com/lomik/go-carbon&#34;&gt;lomik/go-carbon&lt;/a&gt;の Features に Run as daemon と書かれていました。どうやって実現しているのか気になって調べてみたのでメモです。&lt;/p&gt;

&lt;h2 id=&#34;go-carbonでデーモン化するための設定:2b5c8b3f2d099ab733ab91c60a7ca6a5&#34;&gt;go-carbonでデーモン化するための設定&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lomik/go-carbon#configuration&#34;&gt;Configuration&lt;/a&gt;に書いてありますが、設定ファイルの &lt;code&gt;[common]&lt;/code&gt; セクションの &lt;code&gt;user&lt;/code&gt; を指定して、起動オプションに &lt;code&gt;-daemon&lt;/code&gt; を指定すればデーモンとして起動します。&lt;/p&gt;

&lt;h2 id=&#34;コードリーディング:2b5c8b3f2d099ab733ab91c60a7ca6a5&#34;&gt;コードリーディング&lt;/h2&gt;

&lt;p&gt;デーモンとして起動するためのコードは以下のようになっています。
&lt;a href=&#34;https://github.com/lomik/go-carbon/blob/v0.7.1/carbon-agent.go#L103-L137&#34;&gt;https://github.com/lomik/go-carbon/blob/v0.7.1/carbon-agent.go#L103-L137&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if *isDaemon {
		runtime.LockOSThread()

		context := new(daemon.Context)
		if *pidfile != &amp;quot;&amp;quot; {
			context.PidFileName = *pidfile
			context.PidFilePerm = 0644
		}

		if runAsUser != nil {
			uid, err := strconv.ParseInt(runAsUser.Uid, 10, 0)
			if err != nil {
				log.Fatal(err)
			}

			gid, err := strconv.ParseInt(runAsUser.Gid, 10, 0)
			if err != nil {
				log.Fatal(err)
			}

			context.Credential = &amp;amp;syscall.Credential{
				Uid: uint32(uid),
				Gid: uint32(gid),
			}
		}

		child, _ := context.Reborn()

		if child != nil {
			return
		}
		defer context.Release()

		runtime.UnlockOSThread()
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;daemon.Context&lt;/code&gt; は &lt;a href=&#34;https://github.com/sevlyar/go-daemon&#34;&gt;github.com/sevlyar/go-daemon&lt;/a&gt;のfork版の &lt;a href=&#34;https://github.com/lomik/go-daemon&#34;&gt;github.com/lomik/go-daemon&lt;/a&gt;で定義されています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lomik/go-daemon/blob/205ceae1aeac90abdbcae9fca16ba44b407c598d/daemon_posix.go#L20-L61&#34;&gt;Contextの定義&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// A Context describes daemon context.
type Context struct {
	// If PidFileName is non-empty, parent process will try to create and lock
	// pid file with given name. Child process writes process id to file.
	PidFileName string
	// Permissions for new pid file.
	PidFilePerm os.FileMode

	// If LogFileName is non-empty, parent process will create file with given name
	// and will link to fd 2 (stderr) for child process.
	LogFileName string
	// Permissions for new log file.
	LogFilePerm os.FileMode

	// If WorkDir is non-empty, the child changes into the directory before
	// creating the process.
	WorkDir string
	// If Chroot is non-empty, the child changes root directory
	Chroot string

	// If Env is non-nil, it gives the environment variables for the
	// daemon-process in the form returned by os.Environ.
	// If it is nil, the result of os.Environ will be used.
	Env []string
	// If Args is non-nil, it gives the command-line args for the
	// daemon-process. If it is nil, the result of os.Args will be used
	// (without program name).
	Args []string

	// Credential holds user and group identities to be assumed by a daemon-process.
	Credential *syscall.Credential
	// If Umask is non-zero, the daemon-process call Umask() func with given value.
	Umask int

	// Struct contains only serializable public fields (!!!)
	abspath  string
	pidFile  *LockFile
	logFile  *os.File
	nullFile *os.File

	rpipe, wpipe *os.File
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go-carbonのcarbon-agent.goから呼び出していた &lt;code&gt;Context.Reborn()&lt;/code&gt; の定義はこちらです。
&lt;a href=&#34;https://github.com/lomik/go-daemon/blob/205ceae1aeac90abdbcae9fca16ba44b407c598d/daemon_posix.go#L63-L76&#34;&gt;Context.Reborn()&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Reborn runs second copy of current process in the given context.
// function executes separate parts of code in child process and parent process
// and provides demonization of child process. It look similar as the
// fork-daemonization, but goroutine-safe.
// In success returns *os.Process in parent process and nil in child process.
// Otherwise returns error.
func (d *Context) Reborn() (child *os.Process, err error) {
	if !WasReborn() {
		child, err = d.parent()
	} else {
		err = d.child()
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてここで読んでいる &lt;code&gt;Context.parent()&lt;/code&gt; の定義がこちらです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lomik/go-daemon/blob/205ceae1aeac90abdbcae9fca16ba44b407c598d/daemon_posix.go#L97-L130&#34;&gt;Context.parent()&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (d *Context) parent() (child *os.Process, err error) {
	if err = d.prepareEnv(); err != nil {
		return
	}

	defer d.closeFiles()
	if err = d.openFiles(); err != nil {
		return
	}

	attr := &amp;amp;os.ProcAttr{
		Dir:   d.WorkDir,
		Env:   d.Env,
		Files: d.files(),
		Sys: &amp;amp;syscall.SysProcAttr{
			//Chroot:     d.Chroot,
			Credential: d.Credential,
			Setsid:     true,
		},
	}

	if child, err = os.StartProcess(d.abspath, d.Args, attr); err != nil {
		if d.pidFile != nil {
			d.pidFile.Remove()
		}
		return
	}

	d.rpipe.Close()
	encoder := json.NewEncoder(d.wpipe)
	err = encoder.Encode(d)

	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Goの標準ライブラリで &lt;code&gt;os.StartProcess()&lt;/code&gt; というのがあったんですね。APIドキュメントはこちらです。&lt;a href=&#34;https://golang.org/pkg/os/#StartProcess&#34;&gt;os.StartProcess()&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/os/doc.go#L20-L29&#34;&gt;os.StartProcess()の実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// StartProcess starts a new process with the program, arguments and attributes
// specified by name, argv and attr.
//
// StartProcess is a low-level interface. The os/exec package provides
// higher-level interfaces.
//
// If there is an error, it will be of type *PathError.
func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error) {
	return startProcess(name, argv, attr)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/os/exec.go#L34-L56&#34;&gt;os.ProcAttrの定義&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ProcAttr holds the attributes that will be applied to a new process
// started by StartProcess.
type ProcAttr struct {
	// If Dir is non-empty, the child changes into the directory before
	// creating the process.
	Dir string
	// If Env is non-nil, it gives the environment variables for the
	// new process in the form returned by Environ.
	// If it is nil, the result of Environ will be used.
	Env []string
	// Files specifies the open files inherited by the new process.  The
	// first three entries correspond to standard input, standard output, and
	// standard error.  An implementation may support additional entries,
	// depending on the underlying operating system.  A nil entry corresponds
	// to that file being closed when the process starts.
	Files []*File

	// Operating system-specific process creation attributes.
	// Note that setting this field means that your program
	// may not execute properly or even compile on some
	// operating systems.
	Sys *syscall.SysProcAttr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここからはOS依存になりますが、Linuxの実装を見ていきます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_linux.go#L21-L41&#34;&gt;SysProcAttrのLinuxでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type SysProcAttr struct {
	Chroot      string         // Chroot.
	Credential  *Credential    // Credential.
	Ptrace      bool           // Enable tracing.
	Setsid      bool           // Create session.
	Setpgid     bool           // Set process group ID to Pgid, or, if Pgid == 0, to new pid.
	Setctty     bool           // Set controlling terminal to fd Ctty (only meaningful if Setsid is set)
	Noctty      bool           // Detach fd 0 from controlling terminal
	Ctty        int            // Controlling TTY fd
	Foreground  bool           // Place child&#39;s process group in foreground. (Implies Setpgid. Uses Ctty as fd of controlling TTY)
	Pgid        int            // Child&#39;s process group ID if Setpgid.
	Pdeathsig   Signal         // Signal that the process will get when its parent dies (Linux only)
	Cloneflags  uintptr        // Flags for clone calls (Linux only)
	UidMappings []SysProcIDMap // User ID mappings for user namespaces.
	GidMappings []SysProcIDMap // Group ID mappings for user namespaces.
	// GidMappingsEnableSetgroups enabling setgroups syscall.
	// If false, then setgroups syscall will be disabled for the child process.
	// This parameter is no-op if GidMappings == nil. Otherwise for unprivileged
	// users this should be set to false for mappings work.
	GidMappingsEnableSetgroups bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_unix.go#L112-L118&#34;&gt;syscall.CredentialのLinuxなどでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Credential holds user and group identities to be assumed
// by a child process started by StartProcess.
type Credential struct {
	Uid    uint32   // User ID.
	Gid    uint32   // Group ID.
	Groups []uint32 // Supplementary group IDs.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/os/exec_posix.go#L21-L50&#34;&gt;os.startProcess()のLinuxなどでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error) {
	// If there is no SysProcAttr (ie. no Chroot or changed
	// UID/GID), double-check existence of the directory we want
	// to chdir into.  We can make the error clearer this way.
	if attr != nil &amp;amp;&amp;amp; attr.Sys == nil &amp;amp;&amp;amp; attr.Dir != &amp;quot;&amp;quot; {
		if _, err := Stat(attr.Dir); err != nil {
			pe := err.(*PathError)
			pe.Op = &amp;quot;chdir&amp;quot;
			return nil, pe
		}
	}

	sysattr := &amp;amp;syscall.ProcAttr{
		Dir: attr.Dir,
		Env: attr.Env,
		Sys: attr.Sys,
	}
	if sysattr.Env == nil {
		sysattr.Env = Environ()
	}
	for _, f := range attr.Files {
		sysattr.Files = append(sysattr.Files, f.Fd())
	}

	pid, h, e := syscall.StartProcess(name, argv, sysattr)
	if e != nil {
		return nil, &amp;amp;PathError{&amp;quot;fork/exec&amp;quot;, name, e}
	}
	return newProcess(pid, h), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_unix.go#L120-L127&#34;&gt;os.ProcAttrのLinuxなどでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ProcAttr holds attributes that will be applied to a new process started
// by StartProcess.
type ProcAttr struct {
	Dir   string    // Current working directory.
	Env   []string  // Environment.
	Files []uintptr // File descriptors.
	Sys   *SysProcAttr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_unix.go#L238-L242&#34;&gt;syscall.StartProcess()のLinuxなどでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// StartProcess wraps ForkExec for package os.
func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle uintptr, err error) {
	pid, err = forkExec(argv0, argv, attr)
	return pid, 0, err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_unix.go#L132-L231&#34;&gt;syscall.forkExec()のLinuxなどでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error) {
	var p [2]int
	var n int
	var err1 Errno
	var wstatus WaitStatus

	if attr == nil {
		attr = &amp;amp;zeroProcAttr
	}
	sys := attr.Sys
	if sys == nil {
		sys = &amp;amp;zeroSysProcAttr
	}

	p[0] = -1
	p[1] = -1

	// Convert args to C form.
	argv0p, err := BytePtrFromString(argv0)
	if err != nil {
		return 0, err
	}
	argvp, err := SlicePtrFromStrings(argv)
	if err != nil {
		return 0, err
	}
	envvp, err := SlicePtrFromStrings(attr.Env)
	if err != nil {
		return 0, err
	}

	if (runtime.GOOS == &amp;quot;freebsd&amp;quot; || runtime.GOOS == &amp;quot;dragonfly&amp;quot;) &amp;amp;&amp;amp; len(argv[0]) &amp;gt; len(argv0) {
		argvp[0] = argv0p
	}

	var chroot *byte
	if sys.Chroot != &amp;quot;&amp;quot; {
		chroot, err = BytePtrFromString(sys.Chroot)
		if err != nil {
			return 0, err
		}
	}
	var dir *byte
	if attr.Dir != &amp;quot;&amp;quot; {
		dir, err = BytePtrFromString(attr.Dir)
		if err != nil {
			return 0, err
		}
	}

	// Acquire the fork lock so that no other threads
	// create new fds that are not yet close-on-exec
	// before we fork.
	ForkLock.Lock()

	// Allocate child status pipe close on exec.
	if err = forkExecPipe(p[:]); err != nil {
		goto error
	}

	// Kick off child.
	pid, err1 = forkAndExecInChild(argv0p, argvp, envvp, chroot, dir, attr, sys, p[1])
	if err1 != 0 {
		err = Errno(err1)
		goto error
	}
	ForkLock.Unlock()

	// Read child error status from pipe.
	Close(p[1])
	n, err = readlen(p[0], (*byte)(unsafe.Pointer(&amp;amp;err1)), int(unsafe.Sizeof(err1)))
	Close(p[0])
	if err != nil || n != 0 {
		if n == int(unsafe.Sizeof(err1)) {
			err = Errno(err1)
		}
		if err == nil {
			err = EPIPE
		}

		// Child failed; wait for it to exit, to make sure
		// the zombies don&#39;t accumulate.
		_, err1 := Wait4(pid, &amp;amp;wstatus, 0, nil)
		for err1 == EINTR {
			_, err1 = Wait4(pid, &amp;amp;wstatus, 0, nil)
		}
		return 0, err
	}

	// Read got EOF, so pipe closed on exec, so exec succeeded.
	return pid, nil

error:
	if p[0] &amp;gt;= 0 {
		Close(p[0])
		Close(p[1])
	}
	ForkLock.Unlock()
	return 0, err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いよいよ核心に迫ります。
&lt;a href=&#34;https://github.com/golang/go/blob/go1.6.2/src/syscall/exec_linux.go#L47-L325&#34;&gt;syscall.forkAndExecInChild()のLinuxでの実装&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Fork, dup fd onto 0..len(fd), and exec(argv0, argvv, envv) in child.
// If a dup or exec fails, write the errno error to pipe.
// (Pipe is close-on-exec so if exec succeeds, it will be closed.)
// In the child, this function must not acquire any locks, because
// they might have been locked at the time of the fork.  This means
// no rescheduling, no malloc calls, and no new stack segments.
// For the same reason compiler does not race instrument it.
// The calls to RawSyscall are okay because they are assembly
// functions that do not grow the stack.
//go:norace
func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr *ProcAttr, sys *SysProcAttr, pipe int) (pid int, err Errno) {
	// Declare all variables at top in case any
	// declarations require heap allocation (e.g., err1).
	var (
		r1     uintptr
		err1   Errno
		err2   Errno
		nextfd int
		i      int
		p      [2]int
	)

	// Record parent PID so child can test if it has died.
	ppid, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)

	// Guard against side effects of shuffling fds below.
	// Make sure that nextfd is beyond any currently open files so
	// that we can&#39;t run the risk of overwriting any of them.
	fd := make([]int, len(attr.Files))
	nextfd = len(attr.Files)
	for i, ufd := range attr.Files {
		if nextfd &amp;lt; int(ufd) {
			nextfd = int(ufd)
		}
		fd[i] = int(ufd)
	}
	nextfd++

	// Allocate another pipe for parent to child communication for
	// synchronizing writing of User ID/Group ID mappings.
	if sys.UidMappings != nil || sys.GidMappings != nil {
		if err := forkExecPipe(p[:]); err != nil {
			return 0, err.(Errno)
		}
	}

	// About to call fork.
	// No more allocation or calls of non-assembly functions.
	runtime_BeforeFork()
	r1, _, err1 = RawSyscall6(SYS_CLONE, uintptr(SIGCHLD)|sys.Cloneflags, 0, 0, 0, 0, 0)
	if err1 != 0 {
		runtime_AfterFork()
		return 0, err1
	}

	if r1 != 0 {
		// parent; return PID
		runtime_AfterFork()
		pid = int(r1)

		if sys.UidMappings != nil || sys.GidMappings != nil {
			Close(p[0])
			err := writeUidGidMappings(pid, sys)
			if err != nil {
				err2 = err.(Errno)
			}
			RawSyscall(SYS_WRITE, uintptr(p[1]), uintptr(unsafe.Pointer(&amp;amp;err2)), unsafe.Sizeof(err2))
			Close(p[1])
		}

		return pid, 0
	}

	// Fork succeeded, now in child.

	// Wait for User ID/Group ID mappings to be written.
	if sys.UidMappings != nil || sys.GidMappings != nil {
		if _, _, err1 = RawSyscall(SYS_CLOSE, uintptr(p[1]), 0, 0); err1 != 0 {
			goto childerror
		}
		r1, _, err1 = RawSyscall(SYS_READ, uintptr(p[0]), uintptr(unsafe.Pointer(&amp;amp;err2)), unsafe.Sizeof(err2))
		if err1 != 0 {
			goto childerror
		}
		if r1 != unsafe.Sizeof(err2) {
			err1 = EINVAL
			goto childerror
		}
		if err2 != 0 {
			err1 = err2
			goto childerror
		}
	}

	// Enable tracing if requested.
	if sys.Ptrace {
		_, _, err1 = RawSyscall(SYS_PTRACE, uintptr(PTRACE_TRACEME), 0, 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Session ID
	if sys.Setsid {
		_, _, err1 = RawSyscall(SYS_SETSID, 0, 0, 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Set process group
	if sys.Setpgid || sys.Foreground {
		// Place child in process group.
		_, _, err1 = RawSyscall(SYS_SETPGID, 0, uintptr(sys.Pgid), 0)
		if err1 != 0 {
			goto childerror
		}
	}

	if sys.Foreground {
		pgrp := int32(sys.Pgid)
		if pgrp == 0 {
			r1, _, err1 = RawSyscall(SYS_GETPID, 0, 0, 0)
			if err1 != 0 {
				goto childerror
			}

			pgrp = int32(r1)
		}

		// Place process group in foreground.
		_, _, err1 = RawSyscall(SYS_IOCTL, uintptr(sys.Ctty), uintptr(TIOCSPGRP), uintptr(unsafe.Pointer(&amp;amp;pgrp)))
		if err1 != 0 {
			goto childerror
		}
	}

	// Chroot
	if chroot != nil {
		_, _, err1 = RawSyscall(SYS_CHROOT, uintptr(unsafe.Pointer(chroot)), 0, 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// User and groups
	if cred := sys.Credential; cred != nil {
		ngroups := uintptr(len(cred.Groups))
		if ngroups &amp;gt; 0 {
			groups := unsafe.Pointer(&amp;amp;cred.Groups[0])
			_, _, err1 = RawSyscall(SYS_SETGROUPS, ngroups, uintptr(groups), 0)
			if err1 != 0 {
				goto childerror
			}
		}
		_, _, err1 = RawSyscall(SYS_SETGID, uintptr(cred.Gid), 0, 0)
		if err1 != 0 {
			goto childerror
		}
		_, _, err1 = RawSyscall(SYS_SETUID, uintptr(cred.Uid), 0, 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Chdir
	if dir != nil {
		_, _, err1 = RawSyscall(SYS_CHDIR, uintptr(unsafe.Pointer(dir)), 0, 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Parent death signal
	if sys.Pdeathsig != 0 {
		_, _, err1 = RawSyscall6(SYS_PRCTL, PR_SET_PDEATHSIG, uintptr(sys.Pdeathsig), 0, 0, 0, 0)
		if err1 != 0 {
			goto childerror
		}

		// Signal self if parent is already dead. This might cause a
		// duplicate signal in rare cases, but it won&#39;t matter when
		// using SIGKILL.
		r1, _, _ = RawSyscall(SYS_GETPPID, 0, 0, 0)
		if r1 != ppid {
			pid, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)
			_, _, err1 := RawSyscall(SYS_KILL, pid, uintptr(sys.Pdeathsig), 0)
			if err1 != 0 {
				goto childerror
			}
		}
	}

	// Pass 1: look for fd[i] &amp;lt; i and move those up above len(fd)
	// so that pass 2 won&#39;t stomp on an fd it needs later.
	if pipe &amp;lt; nextfd {
		_, _, err1 = RawSyscall(_SYS_dup, uintptr(pipe), uintptr(nextfd), 0)
		if err1 != 0 {
			goto childerror
		}
		RawSyscall(SYS_FCNTL, uintptr(nextfd), F_SETFD, FD_CLOEXEC)
		pipe = nextfd
		nextfd++
	}
	for i = 0; i &amp;lt; len(fd); i++ {
		if fd[i] &amp;gt;= 0 &amp;amp;&amp;amp; fd[i] &amp;lt; int(i) {
			_, _, err1 = RawSyscall(_SYS_dup, uintptr(fd[i]), uintptr(nextfd), 0)
			if err1 != 0 {
				goto childerror
			}
			RawSyscall(SYS_FCNTL, uintptr(nextfd), F_SETFD, FD_CLOEXEC)
			fd[i] = nextfd
			nextfd++
			if nextfd == pipe { // don&#39;t stomp on pipe
				nextfd++
			}
		}
	}

	// Pass 2: dup fd[i] down onto i.
	for i = 0; i &amp;lt; len(fd); i++ {
		if fd[i] == -1 {
			RawSyscall(SYS_CLOSE, uintptr(i), 0, 0)
			continue
		}
		if fd[i] == int(i) {
			// dup2(i, i) won&#39;t clear close-on-exec flag on Linux,
			// probably not elsewhere either.
			_, _, err1 = RawSyscall(SYS_FCNTL, uintptr(fd[i]), F_SETFD, 0)
			if err1 != 0 {
				goto childerror
			}
			continue
		}
		// The new fd is created NOT close-on-exec,
		// which is exactly what we want.
		_, _, err1 = RawSyscall(_SYS_dup, uintptr(fd[i]), uintptr(i), 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// By convention, we don&#39;t close-on-exec the fds we are
	// started with, so if len(fd) &amp;lt; 3, close 0, 1, 2 as needed.
	// Programs that know they inherit fds &amp;gt;= 3 will need
	// to set them close-on-exec.
	for i = len(fd); i &amp;lt; 3; i++ {
		RawSyscall(SYS_CLOSE, uintptr(i), 0, 0)
	}

	// Detach fd 0 from tty
	if sys.Noctty {
		_, _, err1 = RawSyscall(SYS_IOCTL, 0, uintptr(TIOCNOTTY), 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Set the controlling TTY to Ctty
	if sys.Setctty {
		_, _, err1 = RawSyscall(SYS_IOCTL, uintptr(sys.Ctty), uintptr(TIOCSCTTY), 0)
		if err1 != 0 {
			goto childerror
		}
	}

	// Time to exec.
	_, _, err1 = RawSyscall(SYS_EXECVE,
		uintptr(unsafe.Pointer(argv0)),
		uintptr(unsafe.Pointer(&amp;amp;argv[0])),
		uintptr(unsafe.Pointer(&amp;amp;envv[0])))

childerror:
	// send error code on pipe
	RawSyscall(SYS_WRITE, uintptr(pipe), uintptr(unsafe.Pointer(&amp;amp;err1)), unsafe.Sizeof(err1))
	for {
		RawSyscall(SYS_EXIT, 253, 0, 0)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linuxシステムコールの呼び出しのうち気になったところだけをピックアップします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/clone.2.html&#34;&gt;clone(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/setsid.2.html&#34;&gt;setsid(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/chroot.2.html&#34;&gt;chroot(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/setgid.2.html&#34;&gt;setgid(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/setuid.2.html&#34;&gt;setuid(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/chdir.2.html&#34;&gt;chdir(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://www.oreilly.co.jp/books/9784873115856/&#34;&gt;O&amp;rsquo;Reilly Japan - Linuxプログラミングインタフェース&lt;/a&gt;の「デーモン」の章を見ると、デーモン化の手順として7つの項目が上げられていますが、それら全てを行っているわけではないようです。&lt;/p&gt;

&lt;p&gt;例えばumaskのクリアは、上のコードをざっと見た感じではやってなさそうな感じです。&lt;/p&gt;

&lt;p&gt;また、ファイルディスクリプタ0, 1, 2をクローズはしていますが、 /dev/null をオープンはしていないようです。「通常は /dev/null をオープンする」と書いてあるので問題はなさそうです。&lt;/p&gt;

&lt;p&gt;端末デバイスからの切り離しは &lt;a href=&#34;http://man7.org/linux/man-pages/man2/ioctl.2.html&#34;&gt;ioctl(2) - Linux manual page&lt;/a&gt; に &lt;code&gt;TIOCNOTTY&lt;/code&gt; を指定して行っています。 &lt;code&gt;TIOCNOTTY&lt;/code&gt; については &lt;a href=&#34;http://man7.org/linux/man-pages/man4/tty.4.html&#34;&gt;tty(4) - Linux manual page&lt;/a&gt; に説明がありました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;syscall.SysProcAttr&lt;/code&gt; の &lt;code&gt;Setctty&lt;/code&gt; に &lt;code&gt;true&lt;/code&gt; を指定していた場合は、 &lt;a href=&#34;http://man7.org/linux/man-pages/man2/ioctl.2.html&#34;&gt;ioctl(2) - Linux manual page&lt;/a&gt; に &lt;code&gt;TIOCSCTTY&lt;/code&gt; を指定して制御端末の設定を行っています。 &lt;code&gt;TIOCSCTTY&lt;/code&gt; については &lt;a href=&#34;http://man7.org/linux/man-pages/man4/tty.4.html&#34;&gt;tty(4) - Linux manual page&lt;/a&gt; に説明がありました。&lt;/p&gt;

&lt;p&gt;ということで、&lt;a href=&#34;http://www.oreilly.co.jp/books/9784873115856/&#34;&gt;O&amp;rsquo;Reilly Japan - Linuxプログラミングインタフェース&lt;/a&gt;のデーモン化の手順の全てではないですが、かなりの部分は &lt;a href=&#34;https://golang.org/pkg/os/#StartProcess&#34;&gt;os - The Go Programming Language&lt;/a&gt; で実現できるということがわかりました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LXC 2.0でCentOS 7のコンテナを動かしてみた</title>
      <link>/blog/2016/04/19/run_centos7_containers_on_lxc2/</link>
      <pubDate>Tue, 19 Apr 2016 06:37:15 +0900</pubDate>
      
      <guid>/blog/2016/04/19/run_centos7_containers_on_lxc2/</guid>
      <description>

&lt;h2 id=&#34;はじめに:980fa4ed506550f6214721b9e91288b0&#34;&gt;はじめに&lt;/h2&gt;

&lt;h3 id=&#34;なぜdockerではなくlxcを使うのか:980fa4ed506550f6214721b9e91288b0&#34;&gt;なぜDockerではなくLXCを使うのか&lt;/h3&gt;

&lt;p&gt;コンテナと言えばDockerが有名です。Docker 1.9からネットワーク機能が大幅に良くなっていて、Docker Composeでコンテナを作成するとコンテナ名で名前解決できるようになっています。&lt;/p&gt;

&lt;p&gt;また公式のCentOS 7コンテナも良くなっていて、Dockerfileに &lt;code&gt;CMD [&amp;quot;/bin/init&amp;quot;]&lt;/code&gt; と書いておけば普通に systemd が起動するようになっています。&lt;/p&gt;

&lt;p&gt;そして &lt;code&gt;docker run&lt;/code&gt; に &lt;code&gt;--privileged&lt;/code&gt; オプションを付けて実行すれば実行時に &lt;code&gt;/etc/&lt;/code&gt; などの下のファイルを書き換えることも出来ます。&lt;/p&gt;

&lt;p&gt;しかしこのような使い方は&lt;a href=&#34;https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/&#34;&gt;Best practices for writing Dockerfiles&lt;/a&gt;と全く合いません。Dockerのベストプラクティスでは1コンテナ1プロセス、コンテナは最小限で使い捨て、ログやデータはコンテナ外部に保存するというスタンスなのです。&lt;/p&gt;

&lt;p&gt;一方、本番環境でDockerを使わずAnsibleでプロビジョニングする前提であれば、開発環境もAnsibleでプロビジョニングしたいところです。サーバが1台ならVagrant + VirtualBoxで良いのですが、複数台となると仮想マシンではメモリがたくさん必要になりますのでコンテナを使いたいところです。LXCなら従来のLinuxサーバと同じ感覚で利用できます。&lt;/p&gt;

&lt;h3 id=&#34;ubuntu-14-04-16-04でlxc-2-0を使う:980fa4ed506550f6214721b9e91288b0&#34;&gt;Ubuntu 14.04/16.04でLXC 2.0を使う&lt;/h3&gt;

&lt;p&gt;LXCもコンテナなのでLinuxカーネルはホストとコンテナで同じものが使われます。CentOS 7単独の環境に近づけるにはホストもCentOS 7にしたいところです。が、現時点ではCentOS 7ではLXCはepelにバージョン1.0.8があるだけです。&lt;/p&gt;

&lt;p&gt;LXCはCanonical LtdがUbuntu上で開発しているので、Ubuntu上で使うほうがトラブルは少なくて済むと予想します。ということで、LinuxカーネルのバージョンがCentOS 7と違ってしまうというデメリットはあるのですが、ホストはUbuntuを使うことにします。&lt;/p&gt;

&lt;p&gt;Ubuntu 14.04のカーネルのほうがCentOS 7のカーネルより新しいので、アプリケーション開発に使う分にはLinuxカーネルのバージョン違いで影響が出ることはほぼ無いと思います。&lt;/p&gt;

&lt;p&gt;2016-04-06にLXC 2.0がリリースされました。&lt;a href=&#34;https://linuxcontainers.org/ja/lxc/news/&#34;&gt;Linux Containers - LXC - ニュース&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これは長期サポート(Long-term support; LTS) リリースです。ということで、今から使うなら2.0が良いと思います。&lt;/p&gt;

&lt;h2 id=&#34;lxcのセットアップ:980fa4ed506550f6214721b9e91288b0&#34;&gt;LXCのセットアップ&lt;/h2&gt;

&lt;p&gt;セットアップ用のスクリプトとVagrantfileを書きました。
&lt;a href=&#34;https://github.com/hnakamur/setup_lxc_on_vagrant&#34;&gt;hnakamur/setup_lxc_on_vagrant: Vagrantfile to set up LXC 2.x on Ubuntu 14.04 or 16.04&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これを使うと以下の手順でセットアップ出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp Vagrantfile.ubuntu1404 Vagrantfile
vagrant up &amp;amp;&amp;amp; vagrant reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;セットアップした後ネットワークの再起動が必要なので &lt;code&gt;vagrant up&lt;/code&gt; に加えて &lt;code&gt;vagrant reload&lt;/code&gt; を実行しています。&lt;/p&gt;

&lt;p&gt;セットアップは&lt;a href=&#34;https://github.com/hnakamur/setup_lxc_on_vagrant/blob/master/setup_lxc.sh&#34;&gt;setup_lxc.sh&lt;/a&gt;というシェルスクリプトになっているので設定内容が気になる方はこちらを参照してください。Vagrantを使わないUbuntu 14.04/16.04環境でもこのスクリプトを実行すればLXCをセットアップできます。&lt;/p&gt;

&lt;p&gt;Vagrantの仮想マシンの再起動が終わったら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で仮想マシンに入ってLXCを使います。&lt;/p&gt;

&lt;h2 id=&#34;コンテナ作成:980fa4ed506550f6214721b9e91288b0&#34;&gt;コンテナ作成&lt;/h2&gt;

&lt;p&gt;例えばweb01という名前のCentOS 7コンテナを作成するには以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc-create -n web01 -t download -- -d centos -r 7 -a amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-t&lt;/code&gt; はテンプレートを指定するオプションです。centosというテンプレートもあるのですが、それを使うとコンテナの挙動に問題があった (これについては今後別記事で書く予定です) ので、downloadテンプレートを使っています。&lt;/p&gt;

&lt;p&gt;初回はコンテナのイメージファイルをダウンロードするので時間がかかります。イメージファイルのサイズは約60MBとそれほど大きくもないのですが、私の環境では20分程度かかる場合もありました。&lt;/p&gt;

&lt;h2 id=&#34;コンテナ起動:980fa4ed506550f6214721b9e91288b0&#34;&gt;コンテナ起動&lt;/h2&gt;

&lt;p&gt;web01というコンテナを起動するには以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc-start -n web01
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;コンテナ一覧表示:980fa4ed506550f6214721b9e91288b0&#34;&gt;コンテナ一覧表示&lt;/h2&gt;

&lt;p&gt;以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc-ls -f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出力例はこんな感じになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~$ sudo lxc-ls -f
NAME    STATE   AUTOSTART GROUPS IPV4       IPV6
web01   RUNNING 0         -      10.0.3.244  -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動直後に実行するとIPv4の列が-になっています。数秒立ってから再度実行するとIPアドレスがDHCPで設定されて表示されます。&lt;/p&gt;

&lt;h3 id=&#34;コンテナ名でdnsを引けるか確認:980fa4ed506550f6214721b9e91288b0&#34;&gt;コンテナ名でDNSを引けるか確認&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~$ dig +short web01
10.0.3.244
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、LXCのdnsmasqで引けるようにするために&lt;a href=&#34;http://www.clear-code.com/blog/2014/7/30.html#.2Fetc.2Fresolve.conf.E3.81.ABnameserver.E3.82.92.E8.BF.BD.E5.8A.A0.E3.81.99.E3.82.8B&#34;&gt;LXCコンテナに名前でアクセスする方法 - ククログ(2014-07-30)&lt;/a&gt;を参考に &lt;a href=&#34;https://github.com/hnakamur/setup_lxc_on_vagrant/blob/8dac97e2c0dafe3bad275f733a549f7b03477cb4/setup_lxc.sh#L40-L43&#34;&gt;https://github.com/hnakamur/setup_lxc_on_vagrant/blob/8dac97e2c0dafe3bad275f733a549f7b03477cb4/setup_lxc.sh#L40-L43&lt;/a&gt; で設定しています。情報共有ありがとうございます！&lt;/p&gt;

&lt;h2 id=&#34;コンテナ内に入る:980fa4ed506550f6214721b9e91288b0&#34;&gt;コンテナ内に入る&lt;/h2&gt;

&lt;p&gt;web01というコンテナ内に入るには以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lxc-attach -n web01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナ内でシェルのプロンプトが表示されますので、好きなコマンドを実行してください。 &lt;code&gt;exit&lt;/code&gt; で抜けます。実行例を以下に示します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~$ sudo lxc-attach -n web01
bash-4.2# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
9: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether fe:74:45:50:85:27 brd ff:ff:ff:ff:ff:ff
    inet 10.0.3.11/24 brd 10.0.3.255 scope global dynamic eth0
       valid_lft 3219sec preferred_lft 3219sec
    inet6 fe80::fc74:45ff:fe50:8527/64 scope link
       valid_lft forever preferred_lft forever
bash-4.2# exitvagrant@vagrant-ubuntu-trusty-64:~$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;↑exitの後returnキーを押しても改行されませんでした。&lt;/p&gt;

&lt;h2 id=&#34;コンテナを停止する:980fa4ed506550f6214721b9e91288b0&#34;&gt;コンテナを停止する&lt;/h2&gt;

&lt;p&gt;以下のようにして停止します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lxc-stop -n web01
vagrant@vagrant-ubuntu-trusty-64:~$ sudo lxc-ls -f
NAME    STATE   AUTOSTART GROUPS IPV4       IPV6
web01   STOPPED 0         -      -          -
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lxc-stopですぐに停止するには以下の設定が必要:980fa4ed506550f6214721b9e91288b0&#34;&gt;lxc-stopですぐに停止するには以下の設定が必要&lt;/h3&gt;

&lt;p&gt;downloadテンプレートで作成したCentOS 7コンテナはそのままだと、lxc-stopで停止するのに1分間待たされます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lists.linuxcontainers.org/pipermail/lxc-users/2014-February/006304.html&#34;&gt;[lxc-users] lxc-stop doesn&amp;rsquo;t stop centos, waits for the timeout&lt;/a&gt;を参考に、コンテナ内で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ln -s /usr/lib/systemd/system/halt.target /etc/systemd/system/sigpwr.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行すれば、lxc-stopですぐに停止できました。&lt;/p&gt;

&lt;h2 id=&#34;コンテナを削除する:980fa4ed506550f6214721b9e91288b0&#34;&gt;コンテナを削除する&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~$ sudo lxc-destroy -n web01
Destroyed container web01
vagrant@vagrant-ubuntu-trusty-64:~$ sudo lxc-ls -f
vagrant@vagrant-ubuntu-trusty-64:~$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ホストでlxcサービス起動時にコンテナを自動起動する:980fa4ed506550f6214721b9e91288b0&#34;&gt;ホストでLXCサービス起動時にコンテナを自動起動する&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;/var/lib/lxc/${コンテナ名}/config&lt;/code&gt; ファイルに以下の行を追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc.start.auto = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;複数コンテナ間の依存関係を指定して起動の順序を制御するなど高度な指定については加藤泰文さんの&lt;a href=&#34;http://gihyo.jp/admin/serial/01/linux_containers/0025?page=1&#34;&gt;第25回　LXCの構築・活用 [11] ─lxc-autostartコマンドによるコンテナの自動起動：LXCで学ぶコンテナ入門 －軽量仮想化環境を実現する技術｜gihyo.jp … 技術評論社&lt;/a&gt;の記事をご参照ください。私は複雑な指定は試してないです。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:980fa4ed506550f6214721b9e91288b0&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;Ubuntu 14.04上でLXC 2.0をセットアップして使う手順についてまとめました。&lt;/p&gt;

&lt;p&gt;コンテナの作成とプロビジョニングについてはAnsible playbookのサンプルも作ったので今後別記事で書く予定です。また、この記事では触れなかったハマりネタもいくつかあったのでそれも今度書こうと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「サーバ/インフラエンジニア養成読本 DevOps編」の献本を頂きました</title>
      <link>/blog/2016/02/22/software_design_plus_devops_review/</link>
      <pubDate>Mon, 22 Feb 2016 21:30:52 +0900</pubDate>
      
      <guid>/blog/2016/02/22/software_design_plus_devops_review/</guid>
      <description>

&lt;p&gt;「最速攻略！ Ansible 2によるサーバ構築」という特集を書かれた新原 雅司さんから「サーバ/インフラエンジニア養成読本 DevOps編」の献本を頂きました。ありがとうございます！&lt;/p&gt;

&lt;h2 id=&#34;特集1-最速攻略-ansible-2によるサーバ構築:cb20c5254d0c2ec81599ae79716d5283&#34;&gt;特集1 「最速攻略！ Ansible 2によるサーバ構築」&lt;/h2&gt;

&lt;p&gt;私はレビュアとして参加させていただきました。「最速攻略！ Ansible 2によるサーバ構築」の特集は 50 ページの充実した内容となっています。Ansible 2を特集記事で扱うのは紙媒体の書籍としては、おそらく世界初とのことです。&lt;/p&gt;

&lt;p&gt;特集は4つの章から構成されています。&lt;/p&gt;

&lt;p&gt;「第1章 Ansibleの基本」ではAnsibleの概要や動作環境、インストール方法、基本的な使い方が説明されています。&lt;/p&gt;

&lt;p&gt;「第2章 Playbookの基本」では YAML の基本文法から始まって Ansible のモジュールを実行する記法について説明されています。&lt;/p&gt;

&lt;p&gt;「第3章 Ansible [実践]」では LAPP (Linux + Apache + PHP + PostgreSQL) サーバを構築して、デプロイも行うという実践的な内容が説明されています。PHPのバージョンは 7.0 が使われていますので、PHP 7.0 の環境を構築するのに参考になるでしょう。&lt;/p&gt;

&lt;p&gt;「第4章 Playbook ベストプラクティス」では、 playbook が大きくなってきた時のために複数のディレクトリに分割する方法や、 &lt;code&gt;ansible-galaxy&lt;/code&gt;, &lt;code&gt;ansible-vault&lt;/code&gt; コマンドについて説明されています。&lt;/p&gt;

&lt;p&gt;また、コラムが2つあって、1つはCapistranoスタイルのデプロイをAnsibleで行うためのAnsistranoというロールについて紹介しています。もう1つはAnsible 2の新機能について紹介しています。&lt;/p&gt;

&lt;h2 id=&#34;巻頭企画-devopsとinfrastructure-as-codeの概要:cb20c5254d0c2ec81599ae79716d5283&#34;&gt;巻頭企画 「DevOpsとInfrastructure as Codeの概要」&lt;/h2&gt;

&lt;p&gt;Ansibleの特集以外ですが、巻頭企画では吉羽 龍太郎さんの「DevOpsとInfrastructure as Codeの概要」という記事でDevOpsとInfrastructure as Codeについてそれぞれ1章を使って全体像と導入のポイントが説明されています。背景から入って、導入にあたって見当すべき事項や導入する際の進め方の順序が丁寧に解説されていて勉強になります。&lt;/p&gt;

&lt;h2 id=&#34;特集2-circleciによる継続的インテグレーション入門:cb20c5254d0c2ec81599ae79716d5283&#34;&gt;特集2 「CircleCIによる継続的インテグレーション入門」&lt;/h2&gt;

&lt;p&gt;特集2は前田 章さんの「CircleCIによる継続的インテグレーション入門」です。 CircleCI の入門から始まって継続的インテグレーションそして継続的デリバリーを行うまでを具体的な手順とともに説明しています。&lt;/p&gt;

&lt;p&gt;筆者の前田さんが所属するKaizen Platform, Inc.で実際に行っている継続的デリバリーとプロビジョニングの方法を例に説明されていて、使っているブランチモデルも紹介されていますので、参考になります。&lt;/p&gt;

&lt;h2 id=&#34;特集3-dockerによる仮想環境構築とkubernetesによるdockerクラスタ管理:cb20c5254d0c2ec81599ae79716d5283&#34;&gt;特集3 「Dockerによる仮想環境構築とKubernetesによるDockerクラスタ管理」&lt;/h2&gt;

&lt;p&gt;特集3は馬場俊彰さんの「Dockerによる仮想環境構築とKubernetesによるDockerクラスタ管理」です。Dockerの基本の説明から始まって、基本的な使い方とホストのボリュームやポートをバインドするような応用的な使い方を説明しています。&lt;/p&gt;

&lt;p&gt;その後、クラスタ管理ツールの概要を説明し、そのうちの1つであるKubernetesについての概要説明が続きます。次に、RedisクラスターをKubernetesを使って構築するという題材で実際に動かしてみる手順が説明されています。その後、Kubernetesで稼働している各プログラムについて解説されていて、理解を深めることが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:cb20c5254d0c2ec81599ae79716d5283&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;「サーバ/インフラエンジニア養成読本 DevOps編」はDevOpsやInfrastructure as Codeの概要について学び、Ansible 2、CircleCI、Docker、Kubernetesについて実際に動かしつつ理解を深めることが出来るというお勧めの一冊となっています。&lt;/p&gt;

&lt;p&gt;新原さんの&lt;a href=&#34;http://shin1x1.hatenablog.com/entry/gihyo-devops-ansible2&#34;&gt;「サーバ/インフラエンジニア養成読本 DevOps編」にて Ansible 2 について書きました。 - Shin x Hatena Blog&lt;/a&gt; の記事に目次がありますので、そちらもご覧の上、ぜひ購入をご検討ください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache Traffic Server を GDB で動かす</title>
      <link>/blog/2016/02/12/run-apache-traffic-server-with-gdb/</link>
      <pubDate>Fri, 12 Feb 2016 00:02:11 +0900</pubDate>
      
      <guid>/blog/2016/02/12/run-apache-traffic-server-with-gdb/</guid>
      <description>

&lt;h2 id=&#34;はじめに:16844cae3677ced667c896b951ca0019&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://gihyo.jp/magazine/wdpress/archive/2012/vol69&#34;&gt;WEB+DB PRESS Vol.69｜技術評論社&lt;/a&gt; にあった &lt;a href=&#34;http://dev.ariel-networks.com/wp/archives/author/inoue&#34;&gt;アリエル・ネットワーク㈱の井上さん&lt;/a&gt;による「大規模コードリーディング」の特集を読んで、静的解析 (コードを読んで理解する手法) と動的解析 (実行時の動作を予測しながら構造を理解する方法) を行ったり来たり繰り返すのが良いと理解しました。&lt;/p&gt;

&lt;p&gt;というわけで、 &lt;a href=&#34;/blog/blog/2016/02/11/apache-traffic-server-code-reading/&#34;&gt;Apache Traffic Server のコードリーディング · hnakamur&amp;rsquo;s blog at github&lt;/a&gt; でコードを読みつつ、デバッガ上で動かしてみました。手順は整理してないですが、とりあえず自分向けメモです。&lt;/p&gt;

&lt;h2 id=&#34;試した環境:16844cae3677ced667c896b951ca0019&#34;&gt;試した環境&lt;/h2&gt;

&lt;p&gt;試した環境は &lt;a href=&#34;https://github.com/hnakamur/trafficserver-ansible-playbook&#34;&gt;hnakamur/trafficserver-ansible-playbook&lt;/a&gt; で構築したものです。Apache Traffic Server のバージョンは 6.1.1 です。&lt;/p&gt;

&lt;h2 id=&#34;事前準備:16844cae3677ced667c896b951ca0019&#34;&gt;事前準備&lt;/h2&gt;

&lt;h3 id=&#34;debuginfo-パッケージのインストール:16844cae3677ced667c896b951ca0019&#34;&gt;debuginfo パッケージのインストール&lt;/h3&gt;

&lt;p&gt;gdb でプログラムを実行するにはプログラムのパッケージと依存パッケージの debuginfo が必要です。これは、たぶん以下のコマンドでインストールできます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install -y yum-utils
sudo debuginfo-install -y trafficserver
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;debuginfo-パッケージのインストールの試行錯誤メモ:16844cae3677ced667c896b951ca0019&#34;&gt;debuginfo パッケージのインストールの試行錯誤メモ&lt;/h3&gt;

&lt;p&gt;この項は上のコマンドを知る前に試した手順のメモです。&lt;/p&gt;

&lt;p&gt;まずデバッグ情報のパッケージが必要だと思ったので、以下のコマンドでインストールしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install -y trafficserver-debuginfo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl start trafficserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行して trafficserver のサービスを起動した状態で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ps auxww | grep traffic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行して &lt;code&gt;traffic_server&lt;/code&gt; のコマンドラインをメモします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/bin/traffic_server -M --bind_stdout /var/log/trafficserver/traffic.out --bind_stderr /var/log/trafficserver/traffic.out --httpport 80:fd=9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていました。 &lt;a href=&#34;https://docs.trafficserver.apache.org/en/latest/appendices/command-line/traffic_server.en.html&#34;&gt;traffic_server — Apache Traffic Server 6.2.0 documentation&lt;/a&gt; を見ると &lt;code&gt;-M&lt;/code&gt; は &lt;code&gt;--remote_management&lt;/code&gt; のショートオプションです。 &lt;code&gt;systemctl start trafficserver&lt;/code&gt; でサービスを起動すると &lt;code&gt;traffic_cop&lt;/code&gt; と &lt;code&gt;traffic_manager&lt;/code&gt; 経由で &lt;code&gt;traffic_server&lt;/code&gt; が起動するのですが、その場合に必要になるオプションのようです。 gdb で実行するときは &lt;code&gt;-M&lt;/code&gt; は外します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl stop trafficserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でサービスを停止します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb /usr/bin/traffic_server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で gdb を起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;break HttpSM::set_next_state
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとブレークポイントを設定します。ブレークポイントは Apache Traffic Server のソースコードを読んで、自分が止めたい場所にお好みで設定します。&lt;/p&gt;

&lt;p&gt;gdb のプロンプトで以下のように入力して、 Apache Traffic Server を実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;run --bind_stdout /var/log/trafficserver/traffic.out --bind_stderr /var/log/trafficserver/traffic.out --httpport 80:fd=9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ところがdebuginfoが足りず、以下のようなエラーになってしまいました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Inferior 1 (process 17590) exited with code 01]
Missing separate debuginfos, use: debuginfo-install glibc-2.17-106.el7_2.1.x86_64 hwloc-libs-1.7-5.el7.x86_64 keyutils-libs-1.5.8-3.el7.x86_64 krb5-libs-1.13.2-10.el7.x86_64 libcom_err-1.42.9-7.el7.x86_64 libgcc-4.8.5-4.el7.x86_64 libpciaccess-0.13.4-2.el7.x86_64 libselinux-2.2.2-6.el7.x86_64 libstdc++-4.8.5-4.el7.x86_64 libxml2-2.9.1-6.el7_2.2.x86_64 nss-softokn-freebl-3.16.2.3-13.el7_1.x86_64 numactl-libs-2.0.9-5.el7_1.x86_64 openssl-libs-1.0.1e-51.el7_2.2.x86_64 pcre-8.32-15.el7.x86_64 tcl-8.5.13-8.el7.x86_64 xz-libs-5.1.2-12alpha.el7.x86_64 zlib-1.2.7-15.el7.x86_64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;use:&lt;/code&gt; の後をコピペして実行して途中で (y/n) で聞かれたら y を押すと、必要な debuginfo をイントール出来ました。&lt;/p&gt;

&lt;p&gt;調べてみると、最初から以下のコマンドを実行しておけば依存するライブラリの debuginfo もインストールできるようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo debuginfo-install -y trafficserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、 &lt;code&gt;debuginfo-install&lt;/code&gt; コマンドは &lt;code&gt;yum-utils&lt;/code&gt; パッケージに入っているので予めインストールしておきます。&lt;/p&gt;

&lt;h2 id=&#34;実行例:16844cae3677ced667c896b951ca0019&#34;&gt;実行例&lt;/h2&gt;

&lt;p&gt;まず、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb /usr/bin/traffic_server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で gdb を起動し &lt;code&gt;HttpSM::set_next_state&lt;/code&gt; にブレークポイントを設定して traffic_server を実行しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost ~]# gdb /usr/bin/traffic_server
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-80.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &amp;quot;show copying&amp;quot;
and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;x86_64-redhat-linux-gnu&amp;quot;.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;...
Reading symbols from /usr/bin/traffic_server...Reading symbols from /usr/lib/debug/usr/bin/traffic_server.debug...done.
done.
(gdb) break HttpSM::set_next_state
Breakpoint 1 at 0x151510: file HttpSM.cc, line 6940.
(gdb) run --bind_stdout /var/log/trafficserver/traffic.out --bind_stderr /var/log/trafficserver/traffic.out --httpport 80:fd=9
Starting program: /usr/bin/traffic_server --bind_stdout /var/log/trafficserver/traffic.out --bind_stderr /var/log/trafficserver/traffic.out --httpport 80:fd=9
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
traffic_server: using root directory &#39;/usr&#39;
[New Thread 0x7ffff3bde700 (LWP 19929)]
[New Thread 0x7ffff1249700 (LWP 19930)]
[New Thread 0x7ffff1047700 (LWP 19931)]
[New Thread 0x7ffff0a3c700 (LWP 19932)]
[New Thread 0x7fffebefe700 (LWP 19933)]
[New Thread 0x7fffebcfc700 (LWP 19934)]
[New Thread 0x7fffebafa700 (LWP 19935)]
[New Thread 0x7fffeb8f8700 (LWP 19936)]
[New Thread 0x7fffeb6f6700 (LWP 19937)]
[New Thread 0x7fffeb4f4700 (LWP 19938)]
[New Thread 0x7fffeb2f2700 (LWP 19939)]
[New Thread 0x7fffeb0f0700 (LWP 19940)]
[New Thread 0x7fffeac5d700 (LWP 19941)]
[New Thread 0x7fffea95a700 (LWP 19942)]
[New Thread 0x7fffea859700 (LWP 19943)]
[New Thread 0x7fffea657700 (LWP 19944)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで別の端末で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sv http://192.168.33.131/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行しました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HttpSM&lt;/code&gt; というクラス名は &lt;code&gt;Http State Machine&lt;/code&gt; の略と思われます。 HTTP を処理する状態遷移マシンになっています。以下のセッションでは HttpSM クラスの t_state メンバ変数の next_action を表示して、状態の遷移を確認してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) where
#0  HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
#1  0x000055555569aa96 in HttpSM::state_read_client_request_header (this=0x7fffea0d0080, event=&amp;lt;optimized out&amp;gt;, data=&amp;lt;optimized out&amp;gt;)
    at HttpSM.cc:771
#2  0x00005555556a7600 in HttpSM::main_handler (this=0x7fffea0d0080, event=100, data=0x7fffe0017e38) at HttpSM.cc:2561
#3  0x00005555556a0f13 in HttpSM::state_api_callout (this=0x7fffea0d0080, event=&amp;lt;optimized out&amp;gt;, data=&amp;lt;optimized out&amp;gt;)
    at HttpSM.cc:1464
#4  0x00005555556a19a8 in do_api_callout (this=0x7fffea0d0080) at HttpSM.cc:391
#5  HttpSM::state_add_to_list (this=0x7fffea0d0080, event=&amp;lt;optimized out&amp;gt;) at HttpSM.cc:418
#6  0x00005555556a719b in HttpSM::attach_client_session (this=0x7fffea0d0080, client_vc=0x555556592d40, buffer_reader=0x555556575ea8)
    at HttpSM.cc:544
#7  0x0000555555682ec5 in HttpClientSession::new_transaction (this=0x555556592d40) at HttpClientSession.cc:141
#8  0x000055555565e901 in ProxyClientSession::state_api_callout (this=0x555556592d40, event=&amp;lt;optimized out&amp;gt;)
    at ProxyClientSession.cc:123
#9  0x00005555556824b2 in HttpClientSession::new_connection (this=0x555556592d40, new_vc=&amp;lt;optimized out&amp;gt;, iobuf=&amp;lt;optimized out&amp;gt;,
    reader=&amp;lt;optimized out&amp;gt;, backdoor=&amp;lt;optimized out&amp;gt;) at HttpClientSession.cc:220
#10 0x000055555567d969 in HttpSessionAccept::accept (this=0x55555621cab0, netvc=0x7fffe0017d20, iobuf=&amp;lt;optimized out&amp;gt;,
    reader=0x555556575ea8) at HttpSessionAccept.cc:74
#11 0x000055555565e683 in ProtocolProbeTrampoline::ioCompletionEvent (this=0x5555563bc880, event=&amp;lt;optimized out&amp;gt;,
    edata=&amp;lt;optimized out&amp;gt;) at ProtocolProbeSessionAccept.cc:123
#12 0x000055555581de76 in handleEvent (data=0x7fffe0017e38, event=100, this=&amp;lt;optimized out&amp;gt;)
    at ../../iocore/eventsystem/I_Continuation.h:153
#13 read_signal_and_update (vc=0x7fffe0017d20, event=100) at UnixNetVConnection.cc:150
#14 read_from_net (nh=0x7ffff31e0b90, vc=0x7fffe0017d20, thread=0x7ffff31dd010) at UnixNetVConnection.cc:390
#15 0x000055555580e6b0 in NetHandler::mainNetEvent (this=0x7ffff31e0b90, event=&amp;lt;optimized out&amp;gt;, e=&amp;lt;optimized out&amp;gt;) at UnixNet.cc:518
#16 0x000055555583c2d0 in handleEvent (data=0x555556172dc0, event=5, this=&amp;lt;optimized out&amp;gt;) at I_Continuation.h:153
#17 EThread::process_event (this=this@entry=0x7ffff31dd010, e=0x555556172dc0, calling_code=calling_code@entry=5) at UnixEThread.cc:128
#18 0x000055555583cdab in EThread::execute (this=0x7ffff31dd010) at UnixEThread.cc:252
#19 0x000055555560af60 in main (argv=&amp;lt;optimized out&amp;gt;) at Main.cc:1918
(gdb) p t_state.next_action
$1 = HttpTransact::SM_ACTION_API_READ_REQUEST_HDR
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$2 = HttpTransact::SM_ACTION_API_PRE_REMAP
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$3 = HttpTransact::SM_ACTION_REMAP_REQUEST
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$4 = HttpTransact::SM_ACTION_API_POST_REMAP
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$5 = HttpTransact::SM_ACTION_CACHE_LOOKUP
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$6 = HttpTransact::SM_ACTION_API_READ_CACHE_HDR
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$7 = HttpTransact::SM_ACTION_API_CACHE_LOOKUP_COMPLETE
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$8 = HttpTransact::SM_ACTION_DNS_LOOKUP
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$9 = HttpTransact::SM_ACTION_API_OS_DNS
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$10 = HttpTransact::SM_ACTION_CACHE_ISSUE_WRITE
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$11 = HttpTransact::SM_ACTION_ORIGIN_SERVER_OPEN
(gdb) c
Continuing.

Breakpoint 1, HttpSM::set_next_state (this=0x7fffea0d0080) at HttpSM.cc:6940
6940    {
(gdb) p t_state.next_action
$12 = HttpTransact::SM_ACTION_SERVER_READ
(gdb) c
Continuing.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gdb-でよく使うコマンドのメモ:16844cae3677ced667c896b951ca0019&#34;&gt;gdb でよく使うコマンドのメモ&lt;/h2&gt;

&lt;p&gt;ブレークポイント一覧表示あたりをよく忘れるのでメモ。ググってみると &lt;a href=&#34;http://wombat.cc.tsukuba.ac.jp/~furuse/jikken/text-07/text-07.html&#34;&gt;マイクロデータベース管理システムの実装&lt;/a&gt; にわかりやすくまとまっていました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;b: break。ブレークポイント設定。b の後に「クラス名::メソッド名」、「関数名」、「ファイル名:行番号」のように止めたい箇所を指定します。&lt;/li&gt;
&lt;li&gt;i b: info breakpointsの略。ブレークポイント一覧表示。&lt;/li&gt;
&lt;li&gt;del [ブレークポイント番号]。ブレークポイント削除。番号を省略すると全て削除。&lt;/li&gt;
&lt;li&gt;where: ブレークポイントで止まったときにコールスタックを表示します。&lt;/li&gt;
&lt;li&gt;p: print。ブレークポイントで止まったときに変数の値を表示します。&lt;/li&gt;
&lt;li&gt;c: continue。実行継続。ブレークポイントを設定していればそこで止まります。&lt;/li&gt;
&lt;li&gt;n: next。ステップオーバー。関数呼び出しの際には中に入らずにステップ実行します。&lt;/li&gt;
&lt;li&gt;s: step。ステップイン。関数呼び出しの際にの中に入ってステップ実行します。&lt;/li&gt;
&lt;li&gt;q: quit。実行終了。まだ実行中だと &lt;code&gt;Quit anyway? (y or n)&lt;/code&gt; と聞かれるので y を押して終了します。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ブレークポイントで止まっていない場合も、実行中に Ctrl-C で gdb のプロンプトが出るので、そこで上記のコマンドを実行できます。その後 c で実行再開できます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache Traffic Server のコードリーディング</title>
      <link>/blog/2016/02/11/apache-traffic-server-code-reading/</link>
      <pubDate>Thu, 11 Feb 2016 23:11:50 +0900</pubDate>
      
      <guid>/blog/2016/02/11/apache-traffic-server-code-reading/</guid>
      <description>

&lt;p&gt;Apache Traffic Server のコードリーディングを少しやってみたので、将来の自分に向けてメモ。&lt;/p&gt;

&lt;h2 id=&#34;コードリーディングの方法についての参考文献:0af5e1c76a1f6c4753d48d00c2585a54&#34;&gt;コードリーディングの方法についての参考文献&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://gihyo.jp/magazine/wdpress/archive/2012/vol69&#34;&gt;WEB+DB PRESS Vol.69｜技術評論社&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://dev.ariel-networks.com/wp/archives/author/inoue&#34;&gt;アリエル・ネットワーク㈱の井上さん&lt;/a&gt;による「大規模コードリーディング」の特集&lt;/li&gt;
&lt;li&gt;私は&lt;a href=&#34;http://gihyo.jp/book/2013/978-4-7741-5783-2&#34;&gt;WEB+DB PRESS総集編［Vol.1～72］：書籍案内｜技術評論社&lt;/a&gt;を買ってたので、これに入っています。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gihyo.jp/book/2015/978-4-7741-7538-6&#34;&gt;WEB+DB PRESS総集編［Vol.1～84］：書籍案内｜技術評論社&lt;/a&gt;というのも出ていました。将来チェックするときはより新しい総集編が出ているかチェックしましょう。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/satorutakeuchi18/viewing-source-code&#34;&gt;大規模ソースコードの読み方&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ツール:0af5e1c76a1f6c4753d48d00c2585a54&#34;&gt;ツール&lt;/h2&gt;

&lt;p&gt;以下の 2 つのツールを使ってみました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.doxygen.jp/&#34;&gt;Doxygen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.tamacom.com/global-j.html&#34;&gt;GNU GLOBAL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apache Traffic Server は C++ で書かれています。 C 言語に対応したツールなら他にもあるのですが、 C++ に対応していてちゃんと動いたのはこの 2 つでした。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://gccxml.github.io/HTML/Index.html&#34;&gt;GCC-XML&lt;/a&gt; とその後継の &lt;a href=&#34;https://github.com/CastXML/CastXML#readme&#34;&gt;CastXML/CastXML: C-family Abstract Syntax Tree XML Output&lt;/a&gt; はうまくいかなくて諦めました。&lt;/p&gt;

&lt;h3 id=&#34;doxygen:0af5e1c76a1f6c4753d48d00c2585a54&#34;&gt;Doxygen&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.doxygen.jp/starting.html&#34;&gt;Doxygen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://onlineconsultant.jp/pukiwiki/?Doxygen%2FGraphviz%E3%81%A7%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E3%82%92%E8%87%AA%E5%8B%95%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B&#34;&gt;Doxygen/Graphvizでドキュメントを自動生成する -でじうぃき&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;あたりを参考にしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/apache/trafficserver&#34;&gt;https://github.com/apache/trafficserver&lt;/a&gt; を &lt;code&gt;git clone&lt;/code&gt; したディレクトリで作業しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;doxygen -g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で &lt;code&gt;Doxyfile&lt;/code&gt; を生成して、以下のように編集しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--- Doxyfile.generated	2016-02-11 23:27:47.000000000 +0900
+++ Doxyfile	2016-01-22 20:52:30.000000000 +0900
@@ -32,13 +32,13 @@
 # title of most generated pages and in a few other places.
 # The default value is: My Project.
 
-PROJECT_NAME           = &amp;quot;My Project&amp;quot;
+PROJECT_NAME           = &amp;quot;Apache Traffic Server&amp;quot;
 
 # The PROJECT_NUMBER tag can be used to enter a project or revision number. This
 # could be handy for archiving the generated documentation or if some version
 # control system is used.
 
-PROJECT_NUMBER         =
+PROJECT_NUMBER         = 6.0
 
 # Using the PROJECT_BRIEF tag one can provide an optional one line description
 # for a project that appears at the top of each page and should give viewer a
@@ -58,7 +58,7 @@
 # entered, it will be relative to the location where doxygen was started. If
 # left blank the current directory will be used.
 
-OUTPUT_DIRECTORY       =
+OUTPUT_DIRECTORY       = ../trafficserver-doxygen
 
 # If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-
 # directories (in 2 levels) under the output directory of each output format and
@@ -802,7 +802,7 @@
 # be searched for input files as well.
 # The default value is: NO.
 
-RECURSIVE              = NO
+RECURSIVE              = YES
 
 # The EXCLUDE tag can be used to specify files and/or directories that should be
 # excluded from the INPUT source files. This way you can easily exclude a
@@ -933,13 +933,13 @@
 # also VERBATIM_HEADERS is set to NO.
 # The default value is: NO.
 
-SOURCE_BROWSER         = NO
+SOURCE_BROWSER         = YES
 
 # Setting the INLINE_SOURCES tag to YES will include the body of functions,
 # classes and enums directly into the documentation.
 # The default value is: NO.
 
-INLINE_SOURCES         = NO
+INLINE_SOURCES         = YES
 
 # Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
 # special comment blocks from generated source code fragments. Normal C, C++ and
@@ -1865,7 +1865,7 @@
 # captures the structure of the code including all documentation.
 # The default value is: NO.
 
-GENERATE_XML           = NO
+GENERATE_XML           = YES
 
 # The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
 # relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
@@ -2250,7 +2250,7 @@
 # The default value is: NO.
 # This tag requires that the tag HAVE_DOT is set to YES.
 
-CALL_GRAPH             = NO
+CALL_GRAPH             = YES
 
 # If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
 # dependency graph for every global function or class method.
@@ -2262,7 +2262,7 @@
 # The default value is: NO.
 # This tag requires that the tag HAVE_DOT is set to YES.
 
-CALLER_GRAPH           = NO
+CALLER_GRAPH           = YES
 
 # If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
 # hierarchy of all classes instead of a textual one.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Doxyfile&lt;/code&gt; を編集したら、以下のように実行するとドキュメントが生成されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;doxygen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記では &lt;code&gt;GENERATE_XML&lt;/code&gt; を &lt;code&gt;YES&lt;/code&gt; にしていますが、通常は &lt;code&gt;NO&lt;/code&gt; で良いです。生成された HTML に不満がある場合は &lt;code&gt;YES&lt;/code&gt; にして xml ファイルを生成し好みに加工すれば良いということです。&lt;/p&gt;

&lt;p&gt;CALL_GRAPH と CALLER_GRAPH を作るには GraphViz をインストールしておく必要があります。メソッドの呼び出し図ではなくファイルのインクルード関係図っぽかったです (図のあるページへのたどり着き方を見失ってしまって現在確認できず)。&lt;/p&gt;

&lt;h3 id=&#34;gnu-global:0af5e1c76a1f6c4753d48d00c2585a54&#34;&gt;GNU GLOBAL&lt;/h3&gt;

&lt;p&gt;コードリーディング用にはこちらのほうが使いやすかったです。Homebrewからインストールしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install global
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/apache/trafficserver&#34;&gt;https://github.com/apache/trafficserver&lt;/a&gt; を &lt;code&gt;git clone&lt;/code&gt; したディレクトリで以下のコマンドを実行して &lt;code&gt;HTML&lt;/code&gt; ディレクトリにドキュメントが生成しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;htags -sa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-s&lt;/code&gt; をつけると関数などの定義箇所で名前がリンクになり、クリックすると参照箇所一覧のページに飛べます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; はアルファベットの索引を作るオプションです。&lt;/p&gt;

&lt;p&gt;以下のように &lt;code&gt;-n&lt;/code&gt; も追加するとソースリストに行番号が追加されます。ただし、コピペしようとコードを選択すると行番号も混ざってしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;htags -sa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ソースコードのフォントを Monaco にするには &lt;code&gt;HTML/styles.css&lt;/code&gt; に以下のコードを追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pre {
        font-family: Monaco;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;時々参照箇所へのリンクが違うクラスに飛んだりすることがあったので、その場合は &lt;a href=&#34;https://github.com/monochromegane/the_platinum_searcher&#34;&gt;the_platinum_searcher&lt;/a&gt; で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pt -G &#39;\.(h|cc)$&#39; 文字列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;や&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pt -e -G &#39;\.(h|cc)$&#39; 正規表現
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で検索しました。&lt;/p&gt;

&lt;h2 id=&#34;コードリーディングのメモ:0af5e1c76a1f6c4753d48d00c2585a54&#34;&gt;コードリーディングのメモ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/trafficserver-code-reading&#34;&gt;hnakamur/trafficserver-code-reading: This is my code reading memo for Apache Traffic Server&lt;/a&gt; に置きました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rsyslogで信頼性のあるログ転送について調べたメモ</title>
      <link>/blog/2016/01/08/reliable_log_forward_with_rsyslog/</link>
      <pubDate>Fri, 08 Jan 2016 01:12:13 +0900</pubDate>
      
      <guid>/blog/2016/01/08/reliable_log_forward_with_rsyslog/</guid>
      <description>

&lt;p&gt;事の発端は fluentd を使ってみようかと思って &lt;a href=&#34;http://changineer.info/server/logging/fluentd-td-agent.html&#34;&gt;fluentd(td-agent)のインストールと設定&lt;/a&gt; を読んだことで す。fluentd のデメリットのところを読んで、ちょっと気になりました。&lt;/p&gt;

&lt;p&gt;Goで書かれた&lt;a href=&#34;https://github.com/moriyoshi/ik&#34;&gt;moriyoshi/ik&lt;/a&gt;も気になったのですが、最近話聞かないし最終コミットも3ヶ月前だったので、今回は見送りました。&lt;/p&gt;

&lt;p&gt;そこで、rsyslogでのログ転送について調査してみようと思いました。&lt;/p&gt;

&lt;p&gt;rsyslog自体についてはこちらのスライド&lt;a href=&#34;http://www.slideshare.net/ttkzw/logstudy01-rsyslog-primer&#34;&gt;#logstudy 01 rsyslog入門&lt;/a&gt;が分かりやすかったです。&lt;/p&gt;

&lt;h2 id=&#34;syslog形式での出力サポート:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;syslog形式での出力サポート&lt;/h2&gt;

&lt;h3 id=&#34;nginx:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;nginx&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://nginx.org/en/docs/syslog.html&#34;&gt;Logging to syslog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;apache-http-server:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;Apache HTTP server&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.fnal.gov/docs/products/apache/syslog_logs_notes.html&#34;&gt;Sending our web logs to syslog&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;ErrorLogやCustomLogに以下の様な感じで書く。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CustomLog &amp;quot;|/usr/bin/tee -a /var/log/www/access.log | /usr/bin/logger -thttpd -plocal6.notice&amp;quot; combined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;teeでファイルに出力しつつloggerコマンドでsyslogにも出力。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/oratta/20101121/1290341166&#34;&gt;syslogで複数のapacheサーバのログを集積する - orattaの日記&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;こちらもCustomLogでloggerコマンドを呼び出す方式。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dsas.blog.klab.org/archives/51500856.html&#34;&gt;DSAS開発者の部屋:Apacheのアクセスログをsyslog経由で出力するためのモジュールを作りました&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Apache 2.2以降で使えるカスタムモジュール&lt;/li&gt;
&lt;li&gt;Cのsyslog関数を使っている&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://httpd.apache.org/docs/trunk/mod/mod_syslog.html&#34;&gt;mod_syslog - Apache HTTP Server Version 2.5&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Apache 2.5からは標準モジュールになったらしい&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;apache-traffic-server:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;Apache Traffic Server&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://trafficserver.readthedocs.org/en/latest/admin-guide/files/records.config.en.html#proxy-config-syslog-facility&#34;&gt;proxy.config.syslog_facility&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://trafficserver.readthedocs.org/en/latest/admin-guide/files/records.config.en.html#proxy-config-diags-output-emergency&#34;&gt;proxy.config.diags.output.emergency&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;cのsyslog出力関数:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;Cのsyslog出力関数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://linux.die.net/man/3/syslog&#34;&gt;syslog(3): send messages to system logger - Linux man page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;goのsyslogクライアントライブラリ:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;Goのsyslogクライアントライブラリ&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/log/syslog/&#34;&gt;syslog - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;loggerコマンド-シェルスクリプトから出力したい時に使用:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;loggerコマンド (シェルスクリプトから出力したい時に使用)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://linux.die.net/man/1/logger&#34;&gt;logger(1) - Linux man page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;信頼性のあるログ転送のためのrelpプロトコル:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;信頼性のあるログ転送のためのRELPプロトコル&lt;/h2&gt;

&lt;p&gt;UDPで転送するとパケットロスしてログが消失する恐れがあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.slideshare.net/ttkzw/logstudy01-rsyslog-primer&#34;&gt;#logstudy 01 rsyslog入門&lt;/a&gt;の&lt;a href=&#34;http://www.slideshare.net/ttkzw/logstudy01-rsyslog-primer/81&#34;&gt;81枚目のスライド&lt;/a&gt;によると、TCPで転送しておけば、転送先のsyslogサーバがダウンしたら、キューイングして、復活したら再送するそうです。&lt;/p&gt;

&lt;p&gt;これで十分そうな気もしたのですが、syslog forwardでググっていると&lt;a href=&#34;http://ubuntuforums.org/showthread.php?t=2151986&#34;&gt;[SOLVED] Rsyslog forward log to other syslog server&lt;/a&gt;というページからリンクされている&lt;a href=&#34;http://blog.gerhards.net/2008/04/on-unreliability-of-plain-tcp-syslog.html&#34;&gt;Rainer&amp;rsquo;s Blog: On the (un)reliability of plain tcp syslog&amp;hellip;&lt;/a&gt;という記事を見つけました。&lt;/p&gt;

&lt;p&gt;さらにそこからリンクされている&lt;a href=&#34;http://blog.gerhards.net/2008/05/why-you-cant-build-reliable-tcp.html&#34;&gt;Rainer&amp;rsquo;s Blog: why you can&amp;rsquo;t build a reliable TCP protocol without app-level acks&amp;hellip;&lt;/a&gt;という記事も読んでみました。&lt;/p&gt;

&lt;p&gt;一言で言うと、信頼性の有るログ転送を実現するためには、TCPレベルでACKがあってもだめで、アプリケーションレベルのACKが必要ということです。&lt;/p&gt;

&lt;p&gt;アプリケーションレベルのACKが無いと、サーバのバッファスペースが溢れてもクライアントが気づけないというのが問題の本質のようです。&lt;/p&gt;

&lt;p&gt;これを解決するために作られたのが、&lt;a href=&#34;http://blog.gerhards.net/2008/03/relp-reliable-event-logging-protocol.html&#34;&gt;Rainer&amp;rsquo;s Blog: RELP - the reliable event logging protocol&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.librelp.com/&#34;&gt;librelp - a reliable logging library&lt;/a&gt;というのがCの実装で、ソースを見るとライセンスはGPLv3でした。&lt;/p&gt;

&lt;p&gt;RELPはrsyslogdにすでに取り込まれていました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.rsyslog.com/doc/v8-stable/tutorials/reliable_forwarding.html&#34;&gt;Reliable Forwarding of syslog Messages with Rsyslog — rsyslog 8.14.0 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.rsyslog.com/doc/v8-stable/configuration/modules/imrelp.html?highlight=relp&#34;&gt;imrelp: RELP Input Module — rsyslog 8.14.0 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.rsyslog.com/doc/v8-stable/configuration/modules/omrelp.html?highlight=relp&#34;&gt;omrelp: RELP Output Module — rsyslog 8.14.0 documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ただし、imrelpの &lt;code&gt;Ruleset&lt;/code&gt; パラメータはrsyslogdのバージョン7.5.0以降が必要らしいです。CentOS 7のrsyslogdは &lt;code&gt;yum info rsyslogd&lt;/code&gt; によると 7.4.7 なのでこれは使えないようです。&lt;/p&gt;

&lt;p&gt;CentOS 7では &lt;code&gt;rsyslog-relp.x86_64 : RELP protocol support for rsyslog&lt;/code&gt; というパッケージをインストールすればRELPが使えるようです (まだ試してないです)。&lt;/p&gt;

&lt;h2 id=&#34;参考-goで書かれたrsyslogサーバ:dfd1f8fb29d18851ce9cb3c96f51168d&#34;&gt;参考: goで書かれたrsyslogサーバ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mcuadros/go-syslog&#34;&gt;mcuadros/go-syslog&lt;/a&gt;というgoで書かれたrsyslogサーバも見つけました。&lt;/p&gt;

&lt;p&gt;UDP、TCP、Unixソケットでの受信が出来るそうです。READMEに&amp;rdquo;using RFC3164, RFC6587 or RFC5424&amp;rdquo;とありますが、どこまで対応しているかは未調査です。&lt;/p&gt;

&lt;p&gt;RELPは非対応のようです。ソースコードで大文字小文字無視でrelpで検索してヒットしなかったので。&lt;/p&gt;

&lt;p&gt;軽く試してみた結果をgistに貼りました。
&lt;a href=&#34;https://gist.github.com/hnakamur/75385e5572262b5ce9f6&#34;&gt;https://gist.github.com/hnakamur/75385e5572262b5ce9f6&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ambiguous width cjk patchを当てたhomebrew用tmux</title>
      <link>/blog/2015/12/29/homebrew-tmux-ambiguous-width-cjk-patch/</link>
      <pubDate>Tue, 29 Dec 2015 00:53:53 +0900</pubDate>
      
      <guid>/blog/2015/12/29/homebrew-tmux-ambiguous-width-cjk-patch/</guid>
      <description>

&lt;p&gt;ほぼ&lt;a href=&#34;http://qiita.com/macoshita/items/2ee3c15f362103d1e373&#34;&gt;Homebrewでサクッとpatchを当てる - Qiita&lt;/a&gt;のそのままですが、tmuxのバージョンを2.1に上げたものを&lt;a href=&#34;https://github.com/hnakamur/homebrew-custom&#34;&gt;hnakamur/homebrew-custom&lt;/a&gt;に置きました。&lt;/p&gt;

&lt;h2 id=&#34;パッチ適用版tmuxのインストール:eba8e691682467f98f06f7afd1e6bf50&#34;&gt;パッチ適用版tmuxのインストール&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;brew tap hnakamur/custom
brew install tmux-patched
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tmux-confへの設定追加:eba8e691682467f98f06f7afd1e6bf50&#34;&gt;tmux.confへの設定追加&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/macoshita/items/2ee3c15f362103d1e373#comment-ab2f10f09aefe1f3d8b6&#34;&gt;Homebrewでサクッとpatchを当てる - Qiitaのコメント&lt;/a&gt;にある通り、 &lt;code&gt;~/.tmux.conf&lt;/code&gt; に以下の設定が必要でした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set -g pane-border-ascii on
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>CentOS 7用にPython2最新版のrpmを作ってみた</title>
      <link>/blog/2015/12/19/build_latest_python2_rpm_for_centos7/</link>
      <pubDate>Sat, 19 Dec 2015 11:51:30 +0900</pubDate>
      
      <guid>/blog/2015/12/19/build_latest_python2_rpm_for_centos7/</guid>
      <description>

&lt;h2 id=&#34;はじめに:053f4a73ac9fb47562c779868bba4af5&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/12/16/calling_copr_api_with_curl/&#34;&gt;coprのAPIをcurlで呼び出す · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;にも書きましたが、CentOS 7のPythonは古くてhttps通信時にInsecurePlatformWarningが出てしまいます。&lt;/p&gt;

&lt;p&gt;そこで、&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-python-2.7.8-3.el7/&#34;&gt;Software CollectionsのPython27のpythonパッケージ&lt;/a&gt;を改変してPython2の最新版2.7.11のrpmを作ってみました。
&lt;a href=&#34;https://www.softwarecollections.org/en/&#34;&gt;Software Collections&lt;/a&gt;のrpmをベースにしていますので、CentOS 7にインストールされているPythonとは共存可能となっています。&lt;/p&gt;

&lt;h2 id=&#34;python2の最新版rpmの利用方法:053f4a73ac9fb47562c779868bba4af5&#34;&gt;Python2の最新版rpmの利用方法&lt;/h2&gt;

&lt;p&gt;先に利用方法を書いておきます。&lt;/p&gt;

&lt;h3 id=&#34;インストール手順:053f4a73ac9fb47562c779868bba4af5&#34;&gt;インストール手順&lt;/h3&gt;

&lt;p&gt;dockerのcentos:7コンテナにインストールする例で説明します。まず以下のコマンドでコンテナを起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -it centos:7 /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に以下のコマンドを実行してPython2をインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sL -o /etc/yum.repos.d/hnakamur-hnscl-python2.repo https://copr.fedoraproject.org/coprs/hnakamur/hnscl-python2/repo/epel-7/hnakamur-hnscl-python2-epel-7.repo
curl -sL -o /etc/yum.repos.d/hnakamur-hnscl-python2-python.repo https://copr.fedoraproject.org/coprs/hnakamur/hnscl-python2-python/repo/epel-7/hnakamur-hnscl-python2-python-epel-7.repo
yum -y install hn-python2-python
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使い方:053f4a73ac9fb47562c779868bba4af5&#34;&gt;使い方&lt;/h3&gt;

&lt;p&gt;以下のコマンドでPython2最新版用のシェルを起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scl enable hn-python2 bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは通常通りpythonコマンドを実行すればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# which python
/opt/hn/hn-python2/root/usr/bin/python
# python -V
Python 2.7.11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使い終わったら &lt;code&gt;exit&lt;/code&gt; で上記で起動したシェルを抜けてください。&lt;/p&gt;

&lt;p&gt;ちなみに、Software Collectionsで提供されているPython 2.7のインストール方法は&lt;a href=&#34;https://www.softwarecollections.org/en/scls/rhscl/python27/&#34;&gt;Python 2.7 — Software Collections&lt;/a&gt;です。&lt;/p&gt;

&lt;h2 id=&#34;python2の最新版rpmを作った時のメモ:053f4a73ac9fb47562c779868bba4af5&#34;&gt;Python2の最新版rpmを作った時のメモ&lt;/h2&gt;

&lt;p&gt;以下はrpmを作った時のメモです。&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/&#34;&gt;Packaging Guide — Software Collections&lt;/a&gt;を読みながら試行錯誤してrpmを作りました。&lt;/p&gt;

&lt;h3 id=&#34;software-collectionsのメタパッケージ:053f4a73ac9fb47562c779868bba4af5&#34;&gt;Software Collectionsのメタパッケージ&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-Package_Layout&#34;&gt;Packaging Guide — Software Collections&lt;/a&gt;で説明されていますが、Software Collectionsではメタパッケージというのを作成します。&lt;/p&gt;

&lt;p&gt;例えば今回ベースにしたPython 2.7だと&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-1.1-20.el7/&#34;&gt;python27&lt;/a&gt;というのがメタパッケージで、　Python2本体のパッケージは&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-python-2.7.8-3.el7/&#34;&gt;Software CollectionsのPython27のpythonパッケージ&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;Software Collectionsを自作する場合は、パッケージ名が衝突しないように「組織名-」という接頭辞をつけるようにと&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-The_Software_Collections_Prefix&#34;&gt;2.4. The Software Collection Prefix&lt;/a&gt;に書かれています。公式のソフトウェアコレクションは接頭辞無しで &lt;code&gt;python27&lt;/code&gt; のようなコレクション名になっています。&lt;/p&gt;

&lt;p&gt;また、&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-The_File_System_Hierarchy&#34;&gt;2.2. The File System Hierarchy&lt;/a&gt;に書かれているように、ソフトウェアコレクションのrpmに含まれるファイルは &lt;code&gt;/opt/提供者名/ソフトウェアコレクション名/&lt;/code&gt; というディレクトリ構成を取ります。公式のソフトウェアコレクションは &lt;code&gt;/opt/rh/ソフトウェアコレクション名/&lt;/code&gt; というディレクトリになっています。rhはredhatの略だと思います。&lt;/p&gt;

&lt;p&gt;今回は &lt;code&gt;hn-python2&lt;/code&gt; というメタパッケージ名とし、ディレクトリは &lt;code&gt;/opt/hn/python2/&lt;/code&gt; としました。&lt;/p&gt;

&lt;h3 id=&#34;software-collectionsのメタパッケージのビルド:053f4a73ac9fb47562c779868bba4af5&#34;&gt;Software Collectionsのメタパッケージのビルド&lt;/h3&gt;

&lt;p&gt;ビルド用のファイルは&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-rpm&#34;&gt;hnakamur/hnscl-python2-rpm&lt;/a&gt;に置いてあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.softwarecollections.org/en/docs/guide/#sect-The_Software_Collection_Root_Directory&#34;&gt;2.3. The Software Collection Root Directory&lt;/a&gt;によるとspecファイルに以下のように書けばよいそうです。providerの箇所は提供者ごとの値に変えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%global _scl_prefix /opt/provider
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ですが、実際に試してみるとこの設定だけだと、ビルドされたrpm内のファイルパスだったりファイルの中身に &lt;code&gt;/opt/rh/&lt;/code&gt; というパスが残ってしまいました。試行錯誤の結果以下のように書くことで全て &lt;code&gt;/opt/hn/&lt;/code&gt; に変わりました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-rpm/blob/06a6fa366bd485d722139f0637ce2def364eaef3/SPECS/hn-python2.spec#L1-L22&#34;&gt;hn-python2-spec&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%global scl_name_prefix hn-
%global scl_name_base python
%global scl_name_version 2
%global scl %{scl_name_prefix}%{scl_name_base}%{scl_name_version}

# NOTE: You must set _scl_prefix before &#39;%scl_package %scl&#39;.
%global _scl_prefix /opt/hn
# NOTE: The following variables must be re-evaluated after changing _scl_prefix above.
# I got these settings after trials and errors.
# I don&#39;t know this is the right way to set directories with my _scl_prefix.
%global _scl_scripts            %{_scl_prefix}/%{scl}
%global _scl_root               %{_scl_prefix}/%{scl}/root
%global _prefix                 %{_scl_root}/usr
%global _sysconfdir             %{_scl_root}/etc
%global _sharedstatedir         %{_scl_root}/var/lib
%global _localstatedir          %{_scl_root}/var
%global _datadir                %{_scl_root}/share
%global _docdir                 %{_datadir}/doc
%global _mandir                 %{_datadir}/man


%scl_package %scl
...(snip)...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;python本体のパッケージのビルド:053f4a73ac9fb47562c779868bba4af5&#34;&gt;Python本体のパッケージのビルド&lt;/h3&gt;

&lt;p&gt;ビルド用のファイルは&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm&#34;&gt;hnakamur/hnscl-python2-python-rpm&lt;/a&gt;に置いてあります。&lt;/p&gt;

&lt;p&gt;インストールディレクトリを &lt;code&gt;/opt/hn/&lt;/code&gt; 以下にするため、試行錯誤した結果specファイルに以下のように書けばOKでした。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/blob/3a13fe74587d6beca871d28a68149a2273488672/SPECS/python.spec#L1-L31&#34;&gt;python.spec&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%global scl_name_prefix hn-
%global scl_name_base python
%global scl_name_version 2
%global scl %{scl_name_prefix}%{scl_name_base}%{scl_name_version}

# NOTE: You must set _scl_prefix before &#39;%scl_package %scl&#39;.
%global _scl_prefix /opt/hn
# NOTE: The following variables must be re-evaluated after changing _scl_prefix above.
%global _scl_scripts            %{_scl_prefix}/%{scl}
%global _scl_root               %{_scl_prefix}/%{scl}/root
%global _prefix                 %{_scl_root}/usr
%global _sysconfdir             %{_scl_root}/etc
%global _sharedstatedir         %{_scl_root}/var/lib
%global _localstatedir          %{_scl_root}/var

%global _includedir             %{_prefix}/include
%if &amp;quot;%{_lib}&amp;quot; == &amp;quot;lib64&amp;quot;
%global _libdir                 %{_prefix}/lib64
%else
%global _libdir                 %{_prefix}/lib
%endif
%global _datadir                %{_prefix}/share
%global _docdir                 %{_prefix}/share/doc
%global _datarootdir            %{_prefix}/share
%global _infodir                %{_prefix}/share/info
%global _mandir                 %{_prefix}/share/man
%global _defaultdocdir          %{_prefix}/share/doc

%global _exec_prefix            %{_prefix}
%global _bindir                 %{_exec_prefix}/bin
%global _sbindir                %{_exec_prefix}/sbin
...(snip)...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;python本体のspecファイルのパッチ更新:053f4a73ac9fb47562c779868bba4af5&#34;&gt;Python本体のspecファイルのパッチ更新&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/blob/3a13fe74587d6beca871d28a68149a2273488672/SPECS/python.spec&#34;&gt;python.spec&lt;/a&gt;には約60個のパッチが含まれています。&lt;/p&gt;

&lt;p&gt;Pythonのソースのバージョンを上げたのでパッチが当たらなくなるケースが出てきました。patchを実行した時に生成される &lt;code&gt;*.rej&lt;/code&gt; ファイルを見て、なんとなくこんな感じだろという軽いノリでパッチを一通り更新しました。&lt;/p&gt;

&lt;p&gt;作業手順は&lt;a href=&#34;/blog/blog/2015/12/16/how_to_debug_errors_in_rpm_build_using_mock/&#34;&gt;mockを使ったrpmビルドが失敗した時の調査方法 · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;に書いた手順で、mockのchroot環境内でパッチを修正して &lt;code&gt;rpmbuild -bp specファイル名&lt;/code&gt; でパッチを当てるというのをひたすら繰り返した感じです。&lt;/p&gt;

&lt;p&gt;パッチ1つごとの修正を&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/commits/master&#34;&gt;Commits · hnakamur/hnscl-python2-python-rpm&lt;/a&gt;のだいたい1つのコミットにしています。ただ、後からさらに修正が必要だったものは別コミットになっていますが。&lt;/p&gt;

&lt;p&gt;また、CentOSのPythonのspecファイルではリリースビルドとデバッグビルドを作ってテストも実行するようになっています。これがかなり時間がかるので、ビルドが通らない段階では&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/commit/ebb31040e3e5bfe0ceb62cd4eb67793bd1a333b0&#34;&gt;リリースビルドだけにしてテストは実行しないようにしていました&lt;/a&gt;。ビルドが落ち着いてきたところで&lt;a href=&#34;https://github.com/hnakamur/hnscl-python2-python-rpm/commit/8a293e3dbd25f6cb6638b00efc07ce5cf962a397&#34;&gt;この変更をgit revert&lt;/a&gt;してビルド・テストするようにしました。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:053f4a73ac9fb47562c779868bba4af5&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-python-2.7.8-3.el7/&#34;&gt;Software CollectionsのPython27のpythonパッケージ&lt;/a&gt;を改変して作ったPython2の最新版2.7.11のrpmについて説明しました。&lt;/p&gt;

&lt;p&gt;CentOS 7でもPython2の最新版が手軽に利用可能になるので、ぜひご活用ください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>direnvでgo1.5.2とgo1.6beta1を切り替える設定</title>
      <link>/blog/2015/12/19/switch_go1.5.2_and_go1.6beta1_with_direnv/</link>
      <pubDate>Sat, 19 Dec 2015 01:45:25 +0900</pubDate>
      
      <guid>/blog/2015/12/19/switch_go1.5.2_and_go1.6beta1_with_direnv/</guid>
      <description>

&lt;h2 id=&#34;はじめに:9e8ccdd514d51c0448f3d2e7fa828293&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;go1.6beta1がリリースされました。go1.5.2と切り替えて使いたいので、&lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;direnv/direnv&lt;/a&gt;用の設定を書きました。&lt;/p&gt;

&lt;h2 id=&#34;設定内容:9e8ccdd514d51c0448f3d2e7fa828293&#34;&gt;設定内容&lt;/h2&gt;

&lt;p&gt;以下の様な配置で使うことにしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;go1.5.2

&lt;ul&gt;
&lt;li&gt;goのインストールディレクトリ: /usr/local/go&lt;/li&gt;
&lt;li&gt;GOPATH: ~/gocode&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;go1.6beta1

&lt;ul&gt;
&lt;li&gt;goのインストールディレクトリ: /usr/local/go1.6beta1&lt;/li&gt;
&lt;li&gt;GOPATH: ~/gocode1.6&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まず、~/.bash_profileや~/.bashからはgoへのPATH設定やGOPATHの設定は削除します。&lt;/p&gt;

&lt;p&gt;次に以下のファイルを作成します。&lt;/p&gt;

&lt;p&gt;~/gocode/.envrc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GOPATH=$HOME/gocode
export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin
export GO15VENDOREXPERIMENT=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;~/gocode1.6/.envrc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GOROOT=/usr/local/go1.6beta1
export GOPATH=$HOME/gocode1.6
export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記の2つのファイルを有効にします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;direnv allow ~/gocode
direnv allow ~/gocode1.6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使い方:9e8ccdd514d51c0448f3d2e7fa828293&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;go1.5.2を使うときは ~/gocode/ 配下のディレクトリにcdします。
すると~/gocode/.envrcがsourceされてgo1.5.2用の設定が有効になります。&lt;/p&gt;

&lt;p&gt;go1.6beta1を使うときは ~/gocode1.6/ 配下のディレクトリにcdします。
すると~/gocode/.envrcで有効にされたgo1.5.2用の設定はアンロードされて、~/gocode1.6/.envrcがsourceされgo1.6beta1用の設定が有効になります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mockやcoprでrpmをビルドする際にサードパーティのレポジトリを追加する方法</title>
      <link>/blog/2015/12/18/add_third_party_to_build_on_mock_and_copr/</link>
      <pubDate>Fri, 18 Dec 2015 01:43:28 +0900</pubDate>
      
      <guid>/blog/2015/12/18/add_third_party_to_build_on_mock_and_copr/</guid>
      <description>

&lt;h2 id=&#34;はじめに:10b0aafa200b57354ec517996e32ab18&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Mock&#34;&gt;Mock&lt;/a&gt;や&lt;a href=&#34;https://copr.fedoraproject.org/&#34;&gt;copr&lt;/a&gt;でrpmをビルドする際にCentOS標準のレポジトリ以外のサードパーティのレポジトリのrpmに依存したい場合があります。この記事ではサードパーティのレポジトリの追加方法を説明します。&lt;/p&gt;

&lt;p&gt;この記事では&lt;a href=&#34;https://www.varnish-cache.org/vmod/header-manipulation&#34;&gt;libvmod-header&lt;/a&gt;をビルドするために&lt;a href=&#34;https://www.varnish-cache.org/installation/redhat&#34;&gt;varnish-cache.orgのRedHat用インストール手順&lt;/a&gt;で提供されているEL7用のレポジトリを追加する例で説明します。&lt;/p&gt;

&lt;p&gt;ビルドするために私が作成したDockerfileとシェルスクリプトは&lt;a href=&#34;https://github.com/hnakamur/libvmod-header-rpm&#34;&gt;hnakamur/libvmod-header-rpm&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h2 id=&#34;mockでのrpmビルド時にサードパーティのレポジトリを追加する方法:10b0aafa200b57354ec517996e32ab18&#34;&gt;Mockでのrpmビルド時にサードパーティのレポジトリを追加する方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lists.fedorahosted.org/pipermail/softwarecollections/2012-November/000018.html&#34;&gt;Building SCL packages with mock&lt;/a&gt;で紹介されていた方法です。&lt;/p&gt;

&lt;p&gt;CentOS 7用のrpmをビルドする場合 &lt;code&gt;/etc/mock/epel-7-x86_64.cfg&lt;/code&gt; をコピーして &lt;code&gt;/etc/mock/epel-7-varnish-x86_64.cfg&lt;/code&gt; のように別名で保存します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/mock/epel-7-varnish-x86_64.cfg&lt;/code&gt; の最後に &lt;code&gt;config_opts[&#39;yum.conf&#39;]&lt;/code&gt; の設定があります。変更前は以下のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config_opts[&#39;root&#39;] = &#39;epel-7-x86_64&#39;
config_opts[&#39;target_arch&#39;] = &#39;x86_64&#39;
config_opts[&#39;legal_host_arches&#39;] = (&#39;x86_64&#39;,)
config_opts[&#39;chroot_setup_cmd&#39;] = &#39;install @buildsys-build&#39;
config_opts[&#39;dist&#39;] = &#39;el7&#39;  # only useful for --resultdir variable subst
config_opts[&#39;releasever&#39;] = &#39;7&#39;

config_opts[&#39;yum.conf&#39;] = &amp;quot;&amp;quot;&amp;quot;
[main]
keepcache=1
debuglevel=2
reposdir=/dev/null
logfile=/var/log/yum.log
retries=20
obsoletes=1
gpgcheck=0
assumeyes=1
syslog_ident=mock
syslog_device=

# repos
[base]
name=BaseOS
mirrorlist=http://mirrorlist.centos.org/?release=7&amp;amp;arch=x86_64&amp;amp;repo=os
failovermethod=priority
gpgkey=file:///etc/pki/mock/RPM-GPG-KEY-CentOS-7
gpgcheck=1

[updates]
name=updates
enabled=1
mirrorlist=http://mirrorlist.centos.org/?release=7&amp;amp;arch=x86_64&amp;amp;repo=updates
failovermethod=priority
gpgkey=file:///etc/pki/mock/RPM-GPG-KEY-CentOS-7
gpgcheck=1

[epel]
name=epel
mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=epel-7&amp;amp;arch=x86_64
failovermethod=priority
gpgkey=file:///etc/pki/mock/RPM-GPG-KEY-EPEL-7
gpgcheck=1

[extras]
name=extras
mirrorlist=http://mirrorlist.centos.org/?release=7&amp;amp;arch=x86_64&amp;amp;repo=extras
failovermethod=priority
gpgkey=file:///etc/pki/mock/RPM-GPG-KEY-EPEL-7
gpgcheck=1

[testing]
name=epel-testing
enabled=0
mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=testing-epel7&amp;amp;arch=x86_64
failovermethod=priority


[local]
name=local
baseurl=http://kojipkgs.fedoraproject.org/repos/epel7-build/latest/x86_64/
cost=2000
enabled=0

[epel-debug]
name=epel-debug
mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=epel-debug-7&amp;amp;arch=x86_64
failovermethod=priority
enabled=0
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;失敗例1:10b0aafa200b57354ec517996e32ab18&#34;&gt;失敗例1&lt;/h3&gt;

&lt;p&gt;varnish-cache.orgではEL7用のレポジトリ定義が &lt;a href=&#34;https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm&#34;&gt;https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm&lt;/a&gt; で配布されています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;config_opts[&#39;chroot_setup_cmd&#39;] = &#39;install @buildsys-build&#39;&lt;/code&gt; にこのrpmのURLを追加して
&lt;code&gt;config_opts[&#39;chroot_setup_cmd&#39;] = &#39;install @buildsys-build https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm&#39;&lt;/code&gt; にするというのを試してみましたが、これは失敗でした。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo mock -r epel-7-varnish-x86_64 --init&lt;/code&gt; で &lt;code&gt;varnish-4.1&lt;/code&gt; というレポジトリのrpmがインストールされるところまではOKでした。
が、 &lt;code&gt;sudo mock -r epel-7-varnish-x86_64 --install varnish&lt;/code&gt; としてvarnishをインストールすると、このレポジトリからvarnish 4.1.0がインストールされずにepelから4.0.3がインストールされてしまいました。&lt;/p&gt;

&lt;h3 id=&#34;うまくいく方法:10b0aafa200b57354ec517996e32ab18&#34;&gt;うまくいく方法&lt;/h3&gt;

&lt;p&gt;ということでmockで作成するchroot環境では &lt;code&gt;config_opts[&#39;yum.conf&#39;]&lt;/code&gt; に予めレポジトリ定義を書いておく必要があるようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm&#34;&gt;https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm&lt;/a&gt; に含まれる &lt;code&gt;etc/yum.repos.d/varnish-4.1.repo&lt;/code&gt; には以下の様なレポジトリ定義が含まれています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[varnish-4.1]
name=Varnish Cache 4.1 for Enterprise Linux
baseurl=https://repo.varnish-cache.org/redhat/varnish-4.1/el7/$basearch
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-VARNISH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/pki/rpm-gpg/RPM-GPG-KEY-VARNISH&lt;/code&gt; というgpgkeyが折角用意されているので使いたいのですが良い方法が思いつきませんでした。 &lt;code&gt;config_opts[&#39;chroot_setup_cmd&#39;]&lt;/code&gt; にセットアップ時に実行されるコマンドを書けるのですが、先頭に &lt;code&gt;yum&lt;/code&gt; を追加して実行されるので任意のコマンドを実行できるわけではないです。&lt;/p&gt;

&lt;p&gt;今回は諦めてgpgkeyを使うのは諦めて、下記の内容を &lt;code&gt;config_opts[&#39;yum.conf&#39;]&lt;/code&gt; の最後に追加するようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[varnish-4.1]
name=Varnish Cache 4.1 for Enterprise Linux
baseurl=https://repo.varnish-cache.org/redhat/varnish-4.1/el7/$basearch
enabled=1
gpgcheck=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スクリプトでは以下のようにしています。
&lt;a href=&#34;https://github.com/hnakamur/libvmod-header-rpm/blob/5d5b2e580b11944ee630c6fbc2bea81b9fa7bb9a/scripts/build.sh#L47-L75&#34;&gt;https://github.com/hnakamur/libvmod-header-rpm/blob/5d5b2e580b11944ee630c6fbc2bea81b9fa7bb9a/scripts/build.sh#L47-L75&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;create_varnish_repo_file() {
  varnish_repo_file=varnish-4.1.repo
  if [ ! -f $varnish_repo_file ]; then
    # NOTE: Although https://repo.varnish-cache.org/redhat/varnish-4.1.el7.rpm at https://www.varnish-cache.org/installation/redhat
    #       has the gpgkey in it, I don&#39;t use it since I don&#39;t know how to add it to /etc/mock/*.cfg
    cat &amp;gt; ${varnish_repo_file} &amp;lt;&amp;lt;EOF
[${varnish_repo_id}]
name=${varnish_repo_name}
baseurl=${varnish_repo_baseurl}
enabled=1
gpgcheck=0
EOF
  fi
}

create_mock_chroot_cfg() {
  create_varnish_repo_file

  # Insert ${scl_repo_file} before closing &amp;quot;&amp;quot;&amp;quot; of config_opts[&#39;yum.conf&#39;]
  # See: http://unix.stackexchange.com/a/193513/135274
  #
  # NOTE: Support of adding repository was added to mock,
  #       so you can use it in the future.
  # See: https://github.com/rpm-software-management/ci-dnf-stack/issues/30
  (cd ${topdir} \
    &amp;amp;&amp;amp; echo | sed -e &#39;$d;N;P;/\n&amp;quot;&amp;quot;&amp;quot;$/i\
&#39; -e &#39;/\n&amp;quot;&amp;quot;&amp;quot;$/r &#39;${varnish_repo_file} -e &#39;/\n&amp;quot;&amp;quot;&amp;quot;$/a\
&#39; -e D /etc/mock/${base_chroot}.cfg - | sudo sh -c &amp;quot;cat &amp;gt; /etc/mock/${mock_chroot}.cfg&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sedでパターンにマッチした行の後にファイルを挿入するのは &lt;code&gt;/パターン/r ファイル名&lt;/code&gt;ですが、マッチした行の前に挿入するのはトリッキーです。
ここでは &lt;a href=&#34;http://unix.stackexchange.com/a/193513/135274&#34;&gt;http://unix.stackexchange.com/a/193513/135274&lt;/a&gt; で紹介されていた &lt;code&gt;echo | sed -e &#39;$d;N;P;/\nPointer/r file1&#39; -e D file2 -&lt;/code&gt; という手法を使っています。
ただし、ファイルを挿入する前後に改行を入れたかったので &lt;code&gt;i&lt;/code&gt; や &lt;code&gt;a&lt;/code&gt; も使っています。&lt;/p&gt;

&lt;p&gt;これで &lt;code&gt;sudo mock -r epel-7-varnish-x86_64 --rebuild ${SRPMのパス}&lt;/code&gt; でrpmをビルドできます。&lt;/p&gt;

&lt;h2 id=&#34;coprでのrpmビルド時にサードパーティのレポジトリを追加する方法:10b0aafa200b57354ec517996e32ab18&#34;&gt;coprでのrpmビルド時にサードパーティのレポジトリを追加する方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;の&amp;rdquo;Create new project&amp;rdquo;のAPIにreposパラメータがありますので、ここに &lt;code&gt;*.repo&lt;/code&gt; ファイルの &lt;code&gt;baseurl&lt;/code&gt; の値、 &lt;code&gt;https://repo.varnish-cache.org/redhat/varnish-4.1/el7/$basearch&lt;/code&gt; を指定すればOKです。&lt;/p&gt;

&lt;p&gt;実際のスクリプトでは以下の箇所です。
&lt;a href=&#34;https://github.com/hnakamur/libvmod-header-rpm/blob/5d5b2e580b11944ee630c6fbc2bea81b9fa7bb9a/scripts/build.sh#L108-L119&#34;&gt;https://github.com/hnakamur/libvmod-header-rpm/blob/5d5b2e580b11944ee630c6fbc2bea81b9fa7bb9a/scripts/build.sh#L108-L119&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Create the project on copr.
    # We call copr APIs with curl to work around the InsecurePlatformWarning problem
    # since system python in CentOS 7 is old.
    # I read the source code of https://pypi.python.org/pypi/copr/1.62.1
    # since the API document at https://copr.fedoraproject.org/api/ is old.
    curl -s -X POST -u &amp;quot;${COPR_LOGIN}:${COPR_TOKEN}&amp;quot; \
      --data-urlencode &amp;quot;name=${project_name}&amp;quot; \
      --data-urlencode &amp;quot;${base_chroot}=y&amp;quot; \
      --data-urlencode &amp;quot;repos=${varnish_repo_baseurl}&amp;quot; \
      --data-urlencode &amp;quot;description=$copr_project_description&amp;quot; \
      --data-urlencode &amp;quot;instructions=$copr_project_instructions&amp;quot; \
      https://copr.fedoraproject.org/api/coprs/${COPR_USERNAME}/new/
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>mockを使ったrpmビルドが失敗した時の調査方法</title>
      <link>/blog/2015/12/16/how_to_debug_errors_in_rpm_build_using_mock/</link>
      <pubDate>Wed, 16 Dec 2015 01:10:33 +0900</pubDate>
      
      <guid>/blog/2015/12/16/how_to_debug_errors_in_rpm_build_using_mock/</guid>
      <description>

&lt;h2 id=&#34;はじめに:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/&#34;&gt;nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;でspecファイルを書いている最中はmockでのrpmのビルドに失敗することがよくあります。&lt;/p&gt;

&lt;p&gt;私は「なんとなくこんな感じか？」と書いて動かしてみてエラーを見て修正していくスタイルなので、失敗時の調査は重要です。&lt;/p&gt;

&lt;h2 id=&#34;ビルドログ:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;ビルドログ&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sudo mock -r epel-7-x86_64 --rebuild ${srpmファイル名}&lt;/code&gt; のように実行してビルドした場合、 &lt;code&gt;/var/lib/mock/epel-7-x86_64/result/&lt;/code&gt; に &lt;code&gt;build.log&lt;/code&gt; というファイルができるのでそれを見ます。&lt;/p&gt;

&lt;h2 id=&#34;mockコマンドでchroot環境内に入る:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;mockコマンドでchroot環境内に入る&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://linux.die.net/man/1/mock&#34;&gt;mock(1)のmanページ&lt;/a&gt;によると &lt;code&gt;sudo mock -r epel-7-x86_64 --shell&lt;/code&gt; でchroot環境内に入ることが出来ます。 &lt;code&gt;exit&lt;/code&gt; で抜けます。&lt;/p&gt;

&lt;p&gt;mockで作られるchroot環境はビルドに必要な最低限のパッケージしかインストールされておらず、 &lt;code&gt;vim&lt;/code&gt; や &lt;code&gt;less&lt;/code&gt; も使えません。 &lt;code&gt;yum&lt;/code&gt; で入れようにも &lt;code&gt;yum&lt;/code&gt; も無いと言われてしまいます。&lt;/p&gt;

&lt;p&gt;chroot環境に入る前に &lt;code&gt;sudo mock -r epel-7-x86_64 --install vim less&lt;/code&gt; のようにしてインストールしておけばchroot内でvimやlessが使えます。&lt;/p&gt;

&lt;p&gt;あるいはchroot外で &lt;code&gt;/var/lib/mock/epel-7-x86_64/root/&lt;/code&gt; 配下のファイルをvimやlessで見るという手もあります。&lt;/p&gt;

&lt;h2 id=&#34;chroot環境内のrpmビルドディレクトリ:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;chroot環境内のrpmビルドディレクトリ&lt;/h2&gt;

&lt;p&gt;chroot環境内では &lt;code&gt;/builddir/build/&lt;/code&gt; 以下に &lt;code&gt;BUILD&lt;/code&gt;, &lt;code&gt;BUILDDIR&lt;/code&gt;, &lt;code&gt;SOURCES&lt;/code&gt;, &lt;code&gt;SPECS&lt;/code&gt; などのディレクトリが作られているので、これらの中を見ればビルド失敗時の状況を調べられます。&lt;/p&gt;

&lt;h2 id=&#34;chroot環境内でファイルを修正してビルドを再実行:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;chroot環境内でファイルを修正してビルドを再実行&lt;/h2&gt;

&lt;p&gt;mockを使ったrpmビルドはchroot環境を作成してその中で行われるのですが、毎回chroot環境を作るところからやっていると時間がかかって効率が悪いです。&lt;/p&gt;

&lt;p&gt;ですので、chroot環境内のspecファイルや &lt;code&gt;SOURCES&lt;/code&gt; ディレクトリ下のファイルを直接修正して、その後 &lt;code&gt;rpmbuild -bb ${specファイル名}&lt;/code&gt; でrpmのビルドを再度試します。&lt;/p&gt;

&lt;h2 id=&#34;修正したファイルをdockerコンテナ外に取り出す:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;修正したファイルをdockerコンテナ外に取り出す&lt;/h2&gt;

&lt;p&gt;修正のきりが良い所で、chroot環境内の修正したファイルを &lt;code&gt;docker cp&lt;/code&gt; コマンドでdockerコンテナ内からコンテナ外に取り出します。&lt;/p&gt;

&lt;p&gt;まずdockerホストで &lt;code&gt;docker ps&lt;/code&gt; コマンドでコンテナIDかコンテナ名を調べます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
363ad4f85fda        nginxrpm            &amp;quot;/bin/bash&amp;quot;         18 hours ago        Up 18 hours                             romantic_fermi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に &lt;code&gt;docker cp&lt;/code&gt; コマンドでファイルをコピーします。例えばこんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker cp romantic_fermi:/var/lib/mock/epel-7-x86_64/root/builddir/build/SPECS/nginx.spec SPECS/nginx.spec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取り出した修正ファイルはgitにコミットして、さらに修正作業を続けていきます。&lt;/p&gt;

&lt;p&gt;修正が一通り終わったら、クリーンな状態からビルドが成功することを確認するため、dockerコンテナを一度破棄して&lt;a href=&#34;http://localhost:1313/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/&#34;&gt;nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました · hnakamur&amp;rsquo;s blog at github&lt;/a&gt; の手順で再度ビルドしてみます。これでエラーが出なければOKです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:b171a244e2b9b7684f6e19368a4843b1&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;mockを使ったrpmのビルドが失敗した場合の調査方法を紹介しました。もっと良い方法などありましたら、ぜひ教えてください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>coprのAPIをcurlで呼び出す</title>
      <link>/blog/2015/12/16/calling_copr_api_with_curl/</link>
      <pubDate>Wed, 16 Dec 2015 00:06:39 +0900</pubDate>
      
      <guid>/blog/2015/12/16/calling_copr_api_with_curl/</guid>
      <description>

&lt;h2 id=&#34;はじめに:d97aa5d91864f67b35847063abc7f579&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://fedorahosted.org/copr/&#34;&gt;copr&lt;/a&gt;を利用するには以下の3つの手段があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ウェブ管理画面を使う

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://fedorahosted.org/copr/wiki/ScreenshotsTutorial&#34;&gt;スクリーンショットつきのチュートリアル&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://apps.fedoraproject.org/packages/copr-cli&#34;&gt;copr-cli&lt;/a&gt;というコマンドラインツールを使う

&lt;ul&gt;
&lt;li&gt;内部的に下記の&lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;を呼び出しています&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;を使う&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;copr-cliを使わずにcurlでapiを呼ぶ理由:d97aa5d91864f67b35847063abc7f579&#34;&gt;copr-cliを使わずにcurlでAPIを呼ぶ理由&lt;/h2&gt;

&lt;p&gt;折角copr-cliというコマンドラインツールが用意されているのでそれを活用すれば良いのですが、以下のような問題に遭遇したのでAPIをcurlで呼ぶようにしてみました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CentOS 7でyumでインストールできるcopr-cliはバージョンが古くてsrpmのアップロード機能が未サポート&lt;/li&gt;
&lt;li&gt;CentOS 7のPythonが古いのでInsecurePlatformWarningが出てしまう&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;centos-7でyumでインストールできるcopr-cliはバージョンが古くてsrpmのアップロード機能が未サポート:d97aa5d91864f67b35847063abc7f579&#34;&gt;CentOS 7でyumでインストールできるcopr-cliはバージョンが古くてsrpmのアップロード機能が未サポート&lt;/h3&gt;

&lt;p&gt;正確にはcopr-cliが利用している&lt;a href=&#34;https://apps.fedoraproject.org/packages/python-copr/&#34;&gt;python-copr&lt;/a&gt;のバージョンの問題です。
&lt;a href=&#34;https://apps.fedoraproject.org/packages/python-copr/changelog&#34;&gt;python-coprのChangelog&lt;/a&gt;を見ると1.58-1でsrpmをアップロードする機能が追加されています。&lt;/p&gt;

&lt;p&gt;一方、CentOS 7のepelにあるpython-coprは1.57-1です。srpmをアップロードする機能を使わないとなると、インターネット上にsrpmを置いてURLを指定する必要があり面倒です。&lt;/p&gt;

&lt;h3 id=&#34;centos-7のpythonが古いのでinsecureplatformwarningが出てしまう:d97aa5d91864f67b35847063abc7f579&#34;&gt;CentOS 7のPythonが古いのでInsecurePlatformWarningが出てしまう&lt;/h3&gt;

&lt;p&gt;copr-cliはpipからインストールすれば1.58-1が使えて解決と思ったのですが、今度はPythonのバージョンが古くてhttps通信時にInsecurePlatformWarningが出ました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning&#34;&gt;Security: Verified HTTPS with SSL/TLS — urllib3 dev documentation&lt;/a&gt;を見るとPythonを2.7.9以上にするのが一番理想なのですが、CentOS 7に入っているPythonは2.7.5です。
softwarecollection.orgの&lt;a href=&#34;https://www.softwarecollections.org/repos/rhscl/python27/epel-7-x86_64/python27-python-2.7.8-3.el7/&#34;&gt;python27-python&lt;/a&gt;でも2.7.8です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://urllib3.readthedocs.org/en/latest/security.html#without-modifying-code&#34;&gt;Without modifying code&lt;/a&gt;の手順で警告を無視するというあまり良くない方法も使ってみたのですが、手元のDocker環境ではよかったもののTravis CIだとエラーになってしまうという現象が起きました。&lt;/p&gt;

&lt;h2 id=&#34;copr-apiの認証方法:d97aa5d91864f67b35847063abc7f579&#34;&gt;copr APIの認証方法&lt;/h2&gt;

&lt;p&gt;というわけでcopr-cliを使わずにcurlでCoprのAPIを呼び出す方法を調べました。&lt;/p&gt;

&lt;p&gt;まずは認証ですが、&lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;の先頭にcopr-cli用の設定ファイル形式でAPIトークンの情報が表示されています。が、APIの認証方法は記載されていません。&lt;/p&gt;

&lt;p&gt;しかたがないので、python-coprのソースを読んでみるとcopr/client/client.pyに以下のようなコードがありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...(snip)...
    def _fetch(self, url, data=None, username=None, method=None,
               skip_auth=False, on_error_response=None, headers=None):
...(snip)...
        if not skip_auth:
            kwargs[&amp;quot;auth&amp;quot;] = (self.login, self.token)
...(snip)...
        try:
            response = requests.request(
                method=method.upper(),
                url=url,
                **kwargs
            )
...(snip)...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.python-requests.org/en/latest/&#34;&gt;PythonのRequestsライブラリ&lt;/a&gt;の&lt;a href=&#34;http://docs.python-requests.org/en/latest/user/authentication/#basic-authentication&#34;&gt;Basic Authentication&lt;/a&gt;のドキュメントを見ると、上記のコードは &lt;code&gt;self.login&lt;/code&gt; の値をユーザ名、 &lt;code&gt;self.token&lt;/code&gt; の値をパスワードとしてBASIC認証していることがわかりました。&lt;/p&gt;

&lt;h2 id=&#34;apiの呼び出し例:d97aa5d91864f67b35847063abc7f579&#34;&gt;APIの呼び出し例&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/&#34;&gt;hnakamur/nginx-rpm&lt;/a&gt;の&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/358d646a22c9c516a9247595e296b256d61a86f6/scripts/build.sh#L72-L95&#34;&gt;scripts/build.sh&lt;/a&gt;のコードで説明します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;build_rpm_on_copr() {
  build_srpm

  # Check the project is already created on copr.
  status=`curl -s -o /dev/null -w &amp;quot;%{http_code}&amp;quot; https://copr.fedoraproject.org/api/coprs/${COPR_USERNAME}/${copr_project_name}/detail/`
  if [ $status = &amp;quot;404&amp;quot; ]; then
    # Create the project on copr.
    # We call copr APIs with curl to work around the InsecurePlatformWarning problem
    # since system python in CentOS 7 is old.
    # I read the source code of https://pypi.python.org/pypi/copr/1.62.1
    # since the API document at https://copr.fedoraproject.org/api/ is old.
    curl -s -X POST -u &amp;quot;${COPR_LOGIN}:${COPR_TOKEN}&amp;quot; \
      --data-urlencode &amp;quot;name=${copr_project_name}&amp;quot; \
      --data-urlencode &amp;quot;${mock_chroot}=y&amp;quot; \
      --data-urlencode &amp;quot;description=$copr_project_description&amp;quot; \
      --data-urlencode &amp;quot;instructions=$copr_project_instructions&amp;quot; \
      https://copr.fedoraproject.org/api/coprs/${COPR_USERNAME}/new/
  fi
  # Add a new build on copr with uploading a srpm file.
  curl -s -X POST -u &amp;quot;${COPR_LOGIN}:${COPR_TOKEN}&amp;quot; \
    -F &amp;quot;${mock_chroot}=y&amp;quot; \
    -F &amp;quot;pkgs=@${topdir}/SRPMS/${srpm_file};type=application/x-rpm&amp;quot; \
    https://copr.fedoraproject.org/api/coprs/${COPR_USERNAME}/${copr_project_name}/new_build_upload/
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最初の &lt;code&gt;https://copr.fedoraproject.org/api/coprs/${COPR_USERNAME}/${copr_project_name}/detail/&lt;/code&gt; はプロジェクトの詳細情報取得です。これはログイン不要です。&lt;/p&gt;

&lt;p&gt;次の &lt;code&gt;https://copr.fedoraproject.org/api/coprs/${COPR_USERNAME}/new/&lt;/code&gt; にPOSTしているのがプロジェクト作成です。&lt;/p&gt;

&lt;p&gt;最後の &lt;code&gt;https://copr.fedoraproject.org/api/coprs/${COPR_USERNAME}/${copr_project_name}/new_build_upload/&lt;/code&gt; がsrpmをアップロードしてビルド開始のAPIです。&lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;には &lt;code&gt;/new_build/&lt;/code&gt; は記載がありますが、 &lt;code&gt;/new_build_upload/&lt;/code&gt; は記載が無いです。python-coprのcopr/client/client.pyのソースで見つけました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...(snip)...
    def create_new_build(self, projectname, pkgs, username=None,
                         timeout=None, memory=None, chroots=None,
                         progress_callback=None):
...(snip)...
        if urlparse(pkgs[0]).scheme != &amp;quot;&amp;quot;:
            api_endpoint = &amp;quot;new_build&amp;quot;
            data[&amp;quot;pkgs&amp;quot;] = &amp;quot; &amp;quot;.join(pkgs)
        else:
            try:
                api_endpoint = &amp;quot;new_build_upload&amp;quot;
                f = open(pkgs[0], &amp;quot;rb&amp;quot;)
                data[&amp;quot;pkgs&amp;quot;] = (os.path.basename(f.name), f, &amp;quot;application/x-rpm&amp;quot;)
            except IOError as e:
                raise CoprRequestException(e)

        url = &amp;quot;{0}/coprs/{1}/{2}/{3}/&amp;quot;.format(
            self.api_url, username, projectname, api_endpoint
        )
...(snip)...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ:d97aa5d91864f67b35847063abc7f579&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;のAPIドキュメントが不完全ですが、python-coprのソースを参考にしてcurlでCopr APIを呼び出すことが出来ました。&lt;/p&gt;

&lt;p&gt;これによりCentOS 7でcopr-cliやPythonのバージョンが古いことによる問題を回避できるので良かったです。curlでのcopr APIの呼び出しも上記のようにシンプルに書けるのでこれで十分だと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました</title>
      <link>/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/</link>
      <pubDate>Tue, 15 Dec 2015 04:19:16 +0900</pubDate>
      
      <guid>/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/</guid>
      <description>

&lt;h2 id=&#34;はじめに:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/11/26/use_travis_and_copr_to_build_and_host_rpm/&#34;&gt;Travis CIとcopr.fedoraproject.orgを使ってrpmをビルド・配布するのを試してみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;と&lt;a href=&#34;/blog/blog/2015/12/05/build_rpm_with_mock/&#34;&gt;mockコマンドでrpmをビルドする · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;の環境でいくつかrpmをビルド・配布してみたのですが、手元の環境でビルドを成功させるまでに試行錯誤するのと、coprにsrpmをアップロードしてビルド・配布するのが別の環境だと面倒なことに気付きました。&lt;/p&gt;

&lt;p&gt;そこで、1つのdockerコンテナで両方を行えるようにしました。&lt;/p&gt;

&lt;h2 id=&#34;travis-ciは外しました:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;Travis CIは外しました&lt;/h2&gt;

&lt;p&gt;また、Travis CIは使わないようにしました。理由は2つあります。1つめの理由はgithubのプロジェクトごとにTravis CIのプロジェクトを作ってcopr APIのログイン名、ユーザ名、トークンを環境変数で設定するのが面倒だったからです。これ自体はTravisのAPIを使えば解決する問題かもしれません。&lt;/p&gt;

&lt;p&gt;2つめの理由は、結局手元の環境でビルドを試すので、そこからそのままcoprにsrpmを上げるほうが手っ取り早いことに気づいたからです。これは初回にrpmのspecファイルを作成するときも、その後specファイルのバージョンを更新して新しいバージョンのrpmを作成するときもそうです。&lt;/p&gt;

&lt;h2 id=&#34;nginxのカスタムrpmをビルド-配布するためのdockerコンテナ:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;nginxのカスタムrpmをビルド・配布するためのdockerコンテナ&lt;/h2&gt;

&lt;p&gt;githubレポジトリ&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm&#34;&gt;hnakamur/nginx-rpm&lt;/a&gt;に公開しています。対応するcoprのプロジェクトは&lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nginx/&#34;&gt;hnakamur/nginx Copr&lt;/a&gt;です。&lt;/p&gt;

&lt;h2 id=&#34;ビルド前の準備:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;ビルド前の準備&lt;/h2&gt;

&lt;h3 id=&#34;copr-apiトークンを-envrcにコピー:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;copr APIトークンを.envrcにコピー&lt;/h3&gt;

&lt;p&gt;coprを使うにはFedoraアカウントが必要です。&lt;a href=&#34;https://admin.fedoraproject.org/accounts/user/new&#34;&gt;Sign up for a Fedora account&lt;/a&gt; から登録してください。&lt;/p&gt;

&lt;p&gt;Fedoraアカウントにログインした状態で &lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;を開くと、ページの先頭にAPI Tokenというセクションがあり、以下のような内容が表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[copr-cli]
login = ログインID
username = ユーザ名
token = トークン
copr_url = https://copr.fedoraproject.org
# expiration date: 2016-05-12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドを実行して上記のgithubレポジトリを手元にコピーします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/hnakamur/nginx-rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.envrc.example&lt;/code&gt; を &lt;code&gt;.envrc&lt;/code&gt; にコピーして、上で表示したログインID、ユーザ名、トークンを &lt;code&gt;.envrc&lt;/code&gt; 内の &lt;code&gt;COPR_LOGIN&lt;/code&gt;, &lt;code&gt;COPR_USERNAME&lt;/code&gt;, &lt;code&gt;COPR_TOKEN&lt;/code&gt; 環境変数に設定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# NOTE: Copy this file to .envrc and edit the values
# Go https://copr.fedoraproject.org/api/ and login in and see the values to set.
export COPR_LOGIN=_your_login_here_
export COPR_USERNAME=_your_username_here_
export COPR_TOKEN=_your_token_here_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;セキュリティを考慮してこれらの値はdockerのイメージには埋め込まず、実行時にdockerの &lt;code&gt;-e&lt;/code&gt; オプションで渡すようにしています。具体的には &lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/docker_wrapper.sh&#34;&gt;docker_wrapper.sh&lt;/a&gt; の &lt;code&gt;docker run&lt;/code&gt; の行を参照してください。&lt;/p&gt;

&lt;h3 id=&#34;specファイルの調整:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;specファイルの調整&lt;/h3&gt;

&lt;p&gt;specファイルは &lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/SPECS/nginx.spec&#34;&gt;SPECS/nginx&lt;/a&gt; にあります。各自のニーズに応じて適宜調整します。現時点では &lt;a href=&#34;http://nginx.org/packages/centos/7/SRPMS/&#34;&gt;http://nginx.org/packages/centos/7/SRPMS/&lt;/a&gt; で配布されているCentOS 7用のsrpmをベースに以下の3つのモジュールを組み込んだものになっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/openresty/lua-nginx-module&#34;&gt;openresty/lua-nginx-module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yaoweibin/nginx_upstream_check_module&#34;&gt;yaoweibin/nginx_upstream_check_module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/replay/ngx_http_consistent_hash&#34;&gt;replay/ngx_http_consistent_hash&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;nginx.orgで配布されているsrpm内のnginx.specからの差分は &lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/compare/7e234d2a222778c0a46204dba4e2dcaae8bf7894...ce4e842731a9b90034f9e00796e16839d8bda826&#34;&gt;https://github.com/hnakamur/nginx-rpm/compare/7e234d2a222778c0a46204dba4e2dcaae8bf7894...ce4e842731a9b90034f9e00796e16839d8bda826&lt;/a&gt; で見られます。&lt;/p&gt;

&lt;h3 id=&#34;sources-ファイルの調整:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;SOURCES/*ファイルの調整&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/tree/master/SOURCES&#34;&gt;SOURCES/&lt;/a&gt;にsrpmで必要なソースファイルを置いています。必要に応じて調整してください。今は &lt;a href=&#34;http://nginx.org/packages/centos/7/SRPMS/&#34;&gt;http://nginx.org/packages/centos/7/SRPMS/&lt;/a&gt; で配布されているCentOS 7用のsrpmから頂いたものをそのまま使用しています。&lt;/p&gt;

&lt;p&gt;なお、nginx自体のソースコード(例: nginx-1.9.9.tar.gz)や各エクステンションのソースコードは含めず、ビルド時にダウンロードするようにしています。これはgitレポジトリの肥大化を防ぐためです。&lt;/p&gt;

&lt;h3 id=&#34;ビルドスクリプトの調整:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;ビルドスクリプトの調整&lt;/h3&gt;

&lt;p&gt;ビルドスクリプト&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/scripts/build.sh&#34;&gt;scripts/build.sh&lt;/a&gt;も適宜調整します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;copr_project_name、copr_project_description、copr_project_instructions、rpm_nameをお好みで編集してください。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;download_source_files&lt;/code&gt; 関数はspecファイルの &lt;code&gt;/^Source[0-9]*:&lt;/code&gt; にマッチするパターンで値がhttpから始まるURLについてダウンロードするようにしています。そしてURLの最後のスラッシュ以降をファイル名として採用しています。このルールから外れる場合は、この関数を適宜変更してください。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;dockerfileとdockerのラッパースクリプトを調整:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;Dockerfileとdockerのラッパースクリプトを調整&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt;と&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/docker_wrapper.sh&#34;&gt;docker_wrapper.sh&lt;/a&gt;を適宜調整してください。&lt;/p&gt;

&lt;p&gt;通常は&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/fa051c195e030c2e7f247fa258c6fad1ef9f0dde/docker_wrapper.sh&#34;&gt;docker_wrapper.sh&lt;/a&gt;のdockerimageを好きな名前に変えるぐらいで大丈夫だと思います。&lt;/p&gt;

&lt;h2 id=&#34;dockerイメージを作成:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;dockerイメージを作成&lt;/h2&gt;

&lt;p&gt;以下のコマンドを実行してdockerイメージをビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./docker_wrapper.sh build
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dockerイメージを起動してmockでrpmをビルド:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;dockerイメージを起動してmockでrpmをビルド&lt;/h2&gt;

&lt;p&gt;以下のコマンドを実行してdockerイメージを起動してbashプロンプトを表示します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source .envrc
./docker_wrapper.sh bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに私は&lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;direnv/direnv&lt;/a&gt;を使っているので、 &lt;code&gt;source .envrc&lt;/code&gt; の行は自分で入力しなくても&lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;direnv/direnv&lt;/a&gt;が実行してくれるので便利です。direnvについては&lt;a href=&#34;http://blog.hde.co.jp/entry/2015/02/27/182117&#34;&gt;改めて、direnvを使いましょう！ - HDE BLOG&lt;/a&gt;などの記事を参照してください。&lt;/p&gt;

&lt;p&gt;dockerイメージのbashプロンプトで以下のコマンドを実行してmockでrpmをビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./build.sh mock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mockはchroot環境を作ってそこでrpmをビルドするようになっているので、chroot環境の作成にちょっと時間がかかります。&lt;/p&gt;

&lt;p&gt;dockerコンテナという独立空間が既にあるのにmockでchroot環境を作るのは無駄なんですが、coprがmockを使っているためmockでビルドが成功することを確認してからcoprにsrpmをアップロードするほうが、coprでのビルド失敗を減らせて良いですのでこうしています。&lt;/p&gt;

&lt;h2 id=&#34;coprにsrpmをアップロードして-rpmをビルド-配布:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;coprにsrpmをアップロードして、rpmをビルド・配布&lt;/h2&gt;

&lt;p&gt;mockでrpmのビルドが成功することを確認できたら、dockerコンテナ内で以下のコマンドを実行してsrpmをcoprにアップロードします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./build.sh copr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/scripts/build.sh&#34;&gt;scripts/build.sh&lt;/a&gt;の &lt;code&gt;copr_project_name&lt;/code&gt; で指定した名前のプロジェクトがcopr上に存在しない場合はまず作成してからsrpmをアップロードするようになっています。&lt;/p&gt;

&lt;p&gt;coprのプロジェクト &lt;code&gt;https://copr.fedoraproject.org/coprs/${COPR_USER_NAME}/${copr_project_name}/&lt;/code&gt; でビルドが完了すれば、rpmのレポジトリとして利用可能です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;mockとcoprを使ってnginxのカスタムrpmをビルド・配布する環境について説明しました。&lt;/p&gt;

&lt;p&gt;mockを使ってクリーンな環境でビルドできるので、今回のスクリプトでdockerコンテナを使う必要性は特にありません。Dockerfileでセットアップしたのと同等のCentOS7環境があれば &lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/scripts/build.sh&#34;&gt;scripts/build.sh&lt;/a&gt;を使ってsrpmのビルド、rpmのビルド、srpmのcoprへのアップロードを行えます。&lt;/p&gt;

&lt;p&gt;mockでのrpmのビルドが失敗した場合の調査方法とかcoprのAPIをcopr-cliではなくcurlで呼び出している話とか、いくつか書きたい話があるので日を改めて別記事として書こうと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rpmのspecファイルのSourceにGitHubの任意のコミットのtarballのURLを指定するときの良い書き方</title>
      <link>/blog/2015/12/06/good_rpm_spec_source_url_syntax_for_tarball_on_github/</link>
      <pubDate>Sun, 06 Dec 2015 00:07:23 +0900</pubDate>
      
      <guid>/blog/2015/12/06/good_rpm_spec_source_url_syntax_for_tarball_on_github/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Packaging:SourceURL?rd=Packaging/SourceURL#Commit_Revision&#34;&gt;Packaging:SourceURL - FedoraProject&lt;/a&gt;で知ったtipsの紹介です。&lt;/p&gt;

&lt;p&gt;GitHubでプロジェクトの[Download ZIP]ボタンを押すと、ソースをZIP形式でダウンロードできます。
コミット数が多いプロジェクトだと &lt;code&gt;git clone&lt;/code&gt; するよりも高速に取得できるので履歴が不要な場合には便利な方法です。&lt;/p&gt;

&lt;p&gt;例えば&lt;a href=&#34;https://github.com/openresty/lua-nginx-module&#34;&gt;openresty/lua-nginx-module&lt;/a&gt;なら &lt;code&gt;https://github.com/openresty/lua-nginx-module/archive/master.zip&lt;/code&gt; というURLになるのですが、 &lt;code&gt;.zip&lt;/code&gt; を &lt;code&gt;.tar.gz&lt;/code&gt; に変えればtar.gz形式でダウンロードできます。&lt;/p&gt;

&lt;p&gt;また、 &lt;code&gt;master&lt;/code&gt; の部分はブランチ名、タグ名、コミットハッシュを指定することも出来るので任意のコミットのソースを取得可能です。&lt;/p&gt;

&lt;p&gt;好みのファイル名でダウンロードするのは、通常ならダウンロードするツール側で対応すれば良い話です。例えば&lt;a href=&#34;http://linux.die.net/man/1/curl&#34;&gt;curl(1): transfer URL - Linux man page&lt;/a&gt;を使う場合は &lt;code&gt;-o&lt;/code&gt; オプションで &lt;code&gt;-o ファイル名&lt;/code&gt; のように指定すれば良いだけです。&lt;/p&gt;

&lt;p&gt;ただ、RPMのspecファイルの &lt;code&gt;Source:&lt;/code&gt; に指定するときはちょっと厄介です。
&lt;a href=&#34;https://fedoraproject.org/wiki/How_to_create_an_RPM_package#SPEC_file_overview&#34;&gt;SPEC file overview&lt;/a&gt;の &lt;code&gt;Source0&lt;/code&gt; の説明を読むと、URLのベースネーム (最後のスラッシュの後の部分) が &lt;code&gt;~/rpmbuild/SOURCES&lt;/code&gt; ディレクトリ配下に置くファイル名になるようにするべきとあります。&lt;/p&gt;

&lt;p&gt;しかし、上述のようにGitHubでソースのtarballのURLのベースネームは &lt;code&gt;コミットハッシュなど.tar.gz&lt;/code&gt; という形式となっています。これだと複数のソースをダウンロードした時に、どれがどれかわかりにくいですし、 &lt;code&gt;バージョン番号.tar.gz&lt;/code&gt; の場合だとファイル名が衝突する恐れもあります。&lt;/p&gt;

&lt;p&gt;解決策ですが、元のURLに &lt;code&gt;#/&lt;/code&gt; をつけてその後に好きなファイル名を指定すればOKです。具体的には &lt;code&gt;https://github.com/ユーザ名/プロジェクト名/archive/コミットハッシュなど.tar.gz#/プロジェクト名-コミットハッシュなど.tar.gz&lt;/code&gt; のように書きます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Packaging:SourceURL?rd=Packaging/SourceURL#Commit_Revision&#34;&gt;Packaging:SourceURL - FedoraProject&lt;/a&gt;にはbitbucket.orgとgitlab.comの場合の書き方も紹介されていますので、必要に応じてご参照ください。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>