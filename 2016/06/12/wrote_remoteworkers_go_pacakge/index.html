<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja-jp" lang="ja-jp">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.97.3" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Goで複数のリモートのワーカーにジョブを実行させるremoteworkersというパッケージを書いた &middot; hnakamur&#39;s blog</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/copy-button.css">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://hnakamur.github.io/blog/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://hnakamur.github.io/blog/favicon.png">

  
  


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-53263855-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-53263855-1');
</script>



</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://hnakamur.github.io/blog/"><h1>hnakamur&#39;s blog</h1></a>
      <p class="lead">
       my tech memo 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://hnakamur.github.io/blog/"> blog home </a></li><li><a href="https://github.com/hnakamur"> github @hnakamur </a></li><li><a href="https://twitter.com/hnakamur2"> twitter @hnakamur2 </a></li>
      </ul>
    </nav>

    <p>powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://pages.github.com/">GitHub Pages</a></p>
    <p>&copy; 2022. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>Goで複数のリモートのワーカーにジョブを実行させるremoteworkersというパッケージを書いた</h1>
  <time datetime=2016-06-12T21:53:35&#43;0900 class="post-date">2016-06-12</time>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#なぜ書いたか">なぜ書いたか</a></li>
    <li><a href="#これまでに試したこと">これまでに試したこと</a></li>
    <li><a href="#今回の実装">今回の実装</a>
      <ul>
        <li><a href="#connとhub">ConnとHub</a></li>
        <li><a href="#読み取りと書き出しでgoroutineを分ける">読み取りと書き出しでgoroutineを分ける</a></li>
        <li><a href="#ジョブのディスパッチと結果の収集">ジョブのディスパッチと結果の収集</a></li>
        <li><a href="#自動で再接続">自動で再接続</a></li>
        <li><a href="#返信用のチャンネルを渡して実行">返信用のチャンネルを渡して実行</a></li>
        <li><a href="#ジョブのエンコードデコード">ジョブのエンコード・デコード</a></li>
        <li><a href="#結果のエンコードデコード">結果のエンコード・デコード</a></li>
        <li><a href="#tcpソケットからwebsocketにして良かったところ">TCPソケットからWebSocketにして良かったところ</a></li>
      </ul>
    </li>
    <li><a href="#おわりに">おわりに</a></li>
  </ul>
</nav>
  <h2 id="なぜ書いたか">なぜ書いたか</h2>
<p>仕事で複数のサーバで同じ処理を実行して結果を集めたいというニーズがあって、各サーバをgRPCのサーバにするという実装でとりあえず実現していました。でも、出来れば処理を実行するワーカーサーバから制御サーバに接続して繋ぎっぱなしにしておいて、制御サーバからジョブを送り込む方式にしたいなーと思っていて、家で実装を進めていました。</p>
<h2 id="これまでに試したこと">これまでに試したこと</h2>
<p>gRPCに<a href="http://www.grpc.io/docs/tutorials/basic/go.html#bidirectional-streaming-rpc">Bidirectional streaming RPC</a>というのがあったので、<a href="https://github.com/hnakamur/grpc_notification_experiment">hnakamur/grpc_notification_experiment</a>で試してみたのですが、複数クライアントがサーバに接続した状態で、サーバからクライアントにジョブを投げても、1つのクライアントでしか処理が実行されないということがわかりました。</p>
<p>次に、ワーカーサーバから制御サーバにTCPのソケットで接続しておいて、制御サーバからワーカーサーバにジョブを投げて結果を集めるサンプルを書いてみました。
<a href="https://github.com/hnakamur/tcp_pubsubreply_experiment">hnakamur/tcp_pubsubreply_experiment</a></p>
<p>複数のワーカーに同じジョブを投げて結果を集めて、全てのワーカーからの結果が揃ったらクライアントに結果を返すというものです。 <a href="https://github.com/hnakamur/tcp_pubsubreply_experiment/blob/f9201c075661c5d58895f9a30b47f73f5c4cc13d/main.go#L167-L189">https://github.com/hnakamur/tcp_pubsubreply_experiment/blob/f9201c075661c5d58895f9a30b47f73f5c4cc13d/main.go#L167-L189</a> でジョブを各ワーカーのコネクションが持つチャンネルに送って、各ワーカーの結果を返すチャンネルから受け取るという素朴な実装になっています。</p>
<p>しかし、この実装では1つのジョブを実行中は他のジョブを実行できないという制限があります。また試しているとタイミングによっては期待通りの動きにならないことがありました。</p>
<h2 id="今回の実装">今回の実装</h2>
<p>実装は<a href="https://github.com/hnakamur/remoteworkers">hnakamur/remoteworkers</a>で公開しています。使用例は<a href="https://github.com/hnakamur/remoteworkers/tree/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example">remoteworkers/example</a>、APIドキュメントは<a href="https://godoc.org/github.com/hnakamur/remoteworkers">remoteworkers - GoDoc</a>を参照してください。</p>
<p>最初はWebSocketのライブラリ<a href="https://github.com/gorilla/websocket">github.com/gorilla/websocket</a>の<a href="https://github.com/gorilla/websocket/tree/a68708917c6a4f06314ab4e52493cc61359c9d42/examples">examples</a>のchatとechoのclientを組み合わせて改変していきました。chatは1つのクライアントからのメッセージを他のクライアントに送って終わりですが、今回はジョブを実行して結果を集めたいので、その処理を追加で実装しました。また、元のサンプルはグローバル変数や設定用の定数を使うようになっていたのでstructを定義してグローバル変数をやめて設定もstructのメンバーに持つようにしました。</p>
<p>ワーカーはサーバにwebsocketで接続しますが、クライアントは通常のhttpリクエストでジョブを投げてレスポンスで結果を受け取るようにしてみました。ワーカーとサーバの間のメッセージは<a href="/blog/2016/06/04/benchmark_go_msgpack_libraries/">GoのMessagePackのライブラリのベンチマークをしてみた · hnakamur&rsquo;s blog at github</a>で試した<a href="https://github.com/vmihailenco/msgpack">vmihailenco/msgpack</a>を使ってMessagePackでエンコード・デコードしています。</p>
<p>以下実装メモです。</p>
<h3 id="connとhub">ConnとHub</h3>
<p>サーバ側のメインの処理は、サーバとワーカーのコネクションを扱う<a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/conn.go">Conn</a>と複数のConnの間を取り持つ<a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go">Hub</a>が担当しています。</p>
<h3 id="読み取りと書き出しでgoroutineを分ける">読み取りと書き出しでgoroutineを分ける</h3>
<p>上記の<a href="https://github.com/hnakamur/tcp_pubsubreply_experiment">hnakamur/tcp_pubsubreply_experiment</a>では、ワーカーとサーバ間のTCPコネクション1つのに対して1つgoroutineを作ってデータの読み書きをしていました。</p>
<p>一方、<a href="https://godoc.org/github.com/gorilla/websocket">github.com/gorilla/websocketのAPIドキュメント</a>の<a href="https://godoc.org/github.com/gorilla/websocket#hdr-Concurrency">Concurrency</a>にコネクションは1つのコンカレントなリーダーと1つのコンカレントなライターをサポートすると書いてあります。</p>
<p>chatのexampleを見ると<a href="https://github.com/gorilla/websocket/blob/a68708917c6a4f06314ab4e52493cc61359c9d42/examples/chat/conn.go#L50-L69">Conn.readPump()</a>で読み取り処理のループ、<a href="https://github.com/gorilla/websocket/blob/a68708917c6a4f06314ab4e52493cc61359c9d42/examples/chat/conn.go#L78-L116">Conn.writePump()</a>で書き出し処理のループを実装していて <a href="https://github.com/gorilla/websocket/blob/a68708917c6a4f06314ab4e52493cc61359c9d42/examples/chat/conn.go#L127-L128">https://github.com/gorilla/websocket/blob/a68708917c6a4f06314ab4e52493cc61359c9d42/examples/chat/conn.go#L127-L128</a> でgoroutineを使って並行(concurrent)に実行しています。</p>
<p>この方式により上記の<a href="https://godoc.org/github.com/gorilla/websocket#hdr-Concurrency">Concurrency</a>の1つのコネクションに1つのコンカレントなリーダーと1つのコンカレントなライターという条件を自動的に満たすことが出来ます。</p>
<p>さらに、ワーカーでのジョブの実行も <a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/worker.go#L200-L214">https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/worker.go#L200-L214</a> のように別のgoroutineで実行するようにしました。読み取りと書き出しのgoroutineを分け、ジョブ実行のgoroutineも別にしたことで、ワーカーでジョブを実行中でも別のジョブを受け取って実行することが出来るようになりました。</p>
<h3 id="ジョブのディスパッチと結果の収集">ジョブのディスパッチと結果の収集</h3>
<p>各ワーカーからにジョブを投げて結果を集める部分も <a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L139-L171">https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L139-L171</a> のように書くことで、複数のジョブを並行で実行できるようになっています。</p>
<p>例えば、あるジョブを依頼されてそれの結果が集まる前に、次のジョブを受け取ってそちらの結果が先に集まった場合はそちらを先に返すことができます。</p>
<h3 id="自動で再接続">自動で再接続</h3>
<p>ワーカーとの接続が切れた場合は、残ったワーカーだけで処理を実行する仕様としました。ジョブを受け取った時にワーカーが1つもいない場合はエラーとしています。また、ワーカーからサーバへの接続が切れた場合は1秒待って再起動を無限に繰り替えすようにしています。時間は設定で変更可能です。ただし、だんだん間隔を開けるといったことは出来ないのでその場合はフォークして改変してください。</p>
<h3 id="返信用のチャンネルを渡して実行">返信用のチャンネルを渡して実行</h3>
<p>サーバとワーカのコネクションをHubに登録する箇所 <a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/conn.go#L86-L92">https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/conn.go#L86-L92</a> とクライアントから依頼されたジョブをHubに投げて全ワーカーからの結果を受け取る箇所 <a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L194-L203">https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L194-L203</a> では、結果を受け取るためのチャンネルをHubへのチャンネルに渡して実行するという方法を取りました。</p>
<p>これによってHubとのやり取りは全てチャンネル経由になりシンプルになりました。さらに関数の中に閉じ込めることで、ライブラリの利用者はチャンネルを意識することなく単なる関数呼び出しで使えるようになっています。</p>
<h3 id="ジョブのエンコードデコード">ジョブのエンコード・デコード</h3>
<p>まずクライアントではジョブをJSONでエンコードしています。
<a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/client/client.go#L25-L30">https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/client/client.go#L25-L30</a></p>
<p>サーバでは受け取ったジョブをJSONでデコードします。
<a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/server/main.go#L52-L54">https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/server/main.go#L52-L54</a></p>
<p>その後<a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L193-L205">Hub.RequestWork()</a>でHubにジョブが渡されて
<a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L142">https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L142</a>
でMessagePackでエンコードしてワーカーに送ります。</p>
<p>ワーカーでは
<a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/worker.go#L187-L188">https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/worker.go#L187-L188</a>
で受け取ったジョブをMessagePackでデコードします。</p>
<p>ワーカーでジョブを受け取って処理する部分は
<a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/worker/main.go#L47-L58">https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/worker/main.go#L47-L58</a>
です。<a href="https://github.com/vmihailenco/msgpack">vmihailenco/msgpack</a>で <code>map[string]string</code> 型をエンコードしてデコードすると <code>map[interface{}]interface{}</code> になったので<a href="https://golang.org/ref/spec#Type_assertions">type assertion</a>を使って参照する必要がありました。</p>
<h3 id="結果のエンコードデコード">結果のエンコード・デコード</h3>
<p>ワーカーでの結果は
<a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/worker.go#L202-L206">https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/worker.go#L202-L206</a>
でMessagePackにエンコードしています。</p>
<p>サーバでは
<a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/conn.go#L148-L163">https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/conn.go#L148-L163</a>
で結果をMessagePackでデコードしてHubに送っています。</p>
<p>Hubでは
<a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L165-L171">https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/hub.go#L165-L171</a>
で1つのワーカーからの結果を受け取り、全てのワーカーからの結果が揃ったらクライアントへ返信するためのチャンネルに集めた結果を送ります。</p>
<p>サーバでは
<a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/server/main.go#L28-L39">https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/server/main.go#L28-L39</a>
で集めた結果の構造を変形し、
<a href="https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/server/main.go#L69-L70">https://github.com/hnakamur/remoteworkers/blob/0ee6c4fa0ffe12af7ff6e7aefd5e3f0ebe042e31/example/server/main.go#L69-L70</a>
でJSONにエンコードしています。</p>
<h3 id="tcpソケットからwebsocketにして良かったところ">TCPソケットからWebSocketにして良かったところ</h3>
<p>ワーカーからサーバに接続したときにワーカーのIDを登録しているのですが、TCPソケットのときはそのためにワーカーから登録用のメッセージを送って成功失敗の結果を送る必要がありました。一方WebSocketではエンドポイントに接続するときにリクエストヘッダで追加の情報を送れるので <code>X-Worker-ID</code> と言うヘッダ名でワーカーIDを送るようにしました。</p>
<p>また、TCPソケットだと1つのポートでクライアントとワーカーからの通信を受ける場合はメッセージの内容で区別がつくようにしておく必要があります。WebSocketの場合は1つのポートでもURLのPathを別にするという手が使えるので楽です。しかも今回のようにワーカーはWebSocketで接続し、クライアントはhttpで接続ということも出来て便利です。</p>
<h2 id="おわりに">おわりに</h2>
<p>当初やりたいと思っていたことがようやく実現できました。しかも、これだけ並列性が高いプログラムなのにgoroutineとchannelのおかげですっきりシンプルなコードで実装出来ています。これなら保守や改変もしやすくて助かります。やっぱりGoは素晴らしいです！</p>

</div>


<script src="https://hnakamur.github.io/blog/js/copy-button.js"></script>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-53263855-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  </body>
</html>
