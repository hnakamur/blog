<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on hnakamur&#39;s blog at github</title>
    <link>/blog/post/</link>
    <description>Recent content in Posts on hnakamur&#39;s blog at github</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Tue, 15 Dec 2015 04:19:16 +0900</lastBuildDate>
    <atom:link href="/blog/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました</title>
      <link>/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/</link>
      <pubDate>Tue, 15 Dec 2015 04:19:16 +0900</pubDate>
      
      <guid>/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/</guid>
      <description>

&lt;h2 id=&#34;はじめに:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/11/26/use_travis_and_copr_to_build_and_host_rpm/&#34;&gt;Travis CIとcopr.fedoraproject.orgを使ってrpmをビルド・配布するのを試してみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;と&lt;a href=&#34;/blog/blog/2015/12/05/build_rpm_with_mock/&#34;&gt;mockコマンドでrpmをビルドする · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;の環境でいくつかrpmをビルド・配布してみたのですが、手元の環境でビルドを成功させるまでに試行錯誤するのと、coprにsrpmをアップロードしてビルド・配布するのが別の環境だと面倒なことに気付きました。&lt;/p&gt;

&lt;p&gt;そこで、1つのdockerコンテナで両方を行えるようにしました。&lt;/p&gt;

&lt;h2 id=&#34;travis-ciは外しました:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;Travis CIは外しました&lt;/h2&gt;

&lt;p&gt;また、Travis CIは使わないようにしました。理由は2つあります。1つめの理由はgithubのプロジェクトごとにTravis CIのプロジェクトを作ってcopr APIのログイン名、ユーザ名、トークンを環境変数で設定するのが面倒だったからです。これ自体はTravisのAPIを使えば解決する問題かもしれません。&lt;/p&gt;

&lt;p&gt;2つめの理由は、結局手元の環境でビルドを試すので、そこからそのままcoprにsrpmを上げるほうが手っ取り早いことに気づいたからです。これは初回にrpmのspecファイルを作成するときも、その後specファイルのバージョンを更新して新しいバージョンのrpmを作成するときもそうです。&lt;/p&gt;

&lt;h2 id=&#34;nginxのカスタムrpmをビルド-配布するためのdockerコンテナ:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;nginxのカスタムrpmをビルド・配布するためのdockerコンテナ&lt;/h2&gt;

&lt;p&gt;githubレポジトリ&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm&#34;&gt;hnakamur/nginx-rpm&lt;/a&gt;に公開しています。対応するcoprのプロジェクトは&lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nginx/&#34;&gt;hnakamur/nginx Copr&lt;/a&gt;です。&lt;/p&gt;

&lt;h2 id=&#34;ビルド前の準備:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;ビルド前の準備&lt;/h2&gt;

&lt;h3 id=&#34;copr-apiトークンを-envrcにコピー:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;copr APIトークンを.envrcにコピー&lt;/h3&gt;

&lt;p&gt;coprを使うにはFedoraアカウントが必要です。&lt;a href=&#34;https://admin.fedoraproject.org/accounts/user/new&#34;&gt;Sign up for a Fedora account&lt;/a&gt; から登録してください。&lt;/p&gt;

&lt;p&gt;Fedoraアカウントにログインした状態で &lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;を開くと、ページの先頭にAPI Tokenというセクションがあり、以下のような内容が表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[copr-cli]
login = ログインID
username = ユーザ名
token = トークン
copr_url = https://copr.fedoraproject.org
# expiration date: 2016-05-12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドを実行して上記のgithubレポジトリを手元にコピーします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/hnakamur/nginx-rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.envrc.example&lt;/code&gt; を &lt;code&gt;.envrc&lt;/code&gt; にコピーして、上で表示したログインID、ユーザ名、トークンを &lt;code&gt;.envrc&lt;/code&gt; 内の &lt;code&gt;COPR_LOGIN&lt;/code&gt;, &lt;code&gt;COPR_USERNAME&lt;/code&gt;, &lt;code&gt;COPR_TOKEN&lt;/code&gt; 環境変数に設定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# NOTE: Copy this file to .envrc and edit the values
# Go https://copr.fedoraproject.org/api/ and login in and see the values to set.
export COPR_LOGIN=_your_login_here_
export COPR_USERNAME=_your_username_here_
export COPR_TOKEN=_your_token_here_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;セキュリティを考慮してこれらの値はdockerのイメージには埋め込まず、実行時にdockerの &lt;code&gt;-e&lt;/code&gt; オプションで渡すようにしています。具体的には &lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/docker_wrapper.sh&#34;&gt;docker_wrapper.sh&lt;/a&gt; の &lt;code&gt;docker run&lt;/code&gt; の行を参照してください。&lt;/p&gt;

&lt;h3 id=&#34;specファイルの調整:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;specファイルの調整&lt;/h3&gt;

&lt;p&gt;specファイルは &lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/SPECS/nginx.spec&#34;&gt;SPECS/nginx&lt;/a&gt; にあります。各自のニーズに応じて適宜調整します。現時点では &lt;a href=&#34;http://nginx.org/packages/centos/7/SRPMS/&#34;&gt;http://nginx.org/packages/centos/7/SRPMS/&lt;/a&gt; で配布されているCentOS 7用のsrpmをベースに以下の3つのモジュールを組み込んだものになっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/openresty/lua-nginx-module&#34;&gt;openresty/lua-nginx-module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yaoweibin/nginx_upstream_check_module&#34;&gt;yaoweibin/nginx_upstream_check_module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/replay/ngx_http_consistent_hash&#34;&gt;replay/ngx_http_consistent_hash&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;nginx.orgで配布されているsrpm内のnginx.specからの差分は &lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/compare/7e234d2a222778c0a46204dba4e2dcaae8bf7894...ce4e842731a9b90034f9e00796e16839d8bda826&#34;&gt;https://github.com/hnakamur/nginx-rpm/compare/7e234d2a222778c0a46204dba4e2dcaae8bf7894...ce4e842731a9b90034f9e00796e16839d8bda826&lt;/a&gt; で見られます。&lt;/p&gt;

&lt;h3 id=&#34;sources-ファイルの調整:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;SOURCES/*ファイルの調整&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/tree/master/SOURCES&#34;&gt;SOURCES/&lt;/a&gt;にsrpmで必要なソースファイルを置いています。必要に応じて調整してください。今は &lt;a href=&#34;http://nginx.org/packages/centos/7/SRPMS/&#34;&gt;http://nginx.org/packages/centos/7/SRPMS/&lt;/a&gt; で配布されているCentOS 7用のsrpmから頂いたものをそのまま使用しています。&lt;/p&gt;

&lt;p&gt;なお、nginx自体のソースコード(例: nginx-1.9.9.tar.gz)や各エクステンションのソースコードは含めず、ビルド時にダウンロードするようにしています。これはgitレポジトリの肥大化を防ぐためです。&lt;/p&gt;

&lt;h3 id=&#34;ビルドスクリプトの調整:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;ビルドスクリプトの調整&lt;/h3&gt;

&lt;p&gt;ビルドスクリプト&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/scripts/build.sh&#34;&gt;scripts/build.sh&lt;/a&gt;も適宜調整します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;copr_project_name、copr_project_description、copr_project_instructions、rpm_nameをお好みで編集してください。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;download_source_files&lt;/code&gt; 関数はspecファイルの &lt;code&gt;/^Source[0-9]*:&lt;/code&gt; にマッチするパターンで値がhttpから始まるURLについてダウンロードするようにしています。そしてURLの最後のスラッシュ以降をファイル名として採用しています。このルールから外れる場合は、この関数を適宜変更してください。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;dockerfileとdockerのラッパースクリプトを調整:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;Dockerfileとdockerのラッパースクリプトを調整&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt;と&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/docker_wrapper.sh&#34;&gt;docker_wrapper.sh&lt;/a&gt;を適宜調整してください。&lt;/p&gt;

&lt;p&gt;通常は&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/fa051c195e030c2e7f247fa258c6fad1ef9f0dde/docker_wrapper.sh&#34;&gt;docker_wrapper.sh&lt;/a&gt;のdockerimageを好きな名前に変えるぐらいで大丈夫だと思います。&lt;/p&gt;

&lt;h2 id=&#34;dockerイメージを作成:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;dockerイメージを作成&lt;/h2&gt;

&lt;p&gt;以下のコマンドを実行してdockerイメージをビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./docker_wrapper.sh build
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dockerイメージを起動してmockでrpmをビルド:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;dockerイメージを起動してmockでrpmをビルド&lt;/h2&gt;

&lt;p&gt;以下のコマンドを実行してdockerイメージを起動してbashプロンプトを表示します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source .envrc
./docker_wrapper.sh bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに私は&lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;direnv/direnv&lt;/a&gt;を使っているので、 &lt;code&gt;source .envrc&lt;/code&gt; の行は自分で入力しなくても&lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;direnv/direnv&lt;/a&gt;が実行してくれるので便利です。direnvについては&lt;a href=&#34;http://blog.hde.co.jp/entry/2015/02/27/182117&#34;&gt;改めて、direnvを使いましょう！ - HDE BLOG&lt;/a&gt;などの記事を参照してください。&lt;/p&gt;

&lt;p&gt;dockerイメージのbashプロンプトで以下のコマンドを実行してmockでrpmをビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./build.sh mock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mockはchroot環境を作ってそこでrpmをビルドするようになっているので、chroot環境の作成にちょっと時間がかかります。&lt;/p&gt;

&lt;p&gt;dockerコンテナという独立空間が既にあるのにmockでchroot環境を作るのは無駄なんですが、coprがmockを使っているためmockでビルドが成功することを確認してからcoprにsrpmをアップロードするほうが、coprでのビルド失敗を減らせて良いですのでこうしています。&lt;/p&gt;

&lt;h2 id=&#34;coprにsrpmをアップロードして-rpmをビルド-配布:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;coprにsrpmをアップロードして、rpmをビルド・配布&lt;/h2&gt;

&lt;p&gt;mockでrpmのビルドが成功することを確認できたら、dockerコンテナ内で以下のコマンドを実行してsrpmをcoprにアップロードします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./build.sh copr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/scripts/build.sh&#34;&gt;scripts/build.sh&lt;/a&gt;の &lt;code&gt;copr_project_name&lt;/code&gt; で指定した名前のプロジェクトがcopr上に存在しない場合はまず作成してからsrpmをアップロードするようになっています。&lt;/p&gt;

&lt;p&gt;coprのプロジェクト &lt;code&gt;https://copr.fedoraproject.org/coprs/${COPR_USER_NAME}/${copr_project_name}/&lt;/code&gt; でビルドが完了すれば、rpmのレポジトリとして利用可能です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:a6dec0c2f0f4e62064b6bd29ded4a923&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;mockとcoprを使ってnginxのカスタムrpmをビルド・配布する環境について説明しました。&lt;/p&gt;

&lt;p&gt;mockを使ってクリーンな環境でビルドできるので、今回のスクリプトでdockerコンテナを使う必要性は特にありません。Dockerfileでセットアップしたのと同等のCentOS7環境があれば &lt;a href=&#34;https://github.com/hnakamur/nginx-rpm/blob/master/scripts/build.sh&#34;&gt;scripts/build.sh&lt;/a&gt;を使ってsrpmのビルド、rpmのビルド、srpmのcoprへのアップロードを行えます。&lt;/p&gt;

&lt;p&gt;mockでのrpmのビルドが失敗した場合の調査方法とかcoprのAPIをcopr-cliではなくcurlで呼び出している話とか、いくつか書きたい話があるので日を改めて別記事として書こうと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rpmのspecファイルのSourceにGitHubの任意のコミットのtarballのURLを指定するときの良い書き方</title>
      <link>/blog/2015/12/06/good_rpm_spec_source_url_syntax_for_tarball_on_github/</link>
      <pubDate>Sun, 06 Dec 2015 00:07:23 +0900</pubDate>
      
      <guid>/blog/2015/12/06/good_rpm_spec_source_url_syntax_for_tarball_on_github/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Packaging:SourceURL?rd=Packaging/SourceURL#Commit_Revision&#34;&gt;Packaging:SourceURL - FedoraProject&lt;/a&gt;で知ったtipsの紹介です。&lt;/p&gt;

&lt;p&gt;GitHubでプロジェクトの[Download ZIP]ボタンを押すと、ソースをZIP形式でダウンロードできます。
コミット数が多いプロジェクトだと &lt;code&gt;git clone&lt;/code&gt; するよりも高速に取得できるので履歴が不要な場合には便利な方法です。&lt;/p&gt;

&lt;p&gt;例えば&lt;a href=&#34;https://github.com/openresty/lua-nginx-module&#34;&gt;openresty/lua-nginx-module&lt;/a&gt;なら &lt;code&gt;https://github.com/openresty/lua-nginx-module/archive/master.zip&lt;/code&gt; というURLになるのですが、 &lt;code&gt;.zip&lt;/code&gt; を &lt;code&gt;.tar.gz&lt;/code&gt; に変えればtar.gz形式でダウンロードできます。&lt;/p&gt;

&lt;p&gt;また、 &lt;code&gt;master&lt;/code&gt; の部分はブランチ名、タグ名、コミットハッシュを指定することも出来るので任意のコミットのソースを取得可能です。&lt;/p&gt;

&lt;p&gt;好みのファイル名でダウンロードするのは、通常ならダウンロードするツール側で対応すれば良い話です。例えば&lt;a href=&#34;http://linux.die.net/man/1/curl&#34;&gt;curl(1): transfer URL - Linux man page&lt;/a&gt;を使う場合は &lt;code&gt;-o&lt;/code&gt; オプションで &lt;code&gt;-o ファイル名&lt;/code&gt; のように指定すれば良いだけです。&lt;/p&gt;

&lt;p&gt;ただ、RPMのspecファイルの &lt;code&gt;Source:&lt;/code&gt; に指定するときはちょっと厄介です。
&lt;a href=&#34;https://fedoraproject.org/wiki/How_to_create_an_RPM_package#SPEC_file_overview&#34;&gt;SPEC file overview&lt;/a&gt;の &lt;code&gt;Source0&lt;/code&gt; の説明を読むと、URLのベースネーム (最後のスラッシュの後の部分) が &lt;code&gt;~/rpmbuild/SOURCES&lt;/code&gt; ディレクトリ配下に置くファイル名になるようにするべきとあります。&lt;/p&gt;

&lt;p&gt;しかし、上述のようにGitHubでソースのtarballのURLのベースネームは &lt;code&gt;コミットハッシュなど.tar.gz&lt;/code&gt; という形式となっています。これだと複数のソースをダウンロードした時に、どれがどれかわかりにくいですし、 &lt;code&gt;バージョン番号.tar.gz&lt;/code&gt; の場合だとファイル名が衝突する恐れもあります。&lt;/p&gt;

&lt;p&gt;解決策ですが、元のURLに &lt;code&gt;#/&lt;/code&gt; をつけてその後に好きなファイル名を指定すればOKです。具体的には &lt;code&gt;https://github.com/ユーザ名/プロジェクト名/archive/コミットハッシュなど.tar.gz#/プロジェクト名-コミットハッシュなど.tar.gz&lt;/code&gt; のように書きます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Packaging:SourceURL?rd=Packaging/SourceURL#Commit_Revision&#34;&gt;Packaging:SourceURL - FedoraProject&lt;/a&gt;にはbitbucket.orgとgitlab.comの場合の書き方も紹介されていますので、必要に応じてご参照ください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mockコマンドでrpmをビルドする</title>
      <link>/blog/2015/12/05/build_rpm_with_mock/</link>
      <pubDate>Sat, 05 Dec 2015 22:10:26 +0900</pubDate>
      
      <guid>/blog/2015/12/05/build_rpm_with_mock/</guid>
      <description>

&lt;h2 id=&#34;2015-12-15-追記:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;2015-12-15 追記&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/&#34;&gt;nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;という記事を書きましたのでそちらもご参照ください。&lt;/p&gt;

&lt;h2 id=&#34;以下元記事です:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;以下元記事です&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/11/26/use_travis_and_copr_to_build_and_host_rpm/&#34;&gt;Travis CIとcopr.fedoraproject.orgを使ってrpmをビルド・配布するのを試してみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;でrpmを外部のサーバでビルドできるようになりましたが、試行錯誤中はこの手順だと時間がかかりますので、手元の環境でビルドしたいところです。&lt;/p&gt;

&lt;h2 id=&#34;rpmbuild:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;rpmbuild&lt;/h2&gt;

&lt;p&gt;私は最近までrpmbuildでrpmをビルドしていました。以下のコマンドでspecファイルの &lt;code&gt;BuildRequires&lt;/code&gt; に書いたrpmをまとめてインストールすることが出来ることも最近知りました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum-builddep -y specファイルのパス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけでも十分便利ですが、1つの環境でいろんなrpmをビルドするような使い方をしていると不満が出てきます。ビルドに必要なパッケージを &lt;code&gt;BuildRequires&lt;/code&gt; に書き忘れていても、別のrpmのビルドの際にインストールされていてビルドが通ってしまい気づかない恐れがあるからです。&lt;/p&gt;

&lt;h2 id=&#34;mock:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;mock&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Mock&#34;&gt;Mock - FedoraProject&lt;/a&gt;を使えば、chrootでクリーンな環境でrpmをビルドしてくれるので、上記のように &lt;code&gt;BuildRequires&lt;/code&gt; に必要なパッケージを書き忘れた場合はビルドエラーになり間違いに気づくことができます。&lt;/p&gt;

&lt;p&gt;また、実行環境と異なるCPUアーキテクチャやRHELのバージョン用のrpmもビルドできます。 &lt;a href=&#34;http://linux.die.net/man/1/mock&#34;&gt;mock(1): build SRPMs in chroot - Linux man page&lt;/a&gt;によると &lt;code&gt;-r&lt;/code&gt; オプションで &lt;code&gt;/etc/mock/&amp;lt;chroot&amp;gt;.cfg&lt;/code&gt; の &lt;code&gt;&amp;lt;chroot&amp;gt;&lt;/code&gt; の部分を指定すればよいそうです。&lt;/p&gt;

&lt;p&gt;CentOS 7で &lt;code&gt;/etc/mock&lt;/code&gt; を見てみたところ、以下のような環境が用意されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[vagrant@localhost ~]$ ls /etc/mock/
default.cfg            fedora-21-armhfp.cfg   fedora-22-i386.cfg     fedora-23-ppc64.cfg         fedora-rawhide-ppc64le.cfg
epel-5-i386.cfg        fedora-21-i386.cfg     fedora-22-ppc64.cfg    fedora-23-ppc64le.cfg       fedora-rawhide-s390.cfg
epel-5-ppc.cfg         fedora-21-ppc64.cfg    fedora-22-ppc64le.cfg  fedora-23-s390.cfg          fedora-rawhide-s390x.cfg
epel-5-x86_64.cfg      fedora-21-ppc64le.cfg  fedora-22-s390.cfg     fedora-23-s390x.cfg         fedora-rawhide-sparc.cfg
epel-6-i386.cfg        fedora-21-s390.cfg     fedora-22-s390x.cfg    fedora-23-x86_64.cfg        fedora-rawhide-x86_64.cfg
epel-6-ppc64.cfg       fedora-21-s390x.cfg    fedora-22-x86_64.cfg   fedora-rawhide-aarch64.cfg  logging.ini
epel-6-x86_64.cfg      fedora-21-x86_64.cfg   fedora-23-aarch64.cfg  fedora-rawhide-armhfp.cfg   site-defaults.cfg
epel-7-x86_64.cfg      fedora-22-aarch64.cfg  fedora-23-armhfp.cfg   fedora-rawhide-i386.cfg
fedora-21-aarch64.cfg  fedora-22-armhfp.cfg   fedora-23-i386.cfg     fedora-rawhide-ppc64.cfg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Using_Mock_to_test_package_builds#Caching_in_mock_0.8.x_and_later&#34;&gt;Caching in mock 0.8.x and later&lt;/a&gt;を見るとmockの今のバージョンでは &lt;code&gt;mock&lt;/code&gt; を実行してchroot環境を作ってyumでダウンロードしたrpmはホスト環境にキャッシュされるそうです。&lt;/p&gt;

&lt;p&gt;ですので、複数のrpmをビルドしたり、同じrpmを試行錯誤で何度もビルドする場合に、キャッシュによる高速化が期待できます。&lt;/p&gt;

&lt;p&gt;まとめると、mockの利点は以下の2つです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;chrootによりクリーンな環境でビルドできるのでspecファイルの間違いに気づきやすい&lt;/li&gt;
&lt;li&gt;yumのキャッシュがあるのでビルドの際の &lt;code&gt;yum install&lt;/code&gt; が高速化される&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;coprもmockを使用しています:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;coprもmockを使用しています&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://copr.fedoraproject.org/&#34;&gt;copr&lt;/a&gt;でビルドした結果のmockchaing.log.gzを見ると、以下の様な行がありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[2015-12-05 11:13:20,751][  INFO][PID:19554] executing: /usr/bin/mockchain -r epel-7-x86_64 -l /var/tmp/mockremote-ZTm5H/build/ -a https://copr-be.cloud.fedoraproject.org/results/hnakamur/nginx/epel-7-x86_64 -a https://copr-be.cloud.fedoraproject.org/results/hnakamur/nginx/epel-7-x86_64/devel -m &#39;--define=copr_username hnakamur&#39; -m &#39;--define=copr_projectname nginx&#39; -m &#39;--define=vendor Fedora Project COPR (hnakamur/nginx)&#39; /tmp/build_package_repo/nginx/nginx-1.9.7-1.el7.ngx.src.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://linux.die.net/man/1/mockchain&#34;&gt;mockchain(1): chain package builder - Linux man page&lt;/a&gt;によると複数のrpmを一括ビルドするためのコマンドだそうです。&lt;/p&gt;

&lt;h3 id=&#34;mockを使うためのセットアップ:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;mockを使うためのセットアップ&lt;/h3&gt;

&lt;p&gt;epelを入れればmockはyumでインストール可能です。他にもsrpmを作るためにrpm-buildなどもyumでインストールする必要があるので、Vagrant用とDocker用にそれぞれセットアップ手順をまとめたものを作りました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hnakamur/centos-mock-vagrant&#34;&gt;hnakamur/centos-mock-vagrant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hnakamur/centos-mock-docker&#34;&gt;hnakamur/centos-mock-docker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vagrant環境のほうは単に &lt;code&gt;vagrant up&lt;/code&gt; で起動して &lt;code&gt;vagrant ssh&lt;/code&gt; でログインし、 &lt;code&gt;sudo su - mockbuild&lt;/code&gt; で &lt;code&gt;mockbuild&lt;/code&gt; ユーザになって作業します。&lt;/p&gt;

&lt;p&gt;Docker環境でmockを利用する場合、mockがunshareシステムコールを呼ぶので &lt;code&gt;SYS_ADMIN&lt;/code&gt; ケーパビリティが必要になります。そこで &lt;code&gt;docker run&lt;/code&gt; の際に &lt;code&gt;--cap-add=SYS_ADMIN&lt;/code&gt; オプションが必要です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker build -t mock .&lt;/code&gt; で &lt;code&gt;mock&lt;/code&gt; という名前でdockerイメージをビルドした場合、
&lt;code&gt;docker run --cap-add=SYS_ADMIN -it mock&lt;/code&gt; でbashプロンプトが起動しますので、 &lt;code&gt;su - mockbuild&lt;/code&gt; で &lt;code&gt;mockbuild&lt;/code&gt; ユーザになって作業します。&lt;/p&gt;

&lt;p&gt;mockのyumキャッシュを有効活用するには、複数のビルド間に環境を破棄せずに維持したほうが良いです。dockerのほうはbashを抜けると環境が消えてしまうので、もう少しDockerfileを工夫したようが良さそうです。&lt;/p&gt;

&lt;p&gt;とりあえず私はVagrantの環境の方を使っています。&lt;/p&gt;

&lt;h3 id=&#34;mockでのビルド:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;mockでのビルド&lt;/h3&gt;

&lt;p&gt;まずsrpmファイルを作ります。
上記の環境ですと、&lt;code&gt;mockbuild&lt;/code&gt; ユーザの &lt;code&gt;/home/mockbuild/rpmbuild/&lt;/code&gt; の下に &lt;code&gt;SPECS&lt;/code&gt; や &lt;code&gt;SOURCES&lt;/code&gt; ディレクトリが作ってありますので、そこにspecファイルやソースを置いて以下のコマンドを実行して作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpmbuild -bs specファイルのパス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記の環境では &lt;code&gt;/home/mockbuild/rpmbuild/SRPMS/&lt;/code&gt; にsrpmファイルが生成されます。
その後、以下のようにmockコマンドを実行してビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mock --rebuild srpmファイルのパス
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ビルドで生成されたrpmとsrpmファイルは &lt;code&gt;/var/lib/mock/&amp;lt;chroot&amp;gt;/result/&lt;/code&gt; に置かれます。
また、ビルドの作業ディレクトリは &lt;code&gt;/var/lib/mock/&amp;lt;chroot&amp;gt;/root/builddir/build/&lt;/code&gt; 以下に &lt;code&gt;BUILD&lt;/code&gt;, &lt;code&gt;BUILDROOT&lt;/code&gt;, &lt;code&gt;RPMS&lt;/code&gt;, &lt;code&gt;SOURCES&lt;/code&gt;, &lt;code&gt;SPECS&lt;/code&gt;, &lt;code&gt;SRPMS&lt;/code&gt; ディレクトリが作成されていますので、ビルドが失敗した場合はこの中を見て調査できます。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:a3564fc7d32baa9cb6d690c5205a26f2&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;実は&lt;a href=&#34;https://fedoraproject.org/wiki/Mock&#34;&gt;Mock - FedoraProject&lt;/a&gt;や&lt;a href=&#34;https://copr.fedoraproject.org/&#34;&gt;Project List&lt;/a&gt;はしばらく前に存在を知っていたのですが、ググっても情報が少ないしよくわからないのでスルーしていました。今回ついに使ってみたのですが、非常に便利なツールとサービスだということがわかりました。もっと前から使っておけばよかったです。&lt;/p&gt;

&lt;p&gt;みなさんも&lt;a href=&#34;https://fedoraproject.org/wiki/Mock&#34;&gt;Mock - FedoraProject&lt;/a&gt;と&lt;a href=&#34;https://copr.fedoraproject.org/&#34;&gt;Project List&lt;/a&gt;を活用して、快適なrpmビルド・配布環境を手に入れましょう！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Travis CIとcopr.fedoraproject.orgを使ってrpmをビルド・配布するのを試してみた</title>
      <link>/blog/2015/11/26/use_travis_and_copr_to_build_and_host_rpm/</link>
      <pubDate>Thu, 26 Nov 2015 22:33:57 +0900</pubDate>
      
      <guid>/blog/2015/11/26/use_travis_and_copr_to_build_and_host_rpm/</guid>
      <description>

&lt;h2 id=&#34;2015-12-15-追記:feab3b17551715c7fe87c510b9d66160&#34;&gt;2015-12-15 追記&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/12/15/using_mock_and_copr_to_build_nginx_rpm_on_docker/&#34;&gt;nginxのカスタムrpmをmockでビルドできることを確認してからcoprでビルド・配布する環境を作りました · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;という記事を書きましたのでそちらもご参照ください。&lt;/p&gt;

&lt;h2 id=&#34;はじめに:feab3b17551715c7fe87c510b9d66160&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;CentOSを使っていると、パッケージのバージョンが古いのでspecファイルを改変してrpmをビルドすることがちょくちょくあります。
一度ビルドした後は、自作rpmのレポジトリサーバを立ててそこに置いておくのが本来は良いんだろうなと思います。
ですが、サーバの運用の手間を考えると面倒だなと思って、AnsibleやDockerでのプロビジョニング中にビルドするようにしていました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://copr.fedoraproject.org/coprs/&#34;&gt;fedora projectのcoprというサービス&lt;/a&gt;を使うと、自分でサーバを用意しなくても
自作rpmのビルドとホスティングが出来ることを知り、試してみました。&lt;/p&gt;

&lt;h3 id=&#34;今回試したサンプル:feab3b17551715c7fe87c510b9d66160&#34;&gt;今回試したサンプル&lt;/h3&gt;

&lt;p&gt;githubのレポジトリは&lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm&#34;&gt;hnakamur/nodejs-rpm&lt;/a&gt;にあります。Node.jsをビルドするrpmです。&lt;/p&gt;

&lt;p&gt;specファイルは&lt;a href=&#34;https://github.com/kazuhisya/nodejs-rpm&#34;&gt;kazuhisya/nodejs-rpm&lt;/a&gt;のをほぼ流用しています。ありがとうございます！
一点変更したのはダウンロードするNode.jsのソースのtarballを &lt;code&gt;node-v*.tar.gz&lt;/code&gt; ではなく &lt;code&gt;node-v*.tar.xz&lt;/code&gt; にしています。&lt;/p&gt;

&lt;h2 id=&#34;coprについて:feab3b17551715c7fe87c510b9d66160&#34;&gt;coprについて&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://fedorahosted.org/copr/&#34;&gt;copr&lt;/a&gt;に説明があります。FAQの&lt;a href=&#34;https://fedorahosted.org/copr/wiki/UserDocs#HowisCoprpronounced&#34;&gt;How is Copr pronounced?&lt;/a&gt;によると、銅(copper)と同じでカッパーと発音するそうです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://fedorahosted.org/copr/wiki/UserDocs#Howlongdoyoukeepthebuilds&#34;&gt;How long do you keep the builds?&lt;/a&gt;によるとプロジェクトごとに最後に成功したビルドだけが保持されて、古いバージョンのビルドや失敗したビルドは14日後に削除されるそうです。&lt;/p&gt;

&lt;p&gt;ですので、古いバージョンも残しておきたい場合は、coprは使えません。その場合は自前でレポジトリサーバを立てて運用するしかなさそうです。&lt;/p&gt;

&lt;h3 id=&#34;参考-coprのウェブ管理画面にsrpmをアップロードしてrpmをビルドする手順:feab3b17551715c7fe87c510b9d66160&#34;&gt;参考: coprのウェブ管理画面にsrpmをアップロードしてrpmをビルドする手順&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://fedorahosted.org/copr/wiki/ScreenshotsTutorial&#34;&gt;ScreenshotsTutorial – copr&lt;/a&gt;にcoprのウェブ管理画面からsrpmをアップロードしてrpmをビルドする手順がスクリーンショット満載で説明されています。&lt;/p&gt;

&lt;h2 id=&#34;今回試したビルド手順の流れ:feab3b17551715c7fe87c510b9d66160&#34;&gt;今回試したビルド手順の流れ&lt;/h2&gt;

&lt;p&gt;今回試したビルド手順の流れは以下の通りです。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;githubのプロジェクトにspecファイルを置きます。&lt;/li&gt;
&lt;li&gt;git pushしたときにTravis CIでdockerコンテナを動かしてsrpmを作ってcoprに投入します。&lt;/li&gt;
&lt;li&gt;coprでrpmをビルドしてホスティングしてもらいます。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;事前準備:feab3b17551715c7fe87c510b9d66160&#34;&gt;事前準備&lt;/h2&gt;

&lt;h3 id=&#34;fedora-account-登録:feab3b17551715c7fe87c510b9d66160&#34;&gt;Fedora account 登録&lt;/h3&gt;

&lt;p&gt;まずは &lt;a href=&#34;https://admin.fedoraproject.org/accounts/user/new&#34;&gt;Sign up for a Fedora account&lt;/a&gt; からアカウント登録します。手順はメモしてなかったので省略します。&lt;/p&gt;

&lt;p&gt;私のアカウントのログイン後の「アカウントの詳細」のページを見ると「あなたの役割」のところにSigned CLA GroupとSigners of the Fedora Project Contributor Agreementという項目があり、共にステータスが「承認されました」となっているので、これらの申請の手順が必要だったと思います。&lt;/p&gt;

&lt;p&gt;承認されるまでしばらく時間がかかって、その間にrpmをビルドしてみたら署名されないことがありました。今ではプロジェクトごとに鍵が自動生成されてrpmが署名されるようになっています。&lt;/p&gt;

&lt;h3 id=&#34;travis-ciのプロジェクト作成:feab3b17551715c7fe87c510b9d66160&#34;&gt;Travis CIのプロジェクト作成&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/hnakamur/nodejs-rpm&#34;&gt;Travis CI上にhnakamur/nodejs-rpmプロジェクト&lt;/a&gt;を作成して、githubのレポジトリ&lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm&#34;&gt;hnakamur/nodejs-rpm&lt;/a&gt;に対応付けておきます。手順はメモしてなかったので省略します。&lt;/p&gt;

&lt;h3 id=&#34;travis-ciでdockerでコンテナを動かしてsrpmを作る:feab3b17551715c7fe87c510b9d66160&#34;&gt;Travis CIでdockerでコンテナを動かしてsrpmを作る&lt;/h3&gt;

&lt;p&gt;Travis CIでdockerを使う方法は &lt;a href=&#34;https://docs.travis-ci.com/user/docker/&#34;&gt;Using Docker in Builds - Travis CI&lt;/a&gt; で説明されています。&lt;/p&gt;

&lt;p&gt;試行錯誤の結果、以下のような &lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm/blob/0ed19cd5504fcb11875f12184bdb3ccd27caa6aa/.travis.yml&#34;&gt;.travis.yml&lt;/a&gt;を作成しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo: required

services:
  - docker

branches:
  only:
    - master
    - LTS

install:
  - docker build -t hnakamur/nodejsrpm .

script:
  - case $TRAVIS_BRANCH in master) project=nodejs5;; LTS) project=nodejs;; esac
  - docker run hnakamur/nodejsrpm &amp;quot;$COPR_LOGIN&amp;quot; &amp;quot;$COPR_USERNAME&amp;quot; &amp;quot;$COPR_TOKEN&amp;quot; &amp;quot;$project&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm&#34;&gt;hnakamur/nodejs-rpm&lt;/a&gt;では、mainブランチでNode.jsのv5.x (Stable)、LTSブランチでNode.jsのv4.x (LTS)のspecファイルを保持しています。&lt;/p&gt;

&lt;p&gt;coprは上記の通り1つのプロジェクトで複数バージョンは保持できないので、 &lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nodejs5/&#34;&gt;hnakamur/nodejs5 Copr&lt;/a&gt; と &lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nodejs/&#34;&gt;hnakamur/nodejs Copr&lt;/a&gt; の2つのプロジェクトを作ることにしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.travis-ci.com/user/environment-variables/#Default-Environment-Variables&#34;&gt;Environment Variables - Travis CI&lt;/a&gt;によると &lt;code&gt;TRAVIS_BRANCH&lt;/code&gt; 環境変数でgitのブランチが取得できます。ブランチ名に応じてプロジェクト名を切り替え、 &lt;code&gt;docker run&lt;/code&gt; で呼び出すスクリプトの引数に渡しています。&lt;/p&gt;

&lt;p&gt;COPR_LOGIN、COPR_USERNAME、COPR_TOKENの3つの環境変数ですが、Fedora accountにログインした状態で &lt;a href=&#34;https://copr.fedoraproject.org/api/&#34;&gt;API for Copr&lt;/a&gt;にアクセスし表示された値を使います。表示されているのはcoprのコマンドラインクライアント &lt;a href=&#34;https://pypi.python.org/pypi/copr-cli&#34;&gt;copr-cli&lt;/a&gt;用の設定ファイル &lt;code&gt;~/.config/copr&lt;/code&gt; の内容です。&lt;/p&gt;

&lt;p&gt;APIのアクセストークンなどは秘密にすべき情報なのでgithubのレポジトリ内のファイルには含めてはいけません。&lt;/p&gt;

&lt;p&gt;そこでこれらの値は&lt;a href=&#34;https://travis-ci.org/hnakamur/nodejs-rpm&#34;&gt;Travis CI上のhnakamur/nodejs-rpmプロジェクト&lt;/a&gt;で&lt;a href=&#34;https://docs.travis-ci.com/user/environment-variables/#Defining-Variables-in-Repository-Settings&#34;&gt;Defining Variables in Repository Settings&lt;/a&gt;の手順に従って設定しておきます。&lt;/p&gt;

&lt;p&gt;プロジェクトの管理画面の右上の[Settings]/[Settings]メニュー (このメニューはプロジェクトの管理者にのみ表示されます)を選んでCOPR_LOGIN、COPR_USERNAME、COPR_TOKENの3つの環境変数を追加します。COPR_LOGINとCOPR_TOKENの2つは[Display value in build log]を[ON]にしてログに出力しないようにしました。&lt;/p&gt;

&lt;p&gt;docker runで実行されるスクリプトの内容は以下の通りです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm/blob/0ed19cd5504fcb11875f12184bdb3ccd27caa6aa/copr-build.sh&#34;&gt;https://github.com/hnakamur/nodejs-rpm/blob/0ed19cd5504fcb11875f12184bdb3ccd27caa6aa/copr-build.sh&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
set -e
copr_login=$1
copr_username=$2
copr_token=$3
project_name=$4

spec_file=/root/rpmbuild/SPECS/nodejs.spec

mkdir -p /root/.config
cat &amp;gt; /root/.config/copr &amp;lt;&amp;lt;EOF
[copr-cli]
login = ${copr_login}
username = ${copr_username}
token = ${copr_token}
copr_url = https://copr.fedoraproject.org
EOF

status=`curl -s -o /dev/null -w &amp;quot;%{http_code}&amp;quot; https://copr.fedoraproject.org/api/coprs/${copr_username}/${project_name}/detail/`
if [ $status = &amp;quot;404&amp;quot; ]; then
  copr-cli create --chroot epel-7-x86_64 --description &#39;node.js repository&#39; ${project_name}
fi
version=`awk &#39;$1==&amp;quot;Version:&amp;quot; {print $2}&#39; ${spec_file}`
release=$(rpm --eval `awk &#39;$1==&amp;quot;Release:&amp;quot; {print $2}&#39; ${spec_file}`)
srpm_file=/root/rpmbuild/SRPMS/nodejs-${version}-${release}.src.rpm
copr-cli build --nowait ${project_name} ${srpm_file}

rm /root/.config/copr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、引数で渡された情報を元にcopr-cliの設定ファイル &lt;code&gt;/root/.config/copr&lt;/code&gt; を生成します。
次にcoprのAPIでプロジェクトが作成済みかチェックし、作成されていなければ作成します。
その後、 &lt;code&gt;copr-cli build&lt;/code&gt; でsrpmをcoprにアップロードしてビルドを開始します。&lt;/p&gt;

&lt;p&gt;curlでhttpステータスだけを出力する方法は &lt;a href=&#34;http://superuser.com/questions/272265/getting-curl-to-output-http-status-code/442395#442395&#34;&gt;Getting curl to output HTTP status code? - Super User&lt;/a&gt; で知りました。ありがとうございます！&lt;/p&gt;

&lt;p&gt;ビルド完了までTravis側で待つようにするのはムダだと思ったので &lt;code&gt;copr-cli build&lt;/code&gt; には &lt;code&gt;--nowait&lt;/code&gt; オプションを指定しました。代わりに &lt;a href=&#34;https://apps.fedoraproject.org/notifications/&#34;&gt;Fedora Notifications&lt;/a&gt;でメール通知を有効にして、ビルド終了時には &lt;code&gt;notifications@fedoraproject.org&lt;/code&gt; からメールが届くようにして使っています。&lt;/p&gt;

&lt;h3 id=&#34;srpmのビルドとcopr-cliのインストール:feab3b17551715c7fe87c510b9d66160&#34;&gt;srpmのビルドとcopr-cliのインストール&lt;/h3&gt;

&lt;p&gt;話が前後しますが、srpmのビルドとcopr-cliのインストールは &lt;code&gt;docker build&lt;/code&gt; で行っています。
&lt;a href=&#34;https://github.com/hnakamur/nodejs-rpm/blob/0ed19cd5504fcb11875f12184bdb3ccd27caa6aa/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt;の内容は以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM centos:7
MAINTAINER Hiroaki Nakamura &amp;lt;hnakamur@gmail.com&amp;gt;

RUN yum -y install rpmdevtools rpm-build \
 &amp;amp;&amp;amp; rpmdev-setuptree

RUN yum -y install epel-release \
 &amp;amp;&amp;amp; yum -y install python-pip \
 &amp;amp;&amp;amp; pip install copr-cli

ADD nodejs.spec /root/rpmbuild/SPECS/
ADD node-js.*patch /root/rpmbuild/SOURCES/

RUN version=`awk &#39;$1==&amp;quot;Version:&amp;quot; {print $2}&#39; /root/rpmbuild/SPECS/nodejs.spec` \
 &amp;amp;&amp;amp; curl -sL -o /root/rpmbuild/SOURCES/node-v${version}.tar.xz https://nodejs.org/dist/v${version}/node-v${version}.tar.xz \
 &amp;amp;&amp;amp; rpmbuild -bs /root/rpmbuild/SPECS/nodejs.spec

ADD copr-build.sh /root/
ENTRYPOINT [&amp;quot;/bin/bash&amp;quot;, &amp;quot;/root/copr-build.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;copr-cliはCentOS 7だとepelから &lt;code&gt;yum install&lt;/code&gt; でインストール可能なのですが、バージョンが古いため &lt;code&gt;copr-cli build&lt;/code&gt; でsrpmファイルのパスを指定してアップロードする機能が無いようです。サイトにアップロードしておいてURLを指定することは可能なのですが、それだと面倒なので &lt;code&gt;pip&lt;/code&gt; を使って最新版の &lt;code&gt;copr-cli&lt;/code&gt; をインストールしています。&lt;/p&gt;

&lt;p&gt;長く運用するサーバならrpmでインストールされるパスと同じパスにpipでインストールしてしまうのは良くないかもしれませんが、ビルド終了したら破棄するコンテナなので気にせず上書きインストールとしています。&lt;/p&gt;

&lt;h2 id=&#34;rpmを使う手順:feab3b17551715c7fe87c510b9d66160&#34;&gt;rpmを使う手順&lt;/h2&gt;

&lt;p&gt;例えば&lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nodejs/&#34;&gt;hnakamur/nodejs Copr&lt;/a&gt;だと右の方の[Quick Enable]という欄に &lt;code&gt;dnf copr enable hnakamur/nodejs&lt;/code&gt; というコマンドで有効にできるという説明があります。&lt;/p&gt;

&lt;p&gt;その下のリンクをたどると&lt;a href=&#34;https://fedorahosted.org/copr/wiki/HowToEnableRepo&#34;&gt;HowToEnableRepo – copr&lt;/a&gt;に
yumの場合は &lt;code&gt;yum copr enable user/project&lt;/code&gt; となるとあります。ただし、 &lt;code&gt;yum-plugin-copr&lt;/code&gt; という &lt;code&gt;yum&lt;/code&gt; のプラグインが必要です。&lt;/p&gt;

&lt;p&gt;これはepelとかには無いようで、&lt;a href=&#34;https://copr.fedoraproject.org/coprs/alonid/yum-plugin-copr/&#34;&gt;alonid/yum-plugin-copr Copr&lt;/a&gt;にありました。が、これをインストールするにはこのプロジェクトを有効にする必要があるので面倒です。&lt;/p&gt;

&lt;p&gt;コマンドを使わなくても&lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nodejs/&#34;&gt;hnakamur/nodejs Copr&lt;/a&gt;のActive Releasesセクションの表のRepo Downloadの列にある[Epel 7]というボタンを押すと以下のようにレポジトリの設定ファイルが表示されます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://copr.fedoraproject.org/coprs/hnakamur/nodejs/repo/epel-7/hnakamur-nodejs-epel-7.repo&#34;&gt;https://copr.fedoraproject.org/coprs/hnakamur/nodejs/repo/epel-7/hnakamur-nodejs-epel-7.repo&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[hnakamur-nodejs]
name=Copr repo for nodejs owned by hnakamur
baseurl=https://copr-be.cloud.fedoraproject.org/results/hnakamur/nodejs/epel-7-$basearch/
skip_if_unavailable=True
gpgcheck=1
gpgkey=https://copr-be.cloud.fedoraproject.org/results/hnakamur/nodejs/pubkey.gpg
enabled=1
enabled_metadata=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なので、これを &lt;code&gt;/etc/yum.repos.d/hnakamur-nodejs-epel-7.repo&lt;/code&gt; に保存して &lt;code&gt;yum install nodejs&lt;/code&gt; でインストールすればOKです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:feab3b17551715c7fe87c510b9d66160&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;これでスペックファイルを書いてgithubにプッシュすれば、coprでrpmをビルドして公開されるようになり便利になりました。&lt;/p&gt;

&lt;p&gt;ただし問題もあって、coprのビルドはときどき失敗してしまうようです。スペックファイルの中身を変えずにREADMEに無意味な空行を入れるなどして再度pushしてビルドを再実行すると成功したりしました。&lt;/p&gt;

&lt;h2 id=&#34;さらに気になっていること:feab3b17551715c7fe87c510b9d66160&#34;&gt;さらに気になっていること&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://fedorahosted.org/copr/wiki/ScreenshotsTutorial&#34;&gt;ScreenshotsTutorial – copr&lt;/a&gt;の[New Build]タブのスクリーンショットには[From URLs]と[Upload SRPM]という2つのタブしかないですが、実際の画面ではそれに加えて [Git and Tito]、[Mock SCM]というタブがあります。&lt;/p&gt;

&lt;p&gt;これらを使うとTravis CIを使わずにビルドできるかもしれないと期待しているのですが、使い方の説明を見つけられておらず使い方がわからない状態です。ということで一旦この記事を書きました。&lt;/p&gt;

&lt;h2 id=&#34;2015-12-06-追記:feab3b17551715c7fe87c510b9d66160&#34;&gt;2015-12-06 追記&lt;/h2&gt;

&lt;p&gt;rpmのビルドが通るまでの試行錯誤中は毎回coprでビルドするより手元の環境でビルドするほうが快適です。そのための手順を&lt;a href=&#34;/blog/blog/2015/12/05/build_rpm_with_mock/&#34;&gt;mockコマンドでrpmをビルドする · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;に書きましたので、ご参照ください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mattn/gomにGoのvendoringサポートが追加されました</title>
      <link>/blog/2015/10/22/gom_got_go_vendoring_support/</link>
      <pubDate>Thu, 22 Oct 2015 01:22:10 +0900</pubDate>
      
      <guid>/blog/2015/10/22/gom_got_go_vendoring_support/</guid>
      <description>

&lt;p&gt;以前&lt;a href=&#34;http://deeeet.com/writing/2015/06/26/golang-dependency-vendoring/&#34;&gt;Go言語のDependency/Vendoringの問題と今後．gbあるいはGo1.5 | SOTA&lt;/a&gt;を読んだのですが、その時は様子見にしていました。&lt;/p&gt;

&lt;p&gt;しかし、仕事でGoを書くとなるとやはりVendoringは必要だろうと思い、遅ればせながら今回&lt;a href=&#34;https://getgb.io/examples/getting-started/&#34;&gt;gb&lt;/a&gt;, &lt;a href=&#34;https://github.com/tools/godep&#34;&gt;tools/godep&lt;/a&gt;, &lt;a href=&#34;https://github.com/mattn/gom&#34;&gt;mattn/gom&lt;/a&gt;を試してみました。&lt;/p&gt;

&lt;h2 id=&#34;gbの不満:96cfedbb6d327eac2c80a70b44a7b99d&#34;&gt;gbの不満&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://getgb.io/examples/getting-started/&#34;&gt;gb&lt;/a&gt;の例を見ると、自分のプロジェクトのトップディレクトリに &lt;code&gt;src/cmd&lt;/code&gt; あるいは &lt;code&gt;src/github.com/ユーザID/プロジェクト名&lt;/code&gt; というディレクトリを作ってそこにソースを置く必要があるようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://getgb.io/faq/#cannot-build-src-root&#34;&gt;FAQ&lt;/a&gt;にも&lt;a href=&#34;http://getgb.io/faq/#cannot-build-src-root&#34;&gt;Why can&amp;rsquo;t I place source in $PROJECT/src?&lt;/a&gt;という項があるので、これは仕様のようです。&lt;/p&gt;

&lt;p&gt;でもこれだと、自分のプロジェクトを他のプロジェクトで使いたい時に &lt;code&gt;go get&lt;/code&gt; で使えないですよね。
FAQに &amp;ldquo;Can I use gb if I am working on a Go library?&amp;rdquo; とか &amp;ldquo;Copying code is gross! Can I use git submodules?&amp;rdquo; とかあるんですが、git submoduleにせよgit subtreeにせよ面倒だなと思いました。&lt;/p&gt;

&lt;h2 id=&#34;godepsの不満:96cfedbb6d327eac2c80a70b44a7b99d&#34;&gt;godepsの不満&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tools/godep&#34;&gt;tools/godep&lt;/a&gt; の&amp;rdquo;Go 1.5 vendor/ experiment&amp;rdquo;の項を読んで試してみたところ、&lt;code&gt;go build&lt;/code&gt; が使用する環境変数 &lt;code&gt;GO15VENDOREXPERIMENT&lt;/code&gt; を &lt;code&gt;export GO15VENDOREXPERIMENT=1&lt;/code&gt; のように設定しておくと、そうでないときは &lt;code&gt;Godeps/_workspace/&lt;/code&gt; に置かれる依存ライブラリが &lt;code&gt;vendor/&lt;/code&gt; 以下に置かれるようになることがわかりました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vendor/&lt;/code&gt; を &lt;code&gt;.gitignore&lt;/code&gt; で除外してコミットしたいので、後から &lt;code&gt;Godeps/Godeps.json&lt;/code&gt; から &lt;code&gt;vendor/&lt;/code&gt; を再構成する必要があります。READMEには書いてないですが、 &lt;code&gt;godep get&lt;/code&gt; でダウンロードして、 &lt;code&gt;godep save&lt;/code&gt; で &lt;code&gt;vendor/&lt;/code&gt; に反映できることがわかりました。&lt;/p&gt;

&lt;p&gt;ただ、 &lt;code&gt;godep get&lt;/code&gt; でダウンロードする先は環境変数 &lt;code&gt;GOPATH&lt;/code&gt; で指しているディレクトリなんですよね。 &lt;code&gt;godep save&lt;/code&gt; は &lt;code&gt;$GOPATH&lt;/code&gt; から &lt;code&gt;vendor/&lt;/code&gt; に反映するコマンドです。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;code&gt;godep restore&lt;/code&gt; というコマンドもありますが、これは &lt;code&gt;vendor/&lt;/code&gt; から &lt;code&gt;$GOPATH&lt;/code&gt; に反映します。GoにVendoringサポートがなかったときは、これで &lt;code&gt;$GOPATH&lt;/code&gt; に反映してから &lt;code&gt;go build&lt;/code&gt; という手順も妥当な気がしますが、Vendoringがある今となってはグローバルの &lt;code&gt;$GOPATH&lt;/code&gt; 配下は触らずに &lt;code&gt;vendor/&lt;/code&gt; 以下を直接更新したいところです。&lt;/p&gt;

&lt;p&gt;とりあえずイシュー&lt;a href=&#34;https://github.com/tools/godep/issues/299&#34;&gt;Download dependency to vendor/ directory with godep get when GO15VENDOREXPERIMENT=1 · Issue #299 · tools/godep&lt;/a&gt; を立ててみたところ、同じことを考えていたというコメントがついていました。&lt;/p&gt;

&lt;h2 id=&#34;gomならバッチリ:96cfedbb6d327eac2c80a70b44a7b99d&#34;&gt;gomならバッチリ！&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mattn/gom&#34;&gt;mattn/gom&lt;/a&gt;を見ると&lt;a href=&#34;https://github.com/mattn/gom/issues/51&#34;&gt;Consider adding GO15VENDOREXPERIMENT support · Issue #51 · mattn/gom&lt;/a&gt;というイシューがあったので、対応するコードを書いて &lt;a href=&#34;https://github.com/mattn/gom/pull/57&#34;&gt;Support go15vendorexperiment by mattn · Pull Request #57 · mattn/gom&lt;/a&gt;で追加修正の上マージしていただきました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gom install&lt;/code&gt; では内部的に &lt;code&gt;go get&lt;/code&gt; を呼び出しているので、ターゲットディレクトリを &lt;code&gt;vendor/&lt;/code&gt; にしても &lt;code&gt;vendor/src/github.com/...&lt;/code&gt; のように &lt;code&gt;src&lt;/code&gt; フォルダが作られてしまいます。上の修正では対処療法的に &lt;code&gt;gom install&lt;/code&gt; 内で &lt;code&gt;vendor/*&lt;/code&gt; を &lt;code&gt;vendor/src/*&lt;/code&gt; に移動して、終わったら &lt;code&gt;vendor/src/*&lt;/code&gt; を &lt;code&gt;vendor/*&lt;/code&gt; に移動して対応しています。&lt;/p&gt;

&lt;p&gt;正確には最初の移動では &lt;code&gt;vendor/&lt;/code&gt; 以下の &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;pkg&lt;/code&gt;, &lt;code&gt;src&lt;/code&gt; は除外しています。&lt;/p&gt;

&lt;p&gt;これで、 &lt;code&gt;export GO15VENDOREXPERIMENT=1&lt;/code&gt; さえしておけば、 &lt;code&gt;gom install&lt;/code&gt; で &lt;code&gt;$GOPATH&lt;/code&gt; 配下は変更せずに直接 &lt;code&gt;vendor/&lt;/code&gt; 以下を更新できるようになりました。&lt;/p&gt;

&lt;p&gt;READMEには書いてないですが、 &lt;code&gt;gom lock&lt;/code&gt; を実行すれば &lt;code&gt;Gomfile.lock&lt;/code&gt; が作られて、以降の &lt;code&gt;gom install&lt;/code&gt; では依存ライブラリのバージョンを正確に反映できます。&lt;/p&gt;

&lt;p&gt;ということで、gomならバッチリ私の希望を満たしてくれることがわかりました。
mattnさん、便利なツールをありがとうございます！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MySQL APT repositoryからMySQL 5.7.xをインストールするスクリプト</title>
      <link>/blog/2015/09/22/noninteractive_install_from_mysql_apt_repository_on_ubuntu_trusty/</link>
      <pubDate>Tue, 22 Sep 2015 22:35:21 +0900</pubDate>
      
      <guid>/blog/2015/09/22/noninteractive_install_from_mysql_apt_repository_on_ubuntu_trusty/</guid>
      <description>

&lt;p&gt;Ubuntu 14.04 (Trusty)に&lt;a href=&#34;http://dev.mysql.com/downloads/repo/apt/&#34;&gt;MySQL APT Repository&lt;/a&gt;からMySQL 5.7 (Development Release)を
インストールするスクリプトを書きました。&lt;/p&gt;

&lt;p&gt;Vagrantfileと共に&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty&#34;&gt;hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty&lt;/a&gt;に置いてあります。&lt;/p&gt;

&lt;h2 id=&#34;使い方:7b72d99f6277ee322df194c41a872720&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://dev.mysql.com/downloads/repo/apt/&#34;&gt;MySQL :: Download MySQL APT Repository&lt;/a&gt;をブラウザで見てmysql-apt-config_x.x.x-1ubuntu14.04_all.debのファイルのバージョンを確認し、スクリプト内の &lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L4&#34;&gt;mysql_apt_deb_file&lt;/a&gt;変数の値をを適宜修正してください。&lt;/p&gt;

&lt;p&gt;スクリプト内の&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L8&#34;&gt;mysql_root_password&lt;/a&gt;変数の値を設定したいMySQLのrootユーザのパスワードに変更してください。&lt;/p&gt;

&lt;p&gt;あとはスクリプトを実行すればOKです。&lt;/p&gt;

&lt;h2 id=&#34;スクリプトの実装メモ:7b72d99f6277ee322df194c41a872720&#34;&gt;スクリプトの実装メモ&lt;/h2&gt;

&lt;h3 id=&#34;noninteractiveなmysql-apt-configのインストール:7b72d99f6277ee322df194c41a872720&#34;&gt;noninteractiveなmysql-apt-configのインストール&lt;/h3&gt;

&lt;p&gt;単に &lt;code&gt;sudo dpkg -i mysql-apt-config_0.3.7-1ubuntu14.04_all.deb&lt;/code&gt; のように実行すると、途中でCUIのダイアログが開いてMySQLサーバのバージョンなどを聞かれてしまいます。自動インストール用のスクリプトではインタラクティブに聞かれてほしくないので &lt;code&gt;export DEBIAN_FRONTEND=noninteractive&lt;/code&gt; を指定する必要があります。
&lt;a href=&#34;http://manpages.ubuntu.com/manpages/trusty/man7/debconf.7.html&#34;&gt;Ubuntu Manpage: debconf - Debian package configuration system&lt;/a&gt;に説明があります。&lt;/p&gt;

&lt;p&gt;またその後 &lt;code&gt;sudo dpkg ...&lt;/code&gt; だと環境変数を引き継がないので &lt;code&gt;sudo -E dpkg ...&lt;/code&gt; のように &lt;code&gt;-E&lt;/code&gt; オプションを指定しています。&lt;a href=&#34;http://stackoverflow.com/questions/7739645/install-mysql-on-ubuntu-without-password-prompt#comment37966911_7740393&#34;&gt;bash - install mysql on ubuntu without password prompt - Stack Overflow&lt;/a&gt;で知りました。&lt;/p&gt;

&lt;p&gt;実行するのが1回だけなら &lt;code&gt;sudo DEBIAN_FRONTEND=noninteractive dpkg ...&lt;/code&gt; のほうがシンプルで良いと思います。が、今回は後でmysql-community-serverをインストールするときにも必要なので上記の方式にしました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;export DEBIAN_FRONTEND=noninteractive&lt;/code&gt; だけで良い場合もありますが、ダイアログで選ぶ値を予め設定しておく必要がある場合もあります。
&lt;a href=&#34;http://unix.stackexchange.com/questions/158052/how-to-configure-the-mysql-apt-repo-on-ubuntu-on-a-non-interactive-shell?newreg=31ba47900d6f4e01ba1625f43da05f82&#34;&gt;dpkg - How to configure the MySQL APT repo on Ubuntu, on a non-interactive shell? - Unix &amp;amp; Linux Stack Exchange&lt;/a&gt;で mysql-apt-config のインストールには &lt;code&gt;echo mysql-apt-config mysql-apt-config/enable-repo select mysql-5.7-dmr | sudo debconf-set-selections&lt;/code&gt; としておけば良いらしいという情報を得ました。&lt;/p&gt;

&lt;p&gt;ですが、調査のために mysql-apt-config を手動インストールしてその前後で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo debconf-get-selections | grep mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;して設定される項目を見てみると違う名前になっていました。スクリプトでは&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L16-L21&#34;&gt;手動インストールで設定される項目に合わせて設定するようにしました。&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;noninteractiveなmysql-community-serverのインストール:7b72d99f6277ee322df194c41a872720&#34;&gt;noninteractiveなmysql-community-serverのインストール&lt;/h3&gt;

&lt;p&gt;こちらも同様に &lt;code&gt;export DEBIAN_FRONTEND=noninteractive&lt;/code&gt; のあと &lt;code&gt;sudo -E apt-get -y install ...&lt;/code&gt; でインストールしています。設定値は
&lt;a href=&#34;http://stackoverflow.com/questions/7739645/install-mysql-on-ubuntu-without-password-prompt/20037235#20037235&#34;&gt;bash - install mysql on ubuntu without password prompt - Stack Overflow&lt;/a&gt;を参考にしつつ、まず手動インストールして &lt;code&gt;sudo debconf-get-selections | grep mysql&lt;/code&gt; で設定値を確認し、&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L28-L29&#34;&gt;それに合わせて設定するようにしました。&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;noninteractiveなmysql-secure-installationの実行:7b72d99f6277ee322df194c41a872720&#34;&gt;noninteractiveなmysql_secure_installationの実行&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://labs.cybridge.jp/cybridge/development/1312.html&#34;&gt;コードで実行！ mysql_secure_installation プロビジョニング | サイブリッジラボブログ&lt;/a&gt;にも書かれていますが、MySQL 5.5の頃はインタラクティブな入力を要求するシェルスクリプトだったので、中身を読んで等価な処理をすることができました。私も以前&lt;a href=&#34;https://github.com/hnakamur/ansible-playbooks/blob/490b782d57ed93442c981dab5612ff396027ba98/roles/mysql/server/files/mysql_secure_installation.sh&#34;&gt;等価なスクリプト&lt;/a&gt;を書いていました。&lt;/p&gt;

&lt;p&gt;しかし、5.7ではmysql_secure_installationはバイナリになってしまいました。 &lt;code&gt;man mysql_secure_installation&lt;/code&gt; で確認したところ、&lt;code&gt;--password&lt;/code&gt; もしくは &lt;code&gt;-p&lt;/code&gt; オプションはあるが無視して必ずパスワードプロンプトを出すと書いてありました。自動インストール用スクリプトでは困るのですが、&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L34-L35&#34;&gt;./.mysql_root_password.cnf&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[client]
password=${mysql_root_password}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といった内容のファイルを作って &lt;code&gt;--defaults-extra-file&lt;/code&gt; オプションで指定すれば回避できました。&lt;/p&gt;

&lt;p&gt;プロンプトが出て入力する部分は&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L38-L45&#34;&gt;標準入力にリダイレクトで流し込めば&lt;/a&gt; OKでした。ただし、MySQLのrootユーザのパスワードを変えるパターンは試してないです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L51-L101&#34;&gt;上記の入力に対する出力結果&lt;/a&gt;をコメントとして残しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MySQLのrootユーザのパスワードは変えない&lt;/li&gt;
&lt;li&gt;パスワードの強度チェッカーはインストールしない&lt;/li&gt;
&lt;li&gt;anonymousユーザは削除する&lt;/li&gt;
&lt;li&gt;リモートからのrootユーザのログインは許可しない&lt;/li&gt;
&lt;li&gt;testデータベースは削除&lt;/li&gt;
&lt;li&gt;権限をリロード&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という設定となっています。&lt;/p&gt;

&lt;p&gt;標準入力に流し込むのではなく &lt;code&gt;--use-default&lt;/code&gt; オプションを使うという手もあります。
&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L109-L163&#34;&gt;&amp;ndash;use-defaultの場合の出力結果&lt;/a&gt;もコメントとして残しています。 この場合の設定内容は以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MySQLのrootユーザのパスワードは変えない&lt;/li&gt;
&lt;li&gt;パスワードの強度チェッカーをSTRONGの強度に設定する&lt;/li&gt;
&lt;li&gt;anonymousユーザは削除する&lt;/li&gt;
&lt;li&gt;リモートからのrootユーザのログインは許可しない&lt;/li&gt;
&lt;li&gt;testデータベースは削除&lt;/li&gt;
&lt;li&gt;権限をリロード&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/noninteractive_install_mysql_from_apt_repository_to_ubuntu_trusty/blob/3d7392a1d99dbfc3eb26eecef75dee5549a2cca7/provision.sh#L123&#34;&gt;パスワードチェッカーのSTRONGの強度の説明&lt;/a&gt;によると、8文字以上で、文字種は数値、英字大文字、英字小文字、記号を全て含める必要があり、辞書に登録されている単語は弾くようです。実際には試してないので違うかもしれません。&lt;/p&gt;

&lt;h3 id=&#34;参考-debconf-set-selections-で設定した項目の削除方法:7b72d99f6277ee322df194c41a872720&#34;&gt;参考: debconf-set-selections で設定した項目の削除方法&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;debconf-set-selections&lt;/code&gt; で設定した項目は &lt;code&gt;debconf-get-selections&lt;/code&gt; で確認できますが、削除はどうするのかとググってみたら &lt;a href=&#34;http://serverfault.com/questions/332459/how-do-i-delete-values-from-the-debconf-database/332490#332490&#34;&gt;debian - How do I delete values from the debconf database? - Server Fault&lt;/a&gt; に説明を見つけました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo PURGE | debconf-communicate パッケージ名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにすると「パッケージ名」に対する全ての設定を削除できました (スクリプトでは使っていませんが、試行錯誤中に試しました)。
&lt;a href=&#34;https://www.debian.org/doc/packaging-manuals/debconf_specification.html#AEN106&#34;&gt;Configuration management&lt;/a&gt; にPURGEと他のコマンドについて説明があるとのことです。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:7b72d99f6277ee322df194c41a872720&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;というわけで何とか自動化出来ました。個人的にはインストール用のコマンドはコマンドラインオプションか環境変数を設定したらノンインタラクティブで実行できるように作っておいて欲しいなあと思います。インタラクティブにしたい場合もインタラクティブモードで起動するようなコマンドラインオプションをつけて、ダイアログで選択が終わったらそれに対応するコマンドラインオプションを指定して起動したかのように処理をするような作りにすればいいのではないでしょうか。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Goでグローバルなバッファを使いまわしてスタックトレースを取得するライブラリを書いてみた</title>
      <link>/blog/2015/08/31/go_stacktrace_library_with_global_buffer/</link>
      <pubDate>Mon, 31 Aug 2015 00:43:56 +0900</pubDate>
      
      <guid>/blog/2015/08/31/go_stacktrace_library_with_global_buffer/</guid>
      <description>

&lt;h2 id=&#34;背景と経緯:328f76ded598aa8f65807ce0ea1c89b5&#34;&gt;背景と経緯&lt;/h2&gt;

&lt;p&gt;Goでもエラー処理にpanicを使えばスタックトレースが出力されます。でも、ライブラリでは &lt;code&gt;panic&lt;/code&gt; するとエラー処理して続行したいときに困るのでpanicではなく &lt;code&gt;return err&lt;/code&gt; を使うのが普通です。すると今度はスタックトレースが取れないのが残念だと思っていました。エラーが出た箇所でログ出力はするとして、やはりスタックトレースがあるほうがその関数までの呼出経路がわかってデバッグが捗ります。&lt;/p&gt;

&lt;p&gt;標準ライブラリを見てみると、&lt;a href=&#34;http://golang.org/pkg/runtime/debug/#PrintStack&#34;&gt;runtime.debug.PrintStack()&lt;/a&gt; という便利そうな関数を見つけました。が、これは出力先が標準エラー出力固定となっています。私はログファイルに出したいんですよね。&lt;/p&gt;

&lt;p&gt;そこでドキュメントの関数のリンクをクリックしてソースを見てみます。
&lt;a href=&#34;http://golang.org/src/runtime/debug/stack.go?s=516:533#L15&#34;&gt;src/runtime/debug/stack.go - The Go Programming Language&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func PrintStack() {
  os.Stderr.Write(stack())
}

// Stack returns a formatted stack trace of the goroutine that calls it.
// For each routine, it includes the source line information and PC value,
// then attempts to discover, for Go functions, the calling function or
// method and the text of the line containing the invocation.
//
// Deprecated: Use package runtime&#39;s Stack instead.
func Stack() []byte {
  return stack()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;お、&lt;code&gt;Stack()&lt;/code&gt; のほうを使えば &lt;code&gt;[]byte&lt;/code&gt; で取得できるじゃないですか。あれ、でもdeprecatedなので &lt;a href=&#34;http://golang.org/pkg/runtime/#Stack&#34;&gt;runtime.Stack&lt;/a&gt; のほうを使えとあります。シグネチャ見ると &lt;code&gt;func Stack(buf []byte, all bool) int&lt;/code&gt; となっていて、こちらからバッファを渡す必要があるんですね。&lt;/p&gt;

&lt;p&gt;関数定義 &lt;a href=&#34;http://golang.org/src/runtime/mprof.go?s=15278:15314#L552&#34;&gt;src/runtime/mprof.go - The Go Programming Language&lt;/a&gt;を見てみると、バッファサイズが足りない場合は、途中までしか書かれないようです。またどれだけのサイズがあれば大丈夫かを調べる方法もないようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Stack(buf []byte, all bool) int {
  if all {
    stopTheWorld(&amp;quot;stack trace&amp;quot;)
  }

  n := 0
  if len(buf) &amp;gt; 0 {
    gp := getg()
    sp := getcallersp(unsafe.Pointer(&amp;amp;buf))
    pc := getcallerpc(unsafe.Pointer(&amp;amp;buf))
    systemstack(func() {
      g0 := getg()
      g0.writebuf = buf[0:0:len(buf)]
      goroutineheader(gp)
      traceback(pc, sp, 0, gp)
      if all {
        tracebackothers(gp)
      }
      n = len(g0.writebuf)
      g0.writebuf = nil
    })
  }

  if all {
    startTheWorld()
  }
  return n
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実はさっきの &lt;code&gt;stack()&lt;/code&gt; の定義&lt;a href=&#34;http://golang.org/src/runtime/debug/stack.go?s=516:533#L40&#34;&gt;src/runtime/debug/stack.go - The Go Programming Language&lt;/a&gt;を見ると&lt;a href=&#34;http://golang.org/pkg/runtime/#Caller&#34;&gt;runtime.Caller&lt;/a&gt;というより低レベルな関数があってこれを使って自前で実装すれば好きに作れそうではあります。&lt;/p&gt;

&lt;p&gt;しかし、私は手抜きで済ませたいので大きめのバッファをグローバルに予め確保しておいてそれを&lt;a href=&#34;http://golang.org/pkg/runtime/#Stack&#34;&gt;runtime.Stack&lt;/a&gt;に渡す方式にしました。
バッファを予め確保しておくのは、エラーが起きてからメモリ確保しようとして失敗するケースを避けたいからです。&lt;/p&gt;

&lt;p&gt;と言いつつ、&lt;a href=&#34;http://golang.org/pkg/runtime/#Stack&#34;&gt;runtime.Stack&lt;/a&gt;内でメモリ割り当てが発生するかまでは確認していません。&lt;/p&gt;

&lt;h2 id=&#34;実装と使い方:328f76ded598aa8f65807ce0ea1c89b5&#34;&gt;実装と使い方&lt;/h2&gt;

&lt;p&gt;というわけで実装してみました。レポジトリは&lt;a href=&#34;https://github.com/hnakamur/stacktrace&#34;&gt;hnakamur/stacktrace&lt;/a&gt;で、ライセンスはMITです。&lt;/p&gt;

&lt;p&gt;使用例はこちらです。&lt;a href=&#34;https://github.com/hnakamur/stacktrace/blob/ed0a2c8b61528e59f349f6c108a84a6b9dd8e981/example/main.go&#34;&gt;example.go&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
  &amp;quot;errors&amp;quot;
  &amp;quot;log&amp;quot;

  &amp;quot;github.com/hnakamur/stacktrace&amp;quot;
)

func logErrorWithStackTrace(msg interface{}) {
  log.Printf(&amp;quot;error: %s\nstacktrace: %s\n&amp;quot;, msg, stacktrace.LockBufAndGetStackWithSkip(2))
  defer stacktrace.UnlockBuf()
}

func b() {
  err := errors.New(&amp;quot;some error&amp;quot;)
  logErrorWithStackTrace(err)
}

func a() {
  b()
}

func main() {
  a()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずお好みのロギングライブラリ用にスタックトレースを取得してログ出力する関数を定義します。この例の場合は &lt;code&gt;logErrorWithStackTrace&lt;/code&gt; です。メモリ割り当て回数を最低限にしたかったので、 &lt;code&gt;stacktrace.LockBufAndGetStackWithSkip()&lt;/code&gt; はグローバルバッファをロックした状態でそのまま返すようにしています。ですので使い終わったら、&lt;code&gt;stacktrace.UnlockBuf()&lt;/code&gt; でロックを解放する必要があります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;stacktrace.LockBufAndGetStackWithSkip()&lt;/code&gt; の引数で2を渡しているのはスタックトレースから &lt;code&gt;stacktrace.LockBufAndGetStackWithSkip&lt;/code&gt; と &lt;code&gt;logErrorWithStackTrace&lt;/code&gt; の2つを除外するためです。&lt;/p&gt;

&lt;p&gt;出力例は以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go run main.go
2015/08/31 01:24:42 error: some error
stacktrace: goroutine 1 [running]:
main.b()
        /Users/hnakamur/gocode/src/github.com/hnakamur/stacktrace/example/main.go:17 +0xce
main.a()
        /Users/hnakamur/gocode/src/github.com/hnakamur/stacktrace/example/main.go:21 +0x14
main.main()
        /Users/hnakamur/gocode/src/github.com/hnakamur/stacktrace/example/main.go:25 +0x14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでスタックトレース付きのエラーログを簡単に出力できて快適ですね！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>自分のグローバルアドレスをOpenDNSとdigコマンドで調べる方法を試してみた</title>
      <link>/blog/2015/08/12/get_my_global_ip_address_with_opendns/</link>
      <pubDate>Wed, 12 Aug 2015 07:14:59 +0900</pubDate>
      
      <guid>/blog/2015/08/12/get_my_global_ip_address_with_opendns/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://unix.stackexchange.com/questions/22615/how-can-i-get-my-external-ip-address-in-bash/81699&#34;&gt;linux - How can I get my external IP address in bash? - Unix &amp;amp; Linux Stack Exchange&lt;/a&gt;を読んで試してみたのでメモです。&lt;/p&gt;

&lt;p&gt;この記事を読むまでは &lt;code&gt;curl -s http://ifconfig.me&lt;/code&gt; しか知りませんでした。&lt;/p&gt;

&lt;p&gt;処理時間を比べてみました（出力結果のIPアドレスは伏せ字XXX.XXX.XXX.XXXにしています）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time dig +short myip.opendns.com @resolver1.opendns.com
XXX.XXX.XXX.XXX

real    0m0.061s
user    0m0.010s
sys     0m0.016s
$ time curl -s http://whatismyip.akamai.com
XXX.XXX.XXX.XXX
real    0m0.571s
user    0m0.011s
sys     0m0.009s
$ time curl -s http://ifconfig.me
XXX.XXX.XXX.XXX

real    0m0.581s
user    0m0.011s
sys     0m0.007s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;私が試した環境では、whatismyip.akamai.comとifconfig.meにhttpで問い合わせる方法は約0.6秒弱ですが、OpenDNSにdigで問い合わせる方法だと約0.06秒と一桁速いということがわかりました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 14.04のPython3でvenvを使う手順のメモ</title>
      <link>/blog/2015/07/26/use_python3_venv_on_ubuntu_14.04/</link>
      <pubDate>Sun, 26 Jul 2015 23:09:17 +0900</pubDate>
      
      <guid>/blog/2015/07/26/use_python3_venv_on_ubuntu_14.04/</guid>
      <description>

&lt;p&gt;Ubuntu 14.04のPython3でvenv環境をつくろうとしたらエラーになったのですが、&lt;a href=&#34;http://www.thefourtheye.in/2014/12/Python-venv-problem-with-ensurepip-in-Ubuntu.html&#34;&gt;thefourtheye&amp;rsquo;s Tech Blog: Python&amp;rsquo;s venv problem with ensurepip in Ubuntu&lt;/a&gt;に回避方法が紹介されていました。&lt;/p&gt;

&lt;p&gt;venv環境の作成手順をメモしておきます。&lt;/p&gt;

&lt;h2 id=&#34;事前準備:05eb07f168fcd264f562f523d3cefc83&#34;&gt;事前準備&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install python3 python3-pip
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;venv環境作成手順:05eb07f168fcd264f562f523d3cefc83&#34;&gt;venv環境作成手順&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;pyvenv-3.4 --without-pip venv
source venv/bin/activate
curl -LO https://bootstrap.pypa.io/get-pip.py
python3 get-pip.py
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2015-08-29追記-スクリプトを書きました:05eb07f168fcd264f562f523d3cefc83&#34;&gt;2015-08-29追記: スクリプトを書きました&lt;/h2&gt;

&lt;p&gt;以下の内容を~/bin/venv3などというファイル名で保存します。sourceで実行するので実行パーミションは付けないでください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;venv_dir=&amp;quot;${1:-venv}&amp;quot;
pyvenv-3.4 --without-pip &amp;quot;${venv_dir}&amp;quot;
source &amp;quot;${venv_dir}/bin/activate&amp;quot;
curl -L https://bootstrap.pypa.io/get-pip.py | python3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使い方は &lt;code&gt;source ~/bin/venv3 作成するディレクトリ名&lt;/code&gt; です。作成するディレクトリ名を省略するとカレントディレクトリ下のvenvになります。
使用例は以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:/tmp$ source ~/bin/venv3 venv3
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 1379k  100 1379k    0     0  2741k      0 --:--:-- --:--:-- --:--:-- 2737k
Collecting pip
  Using cached pip-7.1.2-py2.py3-none-any.whl
Collecting setuptools
  Using cached setuptools-18.2-py2.py3-none-any.whl
Collecting wheel
  Using cached wheel-0.24.0-py2.py3-none-any.whl
Installing collected packages: pip, setuptools, wheel
Successfully installed pip-7.1.2 setuptools-18.2 wheel-0.24.0
(venv3) vagrant@vagrant-ubuntu-trusty-64:/tmp$
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>HomebrewのPython2とPython3でvirtualenv環境を作成する手順メモ</title>
      <link>/blog/2015/07/26/how_to_use_venv_with_homebrew_python2_and_3/</link>
      <pubDate>Sun, 26 Jul 2015 02:28:59 +0900</pubDate>
      
      <guid>/blog/2015/07/26/how_to_use_venv_with_homebrew_python2_and_3/</guid>
      <description>

&lt;h2 id=&#34;はじめに:0b9e6fd53135617d881618470dafc934&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;ここしばらく&lt;a href=&#34;https://github.com/riywo/anyenv&#34;&gt;riywo/anyenv&lt;/a&gt;と&lt;a href=&#34;https://github.com/yyuu/pyenv&#34;&gt;yyuu/pyenv&lt;/a&gt;でPython 2.7.10をPython 3.4.3を使い分けてきたのですが、私の用途だと2系と3系の最新だけ使えればいいことがわかりました。&lt;/p&gt;

&lt;p&gt;そこで、pyenvを止めてhomebrewのpython2と3を使うことにしました。自分用にPython2のvirtualenvとPython3のvenvで仮想環境を作る手順のメモを書いておきます。&lt;/p&gt;

&lt;h2 id=&#34;事前準備:0b9e6fd53135617d881618470dafc934&#34;&gt;事前準備&lt;/h2&gt;

&lt;p&gt;Python2とvirtualenvのインストール。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install python
pip install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python3のインストール。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install python3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストールされるコマンドはpythonとpipがPython2用で、python3とpip3がPython3用となっています。&lt;/p&gt;

&lt;h2 id=&#34;python2の仮想環境の作成と有効化の手順:0b9e6fd53135617d881618470dafc934&#34;&gt;Python2の仮想環境の作成と有効化の手順&lt;/h2&gt;

&lt;p&gt;作業ディレクトリを作ってそこに移動し、venvというサブディレクトリにPython2用のvirtualenvを作って有効化するのは以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p $(作業ディレクトリ名)
cd !$
virtualenv venv
source venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python3の仮想環境の作成と有効化の手順:0b9e6fd53135617d881618470dafc934&#34;&gt;Python3の仮想環境の作成と有効化の手順&lt;/h2&gt;

&lt;p&gt;Python3では&lt;code&gt;virtualenv&lt;/code&gt;コマンドではなくPython 3.3で追加された&lt;a href=&#34;https://docs.python.org/3/library/venv.html?highlight=venv#module-venv&#34;&gt;venv&lt;/a&gt;という標準モジュールを使います。&lt;/p&gt;

&lt;p&gt;作業ディレクトリを作ってそこに移動し、venvというサブディレクトリにPython2用のvirtualenvを作って有効化するのは以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p $(作業ディレクトリ名)
cd !$
python3 -m venv venv
source venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;python3 -m venv venv&lt;/code&gt; の1つめの &lt;code&gt;venv&lt;/code&gt; はモジュール名で2つめの &lt;code&gt;venv&lt;/code&gt; は作成するサブディレクトリ名です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;source venv/bin/activate&lt;/code&gt; でvenv環境を有効化した後は &lt;code&gt;python3&lt;/code&gt; と &lt;code&gt;pip3&lt;/code&gt; ではなく &lt;code&gt;python&lt;/code&gt; と &lt;code&gt;pip&lt;/code&gt; でコマンドを実行します。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GeForce搭載の旧モデルMacBook ProでCaffeをビルドする手順メモ</title>
      <link>/blog/2015/07/26/build_caffe_on_macbook_with_geforce/</link>
      <pubDate>Sun, 26 Jul 2015 00:53:52 +0900</pubDate>
      
      <guid>/blog/2015/07/26/build_caffe_on_macbook_with_geforce/</guid>
      <description>

&lt;h2 id=&#34;はじめに:4909c7b84850df25b3daeddabfd8580e&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/07/25/setup_cuda_on_macbook_pro_with_geforce/&#34;&gt;GeForce搭載の旧モデルMacBook ProでCUDAをセットアップする手順のメモ&lt;/a&gt;でCUDA 7.0.29をインストールしたMacBook Proで&lt;a href=&#34;http://caffe.berkeleyvision.org/&#34;&gt;Caffe | Deep Learning Framework&lt;/a&gt;をビルドしてみた手順メモです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://pypi.python.org/pypi?%3Aaction=search&amp;amp;term=caffe&amp;amp;submit=search&#34;&gt;PyPIでCaffeで検索&lt;/a&gt;しても出てこないので、ソースからビルドするしかないようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://caffe.berkeleyvision.org/install_osx.html&#34;&gt;OS X Installation&lt;/a&gt;を参考にしつつ、一部手順を変更してインストールしました。&lt;/p&gt;

&lt;h2 id=&#34;caffeはpython3非対応:4909c7b84850df25b3daeddabfd8580e&#34;&gt;CaffeはPython3非対応&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/icoxfog417/items/65e800c3a2094457c3a0&#34;&gt;Python - はじめるDeep learning - Qiita&lt;/a&gt;で紹介されていた&lt;a href=&#34;https://github.com/BVLC/caffe/issues/293&#34;&gt;Python3 support · Issue #293 · BVLC/caffe&lt;/a&gt;によると、オフィシャルでPython3対応の予定はないとのこと。Python3でも動かないこともないそうですが、初心者なのでまずはPython2で動かすことにします。&lt;/p&gt;

&lt;h2 id=&#34;依存ライブラリのインストール:4909c7b84850df25b3daeddabfd8580e&#34;&gt;依存ライブラリのインストール&lt;/h2&gt;

&lt;p&gt;依存するライブラリを以下のコマンドでインストールしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install -vd snappy leveldb gflags glog szip lmdb
brew tap homebrew/science
brew install hdf5 opencv
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;protobufのインストール:4909c7b84850df25b3daeddabfd8580e&#34;&gt;protobufのインストール&lt;/h3&gt;

&lt;p&gt;以下のコマンドでprotobufをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install protobuf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://caffe.berkeleyvision.org/install_osx.html&#34;&gt;OS X Installation&lt;/a&gt;の手順では &lt;code&gt;--with-python&lt;/code&gt; オプションを指定していますが、 &lt;code&gt;brew info protobuf&lt;/code&gt; で確認すると2.6.1用のformulaでは &lt;code&gt;--with-python&lt;/code&gt; オプションは無くなって代わりに &lt;code&gt;--without-python&lt;/code&gt; オプションが出来ていました。何も指定しなければpythonサポートが入るようです。&lt;/p&gt;

&lt;p&gt;なお、インストール完了時に以下のメッセージが出ますが、後でvirtualenvで作った環境内で &lt;code&gt;pip install protobuf&lt;/code&gt; すればいけるので、ここに書かれている対応は不要でした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==&amp;gt; Caveats
Editor support and examples have been installed to:
  /usr/local/Cellar/protobuf/2.6.1/share/doc/protobuf

Python modules have been installed and Homebrew&#39;s site-packages is not
in your Python sys.path, so you will not be able to import the modules
this formula installed. If you plan to develop with these modules,
please run:
  mkdir -p
  echo &#39;import site; site.addsitedir(&amp;quot;/usr/local/lib/python2.7/site-packages&amp;quot;)&#39; &amp;gt;&amp;gt; homebrew.pth
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;boost-1-57-0-boost-python-1-57-0-のインストール:4909c7b84850df25b3daeddabfd8580e&#34;&gt;boost 1.57.0, boost-python 1.57.0 のインストール&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;brew install boost boost-python&lt;/code&gt; だと1.58.0が入ったのですが、Caffeのビルド時にコンパイルエラーが出ました。&lt;a href=&#34;http://itinerantbioinformaticist.blogspot.jp/2015/05/caffe-incompatible-with-boost-1580.html&#34;&gt;Itinerant Bioinformaticist: Caffe incompatible with Boost 1.58.0&lt;/a&gt;と同じエラーですが、ここに回避方法も書かれていたので、これに従いました。&lt;/p&gt;

&lt;p&gt;まず、boost 1.58.0, boost-python 1.58.0が入っている場合はアンインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew uninstall boost boost-python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下の手順で1.57.0をソースからインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd `brew --prefix`/Library/Formula
curl -O https://raw.githubusercontent.com/Homebrew/homebrew/6fd6a9b6b2f56139a44dd689d30b7168ac13effb/Library/Formula/boost.rb
curl -O https://raw.githubusercontent.com/Homebrew/homebrew/3141234b3473717e87f3958d4916fe0ada0baba9/Library/Formula/boost-python.rb
brew install --build-from-source -vd boost boost-python
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python2でvirtualenvで作業用の環境を作成して依存ライブラリをインストール:4909c7b84850df25b3daeddabfd8580e&#34;&gt;Python2でvirtualenvで作業用の環境を作成して依存ライブラリをインストール&lt;/h2&gt;

&lt;p&gt;個人的にはAnaconda Pythonのようなオールインワンのインストーラはあまり好きではないので、&lt;a href=&#34;https://github.com/riywo/anyenv&#34;&gt;riywo/anyenv&lt;/a&gt;と&lt;a href=&#34;https://github.com/yyuu/pyenv&#34;&gt;yyuu/pyenv&lt;/a&gt;で入れたPython 2.7.10を使いました。&lt;/p&gt;

&lt;p&gt;作業用のディレクトリ &lt;code&gt;~/work/caffe&lt;/code&gt; を作ってvirtualenvで環境を作りました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p ~/work/caffe
cd !$
pyenv local 2.7.10
virtualenv venv
source venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HomebrewでインストールしたPython 2.7.10でも &lt;code&gt;pyenv local 2.7.10&lt;/code&gt; の行を除けば同じ手順で行けました。&lt;/p&gt;

&lt;p&gt;Caffeで必要なprotobufとnumpyを以下の手順でインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install protobuf
pip install numpy
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;caffeのソースを取得してビルド:4909c7b84850df25b3daeddabfd8580e&#34;&gt;Caffeのソースを取得してビルド&lt;/h2&gt;

&lt;p&gt;ソースを取得してディレクトリに入ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/work/caffe
git clone https://github.com/BVLC/caffe
cd caffe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://caffe.berkeleyvision.org/installation.html#compilation&#34;&gt;Installation&lt;/a&gt;を参考にビルドします。virtualenv環境のincludeとlibディレクトリを参照するように以下のように加工してMakefile.configを作成します。Caffeのソースを違うディレクトリに配置した場合は適宜変更してください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;
s|/usr/include/python2.7|$(HOME)/work/caffe/venv/include/python2.7|
s|/usr/lib/python2.7/dist-packages|$(HOME)/work/caffe/venv/lib/python2.7/site-packages|
&#39; Makefile.config.example &amp;gt; Makefile.config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Caffeをビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テストコードをビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テストを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv)$ make runtest
...(略)...
[----------] Global test environment tear-down
[==========] 1356 tests from 214 test cases ran. (306870 ms total)
[  PASSED  ] 1356 tests.

  YOU HAVE 2 DISABLED TESTS

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで、Caffeをビルドする手順でした。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GeForce搭載の旧モデルMacBook ProでPyCUDAを試してみた</title>
      <link>/blog/2015/07/25/setup_pycuda_on_macbook_pro_with_geforce/</link>
      <pubDate>Sat, 25 Jul 2015 18:31:56 +0900</pubDate>
      
      <guid>/blog/2015/07/25/setup_pycuda_on_macbook_pro_with_geforce/</guid>
      <description>

&lt;h2 id=&#34;はじめに:2e3483d036f73ae71cfba34bbe193b52&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;../setup_cuda_on_macbook_pro_with_geforce/&#34;&gt;GeForce搭載の旧モデルMacBook ProでCUDAをセットアップする手順のメモ&lt;/a&gt;でCUDAをセットアップした後、&lt;a href=&#34;http://mathema.tician.de/software/pycuda/&#34;&gt;PyCUDA&lt;/a&gt;も試してみたのでメモしておきます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mathema.tician.de/software/pycuda/&#34;&gt;PyCUDA&lt;/a&gt;のページの &lt;code&gt;Prerequisites&lt;/code&gt; に &lt;code&gt;Boost&lt;/code&gt;, &lt;code&gt;CUDA&lt;/code&gt;, &lt;code&gt;Numpy&lt;/code&gt; が書かれています。&lt;/p&gt;

&lt;p&gt;CUDAは&lt;a href=&#34;../setup_cuda_on_macbook_pro_with_geforce/&#34;&gt;GeForce搭載の旧モデルMacBook ProでCUDAをセットアップする手順のメモ&lt;/a&gt;でセットアップ済みです。&lt;/p&gt;

&lt;h2 id=&#34;boostのインストール:2e3483d036f73ae71cfba34bbe193b52&#34;&gt;Boostのインストール&lt;/h2&gt;

&lt;p&gt;Boostは &lt;a href=&#34;http://brew.sh/&#34;&gt;Homebrew — The missing package manager for OS X&lt;/a&gt; でインストールしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew update
brew install boost
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストールされたboostのバージョンは以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew info boost
boost: stable 1.58.0 (bottled), HEAD
Collection of portable C++ source libraries
http://www.boost.org
/usr/local/Cellar/boost/1.58.0 (10718 files, 486M) *
  Poured from bottle
From: https://github.com/Homebrew/homebrew/blob/master/Library/Formula/boost.rb
==&amp;gt; Dependencies
Optional: icu4c ✘
==&amp;gt; Options
--c++11
	Build using C++11 mode
--universal
	Build a universal binary
--with-icu4c
	Build regexp engine with icu support
--with-mpi
	Build with MPI support
--without-single
	Disable building single-threading variant
--without-static
	Disable building static library variant
--HEAD
	Install HEAD version
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;numpyとpycudaをインストールして試してみる:2e3483d036f73ae71cfba34bbe193b52&#34;&gt;NumpyとPyCUDAをインストールして試してみる&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/riywo/anyenv&#34;&gt;riywo/anyenv&lt;/a&gt;と&lt;a href=&#34;https://github.com/yyuu/pyenv&#34;&gt;yyuu/pyenv&lt;/a&gt;で入れたPython 3.4.3を使い、 &lt;code&gt;~/sandbox/pycuda&lt;/code&gt; という作業ディレクトリを作成してvenv環境を作って試しました。&lt;/p&gt;

&lt;p&gt;以下の手順でvenv環境を作って有効にします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p ~/sandbox/pycuda
cd !$
python -m venv venv
source venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;(venv) $&lt;/code&gt; プロンプト内で以下のコマンドでNumPyとPyCUDAをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install numpy
pip install pycuda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PyCUDAのほうは以下のような警告が出ましたが、インストールは出来ました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /Users/hnakamur/sandbox/pycuda/venv/lib/python3.4/site-packages/numpy/core/include/numpy/npy_1_7_deprecated_api.h:15:2: warning: &amp;quot;Using deprecated NumPy API, disable it by &amp;quot;          &amp;quot;#defining NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION&amp;quot; [-W#warnings]
    #warning &amp;quot;Using deprecated NumPy API, disable it by &amp;quot; \
     ^
    src/wrapper/_pvt_struct_v3.cpp:1047:30: warning: conversion from string literal to &#39;char *&#39; is deprecated [-Wc++11-compat-deprecated-writable-strings]
        static char *kwlist[] = {&amp;quot;format&amp;quot;, 0};
                                 ^
    src/wrapper/_pvt_struct_v3.cpp:1166:30: warning: conversion from string literal to &#39;char *&#39; is deprecated [-Wc++11-compat-deprecated-writable-strings]
        static char *kwlist[] = {&amp;quot;buffer&amp;quot;, &amp;quot;offset&amp;quot;, 0};
                                 ^
    src/wrapper/_pvt_struct_v3.cpp:1166:40: warning: conversion from string literal to &#39;char *&#39; is deprecated [-Wc++11-compat-deprecated-writable-strings]
        static char *kwlist[] = {&amp;quot;buffer&amp;quot;, &amp;quot;offset&amp;quot;, 0};
                                           ^
    src/wrapper/_pvt_struct_v3.cpp:1224:17: warning: unused variable &#39;isstring&#39; [-Wunused-variable]
                int isstring;
                    ^
    src/wrapper/_pvt_struct_v3.cpp:1430:6: warning: conversion from string literal to &#39;char *&#39; is deprecated [-Wc++11-compat-deprecated-writable-strings]
        {&amp;quot;format&amp;quot;, (getter)s_get_format, (setter)NULL, &amp;quot;struct format string&amp;quot;, NULL},
         ^
    src/wrapper/_pvt_struct_v3.cpp:1430:52: warning: conversion from string literal to &#39;char *&#39; is deprecated [-Wc++11-compat-deprecated-writable-strings]
        {&amp;quot;format&amp;quot;, (getter)s_get_format, (setter)NULL, &amp;quot;struct format string&amp;quot;, NULL},
                                                       ^
    src/wrapper/_pvt_struct_v3.cpp:1431:6: warning: conversion from string literal to &#39;char *&#39; is deprecated [-Wc++11-compat-deprecated-writable-strings]
        {&amp;quot;size&amp;quot;, (getter)s_get_size, (setter)NULL, &amp;quot;struct size in bytes&amp;quot;, NULL},
         ^
    src/wrapper/_pvt_struct_v3.cpp:1431:48: warning: conversion from string literal to &#39;char *&#39; is deprecated [-Wc++11-compat-deprecated-writable-strings]
        {&amp;quot;size&amp;quot;, (getter)s_get_size, (setter)NULL, &amp;quot;struct size in bytes&amp;quot;, NULL},
                                                   ^
    src/wrapper/_pvt_struct_v3.cpp:1720:1: warning: duplicate &#39;extern&#39; declaration specifier [-Wduplicate-decl-specifier]
    PyMODINIT_FUNC
    ^
    /Users/hnakamur/.anyenv/envs/pyenv/versions/3.4.3/include/python3.4m/pyport.h:778:39: note: expanded from macro &#39;PyMODINIT_FUNC&#39;
    #               define PyMODINIT_FUNC extern &amp;quot;C&amp;quot; PyObject*
                                          ^
    10 warnings generated.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pycudaのサンプルを試す:2e3483d036f73ae71cfba34bbe193b52&#34;&gt;PyCUDAのサンプルを試す&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://documen.tician.de/pycuda/tutorial.html&#34;&gt;Tutorial — PyCUDA 2015.1.2 documentation&lt;/a&gt;と&lt;a href=&#34;http://qiita.com/masato/items/713fa8876e50a65d575c&#34;&gt;Windows7 64bitにPyCUDAとTheanoをインストールしてGPU計算する - Qiita&lt;/a&gt;の&lt;a href=&#34;http://qiita.com/masato/items/713fa8876e50a65d575c#%E3%83%86%E3%82%B9%E3%83%88&#34;&gt;テスト&lt;/a&gt;を参考にして、以下の内容で &lt;code&gt;pycuda-test.py&lt;/code&gt; を作って実行してみました。&lt;/p&gt;

&lt;p&gt;Python 3.xを使っているので &lt;code&gt;print&lt;/code&gt; の引数は括弧で囲むように書き換えています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import pycuda.gpuarray as gpuarray
import pycuda.driver as cuda
import pycuda.autoinit
import numpy

a_gpu = gpuarray.to_gpu(numpy.random.randn(4,4).astype(numpy.float32))
a_doubled = (2*a_gpu).get()
print(a_doubled)
print(a_gpu)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行してみると、以下のように出力されPyCUDAが無事動きました！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv) $ python pycuda-test.py
[[-0.72795004 -0.16994514  0.02276878 -1.07509565]
 [ 0.20851769  2.08421874 -0.51877511 -1.27585149]
 [ 0.29300559 -0.40393201  3.15332532 -1.90199065]
 [ 2.87024021  0.64773476  2.65404892 -2.97092891]]
[[-0.36397502 -0.08497257  0.01138439 -0.53754783]
 [ 0.10425884  1.04210937 -0.25938755 -0.63792574]
 [ 0.14650279 -0.201966    1.57666266 -0.95099533]
 [ 1.43512011  0.32386738  1.32702446 -1.48546445]]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>GeForce搭載の旧モデルMacBook ProでCUDAをセットアップする手順のメモ</title>
      <link>/blog/2015/07/25/setup_cuda_on_macbook_pro_with_geforce/</link>
      <pubDate>Sat, 25 Jul 2015 17:37:59 +0900</pubDate>
      
      <guid>/blog/2015/07/25/setup_cuda_on_macbook_pro_with_geforce/</guid>
      <description>

&lt;h2 id=&#34;はじめに:a311e6dec28847b69a9c104c237fbeb5&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.apple.com/jp/macbook-pro/specs-retina/&#34;&gt;MacBook Pro現行モデルの技術仕様&lt;/a&gt;を見ると最上位機種のグラフィックスチップはIntel Iris Pro GraphicsとAMD Radeon R9 M370Xとなっており、NVIDIA GeForceは搭載されていません。&lt;/p&gt;

&lt;p&gt;ですが、&lt;a href=&#34;https://support.apple.com/kb/SP694?locale=ja_JP&amp;amp;viewlocale=ja_JP&#34;&gt;MacBook Pro (15-inch, Mid 2012) - 技術仕様&lt;/a&gt;を見ると、私が持っているMacBook Proは15インチ2.6GHzモデルなのでNVIDIA GeForce GT 650M、1GB GDDR5メモリが搭載されています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.nvidia.co.jp/object/geforce-gt-650m-jp.html#pdpContent=2&#34;&gt;GeForce GT 650M | NVIDIA&lt;/a&gt;には「プログラミング環境」の行に「CUDA」とあるのでCUDAが使えるようです。&lt;/p&gt;

&lt;p&gt;ということでCUDAを試してみたので、手順をメモしておきます。試した時のOS Xのバージョンは10.10.4、Xcodeのバージョンは6.4です。&lt;/p&gt;

&lt;h2 id=&#34;cudaドライバのインストールとアップデート:a311e6dec28847b69a9c104c237fbeb5&#34;&gt;CUDAドライバのインストールとアップデート&lt;/h2&gt;

&lt;p&gt;後述のCUDAツールキットのインストール中の画面にCUDAドライバも含まれているような記述があったので、この手順は不要かもしれません。が、今回はそれを知らずに先にCUDAドライバを単体でインストールしたので、一応書いておきます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.nvidia.co.jp/object/mac-driver-archive-jp.html&#34;&gt;MAC アーカイブ用CUDA ドライバ | NVIDIA&lt;/a&gt;から最新のドライバをダウンロード、インストールします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.nvidia.co.jp/object/macosx-cuda-7.0.36-driver-jp.html&#34;&gt;NVIDIA DRIVERS 7.0.36&lt;/a&gt;の「リリースハイライト」によると、[システム環境設定]→[CUDA]でインストール済みのCUDAドライバのバージョンと最新バージョンの確認が出来て、アップデートもできるそうです。&lt;/p&gt;

&lt;p&gt;早速確認してみると、インストール済みのCUDA Driver Versionは7.0.29となっており、CUDA 7.0.52 Driver update is availableと表示されていました。&lt;/p&gt;

&lt;p&gt;7.0.36のドライバを単体でインストールしたのに7.0.29になっているのは後述のCUDAツールキットのインストールで上書きされたのだと思われます。ついでなので、[Install CUDA Update]ボタンを押してアップデートしておきました。&lt;/p&gt;

&lt;h2 id=&#34;cudaツールキットのインストール:a311e6dec28847b69a9c104c237fbeb5&#34;&gt;CUDAツールキットのインストール&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.nvidia.com/cuda/index.html#axzz3gt2fIbGh&#34;&gt;CUDA Toolkit Documentation&lt;/a&gt;のページから&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#axzz3gt2fIbGh&#34;&gt;Getting Started Mac OS X&lt;/a&gt;に進み、&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#installation&#34;&gt;3. Installation&lt;/a&gt;を参考にCUDAツールキットをインストールしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.nvidia.com/cuda-downloads&#34;&gt;CUDA 7 Downloads&lt;/a&gt;で[Mac OSX]のタブに切り替えてインストーラをダウンロードします。最初Network Installerを試したのですが、ダウンロードしたdmgファイルを開いてCUDAMacOSXInstallerをダブルクリックしたら「“CUDAMacOSXInstaller”はこわれているため開けません。」というエラーが出たので、Local Installer (977MB)を試したら、こちらは無事インストール出来ました。&lt;/p&gt;

&lt;p&gt;その後、cuFFT Patchをダウンロードして、&lt;a href=&#34;http://developer.download.nvidia.com/compute/cuda/7_0/Prod/cufft_update/README_mac.txt&#34;&gt;README&lt;/a&gt;を参考にターミナルで以下のコマンドを実行してパッチを適用しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo tar zxf ~/Downloads/cufft_patch_mac.tar.gz -C /Developer/NVIDIA/CUDA-7.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cudaツールキット用の環境変数設定:a311e6dec28847b69a9c104c237fbeb5&#34;&gt;CUDAツールキット用の環境変数設定&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#axzz3gt2fIbGh&#34;&gt;Getting Started Mac OS X&lt;/a&gt;の&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#install&#34;&gt;3.2. Install&lt;/a&gt;で環境変数 &lt;code&gt;PATH&lt;/code&gt; と &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; の設定方法が書いてあるのですが、この通りだとあとでPyCUDAをインストールするときに &lt;code&gt;-lcuda&lt;/code&gt; が見つからずリンクエラーになりました。&lt;/p&gt;

&lt;p&gt;検索してみると&lt;a href=&#34;https://code.google.com/p/pyrit/issues/detail?id=248&#34;&gt;Issue 248 - pyrit - Build script can&amp;rsquo;t find CUDA library directory on OS X. - WPA/WPA2-PSK and a world of affordable many-core platforms - Google Project Hosting&lt;/a&gt; で &lt;code&gt;/usr/local/cuda&lt;/code&gt; というディレクトリがあることを知り、&lt;code&gt;/usr/local/cuda/lib&lt;/code&gt; と &lt;code&gt;/Developer/NVIDIA/CUDA-7.0/lib&lt;/code&gt; の中身を見てみると &lt;code&gt;libcuda.dylib&lt;/code&gt; だけは前者にしか無いことが判明しました。&lt;/p&gt;

&lt;p&gt;結局以下のように設定する必要がありました (bash以外の場合は適宜変更してください)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt;&amp;gt; ~/.bash_profile
# CUDA
export CUDA_ROOT=/usr/local/cuda
export PATH=$CUDA_ROOT/bin:$PATH
export DYLD_LIBRARY_PATH=$CUDA_ROOT/lib:$PATH
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;設定ファイルを書き換えたら以下のコマンドでシェルを再起動して設定を読み込んでおきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exec $SHELL -l
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;統合gpuではなくgeforceを使うように切り替える設定:a311e6dec28847b69a9c104c237fbeb5&#34;&gt;統合GPUではなくGeForceを使うように切り替える設定&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#axzz3gt2fIbGh&#34;&gt;Getting Started Mac OS X&lt;/a&gt;の&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#install&#34;&gt;3.2. Install&lt;/a&gt;の説明に従って、以下のように設定しました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[システム環境設定]→[省エネルギー]を開きます&lt;/li&gt;
&lt;li&gt;[グラフィックスの自動切り替え]のチェックを外します&lt;/li&gt;
&lt;li&gt;電源アダプタに繋いでいる場合は[電源アダプタ]、繋いでいない場合は[バッテリー]を選びます&lt;/li&gt;
&lt;li&gt;[コンピュータのスリープ]のスライダーを[しない]に調節します。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cudaのサンプルを試す:a311e6dec28847b69a9c104c237fbeb5&#34;&gt;CUDAのサンプルを試す&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#axzz3gt2fIbGh&#34;&gt;Getting Started Mac OS X&lt;/a&gt;の&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#install&#34;&gt;3.2. Install&lt;/a&gt;の説明に従って、 &lt;code&gt;cuda-install-samples-7.0.sh&lt;/code&gt; を使ってサンプルプログラムを取得して試してみました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;~/sandbox/cuda&lt;/code&gt; という作業用のディレクトリを作って以下の手順で試しました。 &lt;code&gt;cuda-install-samples-7.0.sh&lt;/code&gt; はインストール先のディレクトリを引数で指定する必要がありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p ~/sandbox/cuda
cd !$
cuda-install-samples-7.0.sh .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行すると &lt;code&gt;NVIDIA_CUDA-7.0_Samples&lt;/code&gt; というディレクトリが作成され、配下にサンプルプログラムのソースファイルが展開されていました。&lt;/p&gt;

&lt;p&gt;そのうちの1つ &lt;code&gt;asyncAPI&lt;/code&gt; というのを試してみました。以下の手順でビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd NVIDIA_CUDA-7.0_Samples/0_Simple/asyncAPI
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ../../bin/x86_64/darwin/release/asyncAPI
[../../bin/x86_64/darwin/release/asyncAPI] - Starting...
GPU Device 0: &amp;quot;GeForce GT 650M&amp;quot; with compute capability 3.0

CUDA device [GeForce GT 650M]
time spent executing by the GPU: 99.45
time spent by CPU in CUDA calls: 0.05
CPU executed 583004 iterations while waiting for GPU to finish
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動きました！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OSX上でmultirustを使ったrustfmtのインストール手順</title>
      <link>/blog/2015/07/19/install_rustfmt/</link>
      <pubDate>Sun, 19 Jul 2015 00:33:15 +0900</pubDate>
      
      <guid>/blog/2015/07/19/install_rustfmt/</guid>
      <description>&lt;p&gt;OSXでは&lt;a href=&#34;https://github.com/brson/multirust/issues/43&#34;&gt;building cargo atop multirust fails, dyn link problems (Mac OS X) · Issue #43 · brson/multirust&lt;/a&gt;のイシューの&lt;a href=&#34;https://github.com/brson/multirust/issues/43#issuecomment-106758695&#34;&gt;コメント106758695&lt;/a&gt;にあるように &lt;code&gt;rustfmt&lt;/code&gt; の実行時に環境変数 &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; を設定する必要があります。&lt;/p&gt;

&lt;p&gt;そこで、 &lt;code&gt;rustfmt&lt;/code&gt; の実行ファイルを &lt;code&gt;~/bin/rustfmt.bin&lt;/code&gt; と別の名前にして、起動用のスクリプトを &lt;code&gt;~/bin/rustfmt&lt;/code&gt; として作成します。&lt;/p&gt;

&lt;p&gt;インストール手順は以下のとおりです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/nrc/rustfmt
cd rustfmt
cargo build --release
cp target/release/rustfmt ~/bin/rustfmt.bin
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; ~/bin/rustfmt
#!/bin/sh
DYLD_LIBRARY_PATH=&amp;quot;$HOME/.multirust/toolchains/nightly/lib&amp;quot; $HOME/bin/rustfmt.bin &amp;quot;$@&amp;quot;
EOF
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>manyrustという複数バージョンのrustインストールスクリプトを書いた</title>
      <link>/blog/2015/07/18/manyrust/</link>
      <pubDate>Sat, 18 Jul 2015 23:13:32 +0900</pubDate>
      
      <guid>/blog/2015/07/18/manyrust/</guid>
      <description>

&lt;h2 id=&#34;multirustがあるのに-なぜ新たに書いたのか:dba7f7ce875f36e918dffb470ba2d4ac&#34;&gt;multirustがあるのに、なぜ新たに書いたのか&lt;/h2&gt;

&lt;p&gt;rustのインストールは&lt;a href=&#34;http://www.rust-lang.org/install.html&#34;&gt;Install · The Rust Programming Language&lt;/a&gt;にあるように複数のチャネルから選んでインストールします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;stable (安定版)チャネル&lt;/li&gt;
&lt;li&gt;beta (ベータ版)チャネル&lt;/li&gt;
&lt;li&gt;nightly (毎晩ビルドされる)チャネル&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;rustでunstableなAPIを使うにはnightlyを使う必要があるので、たいていはstableとnightlyの両方をインストールして使い分けたくなるはずです。
その用途には定番のスクリプトとして&lt;a href=&#34;https://github.com/brson/multirust&#34;&gt;brson/multirust&lt;/a&gt;があります。&lt;/p&gt;

&lt;p&gt;私も使っていましたが、rustのソースコードの整形ツール&lt;a href=&#34;https://github.com/nrc/rustfmt&#34;&gt;nrc/rustfmt&lt;/a&gt;をビルドして起動しようとするとエラーになってしまいました。&lt;/p&gt;

&lt;p&gt;既に&lt;a href=&#34;https://github.com/brson/multirust/issues/43&#34;&gt;building cargo atop multirust fails, dyn link problems (Mac OS X) · Issue #43 · brson/multirust&lt;/a&gt;にイシューが上がっていて、&lt;a href=&#34;https://github.com/brson/multirust/issues/43#issuecomment-106758695&#34;&gt;コメント106758695&lt;/a&gt;にあるように環境変数 &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; を設定すれば問題は解消するとのことです。&lt;/p&gt;

&lt;p&gt;ディレクトリによって環境変数を切り替えるのは&lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;direnv/direnv&lt;/a&gt;が便利です。ただ、&lt;code&gt;direnv&lt;/code&gt; を使うのであれば、そもそも &lt;code&gt;multirust&lt;/code&gt; のように &lt;code&gt;rustc&lt;/code&gt; などの実行ファイルをラップしたシェルスクリプトを作る必要は無いわけです。&lt;/p&gt;

&lt;p&gt;rustの複数のバージョンを異なるディレクトリにインストールしておいて、利用するディレクトリごとに環境変数 &lt;code&gt;PATH&lt;/code&gt; と &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; を切り替えればいいだけです。&lt;/p&gt;

&lt;p&gt;であれば、 &lt;code&gt;multirust&lt;/code&gt; 使わなくてももっとシンプルなスクリプトでいいよね、ということで書いたのが &lt;code&gt;manyrust&lt;/code&gt; です。現状はOSXのみサポートしています。&lt;/p&gt;

&lt;h2 id=&#34;インストール手順:dba7f7ce875f36e918dffb470ba2d4ac&#34;&gt;インストール手順&lt;/h2&gt;

&lt;p&gt;以下のようにして &lt;code&gt;~/bin&lt;/code&gt; に &lt;code&gt;manyrust&lt;/code&gt; スクリプトを配置します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir ~/bin
curl -s -o ~/bin/manyrust https://raw.githubusercontent.com/hnakamur/manyrust/master/manyrust
chmod +x ~/bin/manyrust
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;環境変数 &lt;code&gt;PATH&lt;/code&gt; に &lt;code&gt;$HOME/bin&lt;/code&gt; を追加して有効にします。
bashの場合はこんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &#39;export PATH=&amp;quot;$HOME/bin:$PATH&amp;quot;&#39; &amp;gt;&amp;gt; ~/.bash_profilie
exec $SHELL -l
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rustのインストール:dba7f7ce875f36e918dffb470ba2d4ac&#34;&gt;rustのインストール&lt;/h2&gt;

&lt;p&gt;stableチャネルの最新版をインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;manyrust install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;betaチャネルの最新版をインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;manyrust install beta
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nightlyチャネルの最新版をインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;manyrust install nightly
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rustを利用する側の作業ディレクトリでの設定:dba7f7ce875f36e918dffb470ba2d4ac&#34;&gt;rustを利用する側の作業ディレクトリでの設定&lt;/h2&gt;

&lt;p&gt;stableチャネルの最新版を使うディレクトリでの設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;manyrust showcfg &amp;gt;&amp;gt; .envrc
direnv allow .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nightlyチャネルの最新版を使うディレクトリでの設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;manyrust showcfg nightly &amp;gt;&amp;gt; .envrc
direnv allow .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nightlyチャネルの特定のバージョン2015-07-14を使うディレクトリでの設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;manyrust showcfg nightly 2015-07-14 &amp;gt;&amp;gt; .envrc
direnv allow .
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;応用例:dba7f7ce875f36e918dffb470ba2d4ac&#34;&gt;応用例&lt;/h3&gt;

&lt;p&gt;基本的にはstableチャネルのrustを使いたいが、特定のディレクトリ下ではnightlyを使いたい場合は &lt;code&gt;$HOME/.envrc&lt;/code&gt; にstableを使う設定を書いておいて、特定のディレクトリの &lt;code&gt;.envrc&lt;/code&gt; ではnightlyを使う設定を書いておけばOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ manyrust showcfg &amp;gt;&amp;gt; ~/.envrc
direnv: error .envrc is blocked. Run `direnv allow` to approve its content.
$ direnv allow ~
direnv: loading ../../../../.envrc
direnv: export +DYLD_LIBRARY_PATH ~PATH
$ mkdir ~/nightly_work
$ cd !$
cd ~/nightly_work
$ manyrust showcfg nightly &amp;gt;&amp;gt; .envrc
direnv: error .envrc is blocked. Run `direnv allow` to approve its content.
$ direnv allow .
direnv: loading .envrc
direnv: export +DYLD_LIBRARY_PATH ~PATH
$ rustc --version
rustc 1.3.0-nightly (e4e93196e 2015-07-14)
$ echo $DYLD_LIBRARY_PATH
/Users/hnakamur/rust/nightly/2015-07-14/rust/lib:
$ cd
direnv: loading .envrc
direnv: export +DYLD_LIBRARY_PATH ~PATH
$ rustc --version
rustc 1.1.0 (35ceea399 2015-06-19)
$ echo $DYLD_LIBRARY_PATH
/Users/hnakamur/rust/stable/1.1.0/rust/lib:
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;direnvを使って設定を切り替えることの利点:dba7f7ce875f36e918dffb470ba2d4ac&#34;&gt;direnvを使って設定を切り替えることの利点&lt;/h3&gt;

&lt;p&gt;上の例で生成した設定ファイルは以下のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ~/.envrc
source &amp;quot;${MANYRUST_ROOT:-$HOME/rust}/stable/current/etc/bashrc&amp;quot;
$ cat ~/nightly_work/.envrc
source &amp;quot;${MANYRUST_ROOT:-$HOME/rust}/nightly/current/etc/bashrc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;souce&lt;/code&gt; で読み込むファイルは &lt;code&gt;manyrust install&lt;/code&gt; で以下のように生成されています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ~/rust/stable/current/etc/bashrc
rust_root=&amp;quot;${RUSTS_HOME:-$HOME/rust}/stable/1.1.0/rust&amp;quot;
export PATH=&amp;quot;$rust_root/bin:$PATH&amp;quot;
export DYLD_LIBRARY_PATH=&amp;quot;$rust_root/lib:$DYLD_LIBRARY_PATH&amp;quot;
$ cat ~/rust/nightly/current/etc/bashrc
rust_root=&amp;quot;${RUSTS_HOME:-$HOME/rust}/nightly/2015-07-14/rust&amp;quot;
export PATH=&amp;quot;$rust_root/bin:$PATH&amp;quot;
export DYLD_LIBRARY_PATH=&amp;quot;$rust_root/lib:$DYLD_LIBRARY_PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;direnv&lt;/code&gt; を使わずに何回もこういうファイルを &lt;code&gt;source&lt;/code&gt; すると、 &lt;code&gt;PATH&lt;/code&gt; や &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; の中身がどんどん増えてしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval `manyrust showcfg beta`
$ echo $DYLD_LIBRARY_PATH
/Users/hnakamur/rust/beta/1.2.0-beta.2/rust/lib:
$ eval `manyrust showcfg stable`
$ echo $DYLD_LIBRARY_PATH
/Users/hnakamur/rust/stable/1.1.0/rust/lib:/Users/hnakamur/rust/beta/1.2.0-beta.2/rust/lib:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;長いだけではなく、この例だとstableには無いがnightlyにあるライブラリが存在するとstableのライブラリを使いたいのにnightly側が使われてしまうという問題が起きてしまいます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;direnv&lt;/code&gt; を使っていれば、上の応用例のように &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; の値が追加されるのではなく設定が切り替えられるので、この問題は起きません。&lt;/p&gt;

&lt;h2 id=&#34;rustfmtのビルドとインストール:dba7f7ce875f36e918dffb470ba2d4ac&#34;&gt;rustfmtのビルドとインストール&lt;/h2&gt;

&lt;p&gt;で、ここまで書いてから &lt;code&gt;rustfmt&lt;/code&gt; をビルド、インストールしようとして問題に気付きました。 &lt;code&gt;rustfmt&lt;/code&gt; は &lt;code&gt;~/rust/nightly/current/rust/bin/&lt;/code&gt; に置いて上記のように &lt;code&gt;.envrc&lt;/code&gt; で切り替えればいいかと思っていたのですが、そうすると &lt;code&gt;stable&lt;/code&gt; を使うように &lt;code&gt;.envrc&lt;/code&gt; を設定したディレクトリでは &lt;code&gt;rustfmt&lt;/code&gt; が使えなくなってしまいます。&lt;/p&gt;

&lt;p&gt;またnightlyのバージョンが上がると &lt;code&gt;rustfmt&lt;/code&gt; をビルドし直す必要もあります。&lt;/p&gt;

&lt;p&gt;これを回避するためにはビルドした &lt;code&gt;rustfmt&lt;/code&gt; は &lt;code&gt;~/bin/rustfmt.bin&lt;/code&gt; と名前を変えて &lt;code&gt;~/bin&lt;/code&gt; に置いて、ラップしたスクリプトを &lt;code&gt;~/bin/rustfmt&lt;/code&gt; という名前で作成します。&lt;/p&gt;

&lt;p&gt;具体的な手順は以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/nrc/rustfmt
cd rustfmt
manyrust showcfg nightly &amp;gt;&amp;gt; .envrc
direnv allow .
cargo build --release
cp target/release/rustfmt ~/bin/rustfmt.bin
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; ~/bin/rustfmt
#!/bin/sh
DYLD_LIBRARY_PATH=&amp;quot;${MANYRUST_ROOT:-$HOME/rust}/nightly/2015-07-14/rust/lib&amp;quot; $HOME/bin/rustfmt.bin &amp;quot;$@&amp;quot;
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今後nightlyを追加インストールした時に &lt;code&gt;rustfmt&lt;/code&gt; が依存しているディレクトリが新しいバージョンの &lt;code&gt;lib&lt;/code&gt; ディレクトリに存在しない場合に備えて、 &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; は &lt;code&gt;~/rust/nightly/current/rust/lib&lt;/code&gt; ではなく特定のバージョンの &lt;code&gt;lib&lt;/code&gt; ディレクトリを指定しています。&lt;/p&gt;

&lt;p&gt;ということで、 &lt;code&gt;rustfmt&lt;/code&gt; に関しては &lt;code&gt;multirust&lt;/code&gt; でも &lt;code&gt;manyrust&lt;/code&gt; でも同じことで、&lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; を設定して実行するようなスクリプトを書いてラップする必要があるというオチでした。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>