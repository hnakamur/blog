<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on hnakamur&#39;s blog at github</title>
    <link>/blog/post/</link>
    <description>Recent content in Posts on hnakamur&#39;s blog at github</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Mon, 31 Aug 2015 00:43:56 +0900</lastBuildDate>
    <atom:link href="/blog/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Goでグローバルなバッファを使いまわしてスタックトレースを取得するライブラリを書いてみた</title>
      <link>/blog/2015/08/31/go_stacktrace_library_with_global_buffer/</link>
      <pubDate>Mon, 31 Aug 2015 00:43:56 +0900</pubDate>
      
      <guid>/blog/2015/08/31/go_stacktrace_library_with_global_buffer/</guid>
      <description>

&lt;h2 id=&#34;背景と経緯:328f76ded598aa8f65807ce0ea1c89b5&#34;&gt;背景と経緯&lt;/h2&gt;

&lt;p&gt;Goでもエラー処理にpanicを使えばスタックトレースが出力されます。でも、ライブラリでは &lt;code&gt;panic&lt;/code&gt; するとエラー処理して続行したいときに困るのでpanicではなく &lt;code&gt;return err&lt;/code&gt; を使うのが普通です。すると今度はスタックトレースが取れないのが残念だと思っていました。エラーが出た箇所でログ出力はするとして、やはりスタックトレースがあるほうがその関数までの呼出経路がわかってデバッグが捗ります。&lt;/p&gt;

&lt;p&gt;標準ライブラリを見てみると、&lt;a href=&#34;http://golang.org/pkg/runtime/debug/#PrintStack&#34;&gt;runtime.debug.PrintStack()&lt;/a&gt; という便利そうな関数を見つけました。が、これは出力先が標準エラー出力固定となっています。私はログファイルに出したいんですよね。&lt;/p&gt;

&lt;p&gt;そこでドキュメントの関数のリンクをクリックしてソースを見てみます。
&lt;a href=&#34;http://golang.org/src/runtime/debug/stack.go?s=516:533#L15&#34;&gt;src/runtime/debug/stack.go - The Go Programming Language&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func PrintStack() {
  os.Stderr.Write(stack())
}

// Stack returns a formatted stack trace of the goroutine that calls it.
// For each routine, it includes the source line information and PC value,
// then attempts to discover, for Go functions, the calling function or
// method and the text of the line containing the invocation.
//
// Deprecated: Use package runtime&#39;s Stack instead.
func Stack() []byte {
  return stack()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;お、&lt;code&gt;Stack()&lt;/code&gt; のほうを使えば &lt;code&gt;[]byte&lt;/code&gt; で取得できるじゃないですか。あれ、でもdeprecatedなので &lt;a href=&#34;http://golang.org/pkg/runtime/#Stack&#34;&gt;runtime.Stack&lt;/a&gt; のほうを使えとあります。シグネチャ見ると &lt;code&gt;func Stack(buf []byte, all bool) int&lt;/code&gt; となっていて、こちらからバッファを渡す必要があるんですね。&lt;/p&gt;

&lt;p&gt;関数定義 &lt;a href=&#34;http://golang.org/src/runtime/mprof.go?s=15278:15314#L552&#34;&gt;src/runtime/mprof.go - The Go Programming Language&lt;/a&gt;を見てみると、バッファサイズが足りない場合は、途中までしか書かれないようです。またどれだけのサイズがあれば大丈夫かを調べる方法もないようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Stack(buf []byte, all bool) int {
  if all {
    stopTheWorld(&amp;quot;stack trace&amp;quot;)
  }

  n := 0
  if len(buf) &amp;gt; 0 {
    gp := getg()
    sp := getcallersp(unsafe.Pointer(&amp;amp;buf))
    pc := getcallerpc(unsafe.Pointer(&amp;amp;buf))
    systemstack(func() {
      g0 := getg()
      g0.writebuf = buf[0:0:len(buf)]
      goroutineheader(gp)
      traceback(pc, sp, 0, gp)
      if all {
        tracebackothers(gp)
      }
      n = len(g0.writebuf)
      g0.writebuf = nil
    })
  }

  if all {
    startTheWorld()
  }
  return n
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実はさっきの &lt;code&gt;stack()&lt;/code&gt; の定義&lt;a href=&#34;http://golang.org/src/runtime/debug/stack.go?s=516:533#L40&#34;&gt;src/runtime/debug/stack.go - The Go Programming Language&lt;/a&gt;を見ると&lt;a href=&#34;http://golang.org/pkg/runtime/#Caller&#34;&gt;runtime.Caller&lt;/a&gt;というより低レベルな関数があってこれを使って自前で実装すれば好きに作れそうではあります。&lt;/p&gt;

&lt;p&gt;しかし、私は手抜きで済ませたいので大きめのバッファをグローバルに予め確保しておいてそれを&lt;a href=&#34;http://golang.org/pkg/runtime/#Stack&#34;&gt;runtime.Stack&lt;/a&gt;に渡す方式にしました。
バッファを予め確保しておくのは、エラーが起きてからメモリ確保しようとして失敗するケースを避けたいからです。&lt;/p&gt;

&lt;p&gt;と言いつつ、&lt;a href=&#34;http://golang.org/pkg/runtime/#Stack&#34;&gt;runtime.Stack&lt;/a&gt;内でメモリ割り当てが発生するかまでは確認していません。&lt;/p&gt;

&lt;h2 id=&#34;実装と使い方:328f76ded598aa8f65807ce0ea1c89b5&#34;&gt;実装と使い方&lt;/h2&gt;

&lt;p&gt;というわけで実装してみました。レポジトリは&lt;a href=&#34;https://github.com/hnakamur/stacktrace&#34;&gt;hnakamur/stacktrace&lt;/a&gt;で、ライセンスはMITです。&lt;/p&gt;

&lt;p&gt;使用例はこちらです。&lt;a href=&#34;https://github.com/hnakamur/stacktrace/blob/ed0a2c8b61528e59f349f6c108a84a6b9dd8e981/example/main.go&#34;&gt;example.go&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
  &amp;quot;errors&amp;quot;
  &amp;quot;log&amp;quot;

  &amp;quot;github.com/hnakamur/stacktrace&amp;quot;
)

func logErrorWithStackTrace(msg interface{}) {
  log.Printf(&amp;quot;error: %s\nstacktrace: %s\n&amp;quot;, msg, stacktrace.LockBufAndGetStackWithSkip(2))
  defer stacktrace.UnlockBuf()
}

func b() {
  err := errors.New(&amp;quot;some error&amp;quot;)
  logErrorWithStackTrace(err)
}

func a() {
  b()
}

func main() {
  a()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずお好みのロギングライブラリ用にスタックトレースを取得してログ出力する関数を定義します。この例の場合は &lt;code&gt;logErrorWithStackTrace&lt;/code&gt; です。メモリ割り当て回数を最低限にしたかったので、 &lt;code&gt;stacktrace.LockBufAndGetStackWithSkip()&lt;/code&gt; はグローバルバッファをロックした状態でそのまま返すようにしています。ですので使い終わったら、&lt;code&gt;stacktrace.UnlockBuf()&lt;/code&gt; でロックを解放する必要があります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;stacktrace.LockBufAndGetStackWithSkip()&lt;/code&gt; の引数で2を渡しているのはスタックトレースから &lt;code&gt;stacktrace.LockBufAndGetStackWithSkip&lt;/code&gt; と &lt;code&gt;logErrorWithStackTrace&lt;/code&gt; の2つを除外するためです。&lt;/p&gt;

&lt;p&gt;出力例は以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go run main.go
2015/08/31 01:24:42 error: some error
stacktrace: goroutine 1 [running]:
main.b()
        /Users/hnakamur/gocode/src/github.com/hnakamur/stacktrace/example/main.go:17 +0xce
main.a()
        /Users/hnakamur/gocode/src/github.com/hnakamur/stacktrace/example/main.go:21 +0x14
main.main()
        /Users/hnakamur/gocode/src/github.com/hnakamur/stacktrace/example/main.go:25 +0x14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでスタックトレース付きのエラーログを簡単に出力できて快適ですね！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>自分のグローバルアドレスをOpenDNSとdigコマンドで調べる方法を試してみた</title>
      <link>/blog/2015/08/12/get_my_global_ip_address_with_opendns/</link>
      <pubDate>Wed, 12 Aug 2015 07:14:59 +0900</pubDate>
      
      <guid>/blog/2015/08/12/get_my_global_ip_address_with_opendns/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://unix.stackexchange.com/questions/22615/how-can-i-get-my-external-ip-address-in-bash/81699&#34;&gt;linux - How can I get my external IP address in bash? - Unix &amp;amp; Linux Stack Exchange&lt;/a&gt;を読んで試してみたのでメモです。&lt;/p&gt;

&lt;p&gt;この記事を読むまでは &lt;code&gt;curl -s http://ifconfig.me&lt;/code&gt; しか知りませんでした。&lt;/p&gt;

&lt;p&gt;処理時間を比べてみました（出力結果のIPアドレスは伏せ字XXX.XXX.XXX.XXXにしています）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time dig +short myip.opendns.com @resolver1.opendns.com
XXX.XXX.XXX.XXX

real    0m0.061s
user    0m0.010s
sys     0m0.016s
$ time curl -s http://whatismyip.akamai.com
XXX.XXX.XXX.XXX
real    0m0.571s
user    0m0.011s
sys     0m0.009s
$ time curl -s http://ifconfig.me
XXX.XXX.XXX.XXX

real    0m0.581s
user    0m0.011s
sys     0m0.007s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;私が試した環境では、whatismyip.akamai.comとifconfig.meにhttpで問い合わせる方法は約0.6秒弱ですが、OpenDNSにdigで問い合わせる方法だと約0.06秒と一桁速いということがわかりました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 14.04のPython3でvenvを使う手順のメモ</title>
      <link>/blog/2015/07/26/use_python3_venv_on_ubuntu_14.04/</link>
      <pubDate>Sun, 26 Jul 2015 23:09:17 +0900</pubDate>
      
      <guid>/blog/2015/07/26/use_python3_venv_on_ubuntu_14.04/</guid>
      <description>

&lt;p&gt;Ubuntu 14.04のPython3でvenv環境をつくろうとしたらエラーになったのですが、&lt;a href=&#34;http://www.thefourtheye.in/2014/12/Python-venv-problem-with-ensurepip-in-Ubuntu.html&#34;&gt;thefourtheye&amp;rsquo;s Tech Blog: Python&amp;rsquo;s venv problem with ensurepip in Ubuntu&lt;/a&gt;に回避方法が紹介されていました。&lt;/p&gt;

&lt;p&gt;venv環境の作成手順をメモしておきます。&lt;/p&gt;

&lt;h2 id=&#34;事前準備:05eb07f168fcd264f562f523d3cefc83&#34;&gt;事前準備&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install python3 python3-pip
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;venv環境作成手順:05eb07f168fcd264f562f523d3cefc83&#34;&gt;venv環境作成手順&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;pyvenv-3.4 --without-pip venv
source venv/bin/activate
curl -LO https://bootstrap.pypa.io/get-pip.py
python3 get-pip.py
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2015-08-29追記-スクリプトを書きました:05eb07f168fcd264f562f523d3cefc83&#34;&gt;2015-08-29追記: スクリプトを書きました&lt;/h2&gt;

&lt;p&gt;以下の内容を~/bin/venv3などというファイル名で保存します。sourceで実行するので実行パーミションは付けないでください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;venv_dir=&amp;quot;${1:-venv}&amp;quot;
pyvenv-3.4 --without-pip &amp;quot;${venv_dir}&amp;quot;
source &amp;quot;${venv_dir}/bin/activate&amp;quot;
curl -L https://bootstrap.pypa.io/get-pip.py | python3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使い方は &lt;code&gt;source ~/bin/venv3 作成するディレクトリ名&lt;/code&gt; です。作成するディレクトリ名を省略するとカレントディレクトリ下のvenvになります。
使用例は以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:/tmp$ source ~/bin/venv3 venv3
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 1379k  100 1379k    0     0  2741k      0 --:--:-- --:--:-- --:--:-- 2737k
Collecting pip
  Using cached pip-7.1.2-py2.py3-none-any.whl
Collecting setuptools
  Using cached setuptools-18.2-py2.py3-none-any.whl
Collecting wheel
  Using cached wheel-0.24.0-py2.py3-none-any.whl
Installing collected packages: pip, setuptools, wheel
Successfully installed pip-7.1.2 setuptools-18.2 wheel-0.24.0
(venv3) vagrant@vagrant-ubuntu-trusty-64:/tmp$
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>HomebrewのPython2とPython3でvirtualenv環境を作成する手順メモ</title>
      <link>/blog/2015/07/26/how_to_use_venv_with_homebrew_python2_and_3/</link>
      <pubDate>Sun, 26 Jul 2015 02:28:59 +0900</pubDate>
      
      <guid>/blog/2015/07/26/how_to_use_venv_with_homebrew_python2_and_3/</guid>
      <description>

&lt;h2 id=&#34;はじめに:0b9e6fd53135617d881618470dafc934&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;ここしばらく&lt;a href=&#34;https://github.com/riywo/anyenv&#34;&gt;riywo/anyenv&lt;/a&gt;と&lt;a href=&#34;https://github.com/yyuu/pyenv&#34;&gt;yyuu/pyenv&lt;/a&gt;でPython 2.7.10をPython 3.4.3を使い分けてきたのですが、私の用途だと2系と3系の最新だけ使えればいいことがわかりました。&lt;/p&gt;

&lt;p&gt;そこで、pyenvを止めてhomebrewのpython2と3を使うことにしました。自分用にPython2のvirtualenvとPython3のvenvで仮想環境を作る手順のメモを書いておきます。&lt;/p&gt;

&lt;h2 id=&#34;事前準備:0b9e6fd53135617d881618470dafc934&#34;&gt;事前準備&lt;/h2&gt;

&lt;p&gt;Python2とvirtualenvのインストール。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install python
pip install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python3のインストール。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install python3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストールされるコマンドはpythonとpipがPython2用で、python3とpip3がPython3用となっています。&lt;/p&gt;

&lt;h2 id=&#34;python2の仮想環境の作成と有効化の手順:0b9e6fd53135617d881618470dafc934&#34;&gt;Python2の仮想環境の作成と有効化の手順&lt;/h2&gt;

&lt;p&gt;作業ディレクトリを作ってそこに移動し、venvというサブディレクトリにPython2用のvirtualenvを作って有効化するのは以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p $(作業ディレクトリ名)
cd !$
virtualenv venv
source venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python3の仮想環境の作成と有効化の手順:0b9e6fd53135617d881618470dafc934&#34;&gt;Python3の仮想環境の作成と有効化の手順&lt;/h2&gt;

&lt;p&gt;Python3では&lt;code&gt;virtualenv&lt;/code&gt;コマンドではなくPython 3.3で追加された&lt;a href=&#34;https://docs.python.org/3/library/venv.html?highlight=venv#module-venv&#34;&gt;venv&lt;/a&gt;という標準モジュールを使います。&lt;/p&gt;

&lt;p&gt;作業ディレクトリを作ってそこに移動し、venvというサブディレクトリにPython2用のvirtualenvを作って有効化するのは以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p $(作業ディレクトリ名)
cd !$
python3 -m venv venv
source venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;python3 -m venv venv&lt;/code&gt; の1つめの &lt;code&gt;venv&lt;/code&gt; はモジュール名で2つめの &lt;code&gt;venv&lt;/code&gt; は作成するサブディレクトリ名です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;source venv/bin/activate&lt;/code&gt; でvenv環境を有効化した後は &lt;code&gt;python3&lt;/code&gt; と &lt;code&gt;pip3&lt;/code&gt; ではなく &lt;code&gt;python&lt;/code&gt; と &lt;code&gt;pip&lt;/code&gt; でコマンドを実行します。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GeForce搭載の旧モデルMacBook ProでCaffeをビルドする手順メモ</title>
      <link>/blog/2015/07/26/build_caffe_on_macbook_with_geforce/</link>
      <pubDate>Sun, 26 Jul 2015 00:53:52 +0900</pubDate>
      
      <guid>/blog/2015/07/26/build_caffe_on_macbook_with_geforce/</guid>
      <description>

&lt;h2 id=&#34;はじめに:4909c7b84850df25b3daeddabfd8580e&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2015/07/25/setup_cuda_on_macbook_pro_with_geforce/&#34;&gt;GeForce搭載の旧モデルMacBook ProでCUDAをセットアップする手順のメモ&lt;/a&gt;でCUDA 7.0.29をインストールしたMacBook Proで&lt;a href=&#34;http://caffe.berkeleyvision.org/&#34;&gt;Caffe | Deep Learning Framework&lt;/a&gt;をビルドしてみた手順メモです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://pypi.python.org/pypi?%3Aaction=search&amp;amp;term=caffe&amp;amp;submit=search&#34;&gt;PyPIでCaffeで検索&lt;/a&gt;しても出てこないので、ソースからビルドするしかないようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://caffe.berkeleyvision.org/install_osx.html&#34;&gt;OS X Installation&lt;/a&gt;を参考にしつつ、一部手順を変更してインストールしました。&lt;/p&gt;

&lt;h2 id=&#34;caffeはpython3非対応:4909c7b84850df25b3daeddabfd8580e&#34;&gt;CaffeはPython3非対応&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/icoxfog417/items/65e800c3a2094457c3a0&#34;&gt;Python - はじめるDeep learning - Qiita&lt;/a&gt;で紹介されていた&lt;a href=&#34;https://github.com/BVLC/caffe/issues/293&#34;&gt;Python3 support · Issue #293 · BVLC/caffe&lt;/a&gt;によると、オフィシャルでPython3対応の予定はないとのこと。Python3でも動かないこともないそうですが、初心者なのでまずはPython2で動かすことにします。&lt;/p&gt;

&lt;h2 id=&#34;依存ライブラリのインストール:4909c7b84850df25b3daeddabfd8580e&#34;&gt;依存ライブラリのインストール&lt;/h2&gt;

&lt;p&gt;依存するライブラリを以下のコマンドでインストールしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install -vd snappy leveldb gflags glog szip lmdb
brew tap homebrew/science
brew install hdf5 opencv
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;protobufのインストール:4909c7b84850df25b3daeddabfd8580e&#34;&gt;protobufのインストール&lt;/h3&gt;

&lt;p&gt;以下のコマンドでprotobufをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install protobuf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://caffe.berkeleyvision.org/install_osx.html&#34;&gt;OS X Installation&lt;/a&gt;の手順では &lt;code&gt;--with-python&lt;/code&gt; オプションを指定していますが、 &lt;code&gt;brew info protobuf&lt;/code&gt; で確認すると2.6.1用のformulaでは &lt;code&gt;--with-python&lt;/code&gt; オプションは無くなって代わりに &lt;code&gt;--without-python&lt;/code&gt; オプションが出来ていました。何も指定しなければpythonサポートが入るようです。&lt;/p&gt;

&lt;p&gt;なお、インストール完了時に以下のメッセージが出ますが、後でvirtualenvで作った環境内で &lt;code&gt;pip install protobuf&lt;/code&gt; すればいけるので、ここに書かれている対応は不要でした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==&amp;gt; Caveats
Editor support and examples have been installed to:
  /usr/local/Cellar/protobuf/2.6.1/share/doc/protobuf

Python modules have been installed and Homebrew&#39;s site-packages is not
in your Python sys.path, so you will not be able to import the modules
this formula installed. If you plan to develop with these modules,
please run:
  mkdir -p
  echo &#39;import site; site.addsitedir(&amp;quot;/usr/local/lib/python2.7/site-packages&amp;quot;)&#39; &amp;gt;&amp;gt; homebrew.pth
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;boost-1-57-0-boost-python-1-57-0-のインストール:4909c7b84850df25b3daeddabfd8580e&#34;&gt;boost 1.57.0, boost-python 1.57.0 のインストール&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;brew install boost boost-python&lt;/code&gt; だと1.58.0が入ったのですが、Caffeのビルド時にコンパイルエラーが出ました。&lt;a href=&#34;http://itinerantbioinformaticist.blogspot.jp/2015/05/caffe-incompatible-with-boost-1580.html&#34;&gt;Itinerant Bioinformaticist: Caffe incompatible with Boost 1.58.0&lt;/a&gt;と同じエラーですが、ここに回避方法も書かれていたので、これに従いました。&lt;/p&gt;

&lt;p&gt;まず、boost 1.58.0, boost-python 1.58.0が入っている場合はアンインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew uninstall boost boost-python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下の手順で1.57.0をソースからインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd `brew --prefix`/Library/Formula
curl -O https://raw.githubusercontent.com/Homebrew/homebrew/6fd6a9b6b2f56139a44dd689d30b7168ac13effb/Library/Formula/boost.rb
curl -O https://raw.githubusercontent.com/Homebrew/homebrew/3141234b3473717e87f3958d4916fe0ada0baba9/Library/Formula/boost-python.rb
brew install --build-from-source -vd boost boost-python
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python2でvirtualenvで作業用の環境を作成して依存ライブラリをインストール:4909c7b84850df25b3daeddabfd8580e&#34;&gt;Python2でvirtualenvで作業用の環境を作成して依存ライブラリをインストール&lt;/h2&gt;

&lt;p&gt;個人的にはAnaconda Pythonのようなオールインワンのインストーラはあまり好きではないので、&lt;a href=&#34;https://github.com/riywo/anyenv&#34;&gt;riywo/anyenv&lt;/a&gt;と&lt;a href=&#34;https://github.com/yyuu/pyenv&#34;&gt;yyuu/pyenv&lt;/a&gt;で入れたPython 2.7.10を使いました。&lt;/p&gt;

&lt;p&gt;作業用のディレクトリ &lt;code&gt;~/work/caffe&lt;/code&gt; を作ってvirtualenvで環境を作りました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p ~/work/caffe
cd !$
pyenv local 2.7.10
virtualenv venv
source venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HomebrewでインストールしたPython 2.7.10でも &lt;code&gt;pyenv local 2.7.10&lt;/code&gt; の行を除けば同じ手順で行けました。&lt;/p&gt;

&lt;p&gt;Caffeで必要なprotobufとnumpyを以下の手順でインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install protobuf
pip install numpy
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;caffeのソースを取得してビルド:4909c7b84850df25b3daeddabfd8580e&#34;&gt;Caffeのソースを取得してビルド&lt;/h2&gt;

&lt;p&gt;ソースを取得してディレクトリに入ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/work/caffe
git clone https://github.com/BVLC/caffe
cd caffe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://caffe.berkeleyvision.org/installation.html#compilation&#34;&gt;Installation&lt;/a&gt;を参考にビルドします。virtualenv環境のincludeとlibディレクトリを参照するように以下のように加工してMakefile.configを作成します。Caffeのソースを違うディレクトリに配置した場合は適宜変更してください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;
s|/usr/include/python2.7|$(HOME)/work/caffe/venv/include/python2.7|
s|/usr/lib/python2.7/dist-packages|$(HOME)/work/caffe/venv/lib/python2.7/site-packages|
&#39; Makefile.config.example &amp;gt; Makefile.config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Caffeをビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テストコードをビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テストを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv)$ make runtest
...(略)...
[----------] Global test environment tear-down
[==========] 1356 tests from 214 test cases ran. (306870 ms total)
[  PASSED  ] 1356 tests.

  YOU HAVE 2 DISABLED TESTS

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで、Caffeをビルドする手順でした。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GeForce搭載の旧モデルMacBook ProでPyCUDAを試してみた</title>
      <link>/blog/2015/07/25/setup_pycuda_on_macbook_pro_with_geforce/</link>
      <pubDate>Sat, 25 Jul 2015 18:31:56 +0900</pubDate>
      
      <guid>/blog/2015/07/25/setup_pycuda_on_macbook_pro_with_geforce/</guid>
      <description>

&lt;h2 id=&#34;はじめに:2e3483d036f73ae71cfba34bbe193b52&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;../setup_cuda_on_macbook_pro_with_geforce/&#34;&gt;GeForce搭載の旧モデルMacBook ProでCUDAをセットアップする手順のメモ&lt;/a&gt;でCUDAをセットアップした後、&lt;a href=&#34;http://mathema.tician.de/software/pycuda/&#34;&gt;PyCUDA&lt;/a&gt;も試してみたのでメモしておきます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mathema.tician.de/software/pycuda/&#34;&gt;PyCUDA&lt;/a&gt;のページの &lt;code&gt;Prerequisites&lt;/code&gt; に &lt;code&gt;Boost&lt;/code&gt;, &lt;code&gt;CUDA&lt;/code&gt;, &lt;code&gt;Numpy&lt;/code&gt; が書かれています。&lt;/p&gt;

&lt;p&gt;CUDAは&lt;a href=&#34;../setup_cuda_on_macbook_pro_with_geforce/&#34;&gt;GeForce搭載の旧モデルMacBook ProでCUDAをセットアップする手順のメモ&lt;/a&gt;でセットアップ済みです。&lt;/p&gt;

&lt;h2 id=&#34;boostのインストール:2e3483d036f73ae71cfba34bbe193b52&#34;&gt;Boostのインストール&lt;/h2&gt;

&lt;p&gt;Boostは &lt;a href=&#34;http://brew.sh/&#34;&gt;Homebrew — The missing package manager for OS X&lt;/a&gt; でインストールしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew update
brew install boost
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストールされたboostのバージョンは以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew info boost
boost: stable 1.58.0 (bottled), HEAD
Collection of portable C++ source libraries
http://www.boost.org
/usr/local/Cellar/boost/1.58.0 (10718 files, 486M) *
  Poured from bottle
From: https://github.com/Homebrew/homebrew/blob/master/Library/Formula/boost.rb
==&amp;gt; Dependencies
Optional: icu4c ✘
==&amp;gt; Options
--c++11
	Build using C++11 mode
--universal
	Build a universal binary
--with-icu4c
	Build regexp engine with icu support
--with-mpi
	Build with MPI support
--without-single
	Disable building single-threading variant
--without-static
	Disable building static library variant
--HEAD
	Install HEAD version
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;numpyとpycudaをインストールして試してみる:2e3483d036f73ae71cfba34bbe193b52&#34;&gt;NumpyとPyCUDAをインストールして試してみる&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/riywo/anyenv&#34;&gt;riywo/anyenv&lt;/a&gt;と&lt;a href=&#34;https://github.com/yyuu/pyenv&#34;&gt;yyuu/pyenv&lt;/a&gt;で入れたPython 3.4.3を使い、 &lt;code&gt;~/sandbox/pycuda&lt;/code&gt; という作業ディレクトリを作成してvenv環境を作って試しました。&lt;/p&gt;

&lt;p&gt;以下の手順でvenv環境を作って有効にします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p ~/sandbox/pycuda
cd !$
python -m venv venv
source venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;(venv) $&lt;/code&gt; プロンプト内で以下のコマンドでNumPyとPyCUDAをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install numpy
pip install pycuda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PyCUDAのほうは以下のような警告が出ましたが、インストールは出来ました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /Users/hnakamur/sandbox/pycuda/venv/lib/python3.4/site-packages/numpy/core/include/numpy/npy_1_7_deprecated_api.h:15:2: warning: &amp;quot;Using deprecated NumPy API, disable it by &amp;quot;          &amp;quot;#defining NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION&amp;quot; [-W#warnings]
    #warning &amp;quot;Using deprecated NumPy API, disable it by &amp;quot; \
     ^
    src/wrapper/_pvt_struct_v3.cpp:1047:30: warning: conversion from string literal to &#39;char *&#39; is deprecated [-Wc++11-compat-deprecated-writable-strings]
        static char *kwlist[] = {&amp;quot;format&amp;quot;, 0};
                                 ^
    src/wrapper/_pvt_struct_v3.cpp:1166:30: warning: conversion from string literal to &#39;char *&#39; is deprecated [-Wc++11-compat-deprecated-writable-strings]
        static char *kwlist[] = {&amp;quot;buffer&amp;quot;, &amp;quot;offset&amp;quot;, 0};
                                 ^
    src/wrapper/_pvt_struct_v3.cpp:1166:40: warning: conversion from string literal to &#39;char *&#39; is deprecated [-Wc++11-compat-deprecated-writable-strings]
        static char *kwlist[] = {&amp;quot;buffer&amp;quot;, &amp;quot;offset&amp;quot;, 0};
                                           ^
    src/wrapper/_pvt_struct_v3.cpp:1224:17: warning: unused variable &#39;isstring&#39; [-Wunused-variable]
                int isstring;
                    ^
    src/wrapper/_pvt_struct_v3.cpp:1430:6: warning: conversion from string literal to &#39;char *&#39; is deprecated [-Wc++11-compat-deprecated-writable-strings]
        {&amp;quot;format&amp;quot;, (getter)s_get_format, (setter)NULL, &amp;quot;struct format string&amp;quot;, NULL},
         ^
    src/wrapper/_pvt_struct_v3.cpp:1430:52: warning: conversion from string literal to &#39;char *&#39; is deprecated [-Wc++11-compat-deprecated-writable-strings]
        {&amp;quot;format&amp;quot;, (getter)s_get_format, (setter)NULL, &amp;quot;struct format string&amp;quot;, NULL},
                                                       ^
    src/wrapper/_pvt_struct_v3.cpp:1431:6: warning: conversion from string literal to &#39;char *&#39; is deprecated [-Wc++11-compat-deprecated-writable-strings]
        {&amp;quot;size&amp;quot;, (getter)s_get_size, (setter)NULL, &amp;quot;struct size in bytes&amp;quot;, NULL},
         ^
    src/wrapper/_pvt_struct_v3.cpp:1431:48: warning: conversion from string literal to &#39;char *&#39; is deprecated [-Wc++11-compat-deprecated-writable-strings]
        {&amp;quot;size&amp;quot;, (getter)s_get_size, (setter)NULL, &amp;quot;struct size in bytes&amp;quot;, NULL},
                                                   ^
    src/wrapper/_pvt_struct_v3.cpp:1720:1: warning: duplicate &#39;extern&#39; declaration specifier [-Wduplicate-decl-specifier]
    PyMODINIT_FUNC
    ^
    /Users/hnakamur/.anyenv/envs/pyenv/versions/3.4.3/include/python3.4m/pyport.h:778:39: note: expanded from macro &#39;PyMODINIT_FUNC&#39;
    #               define PyMODINIT_FUNC extern &amp;quot;C&amp;quot; PyObject*
                                          ^
    10 warnings generated.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pycudaのサンプルを試す:2e3483d036f73ae71cfba34bbe193b52&#34;&gt;PyCUDAのサンプルを試す&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://documen.tician.de/pycuda/tutorial.html&#34;&gt;Tutorial — PyCUDA 2015.1.2 documentation&lt;/a&gt;と&lt;a href=&#34;http://qiita.com/masato/items/713fa8876e50a65d575c&#34;&gt;Windows7 64bitにPyCUDAとTheanoをインストールしてGPU計算する - Qiita&lt;/a&gt;の&lt;a href=&#34;http://qiita.com/masato/items/713fa8876e50a65d575c#%E3%83%86%E3%82%B9%E3%83%88&#34;&gt;テスト&lt;/a&gt;を参考にして、以下の内容で &lt;code&gt;pycuda-test.py&lt;/code&gt; を作って実行してみました。&lt;/p&gt;

&lt;p&gt;Python 3.xを使っているので &lt;code&gt;print&lt;/code&gt; の引数は括弧で囲むように書き換えています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import pycuda.gpuarray as gpuarray
import pycuda.driver as cuda
import pycuda.autoinit
import numpy

a_gpu = gpuarray.to_gpu(numpy.random.randn(4,4).astype(numpy.float32))
a_doubled = (2*a_gpu).get()
print(a_doubled)
print(a_gpu)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行してみると、以下のように出力されPyCUDAが無事動きました！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv) $ python pycuda-test.py
[[-0.72795004 -0.16994514  0.02276878 -1.07509565]
 [ 0.20851769  2.08421874 -0.51877511 -1.27585149]
 [ 0.29300559 -0.40393201  3.15332532 -1.90199065]
 [ 2.87024021  0.64773476  2.65404892 -2.97092891]]
[[-0.36397502 -0.08497257  0.01138439 -0.53754783]
 [ 0.10425884  1.04210937 -0.25938755 -0.63792574]
 [ 0.14650279 -0.201966    1.57666266 -0.95099533]
 [ 1.43512011  0.32386738  1.32702446 -1.48546445]]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>GeForce搭載の旧モデルMacBook ProでCUDAをセットアップする手順のメモ</title>
      <link>/blog/2015/07/25/setup_cuda_on_macbook_pro_with_geforce/</link>
      <pubDate>Sat, 25 Jul 2015 17:37:59 +0900</pubDate>
      
      <guid>/blog/2015/07/25/setup_cuda_on_macbook_pro_with_geforce/</guid>
      <description>

&lt;h2 id=&#34;はじめに:a311e6dec28847b69a9c104c237fbeb5&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.apple.com/jp/macbook-pro/specs-retina/&#34;&gt;MacBook Pro現行モデルの技術仕様&lt;/a&gt;を見ると最上位機種のグラフィックスチップはIntel Iris Pro GraphicsとAMD Radeon R9 M370Xとなっており、NVIDIA GeForceは搭載されていません。&lt;/p&gt;

&lt;p&gt;ですが、&lt;a href=&#34;https://support.apple.com/kb/SP694?locale=ja_JP&amp;amp;viewlocale=ja_JP&#34;&gt;MacBook Pro (15-inch, Mid 2012) - 技術仕様&lt;/a&gt;を見ると、私が持っているMacBook Proは15インチ2.6GHzモデルなのでNVIDIA GeForce GT 650M、1GB GDDR5メモリが搭載されています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.nvidia.co.jp/object/geforce-gt-650m-jp.html#pdpContent=2&#34;&gt;GeForce GT 650M | NVIDIA&lt;/a&gt;には「プログラミング環境」の行に「CUDA」とあるのでCUDAが使えるようです。&lt;/p&gt;

&lt;p&gt;ということでCUDAを試してみたので、手順をメモしておきます。試した時のOS Xのバージョンは10.10.4、Xcodeのバージョンは6.4です。&lt;/p&gt;

&lt;h2 id=&#34;cudaドライバのインストールとアップデート:a311e6dec28847b69a9c104c237fbeb5&#34;&gt;CUDAドライバのインストールとアップデート&lt;/h2&gt;

&lt;p&gt;後述のCUDAツールキットのインストール中の画面にCUDAドライバも含まれているような記述があったので、この手順は不要かもしれません。が、今回はそれを知らずに先にCUDAドライバを単体でインストールしたので、一応書いておきます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.nvidia.co.jp/object/mac-driver-archive-jp.html&#34;&gt;MAC アーカイブ用CUDA ドライバ | NVIDIA&lt;/a&gt;から最新のドライバをダウンロード、インストールします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.nvidia.co.jp/object/macosx-cuda-7.0.36-driver-jp.html&#34;&gt;NVIDIA DRIVERS 7.0.36&lt;/a&gt;の「リリースハイライト」によると、[システム環境設定]→[CUDA]でインストール済みのCUDAドライバのバージョンと最新バージョンの確認が出来て、アップデートもできるそうです。&lt;/p&gt;

&lt;p&gt;早速確認してみると、インストール済みのCUDA Driver Versionは7.0.29となっており、CUDA 7.0.52 Driver update is availableと表示されていました。&lt;/p&gt;

&lt;p&gt;7.0.36のドライバを単体でインストールしたのに7.0.29になっているのは後述のCUDAツールキットのインストールで上書きされたのだと思われます。ついでなので、[Install CUDA Update]ボタンを押してアップデートしておきました。&lt;/p&gt;

&lt;h2 id=&#34;cudaツールキットのインストール:a311e6dec28847b69a9c104c237fbeb5&#34;&gt;CUDAツールキットのインストール&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.nvidia.com/cuda/index.html#axzz3gt2fIbGh&#34;&gt;CUDA Toolkit Documentation&lt;/a&gt;のページから&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#axzz3gt2fIbGh&#34;&gt;Getting Started Mac OS X&lt;/a&gt;に進み、&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#installation&#34;&gt;3. Installation&lt;/a&gt;を参考にCUDAツールキットをインストールしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.nvidia.com/cuda-downloads&#34;&gt;CUDA 7 Downloads&lt;/a&gt;で[Mac OSX]のタブに切り替えてインストーラをダウンロードします。最初Network Installerを試したのですが、ダウンロードしたdmgファイルを開いてCUDAMacOSXInstallerをダブルクリックしたら「“CUDAMacOSXInstaller”はこわれているため開けません。」というエラーが出たので、Local Installer (977MB)を試したら、こちらは無事インストール出来ました。&lt;/p&gt;

&lt;p&gt;その後、cuFFT Patchをダウンロードして、&lt;a href=&#34;http://developer.download.nvidia.com/compute/cuda/7_0/Prod/cufft_update/README_mac.txt&#34;&gt;README&lt;/a&gt;を参考にターミナルで以下のコマンドを実行してパッチを適用しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo tar zxf ~/Downloads/cufft_patch_mac.tar.gz -C /Developer/NVIDIA/CUDA-7.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cudaツールキット用の環境変数設定:a311e6dec28847b69a9c104c237fbeb5&#34;&gt;CUDAツールキット用の環境変数設定&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#axzz3gt2fIbGh&#34;&gt;Getting Started Mac OS X&lt;/a&gt;の&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#install&#34;&gt;3.2. Install&lt;/a&gt;で環境変数 &lt;code&gt;PATH&lt;/code&gt; と &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; の設定方法が書いてあるのですが、この通りだとあとでPyCUDAをインストールするときに &lt;code&gt;-lcuda&lt;/code&gt; が見つからずリンクエラーになりました。&lt;/p&gt;

&lt;p&gt;検索してみると&lt;a href=&#34;https://code.google.com/p/pyrit/issues/detail?id=248&#34;&gt;Issue 248 - pyrit - Build script can&amp;rsquo;t find CUDA library directory on OS X. - WPA/WPA2-PSK and a world of affordable many-core platforms - Google Project Hosting&lt;/a&gt; で &lt;code&gt;/usr/local/cuda&lt;/code&gt; というディレクトリがあることを知り、&lt;code&gt;/usr/local/cuda/lib&lt;/code&gt; と &lt;code&gt;/Developer/NVIDIA/CUDA-7.0/lib&lt;/code&gt; の中身を見てみると &lt;code&gt;libcuda.dylib&lt;/code&gt; だけは前者にしか無いことが判明しました。&lt;/p&gt;

&lt;p&gt;結局以下のように設定する必要がありました (bash以外の場合は適宜変更してください)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt;&amp;gt; ~/.bash_profile
# CUDA
export CUDA_ROOT=/usr/local/cuda
export PATH=$CUDA_ROOT/bin:$PATH
export DYLD_LIBRARY_PATH=$CUDA_ROOT/lib:$PATH
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;設定ファイルを書き換えたら以下のコマンドでシェルを再起動して設定を読み込んでおきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exec $SHELL -l
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;統合gpuではなくgeforceを使うように切り替える設定:a311e6dec28847b69a9c104c237fbeb5&#34;&gt;統合GPUではなくGeForceを使うように切り替える設定&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#axzz3gt2fIbGh&#34;&gt;Getting Started Mac OS X&lt;/a&gt;の&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#install&#34;&gt;3.2. Install&lt;/a&gt;の説明に従って、以下のように設定しました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[システム環境設定]→[省エネルギー]を開きます&lt;/li&gt;
&lt;li&gt;[グラフィックスの自動切り替え]のチェックを外します&lt;/li&gt;
&lt;li&gt;電源アダプタに繋いでいる場合は[電源アダプタ]、繋いでいない場合は[バッテリー]を選びます&lt;/li&gt;
&lt;li&gt;[コンピュータのスリープ]のスライダーを[しない]に調節します。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cudaのサンプルを試す:a311e6dec28847b69a9c104c237fbeb5&#34;&gt;CUDAのサンプルを試す&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#axzz3gt2fIbGh&#34;&gt;Getting Started Mac OS X&lt;/a&gt;の&lt;a href=&#34;http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html#install&#34;&gt;3.2. Install&lt;/a&gt;の説明に従って、 &lt;code&gt;cuda-install-samples-7.0.sh&lt;/code&gt; を使ってサンプルプログラムを取得して試してみました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;~/sandbox/cuda&lt;/code&gt; という作業用のディレクトリを作って以下の手順で試しました。 &lt;code&gt;cuda-install-samples-7.0.sh&lt;/code&gt; はインストール先のディレクトリを引数で指定する必要がありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p ~/sandbox/cuda
cd !$
cuda-install-samples-7.0.sh .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行すると &lt;code&gt;NVIDIA_CUDA-7.0_Samples&lt;/code&gt; というディレクトリが作成され、配下にサンプルプログラムのソースファイルが展開されていました。&lt;/p&gt;

&lt;p&gt;そのうちの1つ &lt;code&gt;asyncAPI&lt;/code&gt; というのを試してみました。以下の手順でビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd NVIDIA_CUDA-7.0_Samples/0_Simple/asyncAPI
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ../../bin/x86_64/darwin/release/asyncAPI
[../../bin/x86_64/darwin/release/asyncAPI] - Starting...
GPU Device 0: &amp;quot;GeForce GT 650M&amp;quot; with compute capability 3.0

CUDA device [GeForce GT 650M]
time spent executing by the GPU: 99.45
time spent by CPU in CUDA calls: 0.05
CPU executed 583004 iterations while waiting for GPU to finish
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動きました！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OSX上でmultirustを使ったrustfmtのインストール手順</title>
      <link>/blog/2015/07/19/install_rustfmt/</link>
      <pubDate>Sun, 19 Jul 2015 00:33:15 +0900</pubDate>
      
      <guid>/blog/2015/07/19/install_rustfmt/</guid>
      <description>&lt;p&gt;OSXでは&lt;a href=&#34;https://github.com/brson/multirust/issues/43&#34;&gt;building cargo atop multirust fails, dyn link problems (Mac OS X) · Issue #43 · brson/multirust&lt;/a&gt;のイシューの&lt;a href=&#34;https://github.com/brson/multirust/issues/43#issuecomment-106758695&#34;&gt;コメント106758695&lt;/a&gt;にあるように &lt;code&gt;rustfmt&lt;/code&gt; の実行時に環境変数 &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; を設定する必要があります。&lt;/p&gt;

&lt;p&gt;そこで、 &lt;code&gt;rustfmt&lt;/code&gt; の実行ファイルを &lt;code&gt;~/bin/rustfmt.bin&lt;/code&gt; と別の名前にして、起動用のスクリプトを &lt;code&gt;~/bin/rustfmt&lt;/code&gt; として作成します。&lt;/p&gt;

&lt;p&gt;インストール手順は以下のとおりです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/nrc/rustfmt
cd rustfmt
cargo build --release
cp target/release/rustfmt ~/bin/rustfmt.bin
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; ~/bin/rustfmt
#!/bin/sh
DYLD_LIBRARY_PATH=&amp;quot;$HOME/.multirust/toolchains/nightly/lib&amp;quot; $HOME/bin/rustfmt.bin &amp;quot;$@&amp;quot;
EOF
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>manyrustという複数バージョンのrustインストールスクリプトを書いた</title>
      <link>/blog/2015/07/18/manyrust/</link>
      <pubDate>Sat, 18 Jul 2015 23:13:32 +0900</pubDate>
      
      <guid>/blog/2015/07/18/manyrust/</guid>
      <description>

&lt;h2 id=&#34;multirustがあるのに-なぜ新たに書いたのか:dba7f7ce875f36e918dffb470ba2d4ac&#34;&gt;multirustがあるのに、なぜ新たに書いたのか&lt;/h2&gt;

&lt;p&gt;rustのインストールは&lt;a href=&#34;http://www.rust-lang.org/install.html&#34;&gt;Install · The Rust Programming Language&lt;/a&gt;にあるように複数のチャネルから選んでインストールします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;stable (安定版)チャネル&lt;/li&gt;
&lt;li&gt;beta (ベータ版)チャネル&lt;/li&gt;
&lt;li&gt;nightly (毎晩ビルドされる)チャネル&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;rustでunstableなAPIを使うにはnightlyを使う必要があるので、たいていはstableとnightlyの両方をインストールして使い分けたくなるはずです。
その用途には定番のスクリプトとして&lt;a href=&#34;https://github.com/brson/multirust&#34;&gt;brson/multirust&lt;/a&gt;があります。&lt;/p&gt;

&lt;p&gt;私も使っていましたが、rustのソースコードの整形ツール&lt;a href=&#34;https://github.com/nrc/rustfmt&#34;&gt;nrc/rustfmt&lt;/a&gt;をビルドして起動しようとするとエラーになってしまいました。&lt;/p&gt;

&lt;p&gt;既に&lt;a href=&#34;https://github.com/brson/multirust/issues/43&#34;&gt;building cargo atop multirust fails, dyn link problems (Mac OS X) · Issue #43 · brson/multirust&lt;/a&gt;にイシューが上がっていて、&lt;a href=&#34;https://github.com/brson/multirust/issues/43#issuecomment-106758695&#34;&gt;コメント106758695&lt;/a&gt;にあるように環境変数 &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; を設定すれば問題は解消するとのことです。&lt;/p&gt;

&lt;p&gt;ディレクトリによって環境変数を切り替えるのは&lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;direnv/direnv&lt;/a&gt;が便利です。ただ、&lt;code&gt;direnv&lt;/code&gt; を使うのであれば、そもそも &lt;code&gt;multirust&lt;/code&gt; のように &lt;code&gt;rustc&lt;/code&gt; などの実行ファイルをラップしたシェルスクリプトを作る必要は無いわけです。&lt;/p&gt;

&lt;p&gt;rustの複数のバージョンを異なるディレクトリにインストールしておいて、利用するディレクトリごとに環境変数 &lt;code&gt;PATH&lt;/code&gt; と &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; を切り替えればいいだけです。&lt;/p&gt;

&lt;p&gt;であれば、 &lt;code&gt;multirust&lt;/code&gt; 使わなくてももっとシンプルなスクリプトでいいよね、ということで書いたのが &lt;code&gt;manyrust&lt;/code&gt; です。現状はOSXのみサポートしています。&lt;/p&gt;

&lt;h2 id=&#34;インストール手順:dba7f7ce875f36e918dffb470ba2d4ac&#34;&gt;インストール手順&lt;/h2&gt;

&lt;p&gt;以下のようにして &lt;code&gt;~/bin&lt;/code&gt; に &lt;code&gt;manyrust&lt;/code&gt; スクリプトを配置します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir ~/bin
curl -s -o ~/bin/manyrust https://raw.githubusercontent.com/hnakamur/manyrust/master/manyrust
chmod +x ~/bin/manyrust
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;環境変数 &lt;code&gt;PATH&lt;/code&gt; に &lt;code&gt;$HOME/bin&lt;/code&gt; を追加して有効にします。
bashの場合はこんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &#39;export PATH=&amp;quot;$HOME/bin:$PATH&amp;quot;&#39; &amp;gt;&amp;gt; ~/.bash_profilie
exec $SHELL -l
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rustのインストール:dba7f7ce875f36e918dffb470ba2d4ac&#34;&gt;rustのインストール&lt;/h2&gt;

&lt;p&gt;stableチャネルの最新版をインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;manyrust install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;betaチャネルの最新版をインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;manyrust install beta
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nightlyチャネルの最新版をインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;manyrust install nightly
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rustを利用する側の作業ディレクトリでの設定:dba7f7ce875f36e918dffb470ba2d4ac&#34;&gt;rustを利用する側の作業ディレクトリでの設定&lt;/h2&gt;

&lt;p&gt;stableチャネルの最新版を使うディレクトリでの設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;manyrust showcfg &amp;gt;&amp;gt; .envrc
direnv allow .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nightlyチャネルの最新版を使うディレクトリでの設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;manyrust showcfg nightly &amp;gt;&amp;gt; .envrc
direnv allow .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nightlyチャネルの特定のバージョン2015-07-14を使うディレクトリでの設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;manyrust showcfg nightly 2015-07-14 &amp;gt;&amp;gt; .envrc
direnv allow .
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;応用例:dba7f7ce875f36e918dffb470ba2d4ac&#34;&gt;応用例&lt;/h3&gt;

&lt;p&gt;基本的にはstableチャネルのrustを使いたいが、特定のディレクトリ下ではnightlyを使いたい場合は &lt;code&gt;$HOME/.envrc&lt;/code&gt; にstableを使う設定を書いておいて、特定のディレクトリの &lt;code&gt;.envrc&lt;/code&gt; ではnightlyを使う設定を書いておけばOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ manyrust showcfg &amp;gt;&amp;gt; ~/.envrc
direnv: error .envrc is blocked. Run `direnv allow` to approve its content.
$ direnv allow ~
direnv: loading ../../../../.envrc
direnv: export +DYLD_LIBRARY_PATH ~PATH
$ mkdir ~/nightly_work
$ cd !$
cd ~/nightly_work
$ manyrust showcfg nightly &amp;gt;&amp;gt; .envrc
direnv: error .envrc is blocked. Run `direnv allow` to approve its content.
$ direnv allow .
direnv: loading .envrc
direnv: export +DYLD_LIBRARY_PATH ~PATH
$ rustc --version
rustc 1.3.0-nightly (e4e93196e 2015-07-14)
$ echo $DYLD_LIBRARY_PATH
/Users/hnakamur/rust/nightly/2015-07-14/rust/lib:
$ cd
direnv: loading .envrc
direnv: export +DYLD_LIBRARY_PATH ~PATH
$ rustc --version
rustc 1.1.0 (35ceea399 2015-06-19)
$ echo $DYLD_LIBRARY_PATH
/Users/hnakamur/rust/stable/1.1.0/rust/lib:
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;direnvを使って設定を切り替えることの利点:dba7f7ce875f36e918dffb470ba2d4ac&#34;&gt;direnvを使って設定を切り替えることの利点&lt;/h3&gt;

&lt;p&gt;上の例で生成した設定ファイルは以下のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ~/.envrc
source &amp;quot;${MANYRUST_ROOT:-$HOME/rust}/stable/current/etc/bashrc&amp;quot;
$ cat ~/nightly_work/.envrc
source &amp;quot;${MANYRUST_ROOT:-$HOME/rust}/nightly/current/etc/bashrc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;souce&lt;/code&gt; で読み込むファイルは &lt;code&gt;manyrust install&lt;/code&gt; で以下のように生成されています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ~/rust/stable/current/etc/bashrc
rust_root=&amp;quot;${RUSTS_HOME:-$HOME/rust}/stable/1.1.0/rust&amp;quot;
export PATH=&amp;quot;$rust_root/bin:$PATH&amp;quot;
export DYLD_LIBRARY_PATH=&amp;quot;$rust_root/lib:$DYLD_LIBRARY_PATH&amp;quot;
$ cat ~/rust/nightly/current/etc/bashrc
rust_root=&amp;quot;${RUSTS_HOME:-$HOME/rust}/nightly/2015-07-14/rust&amp;quot;
export PATH=&amp;quot;$rust_root/bin:$PATH&amp;quot;
export DYLD_LIBRARY_PATH=&amp;quot;$rust_root/lib:$DYLD_LIBRARY_PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;direnv&lt;/code&gt; を使わずに何回もこういうファイルを &lt;code&gt;source&lt;/code&gt; すると、 &lt;code&gt;PATH&lt;/code&gt; や &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; の中身がどんどん増えてしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval `manyrust showcfg beta`
$ echo $DYLD_LIBRARY_PATH
/Users/hnakamur/rust/beta/1.2.0-beta.2/rust/lib:
$ eval `manyrust showcfg stable`
$ echo $DYLD_LIBRARY_PATH
/Users/hnakamur/rust/stable/1.1.0/rust/lib:/Users/hnakamur/rust/beta/1.2.0-beta.2/rust/lib:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;長いだけではなく、この例だとstableには無いがnightlyにあるライブラリが存在するとstableのライブラリを使いたいのにnightly側が使われてしまうという問題が起きてしまいます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;direnv&lt;/code&gt; を使っていれば、上の応用例のように &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; の値が追加されるのではなく設定が切り替えられるので、この問題は起きません。&lt;/p&gt;

&lt;h2 id=&#34;rustfmtのビルドとインストール:dba7f7ce875f36e918dffb470ba2d4ac&#34;&gt;rustfmtのビルドとインストール&lt;/h2&gt;

&lt;p&gt;で、ここまで書いてから &lt;code&gt;rustfmt&lt;/code&gt; をビルド、インストールしようとして問題に気付きました。 &lt;code&gt;rustfmt&lt;/code&gt; は &lt;code&gt;~/rust/nightly/current/rust/bin/&lt;/code&gt; に置いて上記のように &lt;code&gt;.envrc&lt;/code&gt; で切り替えればいいかと思っていたのですが、そうすると &lt;code&gt;stable&lt;/code&gt; を使うように &lt;code&gt;.envrc&lt;/code&gt; を設定したディレクトリでは &lt;code&gt;rustfmt&lt;/code&gt; が使えなくなってしまいます。&lt;/p&gt;

&lt;p&gt;またnightlyのバージョンが上がると &lt;code&gt;rustfmt&lt;/code&gt; をビルドし直す必要もあります。&lt;/p&gt;

&lt;p&gt;これを回避するためにはビルドした &lt;code&gt;rustfmt&lt;/code&gt; は &lt;code&gt;~/bin/rustfmt.bin&lt;/code&gt; と名前を変えて &lt;code&gt;~/bin&lt;/code&gt; に置いて、ラップしたスクリプトを &lt;code&gt;~/bin/rustfmt&lt;/code&gt; という名前で作成します。&lt;/p&gt;

&lt;p&gt;具体的な手順は以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/nrc/rustfmt
cd rustfmt
manyrust showcfg nightly &amp;gt;&amp;gt; .envrc
direnv allow .
cargo build --release
cp target/release/rustfmt ~/bin/rustfmt.bin
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; ~/bin/rustfmt
#!/bin/sh
DYLD_LIBRARY_PATH=&amp;quot;${MANYRUST_ROOT:-$HOME/rust}/nightly/2015-07-14/rust/lib&amp;quot; $HOME/bin/rustfmt.bin &amp;quot;$@&amp;quot;
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今後nightlyを追加インストールした時に &lt;code&gt;rustfmt&lt;/code&gt; が依存しているディレクトリが新しいバージョンの &lt;code&gt;lib&lt;/code&gt; ディレクトリに存在しない場合に備えて、 &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; は &lt;code&gt;~/rust/nightly/current/rust/lib&lt;/code&gt; ではなく特定のバージョンの &lt;code&gt;lib&lt;/code&gt; ディレクトリを指定しています。&lt;/p&gt;

&lt;p&gt;ということで、 &lt;code&gt;rustfmt&lt;/code&gt; に関しては &lt;code&gt;multirust&lt;/code&gt; でも &lt;code&gt;manyrust&lt;/code&gt; でも同じことで、&lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; を設定して実行するようなスクリプトを書いてラップする必要があるというオチでした。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>xhyveでFreeBSDを動かしてみた</title>
      <link>/blog/2015/07/12/running_freebsd_on_xhyve/</link>
      <pubDate>Sun, 12 Jul 2015 06:34:46 +0900</pubDate>
      
      <guid>/blog/2015/07/12/running_freebsd_on_xhyve/</guid>
      <description>

&lt;p&gt;下記の記事を参考に動かしただけですが、後々使うときに手順を忘れているはずなのでメモ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.holidayworking.org/entry/2015/06/27/xhyve_%E3%81%A7_FreeBSD_%E3%82%92%E5%8B%95%E3%81%8B%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F&#34;&gt;xhyve で FreeBSD を動かしてみた - blog.holidayworking.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.holidayworking.org/entry/2015/07/05/FreeBSD_on_xhyve_%E3%81%A7%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%82%92%E3%83%9E%E3%82%A6%E3%83%B3%E3%83%88%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%9F&#34;&gt;FreeBSD on xhyve でディスクをマウントすることができた - blog.holidayworking.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なお、FreeBSD対応のプルリクエストは既に本家のmasterにマージ済みです。
また、今回使ったスクリプトは &lt;a href=&#34;https://github.com/hnakamur/xhyve/tree/add_scripts_for_freebsd&#34;&gt;hnakamur/xhyveのadd_scripts_for_freebsdブランチ&lt;/a&gt; に上げています。&lt;/p&gt;

&lt;h2 id=&#34;freebsdのvmイメージダウンロードと解凍:c6b057c495414fd6191dc79669cf401e&#34;&gt;FreeBSDのVMイメージダウンロードと解凍&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;./download_freebsd_image.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FreeBSD-10.1-RELEASE-amd64.raw.xzを取得、解凍します。解凍後のファイルサイズは約21GBです。&lt;/p&gt;

&lt;h2 id=&#34;freebsdのvm起動:c6b057c495414fd6191dc79669cf401e&#34;&gt;FreeBSDのVM起動&lt;/h2&gt;

&lt;p&gt;ネットワークを使うためには &lt;code&gt;./xhyverun-freebsd.sh&lt;/code&gt; の &lt;code&gt;NET=&amp;quot;-s 2:0,virtio-net&amp;quot;&lt;/code&gt; の行を有効にする必要がありました。これを有効にすると起動には &lt;code&gt;sudo&lt;/code&gt; が必要でしたので、VM起動は以下のように実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo ./xhyverun-freebsd.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動したら、IDはroot、パスワード無しでログインできます。&lt;/p&gt;

&lt;h2 id=&#34;ネットワークの設定:c6b057c495414fd6191dc79669cf401e&#34;&gt;ネットワークの設定&lt;/h2&gt;

&lt;p&gt;初回起動時は手動でDHCPクライアントを実行してIPアドレスを取得します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dhclient vtnet0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完了後 &lt;code&gt;ifconfig&lt;/code&gt; で確認すると 192.168.64.10 というIPアドレスが取得できていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@:~ # ifconfig
vtnet0: flags=8943&amp;lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&amp;gt; metric 0 mtu 1500
        options=80028&amp;lt;VLAN_MTU,JUMBO_MTU,LINKSTATE&amp;gt;
        ether 6a:c9:2c:45:cf:32
        inet 192.168.64.10 netmask 0xffffff00 broadcast 192.168.64.255
        nd6 options=29&amp;lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&amp;gt;
        media: Ethernet 10Gbase-T &amp;lt;full-duplex&amp;gt;
        status: active
lo0: flags=8049&amp;lt;UP,LOOPBACK,RUNNING,MULTICAST&amp;gt; metric 0 mtu 16384
        options=600003&amp;lt;RXCSUM,TXCSUM,RXCSUM_IPV6,TXCSUM_IPV6&amp;gt;
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x2
        inet 127.0.0.1 netmask 0xff000000
        nd6 options=21&amp;lt;PERFORMNUD,AUTO_LINKLOCAL&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次回以降の起動時に自動的にDHCPクライアントを実行するために、以下のコマンドを実行します。 &lt;code&gt;/etc/rc.conf&lt;/code&gt; は存在していないので &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ではなく &lt;code&gt;&amp;gt;&lt;/code&gt; でも良いですが、良い習慣付けとして &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; にしておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo ifconfig_vtnet0=&amp;quot;DHCP&amp;quot; &amp;gt;&amp;gt; /etc/rc.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;freebsdのvm停止:c6b057c495414fd6191dc79669cf401e&#34;&gt;FreeBSDのVM停止&lt;/h2&gt;

&lt;p&gt;VM内で以下のコマンドを実行するとVMをシャットダウンしてホストOSであるOSXのシェルプロンプトに戻ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shutdown -p now
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Cybozu Garoon APIのファイル管理の部分だけのgoライブラリを書いた</title>
      <link>/blog/2015/06/15/garoon_go_client/</link>
      <pubDate>Mon, 15 Jun 2015 20:24:16 +0900</pubDate>
      
      <guid>/blog/2015/06/15/garoon_go_client/</guid>
      <description>

&lt;h1 id=&#34;はじめに:3036273db89ecc435ad43fdf2cd8cfa3&#34;&gt;はじめに&lt;/h1&gt;

&lt;p&gt;Cybozu &lt;a href=&#34;https://cybozudev.zendesk.com/hc/ja/categories/200157760-Garoon-API&#34;&gt;Garoon API&lt;/a&gt;のファイル管理のうち、フォルダ一覧取得、フォルダ内のファイル一覧取得、ファイルダウンロードのAPIを呼び出すライブラリをGoで書いてみました。&lt;/p&gt;

&lt;p&gt;ただし、汎用的なライブラリではなく、自分が必要な機能のみを実装しています。レスポンスの中の項目も自分が必要な部分だけ取り出して残りは破棄しています。
&lt;a href=&#34;http://blog.sigbus.info/2015/01/p1.html&#34;&gt;sigbus.info: コードを書くことは無限の可能性を捨てて一つのやり方を選ぶということ&lt;/a&gt;を読んでから、汎用性をあまり気にせず自分の用途に合わせて書くようになって楽で良いです。&lt;/p&gt;

&lt;h1 id=&#34;実装方法についてのメモ:3036273db89ecc435ad43fdf2cd8cfa3&#34;&gt;実装方法についてのメモ&lt;/h1&gt;

&lt;p&gt;まず、Garoon APIの手動での呼び出し方は&lt;a href=&#34;http://qiita.com/yamasaki-masahide/items/fff1c84e65043ac4caf7&#34;&gt;garoon - Cybozu ガルーン API を使ってみる - Qiita&lt;/a&gt;を参考にして試してみました。&lt;/p&gt;

&lt;h2 id=&#34;リクエストのxml組み立て:3036273db89ecc435ad43fdf2cd8cfa3&#34;&gt;リクエストのXML組み立て&lt;/h2&gt;

&lt;p&gt;Garoon APIはSOAPなので、リクエストやレスポンスはXMLになります。&lt;/p&gt;

&lt;p&gt;リクエストを送るところは&lt;a href=&#34;http://qiita.com/yamasaki-masahide/items/03dfa6cd70ff20607b58&#34;&gt;Cybozu ガルーン API を golang で叩いてみる - Qiita&lt;/a&gt;を見たのですが、&lt;a href=&#34;http://qiita.com/ono_matope/items/70080cc33b75152c5c2a&#34;&gt;Goのencoding/xmlを使いこなす - Qiita&lt;/a&gt;を参考にMarshalXMLを実装する方式にしてみました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/pkg/encoding/xml/#Marshaler&#34;&gt;xml.Marshaler&lt;/a&gt;の &lt;code&gt;MarshalXML(e *Encoder, start StartElement) error&lt;/code&gt; は &lt;code&gt;start&lt;/code&gt; をエンコードするのが本来の使い方だとは思うのですが、下記の例のように &lt;code&gt;CabinetGetFolderInfo&lt;/code&gt; といったリクエスト本体を渡すと &lt;code&gt;soap:Envelope&lt;/code&gt; でラップしてエンコードしてくれる方が使うときに楽なので、 &lt;code&gt;MarshalXML&lt;/code&gt; 内でデータ構造を組み立ててエンコードするようにしてみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;soap:Envelope xmlns:soap=&amp;quot;http://www.w3.org/2003/05/soap-envelope&amp;quot;&amp;gt;
  &amp;lt;soap:Header&amp;gt;
    &amp;lt;Action&amp;gt;CabinetGetFolderInfo&amp;lt;/Action&amp;gt;
    &amp;lt;Security&amp;gt;
      &amp;lt;UsernameToken&amp;gt;
        &amp;lt;Username&amp;gt;foo&amp;lt;/Username&amp;gt;
        &amp;lt;Password&amp;gt;password&amp;lt;/Password&amp;gt;
      &amp;lt;/UsernameToken&amp;gt;
    &amp;lt;/Security&amp;gt;
    &amp;lt;Timestamp&amp;gt;
      &amp;lt;Created&amp;gt;2010-08-12T14:45:00Z&amp;lt;/Created&amp;gt;
      &amp;lt;Expires&amp;gt;2037-08-12T14:45:00Z&amp;lt;/Expires&amp;gt;
    &amp;lt;/Timestamp&amp;gt;
    &amp;lt;Locale&amp;gt;jp&amp;lt;/Locale&amp;gt;
  &amp;lt;/soap:Header&amp;gt;
  &amp;lt;soap:Body&amp;gt;
    &amp;lt;CabinetGetFolderInfo&amp;gt;
      &amp;lt;parameters&amp;gt;&amp;lt;/parameters&amp;gt;
    &amp;lt;/CabinetGetFolderInfo&amp;gt;
  &amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;soap:Envelope&lt;/code&gt; でラップした構造を作るところは、&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/request.go#L44-L62&#34;&gt;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/request.go#L44-L62&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
func buildRequestStruct(h RequestHeader, apiName string, parameters interface{}) envelope {
	return envelope{
		Xmlns: &amp;quot;http://www.w3.org/2003/05/soap-envelope&amp;quot;,
		Header: header{
			Action:   apiName,
			Username: h.Username,
			Password: h.Password,
			Created:  h.Created,
			Expires:  h.Expires,
			Locale:   h.Locale,
		},
		Body: body{
			Content: bodyContent{
				XMLName:    xml.Name{Local: apiName},
				Parameters: parameters,
			},
		},
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で共通処理として実装し、各API用のリクエストの構造体では&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/cabinet.go#L16-L26&#34;&gt;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/cabinet.go#L16-L26&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type CabinetGetFolderInfoRequest struct {
	Header RequestHeader
}

func (r CabinetGetFolderInfoRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.Encode(buildRequestStruct(
		r.Header,
		&amp;quot;CabinetGetFolderInfo&amp;quot;,
		struct{}{},
	))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにして呼び出しています。&lt;/p&gt;

&lt;p&gt;また、日時の項目は構造体側では &lt;code&gt;time.Time&lt;/code&gt; にしたいところですが、&lt;a href=&#34;https://code.google.com/p/go/issues/detail?id=2771#c2&#34;&gt;Issue 2771 - go - encoding/xml: MarshalXML interface is not good enough - The Go Programming Language - Google Project Hosting&lt;/a&gt;の&lt;a href=&#34;https://code.google.com/p/go/issues/detail?id=2771#c2&#34;&gt;コメント#2&lt;/a&gt;を読んで &lt;code&gt;string&lt;/code&gt; にしました。&lt;/p&gt;

&lt;h2 id=&#34;レスポンスのパース処理:3036273db89ecc435ad43fdf2cd8cfa3&#34;&gt;レスポンスのパース処理&lt;/h2&gt;

&lt;p&gt;レスポンスのパースは&lt;a href=&#34;http://qiita.com/yamasaki-masahide/items/f20a2ca4700e00777303&#34;&gt;Cybozu ガルーン API のレスポンスのXMLを golang でパースする - Qiita&lt;/a&gt;を見たのですが、&lt;a href=&#34;http://blog.davidsingleton.org/parsing-huge-xml-files-with-go/&#34;&gt;Parsing huge XML files with Go - david singleton&lt;/a&gt;の方法のほうが楽なのでこちらを参考にしました。&lt;/p&gt;

&lt;p&gt;共通のユーテリティ関数としては
&lt;a href=&#34;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/response.go&#34;&gt;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/response.go&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var ResponseTagNotFoundError = errors.New(&amp;quot;response tag not found&amp;quot;)

func parseResponse(r io.Reader, localName string, v interface{}) error {
	decoder := xml.NewDecoder(r)
	for {
		t, _ := decoder.Token()
		if t == nil {
			break
		}
		switch se := t.(type) {
		case xml.StartElement:
			if se.Name.Local == localName {
				return decoder.DecodeElement(v, &amp;amp;se)
			}
		}
	}
	return ResponseTagNotFoundError
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように定義して、&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/cabinet.go#L115-L127&#34;&gt;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/cabinet.go#L115-L127&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func parseCabinetGetFolderInfoResponse(r io.Reader) (*CabinetGetFolderInfoResponse, error) {
	exclude := NewExclude(func(b byte) bool {
		return b == 0x08 || b == 0x0B
	})
	r2 := transform.NewReader(r, exclude)
	var resp CabinetGetFolderInfoResponse
	err := parseResponse(r2, &amp;quot;CabinetGetFolderInfoResponse&amp;quot;, &amp;amp;resp)
	if err != nil {
		return nil, err
	}
	resp.fillPath()
	return &amp;amp;resp, err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じで呼び出しています。&lt;/p&gt;

&lt;h2 id=&#34;レスポンスからu-0008などの制御文字を除去:3036273db89ecc435ad43fdf2cd8cfa3&#34;&gt;レスポンスからU+0008などの制御文字を除去&lt;/h2&gt;

&lt;p&gt;あと、レスポンスのXMLをそのまま&lt;a href=&#34;http://golang.org/pkg/encoding/xml/#Decoder&#34;&gt;xml.Decoder&lt;/a&gt;に渡すとUTF-8の不正なバイト列といったエラーが出ました。U+0008やU+000Bというデータが入っていたので、これを除去するようにしました。&lt;/p&gt;

&lt;p&gt;日本語の文字コード変換用のライブラリ&lt;a href=&#34;https://godoc.org/golang.org/x/text/encoding/japanese&#34;&gt;golang.org/x/text/encoding/japanese&lt;/a&gt;で使っているインターフェース&lt;a href=&#34;https://godoc.org/golang.org/x/text/transform#Transformer&#34;&gt;golang.org/x/text/transform/Transformer&lt;/a&gt;に合わせて実装しました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/cabinet.go#L28-L50&#34;&gt;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/cabinet.go#L28-L50&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type exclude struct {
	transform.NopResetter
	excluder func(byte) bool
}

func NewExclude(excluder func(byte) bool) transform.Transformer {
	return exclude{excluder: excluder}
}

func (e exclude) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
	for nSrc = 0; nSrc &amp;lt; len(src); nSrc++ {
		b := src[nSrc]
		if !e.excluder(b) {
			if nDst &amp;gt;= len(dst) {
				err = transform.ErrShortDst
				return
			}
			dst[nDst] = b
			nDst++
		}
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用するときは&lt;a href=&#34;https://godoc.org/golang.org/x/text/transform#NewReader&#34;&gt;golang.org/x/text/transform/NewReader&lt;/a&gt;を使います。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:3036273db89ecc435ad43fdf2cd8cfa3&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Cybozu Garoon APIの一部のクライアントライブラリをGoで実装しました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MarshalXMLを実装することで、構造体とXMLの構造がかなり違う場合でも、XMLに合わせて一々構造体を定義することなく楽に対応出来ました。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://golang.org/pkg/encoding/xml/#Decoder.Token&#34;&gt;xml.DecoderのToken&lt;/a&gt;を使うことでXMLの一部だけをパースしました。&lt;/li&gt;
&lt;li&gt;制御文字除去の処理を&lt;a href=&#34;https://godoc.org/golang.org/x/text/transform#Transformer&#34;&gt;golang.org/x/text/transform/Transformer&lt;/a&gt;インタフェースに合わせて実装しました。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>mecab-ipadicでconfigure実行したらmatrix.defが無いというエラー</title>
      <link>/blog/2015/06/14/mecab-ipadic-matrix.def-missing/</link>
      <pubDate>Sun, 14 Jun 2015 16:40:05 +0900</pubDate>
      
      <guid>/blog/2015/06/14/mecab-ipadic-matrix.def-missing/</guid>
      <description>

&lt;h2 id=&#34;tl-dr:ab08cbd6b60f870d79d44f56fdfdead3&#34;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/taku910/mecab/tree/master/mecab-ipadic&#34;&gt;https://github.com/taku910/mecab/tree/master/mecab-ipadic&lt;/a&gt; を取得して
&lt;code&gt;./configure --with-charset=&amp;quot;utf-8&amp;quot;&lt;/code&gt; と実行したら
&lt;code&gt;configure: error: cannot find sources (matrix.def) in . or ..&lt;/code&gt; というエラーが出て困ってます。解決策を知っている方ぜひ教えてください。&lt;/p&gt;

&lt;h2 id=&#34;経緯と詳細な手順:ab08cbd6b60f870d79d44f56fdfdead3&#34;&gt;経緯と詳細な手順&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://sites.google.com/site/rmecab/&#34;&gt;rmecab&lt;/a&gt;をインストールしたくて、&lt;a href=&#34;http://rmecab.jp/wiki/index.php?RMeCab&#34;&gt;RMeCab - RとLinuxと&amp;hellip;&lt;/a&gt;に沿ってまずはMeCabをインストールしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/MeCab&#34;&gt;MeCab - Wikipedia&lt;/a&gt;によると公式サイトはsourceforge.netだったようですが、実際のページは&lt;a href=&#34;http://mecab.googlecode.com/svn/trunk/mecab/doc/index.html&#34;&gt;MeCab: Yet Another Part-of-Speech and Morphological Analyzer&lt;/a&gt;とgooglecodeにあり、ソースをダウンロードしようと探すと&lt;a href=&#34;https://code.google.com/hosting/moved?project=mecab&#34;&gt;Google Project Hosting&lt;/a&gt;とあり、githubに移ったようです。&lt;/p&gt;

&lt;p&gt;ということで&lt;a href=&#34;https://github.com/taku910/mecab&#34;&gt;taku910/mecab&lt;/a&gt;からソースを取得してビルドしてみました。確認した環境はOS X 10.10.3です。&lt;/p&gt;

&lt;p&gt;mecabのconfigureオプションは&lt;a href=&#34;http://rmecab.jp/wiki/index.php?RMeCab#content_1_2&#34;&gt;Mac OS X 版バイナリ のインストール方法&lt;/a&gt;の手順に合わせて &lt;code&gt;--with-charset=&amp;quot;utf8&amp;quot;&lt;/code&gt; をつけました。mecabは無事ビルド、インストール出来ました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/taku910/mecab
cd mecab
./configure --with-charset=&amp;quot;utf8&amp;quot;
make
make check
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次はmecab-ipadicをビルドしようとしたのですが、configureでエラーになりました。configureのオプションは上記のリンクの「c. 辞書もインストールします」の説明に合わせて &lt;code&gt;--with-charset=&amp;quot;utf-8&amp;quot;&lt;/code&gt; をつけています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ../mecab-ipadic
$ ./configure --with-charset=&amp;quot;utf-8&amp;quot;
configure: error: cannot find sources (matrix.def) in . or ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;matrix.defがどういうものか私は全く知らないのですが、mecab-jumandicにも同名のファイルがあったので、それを使ってビルドしてみたら通ることは通りました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ln -s ../mecab-jumandic/matrix.def
./configure --with-charset=&amp;quot;utf-8&amp;quot;
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、「すもももももももものうち」で試してみると「すもも」「も」の後の「もも」が正しく切り出せていません。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mecab
すもももももももものうち
すもも  名詞,一般,*,*,*,*,すもも,スモモ,スモモ
も  助詞,係助詞,*,*,*,*,も,モ,モ
も  助詞,係助詞,*,*,*,*,も,モ,モ
も  助詞,係助詞,*,*,*,*,も,モ,モ
も  助詞,係助詞,*,*,*,*,も,モ,モ
も  助詞,係助詞,*,*,*,*,も,モ,モ
もの  名詞,非自立,一般,*,*,*,もの,モノ,モノ
うち  名詞,非自立,副詞可能,*,*,*,うち,ウチ,ウチ
EOS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで、mecab-ipadicの正しいビルド方法をご存知のかたはぜひ教えてください！&lt;/p&gt;

&lt;p&gt;と書いてたら、イシュー立てるべきと気づいたので立てました。&lt;a href=&#34;https://github.com/taku910/mecab/issues/18&#34;&gt;mecab-ipadicでconfigure実行したらmatrix.defが無いというエラーが出る · Issue #18 · taku910/mecab&lt;/a&gt; ぜひそちらにコメントお願いします！&lt;/p&gt;

&lt;h2 id=&#34;2015-06-17追記:ab08cbd6b60f870d79d44f56fdfdead3&#34;&gt;2015-06-17追記&lt;/h2&gt;

&lt;p&gt;イシューにコメントを頂きました。
&lt;a href=&#34;https://github.com/taku910/mecab/issues/18#issuecomment-112474144&#34;&gt;https://github.com/taku910/mecab/issues/18#issuecomment-112474144&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;IPA辞書は &lt;a href=&#34;http://taku910.github.io/mecab/#download&#34;&gt;http://taku910.github.io/mecab/#download&lt;/a&gt;  からtarballをダウンロードするのが推奨とのことです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Homebrewを辞めてMacPorts 2.3.3を入れてpkgngをビルドしてみた</title>
      <link>/blog/2015/06/11/tried_macports/</link>
      <pubDate>Thu, 11 Jun 2015 01:09:08 +0900</pubDate>
      
      <guid>/blog/2015/06/11/tried_macports/</guid>
      <description>

&lt;h1 id=&#34;はじめに:ad84efa08756126882b8b191ef8a11ed&#34;&gt;はじめに&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/shibu_jp/status/598332736638582785&#34;&gt;https://twitter.com/shibu_jp/status/598332736638582785&lt;/a&gt; と &lt;a href=&#34;http://gihyo.jp/admin/serial/01/bsd-yomoyama/0002&#34;&gt;第2回　パッケージ管理システム「pkg 1.5」と基本的な使い方：BSD界隈四方山話｜gihyo.jp … 技術評論社&lt;/a&gt;で、実験段階ですがOS Xもサポート対象となったという話を見て &lt;code&gt;pkg&lt;/code&gt; と &lt;code&gt;MacPorts&lt;/code&gt; をシームレスに組み合わせて使えるかが気になっていました。&lt;/p&gt;

&lt;p&gt;FreeBSDではpkgコマンドでバイナリパッケージをインストールし、Ports Collectionでソースからビルドというのが簡単にできるようになっているのですが、上記の記事によるとpkgとPorts Collectionがシームレスに連動しているそうです。&lt;/p&gt;

&lt;p&gt;なので、OS X上では &lt;code&gt;pkg&lt;/code&gt; と &lt;code&gt;MacPorts&lt;/code&gt; が連動するのかな、するといいなあ、と思って、まずは &lt;code&gt;MacPorts&lt;/code&gt; を試してみます。&lt;/p&gt;

&lt;p&gt;私はだいぶ前に MacPorts から Homebrew に切り替えていたので、MacPortsは久々に試します。&lt;/p&gt;

&lt;h2 id=&#34;確認した環境:ad84efa08756126882b8b191ef8a11ed&#34;&gt;確認した環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;MacBook Pro (Retina, Mid 2012)&lt;/li&gt;
&lt;li&gt;OS X Yosemite 10.10.3&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;homebrewのアンインストール:ad84efa08756126882b8b191ef8a11ed&#34;&gt;Homebrewのアンインストール&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/UmedaTakefumi/items/dc52f008586cbf06582f&#34;&gt;Homebrewをアンインストールするには - Qiita&lt;/a&gt;を参考にといいつつ、いきなりバッサリ消すとなにかあったときに戻れないので、アンインストールはせずにHomebrewでインストールしたパッケージのサービスを停止して、/usr/localディレクトリを/usr/local.bakに退避しておくことにします。移行が無事完了したらアンインストールするということで。&lt;/p&gt;

&lt;p&gt;以下のコマンドを実行して~/Library/LaunchAgents/にシンボリックリンクを張ったサービスを停止・解除します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for f in ~/Library/LaunchAgents/homebrew.*; do launchctl unload $f; done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/usr/localを/usr/local.bakに退避します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mv /usr/local /usr/local.bak
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;macportsのインストール:ad84efa08756126882b8b191ef8a11ed&#34;&gt;MacPortsのインストール&lt;/h1&gt;

&lt;p&gt;MacPortsのバイナリパッケージをダウンロードしてインストールします。MacPorts-2.3.3-10.10-Yosemite.pkgをFinderでダブルクリックしてもいいのですが、将来スクリプトで自動化することを見据えて、OS Xの &lt;code&gt;installer&lt;/code&gt; コマンドでインストールしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/Downloads
curl -O https://distfiles.macports.org/MacPorts/MacPorts-2.3.3-10.10-Yosemite.pkg
sudo installer -pkg MacPorts-2.3.3-10.10-Yosemite.pkg -target /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://guide.macports.org/#installing.shell&#34;&gt;2.5.1. The Postflight Script&lt;/a&gt;の説明に従って、環境変数PATHとMANPATHの設定を追加します。以下はシェルはbashを使っていて~/.bash_profileに追加する場合の例です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt;&amp;gt; ~/.bash_profile
export PATH=/opt/local/bin:/opt/local/sbin:$PATH
export MANPATH=/opt/local/share/man:$MANPATH
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドを実行して、上で追加した設定を有効にします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exec $SHELL -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;portコマンドにPATHが通ったことを確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ which port
/opt/local/bin/port
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://www.macports.org/install.php#pkg&#34;&gt;Mac OS X Package (.pkg) Installer&lt;/a&gt;の説明に従って、MacPorts自体のアップデートを行います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo port -v selfupdate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出力の最後に以下のように表示されたので、既に最新版になっていたそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---&amp;gt;  MacPorts base is already the latest version

The ports tree has been updated. To upgrade your installed ports, you should run
  port upgrade outdated
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記の説明によるとインストールしたportsをアップグレードするときは &lt;code&gt;ports upgrade outdated&lt;/code&gt; と実行すればよいそうです。&lt;/p&gt;

&lt;h1 id=&#34;pkgngをソースからビルド:ad84efa08756126882b8b191ef8a11ed&#34;&gt;pkgngをソースからビルド&lt;/h1&gt;

&lt;p&gt;FreeBSDのpkgはpkgngと呼ばれることもあります。&lt;a href=&#34;https://wiki.freebsd.org/pkgng&#34;&gt;pkgng - FreeBSD Wiki&lt;/a&gt;によるとngはNext Generationの略のようです。&lt;/p&gt;

&lt;p&gt;githubにソースレポジトリ &lt;a href=&#34;https://github.com/freebsd/pkg&#34;&gt;freebsd/pkg&lt;/a&gt;があったので、ソースからビルドして入れてみます。&lt;/p&gt;

&lt;p&gt;ホームディレクトリ直下にpkgディレクトリを作るようにして入れてみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd
git clone https://github.com/freebsd/pkg
cd pkg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git tag&lt;/code&gt; で確認すると最新のリリースは 1.5.3 でしたので、それにしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout 1.5.3
git checkout -b 1.5.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/freebsd/pkg#building-pkg-using-sources-from-git&#34;&gt;freebsd/pkg&lt;/a&gt;を参考にやってみました。この手順ではビルドに必要なパッケージをFreeBSDにインストール済みの古いバージョンの &lt;code&gt;pkg&lt;/code&gt; コマンドで入れていますが、OS Xの場合は無いのでMacPortsで入れます。&lt;/p&gt;

&lt;p&gt;また &lt;code&gt;pkgconf&lt;/code&gt; はMacPortsでは &lt;code&gt;pkgconfig&lt;/code&gt; という名前なのでそこも変えています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo port install autoconf automake libtool pkgconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;./autogen.sh
./configure
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;./configure&lt;/code&gt; が以下のようにエラーになってしまいました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;…(略)…
checking for library containing archive_read_open... -larchive
checking archive.h usability... no
checking archive.h presence... no
checking for archive.h... no
configure: error: Unable to find the libarchive headers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そこでlibarchiveをMacPortsでインストールしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo port install libarchive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MacPortsでインストールしたパッケージを見つけてもらうため、&lt;a href=&#34;http://blog.francoismaillet.com/compile-against-libraries-installed-with-macports/&#34;&gt;Compile against libraries installed with MacPorts | Blog de François Maillet&lt;/a&gt;を参考に以下のようにオプションをつけて &lt;code&gt;./configure&lt;/code&gt; を再度実行しました。pkgのsrcディレクトリを見ると、pkgはC++ではなくCで実装されていますので、 &lt;code&gt;configure&lt;/code&gt; の引数もCPPFLAGSではなくCFLAGSにしています。
今度は &lt;code&gt;configure&lt;/code&gt; が成功しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure CFLAGS=&amp;quot;-I/opt/local/include&amp;quot; LDFLAGS=&amp;quot;-L/opt/local/lib&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;configure&lt;/code&gt; の次は &lt;code&gt;make&lt;/code&gt; を実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1つ警告が出ました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;…(略)…
  CCLD     pkg-static
libtool: warning: complete static linking is impossible in this configuration
  CCLD     pkg
…(略)…
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;./configure --help&lt;/code&gt; してみると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  --with-staticonly       Only build the static version (default is no)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というオプションがあり、デフォルトではスタティックリンクするバージョンとしないバージョンの両方を作るようになっているようです。&lt;/p&gt;

&lt;p&gt;とりあえずスタティックリンクしないバージョンはビルドできているのでとりあえず先に進みます。&lt;/p&gt;

&lt;p&gt;以下のコマンドを実行してインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/usr/localに以下のようなファイルとディレクトリが作られました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find /usr/local
/usr/local
/usr/local/etc
/usr/local/etc/bash_completion.d
/usr/local/etc/bash_completion.d/_pkg.bash
/usr/local/etc/periodic
/usr/local/etc/periodic/daily
/usr/local/etc/periodic/daily/411.pkg-backup
/usr/local/etc/periodic/daily/490.status-pkg-changes
/usr/local/etc/periodic/security
/usr/local/etc/periodic/security/410.pkg-audit
/usr/local/etc/periodic/security/460.pkg-checksum
/usr/local/etc/periodic/weekly
/usr/local/etc/periodic/weekly/400.status-pkg
/usr/local/etc/pkg.conf.sample
/usr/local/include
/usr/local/include/pkg.h
/usr/local/lib
/usr/local/lib/libpkg.3.dylib
/usr/local/lib/libpkg.dylib
/usr/local/lib/libpkg.la
/usr/local/lib/libpkg_static.a
/usr/local/lib/libpkg_static.la
/usr/local/libdata
/usr/local/libdata/pkgconfig
/usr/local/libdata/pkgconfig/pkg.pc
/usr/local/man
/usr/local/man/man3
/usr/local/man/man3/pkg_printf.3
/usr/local/man/man3/pkg_repos.3
/usr/local/man/man5
/usr/local/man/man5/pkg-repository.5
/usr/local/man/man5/pkg.conf.5
/usr/local/man/man8
/usr/local/man/man8/pkg-add.8
/usr/local/man/man8/pkg-alias.8
/usr/local/man/man8/pkg-annotate.8
/usr/local/man/man8/pkg-audit.8
/usr/local/man/man8/pkg-autoremove.8
/usr/local/man/man8/pkg-backup.8
/usr/local/man/man8/pkg-check.8
/usr/local/man/man8/pkg-clean.8
/usr/local/man/man8/pkg-config.8
/usr/local/man/man8/pkg-convert.8
/usr/local/man/man8/pkg-create.8
/usr/local/man/man8/pkg-delete.8
/usr/local/man/man8/pkg-fetch.8
/usr/local/man/man8/pkg-info.8
/usr/local/man/man8/pkg-install.8
/usr/local/man/man8/pkg-lock.8
/usr/local/man/man8/pkg-query.8
/usr/local/man/man8/pkg-register.8
/usr/local/man/man8/pkg-remove.8
/usr/local/man/man8/pkg-repo.8
/usr/local/man/man8/pkg-rquery.8
/usr/local/man/man8/pkg-search.8
/usr/local/man/man8/pkg-set.8
/usr/local/man/man8/pkg-shell.8
/usr/local/man/man8/pkg-shlib.8
/usr/local/man/man8/pkg-ssh.8
/usr/local/man/man8/pkg-static.8
/usr/local/man/man8/pkg-stats.8
/usr/local/man/man8/pkg-unlock.8
/usr/local/man/man8/pkg-update.8
/usr/local/man/man8/pkg-updating.8
/usr/local/man/man8/pkg-upgrade.8
/usr/local/man/man8/pkg-version.8
/usr/local/man/man8/pkg-which.8
/usr/local/man/man8/pkg.8
/usr/local/sbin
/usr/local/sbin/pkg
/usr/local/sbin/pkg-static
/usr/local/sbin/pkg2ng
/usr/local/share
/usr/local/share/zsh
/usr/local/share/zsh/site-functions
/usr/local/share/zsh/site-functions/_pkg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pkgコマンドとpkg-staticコマンドは/usr/local/sbinにインストールされていました。
&lt;code&gt;otool -L&lt;/code&gt; で確認すると両方ともダイナミックリンクになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ otool -L /usr/local/sbin/pkg
/usr/local/sbin/pkg:
        /usr/local/lib/libpkg.3.dylib (compatibility version 4.0.0, current version 4.0.0)
        /opt/local/lib/libssl.1.0.0.dylib (compatibility version 1.0.0, current version 1.0.0)
        /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1213.0.0)
        /usr/lib/libutil.dylib (compatibility version 1.0.0, current version 1.0.0)
        /opt/local/lib/libcrypto.1.0.0.dylib (compatibility version 1.0.0, current version 1.0.0)
        /usr/lib/libresolv.9.dylib (compatibility version 1.0.0, current version 1.0.0)
        /opt/local/lib/libarchive.13.dylib (compatibility version 15.0.0, current version 15.2.0)
        /opt/local/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.8)
        /opt/local/lib/libbz2.1.0.dylib (compatibility version 1.0.0, current version 1.0.6)
        /opt/local/lib/liblzma.5.dylib (compatibility version 8.0.0, current version 8.1.0)
$ otool -L /usr/local/sbin/pkg-static
/usr/local/sbin/pkg-static:
        /usr/lib/libutil.dylib (compatibility version 1.0.0, current version 1.0.0)
        /opt/local/lib/libssl.1.0.0.dylib (compatibility version 1.0.0, current version 1.0.0)
        /opt/local/lib/libcrypto.1.0.0.dylib (compatibility version 1.0.0, current version 1.0.0)
        /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1213.0.0)
        /usr/lib/libresolv.9.dylib (compatibility version 1.0.0, current version 1.0.0)
        /opt/local/lib/libarchive.13.dylib (compatibility version 15.0.0, current version 15.2.0)
        /opt/local/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.8)
        /opt/local/lib/libbz2.1.0.dylib (compatibility version 1.0.0, current version 1.0.6)
        /opt/local/lib/liblzma.5.dylib (compatibility version 8.0.0, current version 8.1.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/usr/local/sbinにはPATHが通っていなかったので、設定を変更して有効にしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &#39;export PATH=/usr/local/sbin:$PATH&#39; &amp;gt;&amp;gt; ~/.bash_profile
exec $SHELL -l
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ which pkg
/usr/local/sbin/pkg
$ pkg --version
1.5.3-cfa5423
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というわけでビルドは出来ました。が OS X用のバイナリパッケージレポジトリの情報は見つけられず。&lt;/p&gt;

&lt;p&gt;pkgコマンドの使い方については&lt;a href=&#34;https://github.com/freebsd/pkg#a-quick-usage-introduction-to-pkg&#34;&gt;freebsd/pkg&lt;/a&gt;のREADMEに&lt;a href=&#34;https://github.com/freebsd/pkg#a-quick-usage-introduction-to-pkg&#34;&gt;A quick usage introduction to pkg&lt;/a&gt;というセクションがありました。&lt;/p&gt;

&lt;h1 id=&#34;情報収集中:ad84efa08756126882b8b191ef8a11ed&#34;&gt;情報収集中&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://news.ycombinator.com/item?id=8828866&#34;&gt;Baseline Mac OS X Support merged into FreeBSD package manager | Hacker News&lt;/a&gt;にいくつか有用な情報がありました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://news.ycombinator.com/item?id=8829040&#34;&gt;This change was written by Landon Fuller, one of the founders of MacPorts. There&amp;hellip; | Hacker News&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;pkgngをOS X対応にするプルリクエスト &lt;a href=&#34;https://github.com/freebsd/pkg/pull/1113&#34;&gt;Baseline Mac OS X Support by landonf · Pull Request #1113 · freebsd/pkg&lt;/a&gt;はMacPorts創始者の1人によるもので、&lt;a href=&#34;https://github.com/freebsd/pkg/pull/1113#issuecomment-68063964&#34;&gt;Baseline Mac OS X Support by landonf · Pull Request #1113 · freebsd/pkg&lt;/a&gt;のコメントによるとMacPortsのtclで書いている部分をlibpkgを使って書き直すことが出来るかを模索するつもりらしいです。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://news.ycombinator.com/item?id=8829179&#34;&gt;You can already have that with pkgsrc for osx - joyent maintains the osx binary &amp;hellip; | Hacker News&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;このスレッドによるとpkgngがOS X対応する前から&lt;a href=&#34;http://pkgsrc.joyent.com/&#34;&gt;pkgsrc&lt;/a&gt;というパッケージ管理システムがあるそうです。Node.jsのJoyent, Inc.が作ってるんですね。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.saveosx.org/&#34;&gt;saveosx&lt;/a&gt;にYosemite 64bit用のバイナリパッケージがあるようです。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということで、今後どうなっていくか要注目です。&lt;/p&gt;

&lt;h1 id=&#34;2015-06-13追記-pkgsrcについて訂正:ad84efa08756126882b8b191ef8a11ed&#34;&gt;2015-06-13追記 pkgsrcについて訂正&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.pkgsrc.org/&#34;&gt;pkgsrc&lt;/a&gt;自体はFreeBSDのportsからフォークしてNetBSDで開発されているもので、Joyent, Inc.が提供しているのはSmartOS/illumos, Mac OS X, and Linux用のバイナリバッケージでした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://pkgsrc.joyent.com/&#34;&gt;pkgsrc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Pkgsrc&#34;&gt;pkgsrc - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また &lt;a href=&#34;http://www.saveosx.org/&#34;&gt;saveosx&lt;/a&gt;は&lt;a href=&#34;https://github.com/cmacrae/saveosx&#34;&gt;cmacrae/saveosx&lt;/a&gt;を見るとOS X用のpkgsrcをインストールするためのスクリプトでした。パッケージ自体はJoyentが提供しているそうです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>xhyveを試してみました</title>
      <link>/blog/2015/06/11/tried_xhyve/</link>
      <pubDate>Thu, 11 Jun 2015 00:45:38 +0900</pubDate>
      
      <guid>/blog/2015/06/11/tried_xhyve/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.pagetable.com/?p=831&#34;&gt;xhyve – Lightweight Virtualization on OS X Based on bhyve | pagetable.com&lt;/a&gt;に沿って試してみました。&lt;/p&gt;

&lt;h2 id=&#34;確認した環境:dcbb8845ff06345c06bbfce39966bf55&#34;&gt;確認した環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;MacBook Pro (Retina, Mid 2012)&lt;/li&gt;
&lt;li&gt;OS X Yosemite 10.10.3&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ソースからビルド:dcbb8845ff06345c06bbfce39966bf55&#34;&gt;ソースからビルド&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;cd お好みの作業ディレクトリ
git clone https://github.com/mist64/xhyve
cd xhyve
make
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tiny-core-linuxを起動:dcbb8845ff06345c06bbfce39966bf55&#34;&gt;Tiny Core Linuxを起動&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;./xhyverun.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動メッセージが流れた後、画面がクリアされて以下のように表示されたら起動完了です。ここまで3〜4秒です。速い！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(�-
 //\   Core is distributed with ABSOLUTELY NO WARRANTY.
 v_/_           www.tinycorelinux.com

tc@box:~$ Switched to clocksource tsc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プロンプトにかぶってメッセージが出ていますが、enterを押せばプロンプトが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tc@box:~$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;シャットダウンするには以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo halt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu-server-14-04-2のディスクイメージ作成:dcbb8845ff06345c06bbfce39966bf55&#34;&gt;Ubuntu Server 14.04.2のディスクイメージ作成&lt;/h2&gt;

&lt;p&gt;Ubuntu ServerのISOイメージをダウンロードして、ディスクイメージを作成するための準備を行います。元記事によると、OS Xがハイブリッドファイルシステムを認識しないので、Linux kernelとinitrdを取り出しているそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir ubuntu
cd ubuntu
curl -O ftp://ftp.kddilabs.jp/Linux/packages/ubuntu/releases-cd/14.04.2/ubuntu-14.04.2-server-amd64.iso
dd if=/dev/zero bs=2k count=1 of=/tmp/tmp.iso
dd if=ubuntu-14.04.2-server-amd64.iso bs=2k skip=1 &amp;gt;&amp;gt; /tmp/tmp.iso
hdiutil attach /tmp/tmp.iso
cp /Volumes/Ubuntu-Server\ 14/install/vmlinuz .
cp /Volumes/Ubuntu-Server\ 14/install/initrd.gz .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドでディスクイメージを作成します。ここでは &lt;code&gt;bs=1g count=8&lt;/code&gt; でディスクサイズを8GBとしていますが、お好みで調整してください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dd if=/dev/zero of=hdd.img bs=1g count=8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;xhyve/ubuntuディレクトリではなくxhyveディレクトリにディスクイメージ作成用のスクリプトを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ..
cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; xhyverun_ubuntu_install.sh
#!/bin/sh

KERNEL=&amp;quot;ubuntu/vmlinuz&amp;quot;
INITRD=&amp;quot;ubuntu/initrd.gz&amp;quot;
CMDLINE=&amp;quot;earlyprintk=serial console=ttyS0 acpi=off&amp;quot;

MEM=&amp;quot;-m 1G&amp;quot;
#SMP=&amp;quot;-c 2&amp;quot;
NET=&amp;quot;-s 2:0,virtio-net&amp;quot;
IMG_CD=&amp;quot;-s 3,ahci-cd,ubuntu/ubuntu-14.04.2-server-amd64.iso&amp;quot;
IMG_HDD=&amp;quot;-s 4,virtio-blk,ubuntu/hdd.img&amp;quot;
PCI_DEV=&amp;quot;-s 0:0,hostbridge -s 31,lpc&amp;quot;
LPC_DEV=&amp;quot;-l com1,stdio&amp;quot;

build/xhyve $MEM $SMP $PCI_DEV $LPC_DEV $NET $IMG_CD $IMG_HDD -f kexec,$KERNEL,$INITRD,&amp;quot;$CMDLINE&amp;quot;
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スクリプトに実行パーミションをつけてsudo付きで実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod +x xhyverun_ubuntu_install.sh
sudo ./xhyverun_ubuntu_install.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テキストインストーラが起動しますので、以下のように選択してインストールしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Select a language: English&lt;/li&gt;
&lt;li&gt;Select your location: other -&amp;gt; Asia -&amp;gt; Japan&lt;/li&gt;
&lt;li&gt;Configure locales: United Status - en_US.UTF-8&lt;/li&gt;
&lt;li&gt;Hostname: お好みの名前&lt;/li&gt;
&lt;li&gt;Set up users and passwords: お好みのIDとパスワードで作成&lt;/li&gt;
&lt;li&gt;time zone: Asia/Tokyo&lt;/li&gt;
&lt;li&gt;Partition disks: Guided - use entire disk&lt;/li&gt;
&lt;li&gt;HTTP proxy: 無し&lt;/li&gt;
&lt;li&gt;manage upgrades: No automatic updates&lt;/li&gt;
&lt;li&gt;Software selection:

&lt;ul&gt;
&lt;li&gt;Basic Ubuntu Server&lt;/li&gt;
&lt;li&gt;OpenSSH server&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Install GRUB to the master boot record: Yes&lt;/li&gt;
&lt;li&gt;Is the system clock set to UTC: No&lt;/li&gt;
&lt;li&gt;Installation complete: Go Back -&amp;gt; Execute a shell&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Installation completeのところでContinueではなくGo Backでメニューに戻りExecute a shellを選んで進み、シェルが起動したら以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /target
sbin/ifconfig
tar c boot | nc -l -p 1234
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記のコマンド実行のうちsbin/ifconfigで表示されたIPアドレスをメモしておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/target # sbin/ifconfig
eth0      Link encap:Ethernet  HWaddr e6:0d:f2:6b:cf:32
          inet addr:192.168.64.3  Bcast:192.168.64.255  Mask:255.255.255.0
          inet6 addr: fe80::e40d:f2ff:fe6b:cf32/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:25405 errors:0 dropped:0 overruns:0 frame:85
          TX packets:13601 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:38179647 (38.1 MB)  TX bytes:931189 (931.1 KB)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mac側では以下のコマンドを実行します。IPアドレスはifconfigで表示されたものに置き換えて実行してください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ubuntu
nc 192.168.64.3 1234 | tar x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;VMのシェルのプロンプトで以下のように入力してシェルを終了します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メニューに戻ったら &lt;code&gt;Finish the installation&lt;/code&gt; を選びます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Is the system clock set to UTC?: No&lt;/li&gt;
&lt;li&gt;Installation complete: Continue&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ubuntu-server-14-04-2の起動:dcbb8845ff06345c06bbfce39966bf55&#34;&gt;Ubuntu Server 14.04.2の起動&lt;/h2&gt;

&lt;p&gt;Macでxhyve/ubuntuではなくxhyveのディレクトリで起動用のスクリプトを作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt;&#39;EOF&#39; &amp;gt; ./xhyverun_ubuntu.sh
#!/bin/sh

KERNEL=&amp;quot;ubuntu/boot/vmlinuz-3.16.0-30-generic&amp;quot;
INITRD=&amp;quot;ubuntu/boot/initrd.img-3.16.0-30-generic&amp;quot;
CMDLINE=&amp;quot;earlyprintk=serial console=ttyS0 acpi=off root=/dev/vda1 ro&amp;quot;

MEM=&amp;quot;-m 1G&amp;quot;
#SMP=&amp;quot;-c 2&amp;quot;
NET=&amp;quot;-s 2:0,virtio-net&amp;quot;
IMG_HDD=&amp;quot;-s 4,virtio-blk,ubuntu/hdd.img&amp;quot;
PCI_DEV=&amp;quot;-s 0:0,hostbridge -s 31,lpc&amp;quot;
LPC_DEV=&amp;quot;-l com1,stdio&amp;quot;

build/xhyve $MEM $SMP $PCI_DEV $LPC_DEV $NET $IMG_CD $IMG_HDD -f kexec,$KERNEL,$INITRD,&amp;quot;$CMDLINE&amp;quot;
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スクリプトに実行パーミションをつけてsudo付きで実行してUbuntuを起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod +x ./xhyverun_ubuntu.sh
sudo ./xhyverun_ubuntu.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動してログインプロンプトが出たらインストール時に作成したユーザでログインします。IPアドレスはDHCPで取得する設定にしたのですが、確認してみると、ディスクイメージ作成時とは違う値になっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ip a s eth0
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 62:ca:c1:25:cf:32 brd ff:ff:ff:ff:ff:ff
    inet 192.168.64.4/24 brd 192.168.64.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::60ca:c1ff:fe25:cf32/64 scope link
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Macからsshでログインも出来ました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh ubuntu@192.168.64.4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sshでログインすると初回だけ表示が24行に限定され、リターンを押しても24行の範囲でスクロールされるようになってしまいました。Mac側ではiTermで65行にしていました。と、この説明を書くためにiTermのウィンドウで高さを変えて行数を変えて戻してとやっていたら、次のsshログインからはiTermの行数で表示されるようになりました。&lt;/p&gt;

&lt;p&gt;Ubuntuを停止するにはVM内で以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo shutdown -h now
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntuの起動に必要なファイル:dcbb8845ff06345c06bbfce39966bf55&#34;&gt;Ubuntuの起動に必要なファイル&lt;/h2&gt;

&lt;p&gt;ubuntuフォルダにはビルドに使用したファイルも含まれていますが、起動スクリプトで参照されているファイル以外のファイルを別ディレクトリに移動して起動してみたら起動出来ました。ということで、起動には以下の4つのファイルだけあればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./xhyverun_ubuntu.sh
ubuntu/boot/initrd.img-3.16.0-30-generic
ubuntu/boot/vmlinuz-3.16.0-30-generic
ubuntu/hdd.img
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ:dcbb8845ff06345c06bbfce39966bf55&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;xhyveをソースからビルドして、Tiny Core LinuxとUbuntu Server 14.04.2を動かしてみました。&lt;a href=&#34;https://github.com/mist64/xhyve#todo&#34;&gt;TODO&lt;/a&gt;によると、まだいろいろ対応予定の項目があるようです。今後が楽しみです！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go言語用のメモリマップトファイルのライブラリを探してみた</title>
      <link>/blog/2015/06/03/go_mmap_libraries/</link>
      <pubDate>Wed, 03 Jun 2015 06:29:01 +0900</pubDate>
      
      <guid>/blog/2015/06/03/go_mmap_libraries/</guid>
      <description>

&lt;p&gt;ふとGo言語でメモリマップトファイルを扱えるライブラリってあるのかなと気になったので探してみました。&lt;/p&gt;

&lt;h2 id=&#34;標準ライブラリ:b86aa234eea6d3f9f1ee4426bc5adf77&#34;&gt;標準ライブラリ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/&#34;&gt;Goのホームページ&lt;/a&gt;で&lt;a href=&#34;http://golang.org/search?q=mmap&#34;&gt;mmapで検索してみる&lt;/a&gt;とUnix系では実装があるみたいです。&lt;/p&gt;

&lt;p&gt;Did you mean: &lt;a href=&#34;http://golang.org/search?q=Mmap&#34;&gt;Mmap&lt;/a&gt; と表示されているのでクリックしてみるとsyscallパッケージに&lt;a href=&#34;http://golang.org/pkg/syscall/#Mmap&#34;&gt;Mmap&lt;/a&gt;があることがわかりました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/search?q=Munmap&#34;&gt;Munmapで検索してみる&lt;/a&gt;とこちらはMmapよりは実装されているOSが少ないです。syscallパッケージに&lt;a href=&#34;http://golang.org/pkg/syscall/#Munmap&#34;&gt;Mummap&lt;/a&gt;もあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/search?q=Msync&#34;&gt;Msyncで検索してみる&lt;/a&gt;と5件ヒットしますが、未実装となっていました。&lt;/p&gt;

&lt;p&gt;また、syscallパッケージにMmapとMunmapがあるといっても、Windowsでは実装されていません。&lt;/p&gt;

&lt;h2 id=&#34;github-com-edsrzf-mmap-go:b86aa234eea6d3f9f1ee4426bc5adf77&#34;&gt;github.com/edsrzf/mmap-go&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ソース: &lt;a href=&#34;https://github.com/edsrzf/mmap-go&#34;&gt;edsrzf/mmap-go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GoDoc:  &lt;a href=&#34;https://godoc.org/github.com/edsrzf/mmap-go&#34;&gt;mmap - GoDoc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ライセンス: 3項BSD&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/edsrzf/mmap-go&#34;&gt;README&lt;/a&gt;によるとポータブルなAPIで、Linux (386, amd64), OS X, Windows (386)でテスト済みとのことです。&lt;/p&gt;

&lt;p&gt;mprotect, mincoreなどはサポートしていないのでそういうUnix特有の機能を使いたい場合はGustavo Niemeyerさんの&lt;a href=&#34;http://labix.org/gommap&#34;&gt;gommap&lt;/a&gt;がおすすめとのことです。&lt;/p&gt;

&lt;h2 id=&#34;github-com-tysontate-gommap:b86aa234eea6d3f9f1ee4426bc5adf77&#34;&gt;github.com/tysontate/gommap&lt;/h2&gt;

&lt;p&gt;Gustavo Niemeyerさんの&lt;a href=&#34;http://labix.org/gommap&#34;&gt;gommap&lt;/a&gt;はプロジェクトがlaunchpat.netにホスティングされているので、github.comにミラーリングされていないかなと調べると&lt;a href=&#34;https://github.com/tysontate/gommap&#34;&gt;tysontate/gommap&lt;/a&gt;がありました。&lt;/p&gt;

&lt;p&gt;READMEによるとOS X用のパッチも適用済みとのことです。 &lt;code&gt;mmap_*.go&lt;/code&gt; のファイル名から判断すると対応OSはLinux (386, amd64), OS Xのようです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:b86aa234eea6d3f9f1ee4426bc5adf77&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/edsrzf/mmap-go&#34;&gt;edsrzf/mmap-go&lt;/a&gt;の機能で足りる場合はそちらを、Unix限定になってもいいからmprotectとかを使いたい場合は&lt;a href=&#34;https://github.com/tysontate/gommap&#34;&gt;tysontate/gommap&lt;/a&gt;を使うのがよさそうです。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>