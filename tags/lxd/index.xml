<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lxd on hnakamur&#39;s blog at github</title>
    <link>https://hnakamur.github.io/blog/tags/lxd/index.xml</link>
    <description>Recent content in Lxd on hnakamur&#39;s blog at github</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <atom:link href="https://hnakamur.github.io/blog/tags/lxd/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LXD で privileged な CentOS 7コンテナを作る</title>
      <link>https://hnakamur.github.io/blog/2016/10/22/lxd-privileged-centos-container/</link>
      <pubDate>Sat, 22 Oct 2016 18:54:49 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2016/10/22/lxd-privileged-centos-container/</guid>
      <description>

&lt;p&gt;小ネタのメモです。&lt;/p&gt;

&lt;p&gt;先日 LXD 2.0.5 で CentOS 7 コンテナを起動して &lt;code&gt;journalctl -xe&lt;/code&gt; を実行すると以下のようなエラーが出ていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Oct 22 09:53:58 centos systemd-sysctl[36]: Failed to write &#39;16&#39; to &#39;/proc/sys/kernel/sysrq&#39;: Permission denied
Oct 22 09:53:58 centos systemd-sysctl[36]: Failed to write &#39;1&#39; to &#39;/proc/sys/fs/protected_hardlinks&#39;: Permission denied
Oct 22 09:53:58 centos systemd-sysctl[36]: Failed to write &#39;1&#39; to &#39;/proc/sys/kernel/core_uses_pid&#39;: Permission denied
Oct 22 09:53:58 centos systemd-sysctl[36]: Failed to write &#39;1&#39; to &#39;/proc/sys/fs/protected_symlinks&#39;: Permission denied
Oct 22 09:53:58 centos systemd-remount-fs[35]: /bin/mount for / exited with exit status 32.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナ作成時に以下のように config で &lt;code&gt;security.privileged&lt;/code&gt; を true に設定しておけば出なくなりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc launch -c security.privileged=true images:centos/7/amd64 コンテナ名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;設定の確認は以下のコマンドで行います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc config show コンテナ名
name: centos
profiles:
- default
config:
  security.privileged: &amp;quot;true&amp;quot;
  volatile.base_image: d2a0b3cf928778ad1582ee1feb39a0bbcd57edce01a60868f04e78d959886d71
  volatile.eth0.hwaddr: 00:16:3e:b2:dc:5e
  volatile.last_state.idmap: &#39;[]&#39;
devices:
  root:
    path: /
    type: disk
ephemeral: false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もっと限定した設定でも対応可能かもしれませんが、とりあえずこれで。&lt;/p&gt;

&lt;h2 id=&#34;2016-10-23-追記&#34;&gt;2016-10-23 追記&lt;/h2&gt;

&lt;p&gt;security.privileged を true にするのは良くないと指摘されました。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/hnakamur2&#34;&gt;@hnakamur2&lt;/a&gt; Don&amp;#39;t do that! This errors are actually bugs ( see &lt;a href=&#34;https://t.co/5IuFQzMI9u&#34;&gt;https://t.co/5IuFQzMI9u&lt;/a&gt; + &lt;a href=&#34;https://t.co/4ypMXS5FTq&#34;&gt;https://t.co/4ypMXS5FTq&lt;/a&gt; ), so report them to CentOS&lt;/p&gt;&amp;mdash; Marqin (@mrMarqin) &lt;a href=&#34;https://twitter.com/mrMarqin/status/789838146083098625&#34;&gt;October 22, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;CentOS にバグ報告というのはよくわからなかったので、LXDにイシューを立ててみました。
&lt;a href=&#34;https://github.com/lxc/lxd/issues/2544&#34;&gt;CentOS 7 container gets errors like systemd-sysctl[36]: Failed to write &amp;lsquo;16&amp;rsquo; to &amp;lsquo;/proc/sys/kernel/sysrq&amp;rsquo;: Permission denied · Issue #2544 · lxc/lxd&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pacemakerを使ってPostgreSQLのアクティブ・スタンバイ(1&#43;1構成)を試してみた</title>
      <link>https://hnakamur.github.io/blog/2016/08/21/experiment-postgresql-active-standby-cluster-using-pacemaker/</link>
      <pubDate>Sun, 21 Aug 2016 11:23:01 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2016/08/21/experiment-postgresql-active-standby-cluster-using-pacemaker/</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;STONITH無し、quorum無しのアクティブ・スタンバイ(1+1構成)がとりあえず動くところまでは来たので、一旦メモです。&lt;/p&gt;

&lt;h2 id=&#34;参考資料&#34;&gt;参考資料&lt;/h2&gt;

&lt;p&gt;以下の資料と連載記事がわかりやすくて非常に参考になりました。ありがとうございます！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://linux-ha.osdn.jp/wp/archives/3244&#34;&gt;JPUG 第23回しくみ+アプリケーション勉強会 セミナー資料公開 « Linux-HA Japan&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://linux-ha.osdn.jp/wp/wp-content/uploads/pacemaker_20120526JPUG.pdf&#34;&gt;HAクラスタでPostgreSQLを高可用化(前編) ～Pacemaker入門編～(PDF)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://linux-ha.osdn.jp/wp/wp-content/uploads/b754c737d835c2546415009387407b7b.pdf&#34;&gt;PostgreSQLを高可用化(後編) 〜レプリケーション編〜(PDF)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://linux-ha.osdn.jp/wp/archives/3589&#34;&gt;OSC 2013 Tokyo/Spring 講演資料公開 « Linux-HA Japan&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/takmatsuo/osc-tokyospring2013-16694861&#34;&gt;Pacemaker+PostgreSQLレプリケーションで共有ディスクレス高信頼クラスタの構築＠OSC 2013 Tokyo/Spring&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gihyo.jp/admin/serial/01/pacemaker&#34;&gt;Pacemakerでかんたんクラスタリング体験してみよう！：連載｜gihyo.jp … 技術評論社&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さらに以下の記事と電子書籍も参考にしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://clusterlabs.org/wiki/PgSQL_Replicated_Cluster&#34;&gt;PgSQL Replicated Cluster - ClusterLabs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://shop.oreilly.com/product/9781783550609.do&#34;&gt;PostgreSQL Replication, 2nd Edition - O&amp;rsquo;Reilly Media&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;テスト用のansible-playbook&#34;&gt;テスト用のAnsible playbook&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/postgresql-pacemaker-example-playbook&#34;&gt;https://github.com/hnakamur/postgresql-pacemaker-example-playbook&lt;/a&gt;
に置きました。&lt;/p&gt;

&lt;p&gt;LXD をセットアップ済みの Ubuntu 16.04 上で試しました。&lt;/p&gt;

&lt;h2 id=&#34;セットアップの事前準備&#34;&gt;セットアップの事前準備&lt;/h2&gt;

&lt;p&gt;上記のplaybookを取得します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/hnakamur/postgresql-pacemaker-example-playbook
cd postgresql-pacemaker-example-playbook
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ansibleの &lt;code&gt;lxd_container&lt;/code&gt; モジュールを使うので、virtualenvで仮想環境を作ってAnsibleのmaster版をインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virtualenv venv
source venv/bin/activate
pip install git+https://github.com/ansible/ansible
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回はコンテナのIPアドレスをDHCPではなく静的アドレスを使うようにしてみました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; の &lt;code&gt;LXD_IPV4_DHCP_RANGE&lt;/code&gt; に DHCP のアドレス範囲が設定されているので、ファイルを編集して範囲を狭めます。私の環境では以下のようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## IPv4 network (e.g. 10.0.8.0/24)
LXD_IPV4_NETWORK=&amp;quot;10.155.92.1/24&amp;quot;

## IPv4 DHCP range (e.g. 10.0.8.2,10.0.8.254)
LXD_IPV4_DHCP_RANGE=&amp;quot;10.155.92.200,10.155.92.254&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LXDをインストールしたときに &lt;code&gt;LXD_IPV4_NETWORK&lt;/code&gt; はランダムなアドレスになるかあるいは自分で指定しますので、それに応じた値に適宜変更してください。&lt;/p&gt;

&lt;p&gt;変更したら &lt;code&gt;lxd-bridge&lt;/code&gt; を再起動して変更を反映します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl restart lxd-bridge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;group_vars/development/vars.yml&lt;/code&gt; ファイル内のIPアドレスも適宜変更します。&lt;/p&gt;

&lt;p&gt;また、 &lt;code&gt;group_vars/development/secrets.yml&lt;/code&gt; 内にパスワードやsshの鍵ペアなどが含まれています。これを違う値に変更したい場合は以下のようにします。&lt;/p&gt;

&lt;p&gt;まず、以下のコマンドを実行して一旦復号化します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ansible-vault decrypt group_vars/development/secrets.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;vaultのパスワードを聞かれますので入力します。この例では &lt;code&gt;password&lt;/code&gt; としています。これはあくまで例なのでこういう弱いパスワードにしていますが、実際の案件で使うときは、もっと強いパスワードを指定してください。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;group_vars/development/secrets.yml&lt;/code&gt; 内の変数を適宜変更したら、以下のコマンドを実行して暗号化します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ansible-vault encrypt group_vars/development/secrets.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;vaultの新しいパスワードを聞かれますので入力してください。&lt;/p&gt;

&lt;h2 id=&#34;コンテナの作成&#34;&gt;コンテナの作成&lt;/h2&gt;

&lt;p&gt;以下のコマンドを実行して &lt;code&gt;node1&lt;/code&gt; と &lt;code&gt;node2&lt;/code&gt; という2つのコンテナを作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ansible-playbook launch_containers.yml -D -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;vaultのパスワードを聞かれますので入力してください。&lt;/p&gt;

&lt;h2 id=&#34;コンテナ内にpostgresqlとpacemakerをセットアップ&#34;&gt;コンテナ内にPostgreSQLとPacemakerをセットアップ&lt;/h2&gt;

&lt;p&gt;以下のコマンドを実行して、コンテナ内にPostgreSQLとPacemakerをセットアップします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ansible-playbook setup_containers.yml -D -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは、セットアップ完了後、アクティブスタンバイ構成が開始するまでの時間を図りたいので、以下のように &lt;code&gt;date -u&lt;/code&gt; コマンドも実行するようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ansible-playbook setup_containers.yml -D -v; date -u
…(略)…
Sun Aug 21 13:51:21 UTC 2016
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドを実行して &lt;code&gt;node2&lt;/code&gt; コンテナに入ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc exec node2 bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドを実行して、クラスタの状態をモニターします。
&lt;code&gt;node1&lt;/code&gt;, &lt;code&gt;node2&lt;/code&gt; が両方 Slaves の状態を経て、 &lt;code&gt;node1&lt;/code&gt; が Master になり master-ip が &lt;code&gt;node1&lt;/code&gt; につくまで待ちます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Last updated: Sun Aug 21 13:52:07 2016          Last change: Sun Aug 21 13:52:03 2016 by root via crm_attribute on node1
Stack: corosync
Current DC: node1 (version 1.1.13-10.el7_2.4-44eb2dd) - partition with quorum
2 nodes and 3 resources configured

Online: [ node1 node2 ]

 Master/Slave Set: pgsql-master [pgsql]
     Masters: [ node1 ]
     Slaves: [ node2 ]
master-ip       (ocf::heartbeat:IPaddr2):       Started node1

Node Attributes:
* Node node1:
    + master-pgsql                      : 1000
    + pgsql-data-status                 : LATEST
    + pgsql-master-baseline             : 0000000003000098
    + pgsql-status                      : PRI
    + pgsql-xlog-loc                    : 0000000003000098
* Node node2:
    + master-pgsql                      : -INFINITY
    + pgsql-data-status                 : STREAMING|ASYNC
    + pgsql-status                      : HS:async
    + pgsql-xlog-loc                    : 0000000003000000

Migration Summary:
* Node node2:
* Node node1:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この端末は開いたままにしておきます。&lt;/p&gt;

&lt;h2 id=&#34;node1-コンテナを強制停止してフェールオーバのテスト&#34;&gt;node1 コンテナを強制停止してフェールオーバのテスト&lt;/h2&gt;

&lt;p&gt;別の端末を開いて以下のコマンドを実行し、 &lt;code&gt;node1&lt;/code&gt; コンテナを強制停止し時刻を記録します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc stop -f node1; date -u
Sun Aug 21 13:52:57 UTC 2016
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しばらくすると　&lt;code&gt;crm_mon -fA&lt;/code&gt; の出力が以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Last updated: Sun Aug 21 13:53:11 2016          Last change: Sun Aug 21 13:53:05 2016 by root via crm_attribute on node2
Stack: corosync
Current DC: node2 (version 1.1.13-10.el7_2.4-44eb2dd) - partition with quorum
2 nodes and 3 resources configured

Online: [ node2 ]
OFFLINE: [ node1 ]

 Master/Slave Set: pgsql-master [pgsql]
     Masters: [ node2 ]
master-ip       (ocf::heartbeat:IPaddr2):       Started node2

Node Attributes:
* Node node2:
    + master-pgsql                      : 1000
    + pgsql-data-status                 : LATEST
    + pgsql-master-baseline             : 00000000030001A8
    + pgsql-status                      : PRI
    + pgsql-xlog-loc                    : 0000000003000000

Migration Summary:
* Node node2:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LXDホストで以下のコマンドを実行して &lt;code&gt;node1&lt;/code&gt; を起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc start node1; date -u
Sun Aug 21 13:53:58 UTC 2016
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動後しばらくしても &lt;code&gt;node1&lt;/code&gt; はオフラインのままですが、これは意図した挙動です。実際のケースではディスク障害などが起きているかもしれないので、マシンの状況を確認してから手動でクラスタに復帰させることになるためです。&lt;/p&gt;

&lt;p&gt;以下のコマンドで &lt;code&gt;node1&lt;/code&gt; コンテナに入ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc exec node1 bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PacemakerがPostgreSQLのロックファイルを作っているのでそれを削除します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@node1 ~]# ll /var/run/postgresql/
total 4
-rw-r----- 1 root     root      0 Aug 21 13:52 PGSQL.lock
-rw-r----- 1 postgres postgres 36 Aug 21 13:52 rep_mode.conf
[root@node1 ~]# rm /var/run/postgresql/PGSQL.lock
rm: remove regular empty file &#39;/var/run/postgresql/PGSQL.lock&#39;? y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドで &lt;code&gt;node1&lt;/code&gt; をクラスタに復帰させ、時刻を記録します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@node1 ~]# pcs cluster start node1; date -u
node1: Starting Cluster...
Sun Aug 21 13:55:30 UTC 2016
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;15秒後、 &lt;code&gt;crm_mon -fA&lt;/code&gt; の画面で &lt;code&gt;node1&lt;/code&gt; の PostgreSQL が Slaves に追加されました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Last updated: Sun Aug 21 13:55:45 2016          Last change: Sun Aug 21 13:55:42 2016 by root via crm_attribute on node2
Stack: corosync
Current DC: node2 (version 1.1.13-10.el7_2.4-44eb2dd) - partition with quorum
2 nodes and 3 resources configured

Online: [ node1 node2 ]

 Master/Slave Set: pgsql-master [pgsql]
     Masters: [ node2 ]
     Slaves: [ node1 ]
master-ip       (ocf::heartbeat:IPaddr2):       Started node2

Node Attributes:
* Node node1:
    + master-pgsql                      : 100
    + pgsql-data-status                 : STREAMING|SYNC
    + pgsql-status                      : HS:sync
* Node node2:
    + master-pgsql                      : 1000
    + pgsql-data-status                 : LATEST
    + pgsql-master-baseline             : 00000000030001A8
    + pgsql-status                      : PRI
    + pgsql-xlog-loc                    : 0000000003000000

Migration Summary:
* Node node2:
* Node node1:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで、 &lt;code&gt;node2&lt;/code&gt; で &lt;code&gt;crm_mon -fA&lt;/code&gt; を実行していた端末で Control-C を入力してモニターを終了します。&lt;/p&gt;

&lt;h2 id=&#34;postgresqlのプロセスを強制終了してフェールオーバのテスト&#34;&gt;PostgreSQLのプロセスを強制終了してフェールオーバのテスト&lt;/h2&gt;

&lt;p&gt;今度は &lt;code&gt;node2&lt;/code&gt; の PostgreSQL のプロセスを強制終了してフェールオーバしてみます。&lt;/p&gt;

&lt;p&gt;経過を見るために &lt;code&gt;node1&lt;/code&gt; で以下のコマンドを実行して、その端末を開いたままにしておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@node1 ~]# crm_mon -fA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;開始時点では以下のような出力になっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Last updated: Sun Aug 21 13:57:17 2016          Last change: Sun Aug 21 13:55:42 2016 by root via crm_attribute on node2
Stack: corosync
Current DC: node2 (version 1.1.13-10.el7_2.4-44eb2dd) - partition with quorum
2 nodes and 3 resources configured

Online: [ node1 node2 ]

 Master/Slave Set: pgsql-master [pgsql]
     Masters: [ node2 ]
     Slaves: [ node1 ]
master-ip       (ocf::heartbeat:IPaddr2):       Started node2

Node Attributes:
* Node node1:
    + master-pgsql                      : 100
    + pgsql-data-status                 : STREAMING|SYNC
    + pgsql-status                      : HS:sync
* Node node2:
    + master-pgsql                      : 1000
    + pgsql-data-status                 : LATEST
    + pgsql-master-baseline             : 00000000030001A8
    + pgsql-status                      : PRI
    + pgsql-xlog-loc                    : 0000000003000000

Migration Summary:
* Node node2:
* Node node1:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;node2&lt;/code&gt; で以下のコマンドを実行して PostgreSQL のプロセスを強制終了し、時刻を記録します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@node2 ~]# kill -KILL `head -1 /var/lib/pgsql/9.5/data/postmaster.pid`; date -u
Sun Aug 21 13:58:20 UTC 2016
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;11秒後 &lt;code&gt;node1&lt;/code&gt; の PostgreSQL が Masterに昇格されました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Last updated: Sun Aug 21 13:58:31 2016          Last change: Sun Aug 21 13:58:27 2016 by root via crm_attribute on node1
Stack: corosync
Current DC: node2 (version 1.1.13-10.el7_2.4-44eb2dd) - partition with quorum
2 nodes and 3 resources configured

Online: [ node1 node2 ]

 Master/Slave Set: pgsql-master [pgsql]
     Masters: [ node1 ]
master-ip       (ocf::heartbeat:IPaddr2):       Started node1

Node Attributes:
* Node node1:
    + master-pgsql                      : 1000
    + pgsql-data-status                 : LATEST
    + pgsql-master-baseline             : 0000000003000398
    + pgsql-status                      : PRI
* Node node2:
    + master-pgsql                      : -INFINITY
    + pgsql-data-status                 : DISCONNECT
    + pgsql-status                      : STOP

Migration Summary:
* Node node2:
   pgsql: migration-threshold=2 fail-count=1000000 last-failure=&#39;Sun Aug 21 13:58:23 2016&#39;
* Node node1:

Failed Actions:
* pgsql_start_0 on node2 &#39;unknown error&#39; (1): call=23, status=complete, exitreason=&#39;My data may be inconsistent. You have to remove /va
r/run/postgresql/PGSQL.lock file to force start.&#39;,
    last-rc-change=&#39;Sun Aug 21 13:58:23 2016&#39;, queued=0ms, exec=383ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、 &lt;code&gt;node2&lt;/code&gt; の PostgreSQL を再び稼働してスタンバイにさせてみます。&lt;/p&gt;

&lt;p&gt;まず Pacemaker が作成した PostgreSQL のロックファイル &lt;code&gt;/var/run/postgresql/PGSQL.lock&lt;/code&gt; を削除します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@node2 ~]# ll /var/run/postgresql/
total 4
-rw-r----- 1 root     root      0 Aug 21 13:53 PGSQL.lock
-rw-r----- 1 postgres postgres 31 Aug 21 13:58 rep_mode.conf
[root@node2 ~]# \rm /var/run/postgresql/PGSQL.lock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に以下のコマンドを実行して &lt;code&gt;node2&lt;/code&gt; のPostgreSQL の failcount をリセットし、時刻を記録します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@node2 ~]# pcs resource failcount reset pgsql node2; date -u
Sun Aug 21 14:00:04 UTC 2016
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9秒後、 &lt;code&gt;node1&lt;/code&gt; での &lt;code&gt;crm_mon -fA&lt;/code&gt; の出力を見ると &lt;code&gt;node2&lt;/code&gt; がスタンバイになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Last updated: Sun Aug 21 14:00:13 2016          Last change: Sun Aug 21 14:00:10 2016 by root via crm_attribute on node1
Stack: corosync
Current DC: node2 (version 1.1.13-10.el7_2.4-44eb2dd) - partition with quorum
2 nodes and 3 resources configured

Online: [ node1 node2 ]

 Master/Slave Set: pgsql-master [pgsql]
     Masters: [ node1 ]
     Slaves: [ node2 ]
master-ip       (ocf::heartbeat:IPaddr2):       Started node1

Node Attributes:
* Node node1:
    + master-pgsql                      : 1000
    + pgsql-data-status                 : LATEST
    + pgsql-master-baseline             : 0000000003000398
    + pgsql-status                      : PRI
* Node node2:
    + master-pgsql                      : 100
    + pgsql-data-status                 : STREAMING|SYNC
    + pgsql-status                      : HS:sync

Migration Summary:
* Node node2:
* Node node1:

Failed Actions:
* pgsql_start_0 on node2 &#39;unknown error&#39; (1): call=23, status=complete, exitreason=&#39;My data may be inconsistent. You have to remove /va
r/run/postgresql/PGSQL.lock file to force start.&#39;,
    last-rc-change=&#39;Sun Aug 21 13:58:23 2016&#39;, queued=0ms, exec=383ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;STONITH無し、quorum無しという簡易構成ですが、アクティブ・スタンバイ(1+1構成)でフフェールオーバする検証ができました。本番運用するにはSTONITHやquorumも重要そうなので、そちらも調べて行きたいです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LXDのdnsmasqの固定IP設定をSIGHUPで更新する</title>
      <link>https://hnakamur.github.io/blog/2016/08/12/update-lxd-dnsmasq-dhcp-hosts-config-with-sighup/</link>
      <pubDate>Fri, 12 Aug 2016 06:38:18 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2016/08/12/update-lxd-dnsmasq-dhcp-hosts-config-with-sighup/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2016/05/07/how-to-use-fixed-ip-address-for-a-lxd-container/&#34;&gt;LXDコンテナで固定IPアドレスを使うための設定 · hnakamur&amp;rsquo;s blog at github&lt;/a&gt; では &lt;code&gt;/etc/dnsmasq.conf&lt;/code&gt; に直接 &lt;code&gt;dhcp-host&lt;/code&gt; で設定を書いていましたが、変更するためには &lt;code&gt;lxd-bridge&lt;/code&gt; の再起動が必要でした。&lt;/p&gt;

&lt;p&gt;その後 &lt;a href=&#34;http://manpages.ubuntu.com/manpages/xenial/en/man8/dnsmasq.8.html&#34;&gt;Ubuntu Manpage: dnsmasq - A lightweight DHCP and caching DNS server.&lt;/a&gt; を見て &lt;code&gt;--dhcp-hostsfile=&amp;lt;path&amp;gt;&lt;/code&gt; または &lt;code&gt;--dhcp-hostsdir=&amp;lt;path&amp;gt;&lt;/code&gt; を使っておけば &lt;code&gt;lxd-bridge&lt;/code&gt; を再起動しなくても &lt;code&gt;dnsmasq&lt;/code&gt; に &lt;code&gt;SIGHUP&lt;/code&gt; を送れば更新できることを知りました。 &lt;code&gt;--dhcp-hostsdir=&amp;lt;path&amp;gt;&lt;/code&gt; の場合は、指定したディレクトリ以下のファイルを追加・更新する場合は SIGHUP すら不要で、ファイルを削除した後に反映するときだけ SIGHUP が必要です。&lt;/p&gt;

&lt;p&gt;ですが、実際に試してみると &lt;code&gt;--dhcp-hostsdir&lt;/code&gt; のほうは SIGHUP を送ると &lt;code&gt;duplicate dhcp-host IP address&lt;/code&gt; というエラーになってしまったので (下記のハマりメモ参照)、 &lt;code&gt;--dhcp-hostsfile&lt;/code&gt; のほうを使うことにしました。&lt;/p&gt;

&lt;h2 id=&#34;lxd-bridgeのdnsmasqで-dhcp-hostsfile-を使う設定&#34;&gt;lxd-bridgeのdnsmasqで&amp;ndash;dhcp-hostsfile を使う設定&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;/var/lib/lxd-bridge/dhcp-hosts&lt;/code&gt; というファイルを作って、そこを見るように切り替えてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo touch /var/lib/lxd-bridge/dhcp-hosts
echo &#39;dhcp-hostsfile=/var/lib/lxd-bridge/dhcp-hosts&#39; | sudo tee /etc/dnsmasq.conf &amp;gt; /dev/null
sudo systemctl restart lxd-bridge
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ipアドレスを指定して新規コンテナを作成する&#34;&gt;IPアドレスを指定して新規コンテナを作成する&lt;/h2&gt;

&lt;p&gt;例えば &lt;code&gt;web01&lt;/code&gt; というコンテナを &lt;code&gt;10.155.92.201&lt;/code&gt; というアドレスで作成したい場合は以下のようにします。 &lt;a href=&#34;http://manpages.ubuntu.com/manpages/xenial/en/man8/dnsmasq.8.html&#34;&gt;Ubuntu Manpage: dnsmasq - A lightweight DHCP and caching DNS server.&lt;/a&gt; によると &lt;code&gt;--dhcp-range&lt;/code&gt; で指定した範囲の外でも良いが &lt;code&gt;--dhcp-range&lt;/code&gt; と同じサブネットである必要があるとのことです。 &lt;code&gt;ps auxww | grep dnsmasq&lt;/code&gt; で見たところ &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; の &lt;code&gt;LXD_IPV4_DHCP_RANGE&lt;/code&gt; の値が &lt;code&gt;--dhcp-range&lt;/code&gt; に使われています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo web01,10.155.92.201 | sudo tee /var/lib/lxd-bridge/dhcp-hosts &amp;gt; /dev/null
sudo kill -HUP `cat /var/run/lxd-bridge/dnsmasq.pid`
lxc launch images:centos/7/amd64 web01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数秒してから &lt;code&gt;lxc list&lt;/code&gt; を実行すると指定したアドレスになっていることが確認できます。&lt;/p&gt;

&lt;p&gt;なお、この例では dhcp-hosts 内のエントリが web01 の1つだけなので echo と tee で作成・更新していますが、実際の利用時には複数エントリがあるので既存のエントリを残しつつエントリを追加・更新する必要がありますのでご注意ください。&lt;/p&gt;

&lt;h2 id=&#34;既存のコンテナのipアドレスを変更する&#34;&gt;既存のコンテナのIPアドレスを変更する&lt;/h2&gt;

&lt;p&gt;上記で作成した &lt;code&gt;web01&lt;/code&gt; というコンテナのアドレスを &lt;code&gt;10.155.92.202&lt;/code&gt; に変更してみます。変更にはコンテナの再起動が必要になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo web01,10.155.92.202 | sudo tee /var/lib/lxd-bridge/dhcp-hosts &amp;gt; /dev/null
sudo kill -HUP `cat /var/run/lxd-bridge/dnsmasq.pid`
lxc restart -f web01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数秒してから &lt;code&gt;lxc list&lt;/code&gt; を実行すると指定したアドレスになっていることが確認できます。&lt;/p&gt;

&lt;p&gt;この方法でIPアドレスを変更すると &lt;code&gt;/var/lib/lxd-bridge/dnsmasq.lxdbr0.leases&lt;/code&gt; に変更前のアドレスが残らないので、そのアドレスをすぐに他で再利用することが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;コンテナを削除後-同じipアドレスを他のコンテナで使う&#34;&gt;コンテナを削除後、同じIPアドレスを他のコンテナで使う&lt;/h2&gt;

&lt;p&gt;一方、コンテナを削除しても使っていたIPアドレスはまだ貸出中になっています。&lt;/p&gt;

&lt;p&gt;上記の状態の後&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc delete -f web01
: | sudo tee /var/lib/lxd-bridge/dhcp-hosts
sudo kill -HUP `cat /var/run/lxd-bridge/dnsmasq.pid`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としても &lt;code&gt;/var/lib/lxd-bridge/dnsmasq.lxdbr0.leases&lt;/code&gt; には&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1470963716 00:16:3e:45:a6:d1 10.155.92.202 web01 *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようなエントリが残っています。
このアドレスを他のコンテナで使うためには一旦解放する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dhcp_release lxdbr0 10.155.92.202 00:16:3e:45:a6:d1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように実行するか、あるいは &lt;a href=&#34;https://hnakamur.github.io/blog/blog/2016/08/11/release-all-unused-addresses-of-lxd-bridge/&#34;&gt;LXDのDHCPで使っていないIPアドレスを一括で解放するスクリプトを書いた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt; で書いたスクリプトを実行して解放します。以下では後者のスクリプトを &lt;code&gt;~/bin/lxd-bridge-release-all-unused-addresses.sh&lt;/code&gt; に保存してあるものとして説明します。&lt;/p&gt;

&lt;p&gt;IPアドレスを解放した後で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo web02,10.155.92.202 | sudo tee /var/lib/lxd-bridge/dhcp-hosts &amp;gt; /dev/null
sudo kill -HUP `cat /var/run/lxd-bridge/dnsmasq.pid`
lxc launch images:centos/7/amd64 web02
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように実行すれば、IPアドレスを &lt;code&gt;10.155.92.202&lt;/code&gt; にして &lt;code&gt;web02&lt;/code&gt; というコンテナを作成・起動できました。&lt;/p&gt;

&lt;h2 id=&#34;dhcp-hostsdirのハマりメモ&#34;&gt;&amp;ndash;dhcp-hostsdirのハマりメモ&lt;/h2&gt;

&lt;h3 id=&#34;lxd-bridgeのdnsmasqで-dhcp-hostsdir-を使う設定&#34;&gt;lxd-bridgeのdnsmasqで&amp;ndash;dhcp-hostsdir を使う設定&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;/var/lib/lxd-bridge/dhcp-hosts&lt;/code&gt; というディレクトリを作って、そこを見るように切り替えてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ -f /var/lib/lxd-bridge/dhcp-hosts ] &amp;amp;&amp;amp; sudo rm /var/lib/lxd-bridge/dhcp-hosts
sudo mkdir -p /var/lib/lxd-bridge/dhcp-hosts
echo &#39;dhcp-hostsdir=/var/lib/lxd-bridge/dhcp-hosts&#39; | sudo tee /etc/dnsmasq.conf &amp;gt; /dev/null
sudo systemctl restart lxd-bridge
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ipアドレスを指定して新規コンテナを作成する-1&#34;&gt;IPアドレスを指定して新規コンテナを作成する&lt;/h3&gt;

&lt;p&gt;例えば &lt;code&gt;web01&lt;/code&gt; というコンテナを &lt;code&gt;10.155.92.201&lt;/code&gt; というアドレスで作成したい場合は以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo web01,10.155.92.201 | sudo tee /var/lib/lxd-bridge/dhcp-hosts/web01 &amp;gt; /dev/null
lxc launch images:centos/7/amd64 web01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数秒してから &lt;code&gt;lxc list&lt;/code&gt; を実行すると指定したアドレスになっていることが確認できます。&lt;/p&gt;

&lt;p&gt;と、ここまでは良かったのですが、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;journalctl -f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でログを見ておいて、別端末で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo kill -HUP `cat /var/run/lxd-bridge/dnsmasq.pid`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 12 08:39:56 lxdhostname dnsmasq-dhcp[2455]: read /var/lib/lxd-bridge/dhcp-hosts/web01
Aug 12 08:39:56 lxdhostname dnsmasq[2455]: duplicate dhcp-host IP address 10.155.92.201 at line 1 of /var/lib/lxd-bridge/dhcp-hosts/web01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようなエラーが出てしまいました。 &lt;code&gt;duplicate dhcp-host IP address&lt;/code&gt; から後ろは赤字で表示されました。&lt;/p&gt;

&lt;h3 id=&#34;コンテナを削除後-同じipアドレスを他のコンテナで使いたいが失敗&#34;&gt;コンテナを削除後、同じIPアドレスを他のコンテナで使いたいが失敗&lt;/h3&gt;

&lt;p&gt;以下では &lt;a href=&#34;https://hnakamur.github.io/blog/blog/2016/08/11/release-all-unused-addresses-of-lxd-bridge/&#34;&gt;LXDのDHCPで使っていないIPアドレスを一括で解放するスクリプトを書いた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt; のスクリプトを &lt;code&gt;~/bin/lxd-bridge-release-all-unused-addresses.sh&lt;/code&gt; に保存してあるものとして説明します。&lt;/p&gt;

&lt;p&gt;上記の状態の後、 &lt;code&gt;journalctl -f&lt;/code&gt; を引き続き別端末で実行しておいて&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc delete -f web01
sudo rm /var/lib/lxd-bridge/dhcp-hosts/web01
sudo kill -HUP `cat /var/run/lxd-bridge/dnsmasq.pid`
~/bin/lxd-bridge-release-all-unused-addresses.sh
echo web02,10.155.92.201 | sudo tee /var/lib/lxd-bridge/dhcp-hosts/web02 &amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 12 08:44:13 lxdhostname dnsmasq-dhcp[2455]: read /var/lib/lxd-bridge/dhcp-hosts/web02
Aug 12 08:44:13 lxdhostname dnsmasq[2455]: duplicate dhcp-host IP address 10.155.92.201 at line 1 of /var/lib/lxd-bridge/dhcp-hosts/web02
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と先程と同様のエラーが出ました。ここから&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc launch images:centos/7/amd64 web02
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と実行しても、指定した &lt;code&gt;10.155.92.201&lt;/code&gt; とは異なるアドレスになってしまいました。&lt;/p&gt;

&lt;p&gt;ということで &lt;code&gt;--dhcp-hostsdir=&amp;lt;path&amp;gt;&lt;/code&gt; は正しい使い方がわからなかったので、諦めて &lt;code&gt;--dhcp-hostsfile=&amp;lt;path&amp;gt;&lt;/code&gt; のほうを使うことにしました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LXDのDHCPで使っていないIPアドレスを一括で解放するスクリプトを書いた</title>
      <link>https://hnakamur.github.io/blog/2016/08/11/release-all-unused-addresses-of-lxd-bridge/</link>
      <pubDate>Thu, 11 Aug 2016 22:58:21 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2016/08/11/release-all-unused-addresses-of-lxd-bridge/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2016/05/07/how-to-use-fixed-ip-address-for-a-lxd-container/&#34;&gt;LXDコンテナで固定IPアドレスを使うための設定 · hnakamur&amp;rsquo;s blog at github&lt;/a&gt; の設定を行ってもIPアドレスが指定通りにならないことがありました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;journal -xe&lt;/code&gt; で見てみると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 11 22:46:55 bai1b7faf04 dnsmasq-dhcp[11082]: not using configured address 10.155.92.102 because it is leased to 00:16:3e:1e:08:8a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というメッセージが出ていて、他のMACアドレスに貸出中になっています。&lt;/p&gt;

&lt;p&gt;ググってみると &lt;a href=&#34;http://www.linuxquestions.org/questions/linux-newbie-8/dnsmasq-force-release-renew-of-dhcp-clients-how-933535/&#34;&gt;[SOLVED] dnsmasq force release/renew of dhcp clients, how?&lt;/a&gt; に回答がありました。&lt;/p&gt;

&lt;h2 id=&#34;使っていないipアドレスを手動で消す&#34;&gt;使っていないIPアドレスを手動で消す&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl stop lxd-bridge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で止めて&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo vi /var/lib/lxd-bridge/dnsmasq.lxdbr0.leases
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で使っていないIPアドレスの行を全て削除します。&lt;/p&gt;

&lt;p&gt;その後&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl start lxd-bridge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で再起動します。&lt;/p&gt;

&lt;h2 id=&#34;自動で消すスクリプトも書きました&#34;&gt;自動で消すスクリプトも書きました&lt;/h2&gt;

&lt;p&gt;これでよいかと思ったら、
&lt;a href=&#34;http://lists.thekelleys.org.uk/pipermail/dnsmasq-discuss/2013q3/007356.html&#34;&gt;http://lists.thekelleys.org.uk/pipermail/dnsmasq-discuss/2013q3/007356.html&lt;/a&gt;
を見て &lt;code&gt;dhcp_release&lt;/code&gt; というコマンドを使えば &lt;code&gt;lxd-bridge&lt;/code&gt; の再起動が不要なことを知りました。&lt;/p&gt;

&lt;p&gt;ということでスクリプトを書いてみました。
&lt;a href=&#34;https://gist.github.com/hnakamur/7ed3f7c6175817b633586a1b468bd5c1&#34;&gt;https://gist.github.com/hnakamur/7ed3f7c6175817b633586a1b468bd5c1&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
set -eu

# Set value of LXD_BRIDGE
. /etc/default/lxd-bridge

addr_list_file=/tmp/lxd-addr-list.`date +%Y-%m-%dT%H:%M:%S`
lxc list | awk &#39;$4==&amp;quot;RUNNING&amp;quot;{print $6}&#39; &amp;gt; $addr_list_file
cleanup() {
  rm $addr_list_file
}
trap cleanup EXIT

awk -v addr_list_file=$addr_list_file -v interface=$LXD_BRIDGE &#39;{
  mac_addr = $2
  addr = $3
  ret = system(sprintf(&amp;quot;awk -v addr=%s &#39;\&#39;&#39;BEGIN{rc=1} $1==addr{rc=0} END{exit rc}&#39;\&#39;&#39; %s&amp;quot;, addr,  addr_list_file))
  if (ret == 1) {
    system(sprintf(&amp;quot;sudo dhcp_release %s %s %s&amp;quot;, interface, addr, mac_addr))
  }
}&#39; /var/lib/lxd-bridge/dnsmasq.$LXD_BRIDGE.leases
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ubuntu 16.04 の場合 &lt;code&gt;dhcp_release&lt;/code&gt; コマンドを使うには以下のように &lt;code&gt;dnsmasq-utils&lt;/code&gt; パッケージをインストールする必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt -y install dnsmasq-utils
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LXDコンテナでPostgreSQLの非同期リプリケーションを試してみた</title>
      <link>https://hnakamur.github.io/blog/2016/07/23/tried-postgresql-async-replication-in-lxd-containers/</link>
      <pubDate>Sat, 23 Jul 2016 21:13:52 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2016/07/23/tried-postgresql-async-replication-in-lxd-containers/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://lets.postgresql.jp/documents/technical/replication/1/&#34;&gt;ストリーミング・レプリケーションの構築 — Let&amp;rsquo;s Postgres&lt;/a&gt; と &lt;a href=&#34;http://d.hatena.ne.jp/hiroe_orz17/20111113/1321180635&#34;&gt;PostgreSQL9.1ためしてみた【非同期レプリケーション編】 - ごろねこ日記&lt;/a&gt; を読んで、2台のLXDコンテナを使ってPostgreSQLの非同期リプリケーションを試してみたのでメモです。&lt;/p&gt;

&lt;p&gt;また&lt;a href=&#34;https://www.packtpub.com/big-data-and-business-intelligence/postgresql-replication-second-edition&#34;&gt;PostgreSQL Replication - Second Edition | PACKT Books&lt;/a&gt;が $10 と安かったので、買って非同期レプリケーションの章まで読みました。&lt;/p&gt;

&lt;p&gt;手順はAnsible playbookとしてまとめました。 &lt;a href=&#34;https://github.com/hnakamur/postgresql-async-replication-example-playbook&#34;&gt;hnakamur/postgresql-async-replication-example-playbook&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ansible.cfg&lt;/code&gt; で &lt;code&gt;ask_vault_pass = True&lt;/code&gt; と指定しているので、プレイブック実行時に &lt;code&gt;Vault password:&lt;/code&gt; と聞かれます。パスワードは &lt;code&gt;password&lt;/code&gt; です。サンプルなので単純なパスワードにしていますが、実案件でのプレイブックはきちんとしたパスワードをつけています。&lt;/p&gt;

&lt;h2 id=&#34;テスト環境構築&#34;&gt;テスト環境構築&lt;/h2&gt;

&lt;p&gt;ホストマシンのディストリビューションはUbuntu 16.04でLXD 2.0.3, curl, jqをインストール済みの状態で試しました。&lt;/p&gt;

&lt;p&gt;作業ディレクトリを作って、そこに移動し上記のプレイブックを取得します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/hnakamur/postgresql-async-replication-example-playbook
cd postgresql-async-replication-example-playbook
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lxd_container&lt;/code&gt; モジュールを使うため、 github から最新のAnsibleをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virtualenv venv
source venv/bin/activate
pip install git+https://github.com/ansible/ansible
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;masterとstandbyのコンテナを作成&#34;&gt;masterとstandbyのコンテナを作成&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ansible-playbook launch_containers.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行すると &lt;code&gt;development&lt;/code&gt; というインベントリファイルを生成します。初期状態ではコンテナ &lt;code&gt;pgsql1&lt;/code&gt; が master, コンテナ &lt;code&gt;pgsql2&lt;/code&gt; が standby になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[development]
pgsql1 postgresql_peer_ipaddr=10.155.92.234 postgressql_master_standby_type=master
pgsql2 postgresql_peer_ipaddr=10.155.92.202 postgressql_master_standby_type=standby

[development:vars]
ansible_connection=lxd
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;コンテナ内にpostgresqlの非同期レプリケーションの環境設定&#34;&gt;コンテナ内にPostgreSQLの非同期レプリケーションの環境設定&lt;/h2&gt;

&lt;p&gt;以下のコマンドを実行してセットアップを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ansible-playbook initial_setup.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完了したら、2つ端末を開いて片方で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc exec pgsql1 bash
sudo -u postgres -i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行し、もう片方で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc exec pgsql2 bash
sudo -u postgres -i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行し、データベースを作ったり pgbench を動かしたりして変更が同期されるのを確認します。&lt;/p&gt;

&lt;p&gt;test というデータベースを作ってpgbenchを実行する手順は以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;createdb test
/usr/pgsql-9.5/bin/pgbench -i test
/usr/pgsql-9.5/bin/pgbench -T 180 test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記の手順を1歩ずつ試し、 test データベースを作る前は pgsql2 では &lt;code&gt;psql test&lt;/code&gt; が失敗しますが作った後は成功するなどで同期が確認できます。&lt;/p&gt;

&lt;h2 id=&#34;レプリケーションの状態確認&#34;&gt;レプリケーションの状態確認&lt;/h2&gt;

&lt;h3 id=&#34;master側での確認&#34;&gt;master側での確認&lt;/h3&gt;

&lt;p&gt;以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;watch -n 0.5 &#39;psql -x -c &amp;quot;SELECT * FROM pg_stat_replication&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Every 0.5s: psql -x -c &amp;quot;SELECT * FROM pg_stat_replication&amp;quot;         Sat Jul 23 12:47:27 2016

-[ RECORD 1 ]----+------------------------------
pid              | 2160
usesysid         | 16384
usename          | repl_user
application_name | walreceiver
client_addr      | 10.155.92.234
client_hostname  |
client_port      | 44822
backend_start    | 2016-07-23 08:34:43.696331+00
backend_xmin     |
state            | streaming
sent_location    | 0/30031E0
write_location   | 0/30031E0
flush_location   | 0/30031E0
replay_location  | 0/30031E0
sync_priority    | 0
sync_state       | async
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;standby側での確認&#34;&gt;standby側での確認&lt;/h3&gt;

&lt;p&gt;以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;watch -n 0.5 &#39;ps auxww | grep &amp;quot;[p]ostgres:&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Every 0.5s: ps auxww | grep &amp;quot;[p]ostgres:&amp;quot;                                   Sat Jul 23 12:49:30 2016
ailabl
postgres  2051  0.0  0.0  86736  3420 ?        Ss   08:34   0:00 postgres: logger process
postgres  2052  0.0  0.0 233948  5996 ?        Ss   08:34   0:00 postgres: startup process   recover
ing 000000010000000000000003
postgres  2071  0.0  0.0 234012  7016 ?        Ss   08:34   0:00 postgres: checkpointer process
postgres  2072  0.0  0.0 233912  5916 ?        Ss   08:34   0:00 postgres: writer processl
postgres  2073  0.0  0.0  88856  3444 ?        Ss   08:34   0:00 postgres: stats collector process

postgres  2078  0.0  0.0 240632  7016 ?        Ss   08:34   0:05 postgres: wal receiver process   st
reaming 0/30031E0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;フェイルオーバー&#34;&gt;フェイルオーバー&lt;/h2&gt;

&lt;p&gt;masterのPostgreSQLを停止し、 standbyをmasterにpromote (昇格)させます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ansible-playbook failover.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;旧masterを新standbyとして稼働再開&#34;&gt;旧masterを新standbyとして稼働再開&lt;/h2&gt;

&lt;p&gt;ここでインベントリファイル &lt;code&gt;development&lt;/code&gt; 内の &lt;code&gt;postgressql_master_standby_type&lt;/code&gt; 変数の &lt;code&gt;master&lt;/code&gt; と &lt;code&gt;standby&lt;/code&gt; を入れ替えます。&lt;/p&gt;

&lt;p&gt;その後、新standbyのPostgreSQLを起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ansible-playbook start_new_standby.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もし復旧できない自体になった場合は、今のstandbyであるpgsql1 のデータディレクトリを退避して一からリプリケーション環境を構築します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc exec pgsql1 -- mv /var/lib/pgsql/9.5/data /var/lib/pgsql/9.5/data.bak
ansible-playbook initial_setup.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;フェイルバック&#34;&gt;フェイルバック&lt;/h2&gt;

&lt;p&gt;masterとstandbyを入れ替えているので、フェイルバックの手順はフェイルオーバーと同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ansible-playbook failover.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;コンテナの削除&#34;&gt;コンテナの削除&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ansible-playbook delete_containers.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ansible-vaultを使う際の変数命名規則のtips&#34;&gt;Ansible vaultを使う際の変数命名規則のtips&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ansible-vault encrypt&lt;/code&gt; で暗号化したファイルの内容を確認するには &lt;code&gt;ansible-vault decrypt&lt;/code&gt; で復号化する必要があります。どんな変数があったかを確認する度に行うのは面倒なので、以下のように暗号化するファイル内で定義する変数を一旦別の変数で受け取ってplaybookではそれを参照するようにしました。&lt;/p&gt;

&lt;p&gt;playbookの構成として環境ごとに development, production のようにグループを分けるようにしています（このサンプルでは development だけです）。暗号化するファイルとしないファイルを以下のような配置で作っています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;group_vars/development/secrets.yml
group_vars/development/vars.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;group_vars/development/secrets.yml&lt;/code&gt; では&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;development:
  secrets:
    postgresql_replication_password: _YOUR_PASSWORD_HERE_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように定義します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;group_vars/development/vars.yml&lt;/code&gt; では&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;postgresql_replication_password: &amp;quot;{{ development.secrets.postgresql_replication_password }}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにその変数を参照するようにするという具合です。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;LXDを使えば複数サーバ構成のテスト環境も簡単に作れてとても便利です！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LXDのREST APIクライアントライブラリpylxdを試してみた</title>
      <link>https://hnakamur.github.io/blog/2016/05/07/tried-pylxd/</link>
      <pubDate>Sat, 07 May 2016 21:17:35 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2016/05/07/tried-pylxd/</guid>
      <description>

&lt;p&gt;Python Package Index (PyPI)の &lt;a href=&#34;https://pypi.python.org/pypi/pylxd/2.0.0&#34;&gt;pylxd 2.0.0&lt;/a&gt;のページにインストール方法と使い方の例が書いてあるので、これに沿って試しました。&lt;/p&gt;

&lt;h2 id=&#34;インストール&#34;&gt;インストール&lt;/h2&gt;

&lt;p&gt;Ubuntu 16.04だとaptでインストール可能なのでそちらでインストールしました。Python3用のpython3-pylxdパッケージとPython2用のpython-pylxdパッケージがありますが、今後Ansibleのモジュールを作ることを想定してPython2用のパッケージをインストールして試してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt install -y python-pylxd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストールしたpython-pylxdのバージョンは &lt;code&gt;2.0.0-0ubuntu1&lt;/code&gt; です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dpkg-query -W -f=&#39;${Version}\n&#39; python-pylxd
2.0.0-0ubuntu1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;試してみる&#34;&gt;試してみる&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ python
Python 2.7.11+ (default, Apr 17 2016, 14:00:29)
[GCC 5.3.1 20160413] on linux2
Type &amp;quot;help&amp;quot;, &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information.
&amp;gt;&amp;gt;&amp;gt; from pylxd import api
&amp;gt;&amp;gt;&amp;gt; lxd = api.API()
&amp;gt;&amp;gt;&amp;gt; lxd.container_defined(&#39;cent01&#39;)
True
&amp;gt;&amp;gt;&amp;gt; lxd.container_defined(&#39;hoge&#39;)
False
&amp;gt;&amp;gt;&amp;gt; lxd.container_list()
[u&#39;cent01&#39;, u&#39;cent02&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここから先は &lt;a href=&#34;https://github.com/lxc/pylxd/blob/master/pylxd/client.py&#34;&gt;pylxd/client.py&lt;/a&gt; と &lt;a href=&#34;https://github.com/lxc/pylxd/blob/master/pylxd/container.py&#34;&gt;pylxd/container.py&lt;/a&gt; の ソースを見ながら試しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from pylxd.client import Client
&amp;gt;&amp;gt;&amp;gt; client = Client()
&amp;gt;&amp;gt;&amp;gt; client.containers.all()
[&amp;lt;pylxd.container.Container object at 0x7fd44065db00&amp;gt;, &amp;lt;pylxd.container.Container object at 0x7fd44065db98&amp;gt;]
&amp;gt;&amp;gt;&amp;gt; client.containers.get(u&#39;cent01&#39;)
&amp;lt;pylxd.container.Container object at 0x7fd44065dc30&amp;gt;
&amp;gt;&amp;gt;&amp;gt; client.containers.get(u&#39;cent01&#39;).status
u&#39;Running&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LXDのREST APIをcurlで試してみた</title>
      <link>https://hnakamur.github.io/blog/2016/05/07/tried-lxd-rest-api-with-curl/</link>
      <pubDate>Sat, 07 May 2016 21:17:34 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2016/05/07/tried-lxd-rest-api-with-curl/</guid>
      <description>

&lt;h2 id=&#34;lxdのrest-api&#34;&gt;LXDのREST API&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/rest-api/&#34;&gt;Linux Containers - LXD - REST API&lt;/a&gt;と&lt;a href=&#34;https://github.com/lxc/lxd/blob/master/doc/rest-api.md&#34;&gt;lxd/rest-api.md at master · lxc/lxd&lt;/a&gt;にLXDのREST APIについて説明があります。&lt;/p&gt;

&lt;p&gt;また&lt;a href=&#34;https://github.com/lxc/lxd#using-the-rest-api&#34;&gt;Using the REST API&lt;/a&gt;に &lt;code&gt;curl&lt;/code&gt; コマンドでのAPI呼び出し例が書かれていました。&lt;/p&gt;

&lt;h2 id=&#34;curlでhttpsのエンドポイントにアクセスしてみたがエラー&#34;&gt;curlでhttpsのエンドポイントにアクセスしてみたがエラー&lt;/h2&gt;

&lt;p&gt;まずはhttpsのURLで &lt;a href=&#34;https://github.com/lxc/lxd/blob/master/doc/rest-api.md#10&#34;&gt;/1.0&lt;/a&gt; エンドポイントを試してみたのですが、 &lt;code&gt;ALPN, server did not agree to a protocol&lt;/code&gt; というエラーになってしまいました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -k -v --cert ~/.config/lxc/client.crt --key ~/.config/lxc/client.key https://127.0.0.1:8443/1.0
*   Trying 127.0.0.1...
* Connected to 127.0.0.1 (127.0.0.1) port 8443 (#0)
* found 173 certificates in /etc/ssl/certs/ca-certificates.crt
* found 692 certificates in /etc/ssl/certs
* ALPN, offering http/1.1
* SSL connection using TLS1.2 / ECDHE_RSA_AES_128_GCM_SHA256
*        server certificate verification SKIPPED
*        server certificate status verification SKIPPED
*        common name: root@express (does not match &#39;127.0.0.1&#39;)
*        server certificate expiration date OK
*        server certificate activation date OK
*        certificate public key: RSA
*        certificate version: #3
*        subject: O=linuxcontainers.org,CN=root@express
*        start date: Tue, 03 May 2016 11:26:51 GMT
*        expire date: Fri, 01 May 2026 11:26:51 GMT
*        issuer: O=linuxcontainers.org,CN=root@express
*        compression: NULL
* ALPN, server did not agree to a protocol
&amp;gt; GET /1.0 HTTP/1.1
&amp;gt; Host: 127.0.0.1:8443
&amp;gt; User-Agent: curl/7.47.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Content-Type: application/json
&amp;lt; Date: Sat, 07 May 2016 12:25:53 GMT
&amp;lt; Content-Length: 162
&amp;lt;
{&amp;quot;type&amp;quot;:&amp;quot;sync&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;Success&amp;quot;,&amp;quot;status_code&amp;quot;:200,&amp;quot;metadata&amp;quot;:{&amp;quot;api_extensions&amp;quot;:[],&amp;quot;api_status&amp;quot;:&amp;quot;stable&amp;quot;,&amp;quot;api_version&amp;quot;:&amp;quot;1.0&amp;quot;,&amp;quot;auth&amp;quot;:&amp;quot;untrusted&amp;quot;,&amp;quot;public&amp;quot;:false}}
* Connection #0 to host 127.0.0.1 left intact
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この件は&lt;a href=&#34;https://lists.linuxcontainers.org/pipermail/lxc-users/2016-May/011603.html&#34;&gt;[lxc-users] The error &amp;ldquo;ALPN, server did not agree to a protocol&amp;rdquo; from LXD Rest API&lt;/a&gt;で質問してみました。&lt;/p&gt;

&lt;h2 id=&#34;curlでunix-domain-socket経由でアクセスしてみたら成功&#34;&gt;curlでunix domain socket経由でアクセスしてみたら成功&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/toritori0318/items/193df8f749a9c4bda883&#34;&gt;curlでunix domain socket経由アクセスする - Qiita&lt;/a&gt;を参考に以下のようにアクセスしてみると成功しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s --unix-socket /var/lib/lxd/unix.socket https:/1.0 | jq .
{
  &amp;quot;type&amp;quot;: &amp;quot;sync&amp;quot;,
  &amp;quot;status&amp;quot;: &amp;quot;Success&amp;quot;,
  &amp;quot;status_code&amp;quot;: 200,
  &amp;quot;metadata&amp;quot;: {
    &amp;quot;api_extensions&amp;quot;: [],
    &amp;quot;api_status&amp;quot;: &amp;quot;stable&amp;quot;,
    &amp;quot;api_version&amp;quot;: &amp;quot;1.0&amp;quot;,
    &amp;quot;auth&amp;quot;: &amp;quot;trusted&amp;quot;,
    &amp;quot;config&amp;quot;: {
      &amp;quot;core.https_address&amp;quot;: &amp;quot;127.0.0.1:8443&amp;quot;,
      &amp;quot;core.trust_password&amp;quot;: true
    },
    &amp;quot;environment&amp;quot;: {
      &amp;quot;addresses&amp;quot;: [
        &amp;quot;127.0.0.1:8443&amp;quot;
      ],
      &amp;quot;architectures&amp;quot;: [
        &amp;quot;x86_64&amp;quot;,
        &amp;quot;i686&amp;quot;
      ],
      &amp;quot;certificate&amp;quot;: &amp;quot;-----BEGIN CERTIFICATE-----\n …(略)… \n-----END CERTIFICATE-----\n&amp;quot;,
      &amp;quot;driver&amp;quot;: &amp;quot;lxc&amp;quot;,
      &amp;quot;driver_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;kernel&amp;quot;: &amp;quot;Linux&amp;quot;,
      &amp;quot;kernel_architecture&amp;quot;: &amp;quot;x86_64&amp;quot;,
      &amp;quot;kernel_version&amp;quot;: &amp;quot;4.4.0-21-generic&amp;quot;,
      &amp;quot;server&amp;quot;: &amp;quot;lxd&amp;quot;,
      &amp;quot;server_pid&amp;quot;: 6446,
      &amp;quot;server_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;storage&amp;quot;: &amp;quot;dir&amp;quot;,
      &amp;quot;storage_version&amp;quot;: &amp;quot;&amp;quot;
    },
    &amp;quot;public&amp;quot;: false
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sudo lxd init&lt;/code&gt; でLXDをネットワーク越しに使うかの問いにnoと答えた環境では以下のような出力になりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s --unix-socket /var/lib/lxd/unix.socket http:/1.0 | jq .
{
  &amp;quot;type&amp;quot;: &amp;quot;sync&amp;quot;,
  &amp;quot;status&amp;quot;: &amp;quot;Success&amp;quot;,
  &amp;quot;status_code&amp;quot;: 200,
  &amp;quot;metadata&amp;quot;: {
    &amp;quot;api_extensions&amp;quot;: [],
    &amp;quot;api_status&amp;quot;: &amp;quot;stable&amp;quot;,
    &amp;quot;api_version&amp;quot;: &amp;quot;1.0&amp;quot;,
    &amp;quot;auth&amp;quot;: &amp;quot;trusted&amp;quot;,
    &amp;quot;config&amp;quot;: {},
    &amp;quot;environment&amp;quot;: {
      &amp;quot;addresses&amp;quot;: [],
      &amp;quot;architectures&amp;quot;: [
        &amp;quot;x86_64&amp;quot;,
        &amp;quot;i686&amp;quot;
      ],
      &amp;quot;certificate&amp;quot;: &amp;quot;-----BEGIN CERTIFICATE-----\n …(略)… \n-----END CERTIFICATE-----\n&amp;quot;,
      &amp;quot;driver&amp;quot;: &amp;quot;lxc&amp;quot;,
      &amp;quot;driver_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;kernel&amp;quot;: &amp;quot;Linux&amp;quot;,
      &amp;quot;kernel_architecture&amp;quot;: &amp;quot;x86_64&amp;quot;,
      &amp;quot;kernel_version&amp;quot;: &amp;quot;4.4.0-21-generic&amp;quot;,
      &amp;quot;server&amp;quot;: &amp;quot;lxd&amp;quot;,
      &amp;quot;server_pid&amp;quot;: 2150,
      &amp;quot;server_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;storage&amp;quot;: &amp;quot;dir&amp;quot;,
      &amp;quot;storage_version&amp;quot;: &amp;quot;&amp;quot;
    },
    &amp;quot;public&amp;quot;: false
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>AnsibleのLXDコネクションプラグインを試してみた</title>
      <link>https://hnakamur.github.io/blog/2016/05/07/tried-ansible-lxd-connection-plugin/</link>
      <pubDate>Sat, 07 May 2016 20:32:13 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2016/05/07/tried-ansible-lxd-connection-plugin/</guid>
      <description>

&lt;p&gt;LXDを使うとなるとAnsibleのLXDコネクションプラグインが欲しいなと思って&lt;a href=&#34;https://github.com/ansible/ansible&#34;&gt;ansible/ansibleのgithubのレポジトリ&lt;/a&gt;を眺めていたら &lt;a href=&#34;https://github.com/ansible/ansible/blob/fca5ba153e9258d6a9a28c418d8339d507eee81c/lib/ansible/plugins/connection/lxd.py&#34;&gt;lib/ansible/plugins/connection/lxd.py&lt;/a&gt; に既に作られていることに気付きました。&lt;/p&gt;

&lt;p&gt;ソースを見ると &lt;code&gt;lxc&lt;/code&gt; コマンドを使った実装になっていました。aptでインストールしたansible 2.0.0.2にこのファイルだけ追加して使えないか試してみたのですが、 &lt;code&gt;AttributeError: &#39;PlayContext&#39; object has no attribute &#39;executable&#39;&lt;/code&gt; というエラーが出て使えませんでした。&lt;/p&gt;

&lt;p&gt;そこでvirtualenvで環境を作ってpipでgithubのmasterのansibleをインストールして試してみました。&lt;/p&gt;

&lt;h2 id=&#34;インストール手順&#34;&gt;インストール手順&lt;/h2&gt;

&lt;p&gt;インストール手順は以下の通りです。
まず、virtualenv環境でAnsibleをインストールするのに必要なパッケージをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt update
sudo apt install -y virtualenv build-essential python-dev libffi-dev libssl-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作業ディレクトリを作ってそこに移動し、virtualenvで環境を作ってansibleをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir ~/ansible-lxd-example
cd ~/ansible-lxd-example
virtualenv venv
. venv/bin/activate
pip install git+https://github.com/ansible/ansible
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使ってみる&#34;&gt;使ってみる&lt;/h2&gt;

&lt;p&gt;以下のような設定ファイルとテスト用のプレイブックを作りました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ansible.cfg
[defaults]
inventory = hosts
$ cat hosts
[containers]
cent01 ansible_connection=lxd
cent02 ansible_connection=lxd
$ cat test.yml
---
- hosts: containers
  remote_user: root
  tasks:
    - debug: msg=ipv4_address={{ ansible_default_ipv4.address }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行してみると、問題なく動作しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ansible-playbook test.yml

PLAY [containers] **************************************************************

TASK [setup] *******************************************************************
ok: [cent01]
ok: [cent02]

TASK [debug] *******************************************************************
ok: [cent01] =&amp;gt; {
    &amp;quot;msg&amp;quot;: &amp;quot;ipv4_address=10.155.92.101&amp;quot;
}
ok: [cent02] =&amp;gt; {
    &amp;quot;msg&amp;quot;: &amp;quot;ipv4_address=10.155.92.103&amp;quot;
}

PLAY RECAP *********************************************************************
cent01                     : ok=2    changed=0    unreachable=0    failed=0
cent02                     : ok=2    changed=0    unreachable=0    failed=0

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LXDコンテナで固定IPアドレスを使うための設定</title>
      <link>https://hnakamur.github.io/blog/2016/05/07/how-to-use-fixed-ip-address-for-a-lxd-container/</link>
      <pubDate>Sat, 07 May 2016 18:01:51 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2016/05/07/how-to-use-fixed-ip-address-for-a-lxd-container/</guid>
      <description>

&lt;h2 id=&#34;2016-08-12-追記&#34;&gt;2016-08-12 追記&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lxd-bridge&lt;/code&gt; サービスを再起動せずに固定IPアドレス設定を更新できるようにするための設定方法を &lt;a href=&#34;https://hnakamur.github.io/blog/blog/2016/08/12/update-lxd-dnsmasq-dhcp-hosts-config-with-sighup/&#34;&gt;LXDのdnsmasqの固定IP設定をSIGHUPで更新する · hnakamur&amp;rsquo;s blog at github&lt;/a&gt; に書きました。こちらのほうがお勧めです。&lt;/p&gt;

&lt;h2 id=&#34;設定まとめ&#34;&gt;設定まとめ&lt;/h2&gt;

&lt;p&gt;自分が後から参照することを想定して先に設定方法をまとめます。&lt;/p&gt;

&lt;p&gt;LXDコンテナで固定IPアドレスを使うためには以下の設定が必要です。なお、設定にはroot権限が必要です。&lt;/p&gt;

&lt;p&gt;まず &lt;code&gt;/etc/dnsmasq.conf&lt;/code&gt; に以下のようにコンテナ名に対するIPアドレスを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dhcp-host=cent01,10.64.177.101
dhcp-host=cent02,10.64.177.102
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lxd-bridge&lt;/code&gt; サービスを再起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl restart lxd-bridge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IPアドレスを変更したコンテナを再起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc restart cent01
lxc restart cent02
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;調査メモ&#34;&gt;調査メモ&lt;/h2&gt;

&lt;p&gt;以下は調査メモです。&lt;/p&gt;

&lt;p&gt;まず &lt;a href=&#34;https://github.com/lxc/lxd/issues/1168&#34;&gt;Persistent IP for Containers · Issue #1168 · lxc/lxd&lt;/a&gt; に固定IPアドレスを使うための情報がありました。LXDで特にサポートはないが、各コンテナでDHCPを使わずに静的IPアドレスを使用するか、あるいはホストのDHCPサーバ側で設定すれば実現できるとのことです。&lt;/p&gt;

&lt;p&gt;各コンテナで静的IPアドレスを使う方法も試してみたのですが、ホストのコンテナ内から別のコンテナをコンテナ名で参照しようとすると変更前のIPアドレスで通信しようとしてしまいうまく行きませんでした。&lt;/p&gt;

&lt;p&gt;これを実現するにはホストのDHCPサーバに各コンテナのIPアドレスを把握してもらう必要があるので、後者のDHCPサーバ側で設定するほうが良いです。&lt;/p&gt;

&lt;h3 id=&#34;lxdのブリッジインターフェースとdnsmasqの設定ファイル&#34;&gt;LXDのブリッジインターフェースとdnsmasqの設定ファイル&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://insights.ubuntu.com/2016/04/07/lxd-networking-lxdbr0-explained/&#34;&gt;LXD networking: lxdbr0 explained | Ubuntu Insights&lt;/a&gt;と&lt;a href=&#34;https://gist.github.com/cronnelly/98345100afe21840267270da3283b371&#34;&gt;lxcbr0 is being replaced by lxdbr0&lt;/a&gt;によると、 LXCでは &lt;code&gt;lxcbr0&lt;/code&gt; というブリッジインターフェースを使っていましたが、LXDでは &lt;code&gt;lxdbr0&lt;/code&gt; と別のインターフェースを使うように変更されたそうです。&lt;/p&gt;

&lt;p&gt;これらの記事を見るとLXCの &lt;code&gt;lxcbr0&lt;/code&gt; はインストール時に固定のアドレスネットワークが設定されて環境によっては既存のネットワークと衝突するという問題があったので、LXD の &lt;code&gt;lxdbr0&lt;/code&gt; ではインストール時にはIPv4やIPv6のサブネットは設定せずに &lt;code&gt;sudo lxd init&lt;/code&gt; を実行したときに設定するように変更されたということのようです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo lxd init&lt;/code&gt; で生成した &lt;code&gt;lxdbr0&lt;/code&gt; 用の設定は &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; に保存されています。
ファイルの先頭に書かれていますが、変更したい場合は直接編集せずに &lt;code&gt;dpkg-reconfigure -p medium lxd&lt;/code&gt; を実行するのが良いそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /etc/default/lxd-bridge
# WARNING: This file is generated by a debconf template!
# It is recommended to update it by using &amp;quot;dpkg-reconfigure -p medium lxd&amp;quot;

# Whether to setup a new bridge or use an existing one
USE_LXD_BRIDGE=&amp;quot;true&amp;quot;

# Bridge name
# This is still used even if USE_LXD_BRIDGE is set to false
# set to an empty value to fully disable
LXD_BRIDGE=&amp;quot;lxdbr0&amp;quot;

# Update the &amp;quot;default&amp;quot; LXD profile
UPDATE_PROFILE=&amp;quot;true&amp;quot;

# Path to an extra dnsmasq configuration file
LXD_CONFILE=&amp;quot;&amp;quot;

# DNS domain for the bridge
LXD_DOMAIN=&amp;quot;lxd&amp;quot;

# IPv4
## IPv4 address (e.g. 10.0.8.1)
LXD_IPV4_ADDR=&amp;quot;10.16.29.1&amp;quot;

## IPv4 netmask (e.g. 255.255.255.0)
LXD_IPV4_NETMASK=&amp;quot;255.255.255.0&amp;quot;

## IPv4 network (e.g. 10.0.8.0/24)
LXD_IPV4_NETWORK=&amp;quot;10.16.29.1/24&amp;quot;

## IPv4 DHCP range (e.g. 10.0.8.2,10.0.8.254)
LXD_IPV4_DHCP_RANGE=&amp;quot;10.16.29.2,10.16.29.254&amp;quot;

## IPv4 DHCP number of hosts (e.g. 250)
LXD_IPV4_DHCP_MAX=&amp;quot;252&amp;quot;

## NAT IPv4 traffic
LXD_IPV4_NAT=&amp;quot;true&amp;quot;

# IPv6
## IPv6 address (e.g. 2001:470:b368:4242::1)
LXD_IPV6_ADDR=&amp;quot;fd94:d372:e27f:2987::1&amp;quot;

## IPv6 CIDR mask (e.g. 64)
LXD_IPV6_MASK=&amp;quot;64&amp;quot;

## IPv6 network (e.g. 2001:470:b368:4242::/64)
LXD_IPV6_NETWORK=&amp;quot;fd94:d372:e27f:2987::1/64&amp;quot;

## NAT IPv6 traffic
LXD_IPV6_NAT=&amp;quot;true&amp;quot;

# Run a minimal HTTP PROXY server
LXD_IPV6_PROXY=&amp;quot;false&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このブリッジインタフェースを有効にするには &lt;code&gt;lxd-bridge.service&lt;/code&gt; を開始します。サービスの定義ファイルは以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /lib/systemd/system/lxd-bridge.service
[Unit]
Description=LXD - network bridge
Documentation=man:lxd(1)
Before=lxd.service

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/lib/lxd/lxd-bridge.start
ExecStop=/usr/lib/lxd/lxd-bridge stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ExecStart&lt;/code&gt; に指定しているスクリプトの中身は以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /usr/lib/lxd/lxd-bridge.start
#!/bin/sh -e

[ ! -e /etc/default/lxd-bridge ] &amp;amp;&amp;amp; exit 0

. /etc/default/lxd-bridge

# Start by bringing up the bridge
/usr/lib/lxd/lxd-bridge start

# Switch LXD in setup mode if needed
if [ &amp;quot;${UPDATE_PROFILE:-true}&amp;quot; = &amp;quot;true&amp;quot; ] &amp;amp;&amp;amp; [ -e &amp;quot;/var/lib/lxd&amp;quot; ] &amp;amp;&amp;amp; \
    ([ ! -e &amp;quot;/var/lib/lxd-bridge/timestamp&amp;quot; ] || \
     [ &amp;quot;/etc/default/lxd-bridge&amp;quot; -nt &amp;quot;/var/lib/lxd-bridge/timestamp&amp;quot; ]); then

    mkdir -p /var/lib/lxd-bridge
    touch /var/lib/lxd-bridge/timestamp

    touch /var/lib/lxd/.setup_mode
fi

exit 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここから呼ばれる &lt;code&gt;/usr/lib/lxd/lxd-bridge&lt;/code&gt; を見てみると、initスクリプトになっていて &lt;code&gt;iptables&lt;/code&gt;, &lt;code&gt;ip6tables&lt;/code&gt;, &lt;code&gt;dnsmasq&lt;/code&gt; を実行するようになっていました。また &lt;code&gt;/usr/lib/lxd/lxd-bridge&lt;/code&gt; は上記の &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; を読み込むようになっています。&lt;/p&gt;

&lt;p&gt;起動された &lt;code&gt;dnsmasq&lt;/code&gt; を &lt;code&gt;ps&lt;/code&gt; で見ると以下のようなコマンドラインになっていました。&lt;/p&gt;

&lt;p&gt;$ ps auxww | grep [d]nsmasq
  lxd       2134  0.0  0.0  49984   388 ?        S    09:48   0:00 dnsmasq -s lxd -S /lxd/ -u lxd &amp;ndash;strict-order &amp;ndash;bind-interfaces &amp;ndash;pid-file=/run/lxd-bridge//dnsmasq.pid &amp;ndash;dhcp-no-override &amp;ndash;except-interface=lo &amp;ndash;interface=lxdbr0 &amp;ndash;dhcp-leasefile=/var/lib/lxd-bridge//dnsmasq.lxdbr0.leases &amp;ndash;dhcp-authoritative &amp;ndash;listen-address 10.16.29.1 &amp;ndash;dhcp-range 10.16.29.2,10.16.29.254 &amp;ndash;dhcp-lease-max=252 &amp;ndash;dhcp-range=fd94:d372:e27f:2987::1,ra-only &amp;ndash;listen-address fd94:d372:e27f:2987::1&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/lib/lxd/lxd-bridge&lt;/code&gt; を見ると &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; の &lt;code&gt;LXD_CONFILE&lt;/code&gt; にファイル名を指定しておけば &lt;code&gt;dnsmasq&lt;/code&gt; の &lt;code&gt;--conf-file&lt;/code&gt; オプションを使ってそのファイルを読み込むように書かれています。この方法を使おうかと思ったのですが、一方で &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; の設定にかかわらず &lt;code&gt;--dhcp-authoritative&lt;/code&gt; オプションが常に指定されるように書かれています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;man dnsmasq&lt;/code&gt; によると &lt;code&gt;--dhcp-authoritative&lt;/code&gt; オプションはネットワーク内に他にDHCPサーバが無く唯一のDHCPになっているときに指定するオプションとのことです。ホストで稼働する &lt;code&gt;dnsmasq&lt;/code&gt; が1つという前提であれば、デフォルトの設定ファイル &lt;code&gt;/etc/dnsmasq.conf&lt;/code&gt; を作ってそこに設定を書くほうが手っ取り早いので、そうすることにしました。&lt;/p&gt;

&lt;h3 id=&#34;lxd-bridge-serviceの設定変更はreloadではなくrestartが必要&#34;&gt;lxd-bridge.serviceの設定変更はreloadではなくrestartが必要&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sudo systemctl reload lxd-bridge&lt;/code&gt; を実行してみると以下のようなエラーが出て失敗しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo systemctl reload lxd-bridge
Failed to reload lxd-bridge.service: Job type reload is not applicable for unit lxd-bridge.service.
See system logs and &#39;systemctl status lxd-bridge.service&#39; for details.
$ sudo systemctl status lxd-bridge
● lxd-bridge.service - LXD - network bridge
   Loaded: loaded (/lib/systemd/system/lxd-bridge.service; static; vendor preset: enabled)
   Active: active (exited) since 土 2016-05-07 13:06:06 JST; 6h ago
     Docs: man:lxd(1)
  Process: 3704 ExecStop=/usr/lib/lxd/lxd-bridge stop (code=exited, status=0/SUCCESS)
  Process: 3723 ExecStart=/usr/lib/lxd/lxd-bridge.start (code=exited, status=0/SUCCESS)
 Main PID: 3723 (code=exited, status=0/SUCCESS)
    Tasks: 1 (limit: 512)
   Memory: 412.0K
      CPU: 1.293s
   CGroup: /system.slice/lxd-bridge.service
           └─3755 dnsmasq -s lxd -S /lxd/ -u lxd --strict-order --bind-interfaces --pid-file=/run/lxd-bridge//dnsmasq.pid --dhcp-no-override --except-interface=lo --interface=lxdbr0 --dhcp-leasefile=/var/lib/lxd-bridge//dnsmasq.lxdbr0.leases --dhcp-authoritative --lis
 5月 07 18:56:28 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
 5月 07 19:06:21 express dnsmasq-dhcp[3755]: DHCPREQUEST(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7
 5月 07 19:06:21 express dnsmasq-dhcp[3755]: DHCPACK(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7 cent02
 5月 07 19:06:21 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
 5月 07 19:23:24 express dnsmasq-dhcp[3755]: DHCPREQUEST(lxdbr0) 10.155.92.101 00:16:3e:5f:01:7e
 5月 07 19:23:24 express dnsmasq-dhcp[3755]: DHCPACK(lxdbr0) 10.155.92.101 00:16:3e:5f:01:7e cent01
 5月 07 19:23:24 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
 5月 07 19:33:08 express dnsmasq-dhcp[3755]: DHCPREQUEST(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7
 5月 07 19:33:08 express dnsmasq-dhcp[3755]: DHCPACK(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7 cent02
 5月 07 19:33:08 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで、設定ファイルを変更反映するにも &lt;code&gt;sudo systemctl restart lxd-bridge&lt;/code&gt; のように再起動する必要があります。&lt;/p&gt;

&lt;h3 id=&#34;dnsmasqの再起動後-コンテナの再起動が必要&#34;&gt;dnsmasqの再起動後、コンテナの再起動が必要&lt;/h3&gt;

&lt;p&gt;dnsmasqを再起動しただけではコンテナのIPアドレスは変わらないのでネットワークを再起動する必要がありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc exec cent01 systemctl restart network
lxc exec cent02 systemctl restart network
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナごと再起動でも良いと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc restart cent01
lxc restart cent02
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何回か試してみたところ、作っただけで特に何もしてないコンテナだとネットワーク再起動よりコンテナ自体を再起動するほうが速かったです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time lxc exec cent02 systemctl restart network

real    0m2.878s
user    0m0.008s
sys     0m0.000s
$ time lxc restart cent02

real    0m1.236s
user    0m0.004s
sys     0m0.004s
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LXCの特定の1つのコンテナの起動状態をシェルスクリプトで確認したいときのお勧めの方法</title>
      <link>https://hnakamur.github.io/blog/2016/05/07/script-to-check-running-status-of-lxd-container/</link>
      <pubDate>Sat, 07 May 2016 14:12:49 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2016/05/07/script-to-check-running-status-of-lxd-container/</guid>
      <description>

&lt;h2 id=&#34;イマイチな方法1-lxc-listの出力をawkで加工&#34;&gt;イマイチな方法1: lxc listの出力をawkで加工&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lxc list -h&lt;/code&gt; を見ると &lt;code&gt;lxc list [resource] [filters] [--format table|json] [-c columns] [--fast]&lt;/code&gt; というコマンドラインになっていて、 &lt;code&gt;-c&lt;/code&gt; オプションで表示するカラムを指定可能です。&lt;/p&gt;

&lt;p&gt;例えば　以下のようにすれば &lt;code&gt;cent01&lt;/code&gt; コンテナの起動状態だけを表示できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c s cent01
+---------+
|  STATE  |
+---------+
| RUNNING |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、デフォルトの &lt;code&gt;--format table&lt;/code&gt; だとASCII文字の罫線が表示されるので、状態を抜き出すにはawkで加工する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c s cent01 | awk &#39;NR==4{print $2}&#39;
RUNNING
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;イマイチな方法2-lxc-list-format-jsonの出力をjqで加工&#34;&gt;イマイチな方法2: lxc list &amp;ndash;format jsonの出力をjqで加工&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;--format json&lt;/code&gt; でJSON形式で出力できるのですが、この場合は &lt;code&gt;-c&lt;/code&gt; オプションで項目を限定することは出来ませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list --format json -c s cent01
[{&amp;quot;architecture&amp;quot;:&amp;quot;x86_64&amp;quot;,&amp;quot;config&amp;quot;:{&amp;quot;volatile.base_image&amp;quot;:&amp;quot;a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2&amp;quot;,&amp;quot;volatile.eth0.hwaddr&amp;quot;:&amp;quot;00:16:3e:5f:01:7e&amp;quot;,&amp;quot;volatile.last_state.idmap&amp;quot;:&amp;quot;[{\&amp;quot;Isuid\&amp;quot;:true,\&amp;quot;Isgid\&amp;quot;:false,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\
&amp;quot;:65536},{\&amp;quot;Isuid\&amp;quot;:false,\&amp;quot;Isgid\&amp;quot;:true,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\&amp;quot;:65536}]&amp;quot;},&amp;quot;created_at&amp;quot;:&amp;quot;2016-05-06T18:56:46+09:00&amp;quot;,&amp;quot;devices&amp;quot;:{&amp;quot;root&amp;quot;:{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;disk&amp;quot;}},&amp;quot;ephemeral&amp;quot;:false,&amp;quot;expanded_config&amp;quot;:{&amp;quot;volatile.base_image&amp;quot;:&amp;quot;a027d59858d663fb2bc12b5ba767e9
2196a4aee8dbb2a607db53d718b91eb5d2&amp;quot;,&amp;quot;volatile.eth0.hwaddr&amp;quot;:&amp;quot;00:16:3e:5f:01:7e&amp;quot;,&amp;quot;volatile.last_state.idmap&amp;quot;:&amp;quot;[{\&amp;quot;Isuid\&amp;quot;:true,\&amp;quot;Isgid\&amp;quot;:false,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\&amp;quot;:65536},{\&amp;quot;Isuid\&amp;quot;:false,\&amp;quot;Isgid\&amp;quot;:true,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\&amp;quot;:65536}
]&amp;quot;},&amp;quot;expanded_devices&amp;quot;:{&amp;quot;eth0&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;eth0&amp;quot;,&amp;quot;nictype&amp;quot;:&amp;quot;bridged&amp;quot;,&amp;quot;parent&amp;quot;:&amp;quot;lxdbr0&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;nic&amp;quot;},&amp;quot;root&amp;quot;:{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;disk&amp;quot;}},&amp;quot;name&amp;quot;:&amp;quot;cent01&amp;quot;,&amp;quot;profiles&amp;quot;:[&amp;quot;default&amp;quot;],&amp;quot;stateful&amp;quot;:false,&amp;quot;status&amp;quot;:&amp;quot;Running&amp;quot;,&amp;quot;status_code&amp;quot;:103,&amp;quot;state&amp;quot;:null,&amp;quot;snapshots&amp;quot;:null}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sudo apt install jq&lt;/code&gt; で &lt;code&gt;jq&lt;/code&gt; コマンドをインストールして、それで状態を抜き出すことは可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list --format json cent01 | jq -r &#39;.[0].status&#39;
Running
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;お勧めの方法-lxc-infoの出力をawkで加工&#34;&gt;お勧めの方法: lxc infoの出力をawkで加工&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lxc list&lt;/code&gt; の場合は指定した文字列は完全一致ではなくて前方一致で表示されました。上記の例のように &lt;code&gt;cent01&lt;/code&gt; と &lt;code&gt;cent02&lt;/code&gt; の2つのコンテナがあるときに、 &lt;code&gt;lxc list -c s cent0&lt;/code&gt; と実行すると以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c s cent0
+---------+
|  STATE  |
+---------+
| RUNNING |
+---------+
| RUNNING |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだとどの行がどのコンテナかわからないのでコンテナ名の列も付ける必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c ns cent0
+--------+---------+
|  NAME  |  STATE  |
+--------+---------+
| cent01 | RUNNING |
+--------+---------+
| cent02 | RUNNING |
+--------+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この結果をawkで加工するのでも良いのですが、もっと良いのは &lt;code&gt;lxc info&lt;/code&gt; コマンドを使うことです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc info cent01
コンテナ名: cent01
アーキテクチャ: x86_64
作成日時: 2016/05/06 09:56 UTC
状態: Running
タイプ: persistent
プロファイル: default
Pid: 29354
IPアドレス:
  eth0: inet    10.155.92.101   vethG4XSE4
  eth0: inet6   fe80::216:3eff:fe5f:17e vethG4XSE4
  lo:   inet    127.0.0.1
  lo:   inet6   ::1
リソース:
  プロセス数: 10
  メモリ消費量:
    メモリ (現在値): 23.60MB
    メモリ (ピーク): 43.08MB
  ネットワーク使用状況:
    eth0:
      受信バイト数: 24.16kB
      送信バイト数: 8.06kB
      受信パケット: 232
      送信パケット: 88
    lo:
      受信バイト数: 0 bytes
      送信バイト数: 0 bytes
      受信パケット: 0
      送信パケット: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存在しないコンテナ名を指定するとエラーになります。これは標準エラー出力に出力されています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc info hoge
エラー: not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;シェルスクリプトで加工するには英語出力のほうが良いので &lt;code&gt;LANG=C&lt;/code&gt; 付きで実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ LANG=C lxc info cent01
Name: cent01
Architecture: x86_64
Created: 2016/05/06 09:56 UTC
Status: Running
Type: persistent
Profiles: default
Pid: 29354
Ips:
  eth0: inet    10.155.92.101   vethG4XSE4
  eth0: inet6   fe80::216:3eff:fe5f:17e vethG4XSE4
  lo:   inet    127.0.0.1
  lo:   inet6   ::1
Resources:
  Processes: 10
  Memory usage:
    Memory (current): 23.60MB
    Memory (peak): 43.08MB
  Network usage:
    eth0:
      Bytes received: 24.58kB
      Bytes sent: 8.56kB
      Packets received: 235
      Packets sent: 93
    lo:
      Bytes received: 0 bytes
      Bytes sent: 0 bytes
      Packets received: 0
      Packets sent: 0
$ LANG=C lxc info hoge
error: not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結局以下のように実行するのがお勧めです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ LANG=C lxc info cent01 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;
Running
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存在しない場合は空文字列になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ LANG=C lxc info hoge 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判定例はこんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ [ x`LANG=C lxc info cent01 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;` == xRunning ] &amp;amp;&amp;amp; echo &amp;quot;container is running&amp;quot;
container is running
$ [ x`LANG=C lxc info hoge 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;` == xRunning ] &amp;amp;&amp;amp; echo &amp;quot;container is running&amp;quot;
$
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04 LTSでLXD 2.0をセットアップして使ってみる</title>
      <link>https://hnakamur.github.io/blog/2016/05/07/start-using-lxd-2.0-on-ubuntu-16.04/</link>
      <pubDate>Sat, 07 May 2016 14:12:49 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2016/05/07/start-using-lxd-2.0-on-ubuntu-16.04/</guid>
      <description>

&lt;h2 id=&#34;参考記事&#34;&gt;参考記事&lt;/h2&gt;

&lt;p&gt;公式ドキュメントの&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/getting-started-cli/&#34;&gt;Linux Containers - LXD - はじめに - コマンドライン&lt;/a&gt;によくまとまっているのですが、より詳細には &lt;a href=&#34;http://insights.ubuntu.com/2016/03/14/the-lxd-2-0-story-prologue/&#34;&gt;The LXD 2.0 Story (Prologue) | Ubuntu Insights&lt;/a&gt; にリストアップされている記事がわかりやすかったです。&lt;/p&gt;

&lt;h3 id=&#34;ubuntu-16-04-serverでのlxdの初期セットアップ&#34;&gt;Ubuntu 16.04 serverでのLXDの初期セットアップ&lt;/h3&gt;

&lt;p&gt;Ubuntu 16.04 serverならLXDはインストール済みなので、 &lt;code&gt;apt-get install lxd&lt;/code&gt; と &lt;code&gt;newgrp lxd&lt;/code&gt; は不要でした。&lt;/p&gt;

&lt;p&gt;LXCではコンテナ一覧表示は &lt;code&gt;lxc-ls&lt;/code&gt;、コンテナ作成は &lt;code&gt;lxc-create&lt;/code&gt; のように別々のコマンドになっていましたが、 LXDではそれぞれ &lt;code&gt;lxc list&lt;/code&gt;, &lt;code&gt;lxc launch&lt;/code&gt; と &lt;code&gt;lxc&lt;/code&gt; コマンドのサブコマンドになっています。&lt;/p&gt;

&lt;p&gt;また &lt;code&gt;lxd&lt;/code&gt; というプログラムもあります。 &lt;code&gt;man lxd&lt;/code&gt; と &lt;code&gt;man lxc&lt;/code&gt; してみると &lt;code&gt;lxd&lt;/code&gt; はコンテナのハイパーバイザのデーモンで、 &lt;code&gt;lxc&lt;/code&gt; はコンテナのハイパーバイザのクライアントです。&lt;/p&gt;

&lt;p&gt;まずバージョンを確認してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxd --version
2.0.0
$ lxc --version
2.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、 &lt;code&gt;lxc&lt;/code&gt; のほうは &lt;code&gt;lxc version&lt;/code&gt; と &lt;code&gt;version&lt;/code&gt; サブコマンドも用意されていますが、 &lt;code&gt;lxd version&lt;/code&gt; は &lt;code&gt;error: Unknown arguments&lt;/code&gt; とエラーになりました。&lt;/p&gt;

&lt;p&gt;コンテナ一覧を表示してみます。まだ1つもコンテナを作っていないので一覧は空です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
Generating a client certificate. This may take a minute...
If this is your first time using LXD, you should also run: sudo lxd init

+------+-------+------+------+------+-----------+
| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |
+------+-------+------+------+------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lxc list&lt;/code&gt; の出力の1行目にある通り、初回実行時にはクライアント証明書が生成されます。 &lt;code&gt;~/.config/lxc/client.key&lt;/code&gt; に秘密鍵、 &lt;code&gt;~/.config/lxc/client.crt&lt;/code&gt; に証明書が作られました。&lt;/p&gt;

&lt;p&gt;また、 &lt;code&gt;lxc list&lt;/code&gt; の出力の2行目に LXDを初めて使うときは &lt;code&gt;sudo lxd init&lt;/code&gt; を実行するようにも書かれていますので、実行します。&lt;/p&gt;

&lt;p&gt;すると、いくつか質問されるので入力していきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lxd init
sudo: unable to resolve host ubuntu-xenial
Name of the storage backend to use (dir or zfs): dir
Would you like LXD to be available over the network (yes/no)? no
Do you want to configure the LXD bridge (yes/no)? yes
Warning: Stopping lxd.service, but it can still be activated by:
  lxd.socket
LXD has been successfully configured.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1つ目はストレージバックアップの選択です。選択肢は &lt;code&gt;dir&lt;/code&gt; か &lt;code&gt;zfs&lt;/code&gt; ですが、上記では &lt;code&gt;dir&lt;/code&gt; にしました。&lt;/p&gt;

&lt;p&gt;2つ目はLXDをネットワーク越しで利用するかどうかです。上記では &lt;code&gt;no&lt;/code&gt; にしました。
すると上記の警告にあるとおり &lt;code&gt;lxd.service&lt;/code&gt; が停止されました。 &lt;code&gt;sudo systemctl status lxd&lt;/code&gt; で確認すると &lt;code&gt;Active:&lt;/code&gt; の右が &lt;code&gt;inactive (dead)&lt;/code&gt; になっていました。&lt;/p&gt;

&lt;p&gt;一方で、 &lt;code&gt;lxd.socket&lt;/code&gt; は稼働しています。 &lt;code&gt;sudo systemctl status lxd.socket&lt;/code&gt; で確認すると &lt;code&gt;Active:&lt;/code&gt; の右が &lt;code&gt;active (running)&lt;/code&gt; になっていました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/lib/systemd/system/lxd.socket&lt;/code&gt; を見ると &lt;code&gt;/var/lib/lxd/unix.socket&lt;/code&gt; というファイル名でUnixドメインソケットが作られていることがわかりました。&lt;/p&gt;

&lt;p&gt;3つ目はLXDのブリッジを設定するかどうかです。上記は &lt;code&gt;yes&lt;/code&gt; にしました。すると CUI でダイアログが次々開いて DHCPで発行するIPv4やIPv6のアドレスの範囲などを聞かれるので、順次入力していきます。ランダムなアドレスの範囲が事前入力されているので、特に変更不要な場合はenterキーを連打していけばOKでした。&lt;/p&gt;

&lt;p&gt;再度 &lt;code&gt;lxc list&lt;/code&gt; を実行してみると、今度はクライアント証明書を生成したとか、 &lt;code&gt;sudo lxc init&lt;/code&gt; を実行せよとかの文言は表示されなくなりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+------+-------+------+------+------+-----------+
| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |
+------+-------+------+------+------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;別パターンの初期化の検証&#34;&gt;別パターンの初期化の検証&lt;/h4&gt;

&lt;p&gt;このパターンではLXDをネットワーク越しに使うかの質問に &lt;code&gt;yes&lt;/code&gt; と答えました。すると、バインドするアドレスとポートを聞かれます。ポートは &lt;code&gt;8443&lt;/code&gt; がお勧めと書かれていますが、enterキー空打ちではだめで、ちゃんと値を入力する必要がありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lxd init
sudo: unable to resolve host ubuntu-xenial
Name of the storage backend to use (dir or zfs): dir
Would you like LXD to be available over the network (yes/no)? yes
Address to bind LXD to (not including port): 0.0.0.0
Port to bind LXD to (8443 recommended):
Invalid input, try again.

Port to bind LXD to (8443 recommended): 8443
Trust password for new clients:
Again:
Do you want to configure the LXD bridge (yes/no)? no
LXD has been successfully configured.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この設定の後に &lt;code&gt;sudo systemctl status lxd&lt;/code&gt; を実行すると &lt;code&gt;Active:&lt;/code&gt; の右は &lt;code&gt;active (running)&lt;/code&gt; になっていました。&lt;/p&gt;

&lt;p&gt;また、上記ではLXDブリッジを設定するかの質問に &lt;code&gt;no&lt;/code&gt; と答えてみました。この場合は CUIのダイアログは開かれず、すぐに &lt;code&gt;LXD has been successfully configured.&lt;/code&gt; が表示されて完了しました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ip a&lt;/code&gt; で確認すると、この場合も &lt;code&gt;lxdbr0&lt;/code&gt; というネットワークインターフェース自体は作成されていました。ただし、IPアドレスは設定されていない状態です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ip a
...(略)...
4: lxdbr0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN group default qlen 1000
    link/ether 0a:b4:d4:fa:b3:71 brd ff:ff:ff:ff:ff:ff
    inet6 fe80::8b4:d4ff:fefa:b371/64 scope link
       valid_lft forever preferred_lft forever
    inet6 fe80::1/64 scope link
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、その後 &lt;code&gt;lxc launch&lt;/code&gt; でコンテナを起動した後再度確認すると &lt;code&gt;lxdbr0&lt;/code&gt; の左の番号が &lt;code&gt;4:&lt;/code&gt; から &lt;code&gt;5:&lt;/code&gt; に変わっていて、IPv4アドレスも設定されていました。また &lt;code&gt;lxc.service&lt;/code&gt; も起動していました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo ss -antp&lt;/code&gt; で確認したところ、LXDをネットワーク越しに使う設定を &lt;code&gt;yes&lt;/code&gt; にしたときは &lt;code&gt;lxd&lt;/code&gt; のプロセスが指定したポート（上記の例では8443番ポート）をLISTENしていますが、 &lt;code&gt;no&lt;/code&gt; にしたときはLISTENしていませんでした。&lt;/p&gt;

&lt;h3 id=&#34;リモートとローカルのイメージ一覧表示&#34;&gt;リモートとローカルのイメージ一覧表示&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;lxc image&lt;/code&gt; サブコマンドでイメージを取り扱います。 &lt;code&gt;lxc image -h&lt;/code&gt; と入力すると使用方法が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lxc image list&lt;/code&gt; の説明の部分を以下に引用します。 &lt;code&gt;LANG&lt;/code&gt; 環境変数が &lt;code&gt;ja_JP.UTF8&lt;/code&gt; ならヘルプメッセージは日本語で表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc image list [remote:] [filter]
    LXD のイメージストア内のイメージを一覧表示します。プロパティでフィルタ
    を行う場合は、フィルタは &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; の形になります。フィルタはイメー
    ジハッシュの一部やイメージエイリアス名の一部も指定できます。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;英語のヘルプメッセージを見たい場合は &lt;code&gt;LANG=C&lt;/code&gt; をつけて &lt;code&gt;LANG=C lxc image&lt;/code&gt; のように実行すればOKです。 &lt;code&gt;lxc image list&lt;/code&gt; の英語ヘルプメッセージを以下に引用します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc image list [remote:] [filter]
    List images in the LXD image store. Filters may be of the
    &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; form for property based filtering, or part of the image
    hash or part of the image alias name.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リモートのイメージ一覧は &lt;code&gt;lxc image list images:&lt;/code&gt; で表示できます。最後の &lt;code&gt;:&lt;/code&gt; はリモートの指定か区別するために必要です。&lt;/p&gt;

&lt;p&gt;ローカルのイメージ一覧は &lt;code&gt;lxc image list&lt;/code&gt; で表示できます。1つもコンテナを作っていない時は空になります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[remote:]&lt;/code&gt; の部分に指定可能なリモートの一覧は &lt;code&gt;lxc remote list&lt;/code&gt; で確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc remote list
+-----------------+------------------------------------------+---------------+--------+--------+
|      NAME       |                   URL                    |   PROTOCOL    | PUBLIC | STATIC |
+-----------------+------------------------------------------+---------------+--------+--------+
| images          | https://images.linuxcontainers.org       | lxd           | YES    | NO     |
+-----------------+------------------------------------------+---------------+--------+--------+
| local (default) | unix://                                  | lxd           | NO     | YES    |
+-----------------+------------------------------------------+---------------+--------+--------+
| ubuntu          | https://cloud-images.ubuntu.com/releases | simplestreams | YES    | YES    |
+-----------------+------------------------------------------+---------------+--------+--------+
| ubuntu-daily    | https://cloud-images.ubuntu.com/daily    | simplestreams | YES    | YES    |
+-----------------+------------------------------------------+---------------+--------+--------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フィルタを指定してリモートのcentosのイメージ一覧を表示すると以下の3つがヒットしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc image list images: centos
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
|          ALIAS          | FINGERPRINT  | PUBLIC |            DESCRIPTION            |  ARCH  |  SIZE   |         UPLOAD DATE         |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| centos/6/amd64 (1 more) | 81c42e7d8c4e | yes    | Centos 6 (amd64) (20160507_02:16) | x86_64 | 52.23MB | May 7, 2016 at 3:15am (UTC) |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| centos/6/i386 (1 more)  | 74c61c775024 | yes    | Centos 6 (i386) (20160507_02:16)  | i686   | 52.16MB | May 7, 2016 at 3:16am (UTC) |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| centos/7/amd64 (1 more) | 9c8a52ca68e4 | yes    | Centos 7 (amd64) (20160507_02:16) | x86_64 | 62.93MB | May 7, 2016 at 3:16am (UTC) |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;centos-7のコンテナを起動してみる&#34;&gt;CentOS 7のコンテナを起動してみる&lt;/h3&gt;

&lt;p&gt;起動に使用するのは &lt;code&gt;lxc launch&lt;/code&gt; サブコマンドです。 &lt;code&gt;lxc launch -h&lt;/code&gt; でヘルプが見られます。&lt;/p&gt;

&lt;p&gt;ここでは &lt;code&gt;images&lt;/code&gt; のリモートの &lt;code&gt;centos/7/amd64&lt;/code&gt; のエイリアスのイメージを起動して &lt;code&gt;cent01&lt;/code&gt; というコンテナ名を付けてみます。どれぐらい時間がかかるか計測するため &lt;code&gt;time&lt;/code&gt; コマンドを付けて実行してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time lxc launch images:centos/7/amd64 cent01
Creating cent01
Retrieving image: 100%
Starting cent01

real    0m58.036s
user    0m0.056s
sys     0m0.036s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Retrieving image: 100%&lt;/code&gt; と表示されているように初回はイメージのダウンロードを行うので少し時間がかかります。私の環境では1分弱でした。&lt;/p&gt;

&lt;p&gt;起動直後に &lt;code&gt;lxc list&lt;/code&gt; を実行すると、 IPv6アドレスは付与されていますが、 IPv4アドレスはまだ空です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  | IPV4 |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING |      | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数秒立ってから再度実行するとIPv4アドレスが付与されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  |         IPV4         |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING | 10.64.177.167 (eth0) | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この時点でローカルのイメージ一覧を表示してみると、CentOS 7のイメージが追加されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc image list
+-------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| ALIAS | FINGERPRINT  | PUBLIC |            DESCRIPTION            |  ARCH  |  SIZE   |         UPLOAD DATE         |
+-------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
|       | 9c8a52ca68e4 | no     | Centos 7 (amd64) (20160507_02:16) | x86_64 | 62.93MB | May 7, 2016 at 7:13am (UTC) |
+-------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じイメージで2つめのコンテナを起動してみると今度はローカルのイメージを使うので起動時間は短くてすみました。私の環境では約10秒でした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time lxc launch images:centos/7/amd64 cent02
Creating cent02
Starting cent02

real    0m10.189s
user    0m0.044s
sys     0m0.008s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動直後にコンテナ一覧を確認すると、今起動した &lt;code&gt;cent02&lt;/code&gt; コンテナのIPv4アドレスはやはり空です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  |         IPV4         |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING | 10.64.177.167 (eth0) | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent02 | RUNNING |                      | fd36:b946:6537:931e:216:3eff:fe18:680a (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数秒立ってから再度確認すると &lt;code&gt;centos02&lt;/code&gt; コンテナにもIPv4アドレスが付与されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  |         IPV4         |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING | 10.64.177.167 (eth0) | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent02 | RUNNING | 10.64.177.34 (eth0)  | fd36:b946:6537:931e:216:3eff:fe18:680a (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;コンテナ内でコマンドを実行する&#34;&gt;コンテナ内でコマンドを実行する&lt;/h3&gt;

&lt;p&gt;例えば &lt;code&gt;cent01&lt;/code&gt; コンテナで &lt;code&gt;bash&lt;/code&gt; を起動するには &lt;code&gt;lxc exec cent01 bash&lt;/code&gt; と実行します。するとコンテナ内で root ユーザになってプロンプトが表示されるので、好きなコマンドを入力して実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc exec cent01 bash
[root@cent01 ~]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
37: eth0@if38: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP qlen 1000
    link/ether 00:16:3e:5f:01:7e brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 10.155.92.101/24 brd 10.155.92.255 scope global dynamic eth0
       valid_lft 2508sec preferred_lft 2508sec
    inet6 fe80::216:3eff:fe5f:17e/64 scope link
       valid_lft forever preferred_lft forever
[root@cent01 ~]# ping -c 3 cent02
PING cent02.lxd (10.64.177.34) 56(84) bytes of data.
64 bytes from cent02.lxd (10.64.177.34): icmp_seq=1 ttl=64 time=0.034 ms
64 bytes from cent02.lxd (10.64.177.34): icmp_seq=2 ttl=64 time=0.068 ms
64 bytes from cent02.lxd (10.64.177.34): icmp_seq=3 ttl=64 time=0.081 ms

--- cent02.lxd ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1998ms
rtt min/avg/max/mdev = 0.034/0.061/0.081/0.019 ms
[root@cent01 ~]# exit
exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記の &lt;code&gt;ping&lt;/code&gt; の例でも分かる通り、コンテナ内から別のコンテナの名前を指定して通信可能です。 &lt;code&gt;ping&lt;/code&gt; の出力を見ると &lt;code&gt;.lxd&lt;/code&gt; というトップレベルドメインがつけられていて、 &lt;code&gt;ping -c 3 cent02.lxd&lt;/code&gt; でも大丈夫でした。この &lt;code&gt;.lxd&lt;/code&gt; という値は &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; の &lt;code&gt;LXD_DOMAIN=&amp;quot;lxd&amp;quot;&lt;/code&gt; という設定で指定されています。&lt;/p&gt;

&lt;p&gt;Control-Dを押すか、&lt;code&gt;exit&lt;/code&gt; に続いてenterキーで &lt;code&gt;bash&lt;/code&gt; から抜けます。&lt;/p&gt;

&lt;p&gt;単一のコマンドを実行したい場合は &lt;code&gt;bash&lt;/code&gt; の代わりにコマンドを書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc exec cent01 ls /
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドにオプションを指定するとエラーになりますが、コマンドの前に &lt;code&gt;--&lt;/code&gt; を入れれば大丈夫です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc exec cent01 ls -a /
error: flag provided but not defined: -a
$ lxc exec cent01 -- ls -a /
.  ..  .autorelabel  bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ホストosを再起動するとコンテナは自動起動されます&#34;&gt;ホストOSを再起動するとコンテナは自動起動されます&lt;/h2&gt;

&lt;p&gt;LXCではホストOS起動時にコンテナを自動起動するには設定ファイルの編集が必要でしたが、LXDは特に設定は不要でした。　
ホストOSを再起動して &lt;code&gt;lxc list&lt;/code&gt; を実行してみると上記で作成した2つのコンテナのSTATEがRUNNINGになっていました。&lt;/p&gt;

&lt;h2 id=&#34;コンテナの停止と削除&#34;&gt;コンテナの停止と削除&lt;/h2&gt;

&lt;p&gt;停止は &lt;code&gt;lxc stop コンテナ名&lt;/code&gt; 、削除は &lt;code&gt;lxc delete コンテナ名&lt;/code&gt; で出来ます。が、 CentOS 7 のコンテナを停止するには以下の事前準備が必要でした。&lt;/p&gt;

&lt;h3 id=&#34;centos-7-のコンテナを停止可能にするための設定&#34;&gt;CentOS 7 のコンテナを停止可能にするための設定&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;cent01&lt;/code&gt; のところは実際のコンテナ名に置き換えて、各コンテナで実行が必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc exec cent01 -- sh -c &#39;ln -s /usr/lib/systemd/system/halt.target /etc/systemd/system/sigpwr.target &amp;amp;&amp;amp; systemctl daemon-reload&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この回避方法は &lt;a href=&#34;https://lists.linuxcontainers.org/pipermail/lxc-users/2014-February/006304.html&#34;&gt;[lxc-users] lxc-stop doesn&amp;rsquo;t stop centos, waits for the timeout&lt;/a&gt; で紹介されていました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lists.linuxcontainers.org/pipermail/lxc-users/2016-May/011602.html&#34;&gt;[lxc-users] lxc stop does not stop a CentOS 7 container&lt;/a&gt; で &lt;code&gt;images:&lt;/code&gt; で公開しているイメージにこの修正を取り込めないか問い合わせ中です。&lt;/p&gt;

&lt;h2 id=&#34;コンテナやイメージのファイルの在り処&#34;&gt;コンテナやイメージのファイルの在り処&lt;/h2&gt;

&lt;p&gt;コンテナのファイルは &lt;code&gt;/var/lib/lxd/containers/&lt;/code&gt; にありました。操作しているユーザのuidとgidは1000なのですが、コンテナのディレクトリは100000と異なっていました。どこかでマッピングを持っているのだと思いますが、未調査です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ls -l /var/lib/lxd/containers/
合計 24
drwxr-xr-x+ 4 100000 100000  4096  5月  6 18:56 cent01
drwxr-xr-x+ 4 100000 100000  4096  5月  7 03:18 cent02
-rw-r--r--  1 root   root   10756  5月  7 19:47 lxc-monitord.log
drwxr-xr-x+ 4 100000 100000  4096  5月  3 20:46 my-ubuntu
$ sudo ls -l /var/lib/lxd/containers/cent01
合計 12
-rw-r--r--  1 root   root    628  1月  1  1970 metadata.yaml
dr-xr-xr-x 18 100000 100000 4096  5月  6 18:56 rootfs
drwxr-xr-x  2 root   root   4096  5月  6 18:56 templates
1$ sudo ls -l /var/lib/lxd/containers/cent01/rootfs/
合計 64
lrwxrwxrwx  1 100000 100000    7  5月  6 11:25 bin -&amp;gt; usr/bin
dr-xr-xr-x  2 100000 100000 4096  8月 12  2015 boot
drwxr-xr-x  4 100000 100000 4096  5月  6 11:25 dev
drwxr-xr-x 55 100000 100000 4096  5月  7 12:13 etc
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 home
lrwxrwxrwx  1 100000 100000    7  5月  6 11:25 lib -&amp;gt; usr/lib
lrwxrwxrwx  1 100000 100000    9  5月  6 11:25 lib64 -&amp;gt; usr/lib64
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 media
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 mnt
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 opt
dr-xr-xr-x  2 100000 100000 4096  8月 12  2015 proc
dr-xr-x---  3 100000 100000 4096  5月  7 03:42 root
drwxr-xr-x  7 100000 100000 4096  5月  6 11:25 run
lrwxrwxrwx  1 100000 100000    8  5月  6 11:25 sbin -&amp;gt; usr/sbin
drwxr-xr-x  2 100000 100000 4096  5月  6 11:25 selinux
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 srv
dr-xr-xr-x  2 100000 100000 4096  8月 12  2015 sys
drwxrwxrwt  7 100000 100000 4096  5月  7 12:54 tmp
drwxr-xr-x 13 100000 100000 4096  5月  6 11:25 usr
drwxr-xr-x 19 100000 100000 4096  5月  6 18:56 var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イメージのファイルは &lt;code&gt;/var/lib/lxd/images/&lt;/code&gt; にありました。 &lt;code&gt;lxc image list&lt;/code&gt; で表示されるフィンガープリント名のファイルとフィンガープリントに &lt;code&gt;.rootfs&lt;/code&gt; を追加した名前のファイルがあります。調べてみるとtar.xz形式のファイルになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ls -l /var/lib/lxd/images/
合計 205244
-rw-r--r-- 1 root root       588  5月  6 18:54 a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2
-rw-r--r-- 1 root root  65931516  5月  6 18:55 a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs
-rw-r--r-- 1 root root       792  5月  3 20:32 f4c4c60a6b752a381288ae72a1689a9da00f8e03b732c8d1b8a8fcd1a8890800
-rw-r--r-- 1 root root 144223868  5月  3 20:46 f4c4c60a6b752a381288ae72a1689a9da00f8e03b732c8d1b8a8fcd1a8890800.rootfs
$ sudo file /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2
/var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2: XZ compressed data
$ sudo file /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs
/var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs: XZ compressed data
$ sudo tar tvf /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2
-rw-r--r-- 0/0             239 1970-01-01 09:00 templates/hosts.tpl
-rw-r--r-- 0/0             628 1970-01-01 09:00 metadata.yaml
-rw-r--r-- 0/0              21 1970-01-01 09:00 templates/hostname.tpl
$ sudo tar tvf /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs | head
dr-xr-xr-x 0/0               0 2016-05-06 11:25 ./
drwxr-xr-x 0/0               0 2016-05-06 11:25 ./dev/
crw-rw-rw- 0/0             5,2 2016-05-06 11:25 ./dev/ptmx
prw------- 0/0               0 2016-05-06 11:25 ./dev/initctl
crw-rw-rw- 0/0             1,7 2016-05-06 11:25 ./dev/full
crw------- 0/0             5,1 2016-05-06 11:25 ./dev/console
crw-rw-rw- 0/0             4,4 2016-05-06 11:25 ./dev/tty4
crw-rw-rw- 0/0             4,3 2016-05-06 11:25 ./dev/tty3
crw-rw-rw- 0/0             4,2 2016-05-06 11:25 ./dev/tty2
crw-rw-rw- 0/0             4,1 2016-05-06 11:25 ./dev/tty1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/var/lib/lxd/&lt;/code&gt; には他にもディレクトリやファイルが存在しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l /var/lib/lxd
合計 84
drwx--x--x 5 root root  4096  5月  7 12:54 containers
drwx--x--x 5 root root  4096  5月  7 12:54 devices
drwxr-xr-x 2 root root  4096  5月  7 19:41 devlxd
drwx------ 2 root root  4096  5月  7 06:13 images
-rw-r--r-- 1 root root 43008  5月  7 19:46 lxd.db
drwx------ 4 root root  4096  5月  3 20:46 security
-rw-r--r-- 1 root root  2004  5月  3 20:26 server.crt
-rw------- 1 root root  3247  5月  3 20:26 server.key
drwx--x--x 5 root root  4096  5月  7 12:54 shmounts
drwx------ 2 root root  4096  5月  3 20:26 snapshots
srw-rw---- 1 root lxd      0  5月  7 12:51 unix.socket
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04 LTSでLXD 2.0を試してみた</title>
      <link>https://hnakamur.github.io/blog/2016/05/07/tried-lxd-2.0-on-ubuntu-16.04/</link>
      <pubDate>Sat, 07 May 2016 14:12:49 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2016/05/07/tried-lxd-2.0-on-ubuntu-16.04/</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2016/04/19/run_centos7_containers_on_lxc2/&#34;&gt;LXC 2.0でCentOS 7のコンテナを動かしてみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;でLXC 2.0を試しましたが、今度はLXD 2.0を試してみました。&lt;/p&gt;

&lt;p&gt;実は私は、コンテナをローカルホストでしか動かさないならLXC、リモートホストでも動かすならLXDという使い分けなのかなと漠然と思っていました。&lt;/p&gt;

&lt;p&gt;上記の記事ではrootユーザでコンテナを作成するという特権コンテナについて書きましたが、非rootユーザでコンテナを作成する非特権コンテナについては書いていませんでした。&lt;/p&gt;

&lt;p&gt;実は CentOS 7 の非特権コンテナも試していたのですが、 DHCP で IPアドレスが付与されないという現象が起きていました。私の当面の用途は開発環境構築でありホストOS側でroot権限はあることが前提なので非特権コンテナは調査しないことにしました。&lt;/p&gt;

&lt;p&gt;一方、LXDはデフォルトで非特権コンテナを作るようになっています。今回試してみたところ、 CentOS 7 のコンテナも DHCP で無事 IPアドレスが付与されました。&lt;/p&gt;

&lt;p&gt;root権限を使うのは必要最小限にするのが望ましいので、この状況を見ると今後新規に環境構築するならLXCよりもLXDを使うほうが良いかなと思います。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;a href=&#34;https://github.com/lxc/lxd&#34;&gt;https://github.com/lxc/lxd&lt;/a&gt; によると、LXD は lex-dee と発音するそうです。カタカナで書くとレックスディーもしくはレクスディーでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;記事リスト&#34;&gt;記事リスト&lt;/h2&gt;

&lt;p&gt;いろいろ試していたら記事が長くなってきたので分割しました。例によって他の方に向けた入門記事ではなく、自分用の調査メモです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2016/05/07/start-using-lxd-2.0-on-ubuntu-16.04/&#34;&gt;Ubuntu 16.04 LTSでLXD 2.0をセットアップして使ってみる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2016/05/07/script-to-check-running-status-of-lxd-container/&#34;&gt;LXCの特定の1つのコンテナの起動状態をシェルスクリプトで確認したいときのお勧めの方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2016/05/07/how-to-use-fixed-ip-address-for-a-lxd-container/&#34;&gt;LXDコンテナで固定IPアドレスを使うための設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2016/05/07/tried-ansible-lxd-connection-plugin/&#34;&gt;AnsibleのLXDコネクションプラグインを試してみた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2016/05/07/tried-lxd-rest-api-with-curl/&#34;&gt;LXDのREST APIをcurlで試してみた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2016/05/07/tried-pylxd/&#34;&gt;LXDのREST APIクライアントライブラリpylxdを試してみた&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なお、記事によってコンテナのIPアドレスのネットワークが違う場合がありますが、何回か環境を作りなおして毎回ランダムなネットワークを使っているためなので気にしないでください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LXD 0.7ではlxc execでシェルの対話操作もできるようになっていました</title>
      <link>https://hnakamur.github.io/blog/2015/04/23/try-lxd-0.7-with-vagrant/</link>
      <pubDate>Thu, 23 Apr 2015 00:08:30 +0900</pubDate>
      
      <guid>https://hnakamur.github.io/blog/2015/04/23/try-lxd-0.7-with-vagrant/</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://hnakamur.github.io/blog/blog/2014/12/01/lxd-the-linux-container-daemon/&#34;&gt;LXDを試してみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;の記事を書いて以来、LXD触る時間を作れてなかったのですが、久々に試してみました。&lt;/p&gt;

&lt;p&gt;今では&lt;a href=&#34;https://github.com/lxc/lxd&#34;&gt;lxc/lxd&lt;/a&gt;にVagrantfileが同梱されているので、それを使うだけで簡単に試せます。&lt;/p&gt;

&lt;p&gt;VirtualBox 4.3.26, Vagrant 1.7.2, OS X Yosemiteという環境で試しました。&lt;/p&gt;

&lt;h2 id=&#34;操作手順&#34;&gt;操作手順&lt;/h2&gt;

&lt;h3 id=&#34;vagrantでvmを起動&#34;&gt;VagrantでVMを起動&lt;/h3&gt;

&lt;p&gt;まずOS X上で以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/lxc/lxd
cd lxd
vagrant up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lxc/lxd/blob/lxd-0.7/Vagrantfile&#34;&gt;Vagrantfile&lt;/a&gt;を見てみると、Vagrantのシェルプロビジョナでgoとlxdをインストールするようになっています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lxc/lxd/blob/lxd-0.7/scripts/vagrant/install-lxd.sh&#34;&gt;lxd/install-lxd.sh at lxd-0.7 · lxc/lxd&lt;/a&gt;を見てみると、&lt;a href=&#34;https://github.com/lxc/lxd&#34;&gt;lxdのREADME&lt;/a&gt;と同様のセットアップ手順に加えてlxdをサービスとして登録して起動する処理まで含まれています。&lt;/p&gt;

&lt;h3 id=&#34;vmにログインしてlxcコマンドを試してみる&#34;&gt;VMにログインしてlxcコマンドを試してみる&lt;/h3&gt;

&lt;p&gt;以下のコマンドを実行してVMにログインします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以降のコマンドはVM上で実行します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lxc&lt;/code&gt; と &lt;code&gt;lxd&lt;/code&gt; にはPATHが通った状態になっていることを確認しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ which lxc
/home/vagrant/go/bin/lxc
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ which lxd
/home/vagrant/go/bin/lxd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バージョンを確認してみると、 &lt;code&gt;lxc&lt;/code&gt;, &lt;code&gt;lxd&lt;/code&gt; ともに0.7でした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxd --version
0.7
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc --version
0.7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lxc/lxd#first-steps&#34;&gt;lxdのREADMEのFirst steps&lt;/a&gt;に添って、ubuntuとdebianのイメージを取得します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ ./scripts/lxd-images import lxc ubuntu trusty amd64 --alias ubuntu --alias ubuntu/trusty
Downloading the GPG key for https://images.linuxcontainers.org
Downloading the image list for https://images.linuxcontainers.org
Validating the GPG signature of /tmp/tmpsccxc1fa/index.json.asc
Downloading the image: https://images.linuxcontainers.org/images/ubuntu/trusty/amd64/default/20150420_03:49/lxd.tar.xz
Validating the GPG signature of /tmp/tmpsccxc1fa/ubuntu-trusty-amd64-default-20150420_03:49.tar.xz.asc
Image imported as: c9176e837c0012d6d0eed221312ee9fc761765319701f57e65e63542ad9beade
Setup alias: ubuntu
Setup alias: ubuntu/trusty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;debianのほうは最初コピペミスでaliasに2回同じ値を指定してしまってエラーになりましたが、再度実行すると成功しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ scripts/lxd-images import lxc debian wheezy amd64 --alias debian --alias debian/wheezy --alias debian/wheezy
Downloading the GPG key for https://images.linuxcontainers.org
Downloading the image list for https://images.linuxcontainers.org
Validating the GPG signature of /tmp/tmp_d1gz0q6/index.json.asc
Downloading the image: https://images.linuxcontainers.org/images/debian/wheezy/amd64/default/20150419_22:42/lxd.tar.xz
Validating the GPG signature of /tmp/tmp_d1gz0q6/debian-wheezy-amd64-default-20150419_22:42.tar.xz.asc
Image imported as: cd398814f6e4e1e50799ba8249b80aa3558e5b05edf71a996a174def87569ae5
Setup alias: debian
Setup alias: debian/wheezy
Traceback (most recent call last):
  File &amp;quot;scripts/lxd-images&amp;quot;, line 410, in &amp;lt;module&amp;gt;
    args.func(parser, args)
  File &amp;quot;scripts/lxd-images&amp;quot;, line 367, in import_lxc
    setup_alias(parser, args, fingerprint)
  File &amp;quot;scripts/lxd-images&amp;quot;, line 330, in setup_alias
    lxd.aliases_create(alias, fingerprint)
  File &amp;quot;scripts/lxd-images&amp;quot;, line 83, in aliases_create
    raise Exception(&amp;quot;Failed to create alias: %s&amp;quot; % name)
Exception: Failed to create alias: debian/wheezy
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ scripts/lxd-images import lxc debian wheezy amd64 --alias debian --alias debian/wheezy --alias debian/wheezy/amd64
Downloading the GPG key for https://images.linuxcontainers.org
Downloading the image list for https://images.linuxcontainers.org
Validating the GPG signature of /tmp/tmpeqkwuvfw/index.json.asc
Downloading the image: https://images.linuxcontainers.org/images/debian/wheezy/amd64/default/20150419_22:42/lxd.tar.xz
Validating the GPG signature of /tmp/tmpeqkwuvfw/debian-wheezy-amd64-default-20150419_22:42.tar.xz.asc
This image is already in the store.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナを起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc launch ubuntuCreating container...done
Starting container...done
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc launch debian debian01
Creating container...done
Starting container...done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナの一覧を表示してみます。ubuntuのほうはコンテナ名を指定しなかったので、自動で付けられています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc list
+---------------------+---------+------------+------+-----------+
|        NAME         |  STATE  |    IPV4    | IPV6 | EPHEMERAL |
+---------------------+---------+------------+------+-----------+
| preterhuman-araceli | RUNNING | 10.0.3.188 |      | NO        |
| debian01            | RUNNING |            |      | NO        |
+---------------------+---------+------------+------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;debianのほうはIPアドレスが空になっていて、あれ？と思ったのですが、実行するタイミングが早すぎたようで、数秒立ってから再度実行するとアドレスが表示されました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc list
+---------------------+---------+------------+------+-----------+
|        NAME         |  STATE  |    IPV4    | IPV6 | EPHEMERAL |
+---------------------+---------+------------+------+-----------+
| preterhuman-araceli | RUNNING | 10.0.3.188 |      | NO        |
| debian01            | RUNNING | 10.0.3.42  |      | NO        |
+---------------------+---------+------------+------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以前未実装だった &lt;code&gt;lxc shell&lt;/code&gt; の代わりに &lt;code&gt;lxc exec&lt;/code&gt; でコマンド実行やシェルでの対話操作ができるようになっていました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lxc exec コンテナ名 コマンド 引数&lt;/code&gt; のように指定すると、コンテナ内でコマンドを実行できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
6: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:16:3e:01:bd:a1 brd ff:ff:ff:ff:ff:ff
    inet 10.0.3.42/24 brd 10.0.3.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::216:3eff:fe01:bda1/64 scope link
       valid_lft forever preferred_lft forever
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec preterhuman-araceli ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
4: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:16:3e:5e:6c:79 brd ff:ff:ff:ff:ff:ff
    inet 10.0.3.188/24 brd 10.0.3.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::216:3eff:fe5e:6c79/64 scope link
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;uname -a&lt;/code&gt; のようなコマンドを &lt;code&gt;lxc exec コンテナ名 コマンド 引数&lt;/code&gt; のように指定するとlxcのオプションと解釈するようで、以下のエラーになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec preterhuman-araceli uname -a
error: flag provided but not defined: -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナ名のあとに &lt;code&gt;--&lt;/code&gt; を入れれば回避出来ました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec preterhuman-araceli -- uname -a
Linux preterhuman-araceli 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、原因は不明なのですが、何回か実行してみると、時々何も出力されないことがありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
Linux debian01 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 GNU/Linux
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
Linux debian01 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 GNU/Linux
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
Linux debian01 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 GNU/Linux
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
Linux debian01 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 GNU/Linux
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
Linux debian01 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 GNU/Linux
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
Linux debian01 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 GNU/Linux
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
Linux debian01 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lxc exec コンテナ名 /bin/bash&lt;/code&gt; のようにコマンドにシェルを指定すると、コンテナ内でシェルが起動され対話操作が出来ました。ubuntuコンテナの実際の画面では &lt;code&gt;ls&lt;/code&gt; の結果もカラー表示されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec preterhuman-araceli /bin/bash
root@preterhuman-araceli:~# ls
root@preterhuman-araceli:~# pwd
/root
root@preterhuman-araceli:~# cd /
root@preterhuman-araceli:/# ls -l
total 60
drwxr-xr-x   2 root   root    4096 Apr 20 03:55 bin
drwxr-xr-x   2 root   root    4096 Apr 10  2014 boot
drwxr-xr-x   5 root   root     420 Apr 22 13:51 dev
drwxr-xr-x  63 root   root    4096 Apr 22 13:51 etc
drwxr-xr-x   3 root   root    4096 Apr 20 03:55 home
drwxr-xr-x  12 root   root    4096 Apr 20 03:54 lib
drwxr-xr-x   2 root   root    4096 Apr 20 03:54 lib64
drwxr-xr-x   2 root   root    4096 Apr 20 03:53 media
drwxr-xr-x   2 root   root    4096 Apr 10  2014 mnt
drwxr-xr-x   2 root   root    4096 Apr 20 03:53 opt
dr-xr-xr-x 109 nobody nogroup    0 Apr 22 13:51 proc
drwx------   2 root   root    4096 Apr 20 03:53 root
drwxr-xr-x   9 root   root     380 Apr 22 13:51 run
drwxr-xr-x   2 root   root    4096 Apr 20 03:55 sbin
drwxr-xr-x   2 root   root    4096 Apr 20 03:53 srv
dr-xr-xr-x  13 nobody nogroup    0 Apr 22 13:51 sys
drwxrwxrwt   2 root   root    4096 Apr 20 03:55 tmp
drwxr-xr-x  10 root   root    4096 Apr 20 03:53 usr
drwxr-xr-x  11 root   root    4096 Apr 20 03:53 var
root@preterhuman-araceli:/# ls
bin   dev  home  lib64  mnt  proc  run   srv  tmp  var
boot  etc  lib   media  opt  root  sbin  sys  usr
root@preterhuman-araceli:/# pwd
/
root@preterhuman-araceli:/# exit
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;以前試した時に比べて、かなり進歩してますね。&lt;/p&gt;

&lt;p&gt;ten_forwardさんのライブマイグレーションの記事とかも、今後試してみようと思います。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/defiant/20150415/1429089615&#34;&gt;lxd を使ったライブマイグレーション (1) - TenForwardの日記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/defiant/20150415/1429090896&#34;&gt;lxd を使ったライブマイグレーション (2) - TenForwardの日記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>