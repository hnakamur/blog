<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lxd on hnakamur&#39;s blog at github</title>
    <link>/blog/tags/lxd/</link>
    <description>Recent content in Lxd on hnakamur&#39;s blog at github</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Sat, 07 May 2016 21:17:35 +0900</lastBuildDate>
    <atom:link href="/blog/tags/lxd/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LXDのREST APIクライアントライブラリpylxdを試してみた</title>
      <link>/blog/2016/05/07/tried-pylxd/</link>
      <pubDate>Sat, 07 May 2016 21:17:35 +0900</pubDate>
      
      <guid>/blog/2016/05/07/tried-pylxd/</guid>
      <description>

&lt;p&gt;Python Package Index (PyPI)の &lt;a href=&#34;https://pypi.python.org/pypi/pylxd/2.0.0&#34;&gt;pylxd 2.0.0&lt;/a&gt;のページにインストール方法と使い方の例が書いてあるので、これに沿って試しました。&lt;/p&gt;

&lt;h2 id=&#34;インストール&#34;&gt;インストール&lt;/h2&gt;

&lt;p&gt;Ubuntu 16.04だとaptでインストール可能なのでそちらでインストールしました。Python3用のpython3-pylxdパッケージとPython2用のpython-pylxdパッケージがありますが、今後Ansibleのモジュールを作ることを想定してPython2用のパッケージをインストールして試してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt install -y python-pylxd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストールしたpython-pylxdのバージョンは &lt;code&gt;2.0.0-0ubuntu1&lt;/code&gt; です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dpkg-query -W -f=&#39;${Version}\n&#39; python-pylxd
2.0.0-0ubuntu1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;試してみる&#34;&gt;試してみる&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ python
Python 2.7.11+ (default, Apr 17 2016, 14:00:29)
[GCC 5.3.1 20160413] on linux2
Type &amp;quot;help&amp;quot;, &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information.
&amp;gt;&amp;gt;&amp;gt; from pylxd import api
&amp;gt;&amp;gt;&amp;gt; lxd = api.API()
&amp;gt;&amp;gt;&amp;gt; lxd.container_defined(&#39;cent01&#39;)
True
&amp;gt;&amp;gt;&amp;gt; lxd.container_defined(&#39;hoge&#39;)
False
&amp;gt;&amp;gt;&amp;gt; lxd.container_list()
[u&#39;cent01&#39;, u&#39;cent02&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここから先は &lt;a href=&#34;https://github.com/lxc/pylxd/blob/master/pylxd/client.py&#34;&gt;pylxd/client.py&lt;/a&gt; と &lt;a href=&#34;https://github.com/lxc/pylxd/blob/master/pylxd/container.py&#34;&gt;pylxd/container.py&lt;/a&gt; の ソースを見ながら試しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from pylxd.client import Client
&amp;gt;&amp;gt;&amp;gt; client = Client()
&amp;gt;&amp;gt;&amp;gt; client.containers.all()
[&amp;lt;pylxd.container.Container object at 0x7fd44065db00&amp;gt;, &amp;lt;pylxd.container.Container object at 0x7fd44065db98&amp;gt;]
&amp;gt;&amp;gt;&amp;gt; client.containers.get(u&#39;cent01&#39;)
&amp;lt;pylxd.container.Container object at 0x7fd44065dc30&amp;gt;
&amp;gt;&amp;gt;&amp;gt; client.containers.get(u&#39;cent01&#39;).status
u&#39;Running&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LXDのREST APIをcurlで試してみた</title>
      <link>/blog/2016/05/07/tried-lxd-rest-api-with-curl/</link>
      <pubDate>Sat, 07 May 2016 21:17:34 +0900</pubDate>
      
      <guid>/blog/2016/05/07/tried-lxd-rest-api-with-curl/</guid>
      <description>

&lt;h2 id=&#34;lxdのrest-api&#34;&gt;LXDのREST API&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/rest-api/&#34;&gt;Linux Containers - LXD - REST API&lt;/a&gt;と&lt;a href=&#34;https://github.com/lxc/lxd/blob/master/doc/rest-api.md&#34;&gt;lxd/rest-api.md at master · lxc/lxd&lt;/a&gt;にLXDのREST APIについて説明があります。&lt;/p&gt;

&lt;p&gt;また&lt;a href=&#34;https://github.com/lxc/lxd#using-the-rest-api&#34;&gt;Using the REST API&lt;/a&gt;に &lt;code&gt;curl&lt;/code&gt; コマンドでのAPI呼び出し例が書かれていました。&lt;/p&gt;

&lt;h2 id=&#34;curlでhttpsのエンドポイントにアクセスしてみたがエラー&#34;&gt;curlでhttpsのエンドポイントにアクセスしてみたがエラー&lt;/h2&gt;

&lt;p&gt;まずはhttpsのURLで &lt;a href=&#34;https://github.com/lxc/lxd/blob/master/doc/rest-api.md#10&#34;&gt;/1.0&lt;/a&gt; エンドポイントを試してみたのですが、 &lt;code&gt;ALPN, server did not agree to a protocol&lt;/code&gt; というエラーになってしまいました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -k -v --cert ~/.config/lxc/client.crt --key ~/.config/lxc/client.key https://127.0.0.1:8443/1.0
*   Trying 127.0.0.1...
* Connected to 127.0.0.1 (127.0.0.1) port 8443 (#0)
* found 173 certificates in /etc/ssl/certs/ca-certificates.crt
* found 692 certificates in /etc/ssl/certs
* ALPN, offering http/1.1
* SSL connection using TLS1.2 / ECDHE_RSA_AES_128_GCM_SHA256
*        server certificate verification SKIPPED
*        server certificate status verification SKIPPED
*        common name: root@express (does not match &#39;127.0.0.1&#39;)
*        server certificate expiration date OK
*        server certificate activation date OK
*        certificate public key: RSA
*        certificate version: #3
*        subject: O=linuxcontainers.org,CN=root@express
*        start date: Tue, 03 May 2016 11:26:51 GMT
*        expire date: Fri, 01 May 2026 11:26:51 GMT
*        issuer: O=linuxcontainers.org,CN=root@express
*        compression: NULL
* ALPN, server did not agree to a protocol
&amp;gt; GET /1.0 HTTP/1.1
&amp;gt; Host: 127.0.0.1:8443
&amp;gt; User-Agent: curl/7.47.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Content-Type: application/json
&amp;lt; Date: Sat, 07 May 2016 12:25:53 GMT
&amp;lt; Content-Length: 162
&amp;lt;
{&amp;quot;type&amp;quot;:&amp;quot;sync&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;Success&amp;quot;,&amp;quot;status_code&amp;quot;:200,&amp;quot;metadata&amp;quot;:{&amp;quot;api_extensions&amp;quot;:[],&amp;quot;api_status&amp;quot;:&amp;quot;stable&amp;quot;,&amp;quot;api_version&amp;quot;:&amp;quot;1.0&amp;quot;,&amp;quot;auth&amp;quot;:&amp;quot;untrusted&amp;quot;,&amp;quot;public&amp;quot;:false}}
* Connection #0 to host 127.0.0.1 left intact
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この件は&lt;a href=&#34;https://lists.linuxcontainers.org/pipermail/lxc-users/2016-May/011603.html&#34;&gt;[lxc-users] The error &amp;ldquo;ALPN, server did not agree to a protocol&amp;rdquo; from LXD Rest API&lt;/a&gt;で質問してみました。&lt;/p&gt;

&lt;h2 id=&#34;curlでunix-domain-socket経由でアクセスしてみたら成功&#34;&gt;curlでunix domain socket経由でアクセスしてみたら成功&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/toritori0318/items/193df8f749a9c4bda883&#34;&gt;curlでunix domain socket経由アクセスする - Qiita&lt;/a&gt;を参考に以下のようにアクセスしてみると成功しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s --unix-socket /var/lib/lxd/unix.socket https:/1.0 | jq .
{
  &amp;quot;type&amp;quot;: &amp;quot;sync&amp;quot;,
  &amp;quot;status&amp;quot;: &amp;quot;Success&amp;quot;,
  &amp;quot;status_code&amp;quot;: 200,
  &amp;quot;metadata&amp;quot;: {
    &amp;quot;api_extensions&amp;quot;: [],
    &amp;quot;api_status&amp;quot;: &amp;quot;stable&amp;quot;,
    &amp;quot;api_version&amp;quot;: &amp;quot;1.0&amp;quot;,
    &amp;quot;auth&amp;quot;: &amp;quot;trusted&amp;quot;,
    &amp;quot;config&amp;quot;: {
      &amp;quot;core.https_address&amp;quot;: &amp;quot;127.0.0.1:8443&amp;quot;,
      &amp;quot;core.trust_password&amp;quot;: true
    },
    &amp;quot;environment&amp;quot;: {
      &amp;quot;addresses&amp;quot;: [
        &amp;quot;127.0.0.1:8443&amp;quot;
      ],
      &amp;quot;architectures&amp;quot;: [
        &amp;quot;x86_64&amp;quot;,
        &amp;quot;i686&amp;quot;
      ],
      &amp;quot;certificate&amp;quot;: &amp;quot;-----BEGIN CERTIFICATE-----\n …(略)… \n-----END CERTIFICATE-----\n&amp;quot;,
      &amp;quot;driver&amp;quot;: &amp;quot;lxc&amp;quot;,
      &amp;quot;driver_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;kernel&amp;quot;: &amp;quot;Linux&amp;quot;,
      &amp;quot;kernel_architecture&amp;quot;: &amp;quot;x86_64&amp;quot;,
      &amp;quot;kernel_version&amp;quot;: &amp;quot;4.4.0-21-generic&amp;quot;,
      &amp;quot;server&amp;quot;: &amp;quot;lxd&amp;quot;,
      &amp;quot;server_pid&amp;quot;: 6446,
      &amp;quot;server_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;storage&amp;quot;: &amp;quot;dir&amp;quot;,
      &amp;quot;storage_version&amp;quot;: &amp;quot;&amp;quot;
    },
    &amp;quot;public&amp;quot;: false
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sudo lxd init&lt;/code&gt; でLXDをネットワーク越しに使うかの問いにnoと答えた環境では以下のような出力になりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s --unix-socket /var/lib/lxd/unix.socket http:/1.0 | jq .
{
  &amp;quot;type&amp;quot;: &amp;quot;sync&amp;quot;,
  &amp;quot;status&amp;quot;: &amp;quot;Success&amp;quot;,
  &amp;quot;status_code&amp;quot;: 200,
  &amp;quot;metadata&amp;quot;: {
    &amp;quot;api_extensions&amp;quot;: [],
    &amp;quot;api_status&amp;quot;: &amp;quot;stable&amp;quot;,
    &amp;quot;api_version&amp;quot;: &amp;quot;1.0&amp;quot;,
    &amp;quot;auth&amp;quot;: &amp;quot;trusted&amp;quot;,
    &amp;quot;config&amp;quot;: {},
    &amp;quot;environment&amp;quot;: {
      &amp;quot;addresses&amp;quot;: [],
      &amp;quot;architectures&amp;quot;: [
        &amp;quot;x86_64&amp;quot;,
        &amp;quot;i686&amp;quot;
      ],
      &amp;quot;certificate&amp;quot;: &amp;quot;-----BEGIN CERTIFICATE-----\n …(略)… \n-----END CERTIFICATE-----\n&amp;quot;,
      &amp;quot;driver&amp;quot;: &amp;quot;lxc&amp;quot;,
      &amp;quot;driver_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;kernel&amp;quot;: &amp;quot;Linux&amp;quot;,
      &amp;quot;kernel_architecture&amp;quot;: &amp;quot;x86_64&amp;quot;,
      &amp;quot;kernel_version&amp;quot;: &amp;quot;4.4.0-21-generic&amp;quot;,
      &amp;quot;server&amp;quot;: &amp;quot;lxd&amp;quot;,
      &amp;quot;server_pid&amp;quot;: 2150,
      &amp;quot;server_version&amp;quot;: &amp;quot;2.0.0&amp;quot;,
      &amp;quot;storage&amp;quot;: &amp;quot;dir&amp;quot;,
      &amp;quot;storage_version&amp;quot;: &amp;quot;&amp;quot;
    },
    &amp;quot;public&amp;quot;: false
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>AnsibleのLXDコネクションプラグインを試してみた</title>
      <link>/blog/2016/05/07/tried-ansible-lxd-connection-plugin/</link>
      <pubDate>Sat, 07 May 2016 20:32:13 +0900</pubDate>
      
      <guid>/blog/2016/05/07/tried-ansible-lxd-connection-plugin/</guid>
      <description>

&lt;p&gt;LXDを使うとなるとAnsibleのLXDコネクションプラグインが欲しいなと思って&lt;a href=&#34;https://github.com/ansible/ansible&#34;&gt;ansible/ansibleのgithubのレポジトリ&lt;/a&gt;を眺めていたら &lt;a href=&#34;https://github.com/ansible/ansible/blob/fca5ba153e9258d6a9a28c418d8339d507eee81c/lib/ansible/plugins/connection/lxd.py&#34;&gt;lib/ansible/plugins/connection/lxd.py&lt;/a&gt; に既に作られていることに気付きました。&lt;/p&gt;

&lt;p&gt;ソースを見ると &lt;code&gt;lxc&lt;/code&gt; コマンドを使った実装になっていました。aptでインストールしたansible 2.0.0.2にこのファイルだけ追加して使えないか試してみたのですが、 &lt;code&gt;AttributeError: &#39;PlayContext&#39; object has no attribute &#39;executable&#39;&lt;/code&gt; というエラーが出て使えませんでした。&lt;/p&gt;

&lt;p&gt;そこでvirtualenvで環境を作ってpipでgithubのmasterのansibleをインストールして試してみました。&lt;/p&gt;

&lt;h2 id=&#34;インストール手順&#34;&gt;インストール手順&lt;/h2&gt;

&lt;p&gt;インストール手順は以下の通りです。
まず、virtualenv環境でAnsibleをインストールするのに必要なパッケージをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt update
sudo apt install -y virtualenv build-essential python-dev libffi-dev libssl-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作業ディレクトリを作ってそこに移動し、virtualenvで環境を作ってansibleをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir ~/ansible-lxd-example
cd ~/ansible-lxd-example
virtualenv venv
. venv/bin/activate
pip install git+https://github.com/ansible/ansible
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使ってみる&#34;&gt;使ってみる&lt;/h2&gt;

&lt;p&gt;以下のような設定ファイルとテスト用のプレイブックを作りました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ansible.cfg
[defaults]
inventory = hosts
$ cat hosts
[containers]
cent01 ansible_connection=lxd
cent02 ansible_connection=lxd
$ cat test.yml
---
- hosts: containers
  remote_user: root
  tasks:
    - debug: msg=ipv4_address={{ ansible_default_ipv4.address }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行してみると、問題なく動作しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ansible-playbook test.yml

PLAY [containers] **************************************************************

TASK [setup] *******************************************************************
ok: [cent01]
ok: [cent02]

TASK [debug] *******************************************************************
ok: [cent01] =&amp;gt; {
    &amp;quot;msg&amp;quot;: &amp;quot;ipv4_address=10.155.92.101&amp;quot;
}
ok: [cent02] =&amp;gt; {
    &amp;quot;msg&amp;quot;: &amp;quot;ipv4_address=10.155.92.103&amp;quot;
}

PLAY RECAP *********************************************************************
cent01                     : ok=2    changed=0    unreachable=0    failed=0
cent02                     : ok=2    changed=0    unreachable=0    failed=0

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LXDコンテナで固定IPアドレスを使うための設定</title>
      <link>/blog/2016/05/07/how-to-use-fixed-ip-address-for-a-lxd-container/</link>
      <pubDate>Sat, 07 May 2016 18:01:51 +0900</pubDate>
      
      <guid>/blog/2016/05/07/how-to-use-fixed-ip-address-for-a-lxd-container/</guid>
      <description>

&lt;h2 id=&#34;設定まとめ&#34;&gt;設定まとめ&lt;/h2&gt;

&lt;p&gt;自分が後から参照することを想定して先に設定方法をまとめます。&lt;/p&gt;

&lt;p&gt;LXDコンテナで固定IPアドレスを使うためには以下の設定が必要です。なお、設定にはroot権限が必要です。&lt;/p&gt;

&lt;p&gt;まず &lt;code&gt;/etc/dnsmasq.conf&lt;/code&gt; に以下のようにコンテナ名に対するIPアドレスを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dhcp-host=cent01,10.64.177.101
dhcp-host=cent02,10.64.177.102
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lxd-bridge&lt;/code&gt; サービスを再起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl restart lxd-bridge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IPアドレスを変更したコンテナを再起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc restart cent01
lxc restart cent02
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;調査メモ&#34;&gt;調査メモ&lt;/h2&gt;

&lt;p&gt;以下は調査メモです。&lt;/p&gt;

&lt;p&gt;まず &lt;a href=&#34;https://github.com/lxc/lxd/issues/1168&#34;&gt;Persistent IP for Containers · Issue #1168 · lxc/lxd&lt;/a&gt; に固定IPアドレスを使うための情報がありました。LXDで特にサポートはないが、各コンテナでDHCPを使わずに静的IPアドレスを使用するか、あるいはホストのDHCPサーバ側で設定すれば実現できるとのことです。&lt;/p&gt;

&lt;p&gt;各コンテナで静的IPアドレスを使う方法も試してみたのですが、ホストのコンテナ内から別のコンテナをコンテナ名で参照しようとすると変更前のIPアドレスで通信しようとしてしまいうまく行きませんでした。&lt;/p&gt;

&lt;p&gt;これを実現するにはホストのDHCPサーバに各コンテナのIPアドレスを把握してもらう必要があるので、後者のDHCPサーバ側で設定するほうが良いです。&lt;/p&gt;

&lt;h3 id=&#34;lxdのブリッジインターフェースとdnsmasqの設定ファイル&#34;&gt;LXDのブリッジインターフェースとdnsmasqの設定ファイル&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://insights.ubuntu.com/2016/04/07/lxd-networking-lxdbr0-explained/&#34;&gt;LXD networking: lxdbr0 explained | Ubuntu Insights&lt;/a&gt;と&lt;a href=&#34;https://gist.github.com/cronnelly/98345100afe21840267270da3283b371&#34;&gt;lxcbr0 is being replaced by lxdbr0&lt;/a&gt;によると、 LXCでは &lt;code&gt;lxcbr0&lt;/code&gt; というブリッジインターフェースを使っていましたが、LXDでは &lt;code&gt;lxdbr0&lt;/code&gt; と別のインターフェースを使うように変更されたそうです。&lt;/p&gt;

&lt;p&gt;これらの記事を見るとLXCの &lt;code&gt;lxcbr0&lt;/code&gt; はインストール時に固定のアドレスネットワークが設定されて環境によっては既存のネットワークと衝突するという問題があったので、LXD の &lt;code&gt;lxdbr0&lt;/code&gt; ではインストール時にはIPv4やIPv6のサブネットは設定せずに &lt;code&gt;sudo lxd init&lt;/code&gt; を実行したときに設定するように変更されたということのようです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo lxd init&lt;/code&gt; で生成した &lt;code&gt;lxdbr0&lt;/code&gt; 用の設定は &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; に保存されています。
ファイルの先頭に書かれていますが、変更したい場合は直接編集せずに &lt;code&gt;dpkg-reconfigure -p medium lxd&lt;/code&gt; を実行するのが良いそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /etc/default/lxd-bridge
# WARNING: This file is generated by a debconf template!
# It is recommended to update it by using &amp;quot;dpkg-reconfigure -p medium lxd&amp;quot;

# Whether to setup a new bridge or use an existing one
USE_LXD_BRIDGE=&amp;quot;true&amp;quot;

# Bridge name
# This is still used even if USE_LXD_BRIDGE is set to false
# set to an empty value to fully disable
LXD_BRIDGE=&amp;quot;lxdbr0&amp;quot;

# Update the &amp;quot;default&amp;quot; LXD profile
UPDATE_PROFILE=&amp;quot;true&amp;quot;

# Path to an extra dnsmasq configuration file
LXD_CONFILE=&amp;quot;&amp;quot;

# DNS domain for the bridge
LXD_DOMAIN=&amp;quot;lxd&amp;quot;

# IPv4
## IPv4 address (e.g. 10.0.8.1)
LXD_IPV4_ADDR=&amp;quot;10.16.29.1&amp;quot;

## IPv4 netmask (e.g. 255.255.255.0)
LXD_IPV4_NETMASK=&amp;quot;255.255.255.0&amp;quot;

## IPv4 network (e.g. 10.0.8.0/24)
LXD_IPV4_NETWORK=&amp;quot;10.16.29.1/24&amp;quot;

## IPv4 DHCP range (e.g. 10.0.8.2,10.0.8.254)
LXD_IPV4_DHCP_RANGE=&amp;quot;10.16.29.2,10.16.29.254&amp;quot;

## IPv4 DHCP number of hosts (e.g. 250)
LXD_IPV4_DHCP_MAX=&amp;quot;252&amp;quot;

## NAT IPv4 traffic
LXD_IPV4_NAT=&amp;quot;true&amp;quot;

# IPv6
## IPv6 address (e.g. 2001:470:b368:4242::1)
LXD_IPV6_ADDR=&amp;quot;fd94:d372:e27f:2987::1&amp;quot;

## IPv6 CIDR mask (e.g. 64)
LXD_IPV6_MASK=&amp;quot;64&amp;quot;

## IPv6 network (e.g. 2001:470:b368:4242::/64)
LXD_IPV6_NETWORK=&amp;quot;fd94:d372:e27f:2987::1/64&amp;quot;

## NAT IPv6 traffic
LXD_IPV6_NAT=&amp;quot;true&amp;quot;

# Run a minimal HTTP PROXY server
LXD_IPV6_PROXY=&amp;quot;false&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このブリッジインタフェースを有効にするには &lt;code&gt;lxd-bridge.service&lt;/code&gt; を開始します。サービスの定義ファイルは以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /lib/systemd/system/lxd-bridge.service
[Unit]
Description=LXD - network bridge
Documentation=man:lxd(1)
Before=lxd.service

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/lib/lxd/lxd-bridge.start
ExecStop=/usr/lib/lxd/lxd-bridge stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ExecStart&lt;/code&gt; に指定しているスクリプトの中身は以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /usr/lib/lxd/lxd-bridge.start
#!/bin/sh -e

[ ! -e /etc/default/lxd-bridge ] &amp;amp;&amp;amp; exit 0

. /etc/default/lxd-bridge

# Start by bringing up the bridge
/usr/lib/lxd/lxd-bridge start

# Switch LXD in setup mode if needed
if [ &amp;quot;${UPDATE_PROFILE:-true}&amp;quot; = &amp;quot;true&amp;quot; ] &amp;amp;&amp;amp; [ -e &amp;quot;/var/lib/lxd&amp;quot; ] &amp;amp;&amp;amp; \
    ([ ! -e &amp;quot;/var/lib/lxd-bridge/timestamp&amp;quot; ] || \
     [ &amp;quot;/etc/default/lxd-bridge&amp;quot; -nt &amp;quot;/var/lib/lxd-bridge/timestamp&amp;quot; ]); then

    mkdir -p /var/lib/lxd-bridge
    touch /var/lib/lxd-bridge/timestamp

    touch /var/lib/lxd/.setup_mode
fi

exit 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここから呼ばれる &lt;code&gt;/usr/lib/lxd/lxd-bridge&lt;/code&gt; を見てみると、initスクリプトになっていて &lt;code&gt;iptables&lt;/code&gt;, &lt;code&gt;ip6tables&lt;/code&gt;, &lt;code&gt;dnsmasq&lt;/code&gt; を実行するようになっていました。また &lt;code&gt;/usr/lib/lxd/lxd-bridge&lt;/code&gt; は上記の &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; を読み込むようになっています。&lt;/p&gt;

&lt;p&gt;起動された &lt;code&gt;dnsmasq&lt;/code&gt; を &lt;code&gt;ps&lt;/code&gt; で見ると以下のようなコマンドラインになっていました。&lt;/p&gt;

&lt;p&gt;$ ps auxww | grep [d]nsmasq
  lxd       2134  0.0  0.0  49984   388 ?        S    09:48   0:00 dnsmasq -s lxd -S /lxd/ -u lxd &amp;ndash;strict-order &amp;ndash;bind-interfaces &amp;ndash;pid-file=/run/lxd-bridge//dnsmasq.pid &amp;ndash;dhcp-no-override &amp;ndash;except-interface=lo &amp;ndash;interface=lxdbr0 &amp;ndash;dhcp-leasefile=/var/lib/lxd-bridge//dnsmasq.lxdbr0.leases &amp;ndash;dhcp-authoritative &amp;ndash;listen-address 10.16.29.1 &amp;ndash;dhcp-range 10.16.29.2,10.16.29.254 &amp;ndash;dhcp-lease-max=252 &amp;ndash;dhcp-range=fd94:d372:e27f:2987::1,ra-only &amp;ndash;listen-address fd94:d372:e27f:2987::1&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/lib/lxd/lxd-bridge&lt;/code&gt; を見ると &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; の &lt;code&gt;LXD_CONFILE&lt;/code&gt; にファイル名を指定しておけば &lt;code&gt;dnsmasq&lt;/code&gt; の &lt;code&gt;--conf-file&lt;/code&gt; オプションを使ってそのファイルを読み込むように書かれています。この方法を使おうかと思ったのですが、一方で &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; の設定にかかわらず &lt;code&gt;--dhcp-authoritative&lt;/code&gt; オプションが常に指定されるように書かれています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;man dnsmasq&lt;/code&gt; によると &lt;code&gt;--dhcp-authoritative&lt;/code&gt; オプションはネットワーク内に他にDHCPサーバが無く唯一のDHCPになっているときに指定するオプションとのことです。ホストで稼働する &lt;code&gt;dnsmasq&lt;/code&gt; が1つという前提であれば、デフォルトの設定ファイル &lt;code&gt;/etc/dnsmasq.conf&lt;/code&gt; を作ってそこに設定を書くほうが手っ取り早いので、そうすることにしました。&lt;/p&gt;

&lt;h3 id=&#34;lxd-bridge-serviceの設定変更はreloadではなくrestartが必要&#34;&gt;lxd-bridge.serviceの設定変更はreloadではなくrestartが必要&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sudo systemctl reload lxd-bridge&lt;/code&gt; を実行してみると以下のようなエラーが出て失敗しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo systemctl reload lxd-bridge
Failed to reload lxd-bridge.service: Job type reload is not applicable for unit lxd-bridge.service.
See system logs and &#39;systemctl status lxd-bridge.service&#39; for details.
$ sudo systemctl status lxd-bridge
● lxd-bridge.service - LXD - network bridge
   Loaded: loaded (/lib/systemd/system/lxd-bridge.service; static; vendor preset: enabled)
   Active: active (exited) since 土 2016-05-07 13:06:06 JST; 6h ago
     Docs: man:lxd(1)
  Process: 3704 ExecStop=/usr/lib/lxd/lxd-bridge stop (code=exited, status=0/SUCCESS)
  Process: 3723 ExecStart=/usr/lib/lxd/lxd-bridge.start (code=exited, status=0/SUCCESS)
 Main PID: 3723 (code=exited, status=0/SUCCESS)
    Tasks: 1 (limit: 512)
   Memory: 412.0K
      CPU: 1.293s
   CGroup: /system.slice/lxd-bridge.service
           └─3755 dnsmasq -s lxd -S /lxd/ -u lxd --strict-order --bind-interfaces --pid-file=/run/lxd-bridge//dnsmasq.pid --dhcp-no-override --except-interface=lo --interface=lxdbr0 --dhcp-leasefile=/var/lib/lxd-bridge//dnsmasq.lxdbr0.leases --dhcp-authoritative --lis
 5月 07 18:56:28 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
 5月 07 19:06:21 express dnsmasq-dhcp[3755]: DHCPREQUEST(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7
 5月 07 19:06:21 express dnsmasq-dhcp[3755]: DHCPACK(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7 cent02
 5月 07 19:06:21 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
 5月 07 19:23:24 express dnsmasq-dhcp[3755]: DHCPREQUEST(lxdbr0) 10.155.92.101 00:16:3e:5f:01:7e
 5月 07 19:23:24 express dnsmasq-dhcp[3755]: DHCPACK(lxdbr0) 10.155.92.101 00:16:3e:5f:01:7e cent01
 5月 07 19:23:24 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
 5月 07 19:33:08 express dnsmasq-dhcp[3755]: DHCPREQUEST(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7
 5月 07 19:33:08 express dnsmasq-dhcp[3755]: DHCPACK(lxdbr0) 10.155.92.102 00:16:3e:59:21:d7 cent02
 5月 07 19:33:08 express dnsmasq-dhcp[3755]: not giving name cent02 to the DHCP lease of 10.155.92.102 because the name exists in /etc/hosts with address 10.155.92.201
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで、設定ファイルを変更反映するにも &lt;code&gt;sudo systemctl restart lxd-bridge&lt;/code&gt; のように再起動する必要があります。&lt;/p&gt;

&lt;h3 id=&#34;dnsmasqの再起動後-コンテナの再起動が必要&#34;&gt;dnsmasqの再起動後、コンテナの再起動が必要&lt;/h3&gt;

&lt;p&gt;dnsmasqを再起動しただけではコンテナのIPアドレスは変わらないのでネットワークを再起動する必要がありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc exec cent01 systemctl restart network
lxc exec cent02 systemctl restart network
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナごと再起動でも良いと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc restart cent01
lxc restart cent02
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何回か試してみたところ、作っただけで特に何もしてないコンテナだとネットワーク再起動よりコンテナ自体を再起動するほうが速かったです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time lxc exec cent02 systemctl restart network

real    0m2.878s
user    0m0.008s
sys     0m0.000s
$ time lxc restart cent02

real    0m1.236s
user    0m0.004s
sys     0m0.004s
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LXCの特定の1つのコンテナの起動状態をシェルスクリプトで確認したいときのお勧めの方法</title>
      <link>/blog/2016/05/07/script-to-check-running-status-of-lxd-container/</link>
      <pubDate>Sat, 07 May 2016 14:12:49 +0900</pubDate>
      
      <guid>/blog/2016/05/07/script-to-check-running-status-of-lxd-container/</guid>
      <description>

&lt;h2 id=&#34;イマイチな方法1-lxc-listの出力をawkで加工&#34;&gt;イマイチな方法1: lxc listの出力をawkで加工&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lxc list -h&lt;/code&gt; を見ると &lt;code&gt;lxc list [resource] [filters] [--format table|json] [-c columns] [--fast]&lt;/code&gt; というコマンドラインになっていて、 &lt;code&gt;-c&lt;/code&gt; オプションで表示するカラムを指定可能です。&lt;/p&gt;

&lt;p&gt;例えば　以下のようにすれば &lt;code&gt;cent01&lt;/code&gt; コンテナの起動状態だけを表示できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c s cent01
+---------+
|  STATE  |
+---------+
| RUNNING |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、デフォルトの &lt;code&gt;--format table&lt;/code&gt; だとASCII文字の罫線が表示されるので、状態を抜き出すにはawkで加工する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c s cent01 | awk &#39;NR==4{print $2}&#39;
RUNNING
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;イマイチな方法2-lxc-list-format-jsonの出力をjqで加工&#34;&gt;イマイチな方法2: lxc list &amp;ndash;format jsonの出力をjqで加工&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;--format json&lt;/code&gt; でJSON形式で出力できるのですが、この場合は &lt;code&gt;-c&lt;/code&gt; オプションで項目を限定することは出来ませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list --format json -c s cent01
[{&amp;quot;architecture&amp;quot;:&amp;quot;x86_64&amp;quot;,&amp;quot;config&amp;quot;:{&amp;quot;volatile.base_image&amp;quot;:&amp;quot;a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2&amp;quot;,&amp;quot;volatile.eth0.hwaddr&amp;quot;:&amp;quot;00:16:3e:5f:01:7e&amp;quot;,&amp;quot;volatile.last_state.idmap&amp;quot;:&amp;quot;[{\&amp;quot;Isuid\&amp;quot;:true,\&amp;quot;Isgid\&amp;quot;:false,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\
&amp;quot;:65536},{\&amp;quot;Isuid\&amp;quot;:false,\&amp;quot;Isgid\&amp;quot;:true,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\&amp;quot;:65536}]&amp;quot;},&amp;quot;created_at&amp;quot;:&amp;quot;2016-05-06T18:56:46+09:00&amp;quot;,&amp;quot;devices&amp;quot;:{&amp;quot;root&amp;quot;:{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;disk&amp;quot;}},&amp;quot;ephemeral&amp;quot;:false,&amp;quot;expanded_config&amp;quot;:{&amp;quot;volatile.base_image&amp;quot;:&amp;quot;a027d59858d663fb2bc12b5ba767e9
2196a4aee8dbb2a607db53d718b91eb5d2&amp;quot;,&amp;quot;volatile.eth0.hwaddr&amp;quot;:&amp;quot;00:16:3e:5f:01:7e&amp;quot;,&amp;quot;volatile.last_state.idmap&amp;quot;:&amp;quot;[{\&amp;quot;Isuid\&amp;quot;:true,\&amp;quot;Isgid\&amp;quot;:false,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\&amp;quot;:65536},{\&amp;quot;Isuid\&amp;quot;:false,\&amp;quot;Isgid\&amp;quot;:true,\&amp;quot;Hostid\&amp;quot;:100000,\&amp;quot;Nsid\&amp;quot;:0,\&amp;quot;Maprange\&amp;quot;:65536}
]&amp;quot;},&amp;quot;expanded_devices&amp;quot;:{&amp;quot;eth0&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;eth0&amp;quot;,&amp;quot;nictype&amp;quot;:&amp;quot;bridged&amp;quot;,&amp;quot;parent&amp;quot;:&amp;quot;lxdbr0&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;nic&amp;quot;},&amp;quot;root&amp;quot;:{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;disk&amp;quot;}},&amp;quot;name&amp;quot;:&amp;quot;cent01&amp;quot;,&amp;quot;profiles&amp;quot;:[&amp;quot;default&amp;quot;],&amp;quot;stateful&amp;quot;:false,&amp;quot;status&amp;quot;:&amp;quot;Running&amp;quot;,&amp;quot;status_code&amp;quot;:103,&amp;quot;state&amp;quot;:null,&amp;quot;snapshots&amp;quot;:null}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sudo apt install jq&lt;/code&gt; で &lt;code&gt;jq&lt;/code&gt; コマンドをインストールして、それで状態を抜き出すことは可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list --format json cent01 | jq -r &#39;.[0].status&#39;
Running
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;お勧めの方法-lxc-infoの出力をawkで加工&#34;&gt;お勧めの方法: lxc infoの出力をawkで加工&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lxc list&lt;/code&gt; の場合は指定した文字列は完全一致ではなくて前方一致で表示されました。上記の例のように &lt;code&gt;cent01&lt;/code&gt; と &lt;code&gt;cent02&lt;/code&gt; の2つのコンテナがあるときに、 &lt;code&gt;lxc list -c s cent0&lt;/code&gt; と実行すると以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c s cent0
+---------+
|  STATE  |
+---------+
| RUNNING |
+---------+
| RUNNING |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだとどの行がどのコンテナかわからないのでコンテナ名の列も付ける必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list -c ns cent0
+--------+---------+
|  NAME  |  STATE  |
+--------+---------+
| cent01 | RUNNING |
+--------+---------+
| cent02 | RUNNING |
+--------+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この結果をawkで加工するのでも良いのですが、もっと良いのは &lt;code&gt;lxc info&lt;/code&gt; コマンドを使うことです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc info cent01
コンテナ名: cent01
アーキテクチャ: x86_64
作成日時: 2016/05/06 09:56 UTC
状態: Running
タイプ: persistent
プロファイル: default
Pid: 29354
IPアドレス:
  eth0: inet    10.155.92.101   vethG4XSE4
  eth0: inet6   fe80::216:3eff:fe5f:17e vethG4XSE4
  lo:   inet    127.0.0.1
  lo:   inet6   ::1
リソース:
  プロセス数: 10
  メモリ消費量:
    メモリ (現在値): 23.60MB
    メモリ (ピーク): 43.08MB
  ネットワーク使用状況:
    eth0:
      受信バイト数: 24.16kB
      送信バイト数: 8.06kB
      受信パケット: 232
      送信パケット: 88
    lo:
      受信バイト数: 0 bytes
      送信バイト数: 0 bytes
      受信パケット: 0
      送信パケット: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存在しないコンテナ名を指定するとエラーになります。これは標準エラー出力に出力されています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc info hoge
エラー: not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;シェルスクリプトで加工するには英語出力のほうが良いので &lt;code&gt;LANG=C&lt;/code&gt; 付きで実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ LANG=C lxc info cent01
Name: cent01
Architecture: x86_64
Created: 2016/05/06 09:56 UTC
Status: Running
Type: persistent
Profiles: default
Pid: 29354
Ips:
  eth0: inet    10.155.92.101   vethG4XSE4
  eth0: inet6   fe80::216:3eff:fe5f:17e vethG4XSE4
  lo:   inet    127.0.0.1
  lo:   inet6   ::1
Resources:
  Processes: 10
  Memory usage:
    Memory (current): 23.60MB
    Memory (peak): 43.08MB
  Network usage:
    eth0:
      Bytes received: 24.58kB
      Bytes sent: 8.56kB
      Packets received: 235
      Packets sent: 93
    lo:
      Bytes received: 0 bytes
      Bytes sent: 0 bytes
      Packets received: 0
      Packets sent: 0
$ LANG=C lxc info hoge
error: not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結局以下のように実行するのがお勧めです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ LANG=C lxc info cent01 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;
Running
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存在しない場合は空文字列になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ LANG=C lxc info hoge 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判定例はこんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ [ x`LANG=C lxc info cent01 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;` == xRunning ] &amp;amp;&amp;amp; echo &amp;quot;container is running&amp;quot;
container is running
$ [ x`LANG=C lxc info hoge 2&amp;gt; /dev/null | awk &#39;$1==&amp;quot;Status:&amp;quot;{print $2}&#39;` == xRunning ] &amp;amp;&amp;amp; echo &amp;quot;container is running&amp;quot;
$
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04 LTSでLXD 2.0をセットアップして使ってみる</title>
      <link>/blog/2016/05/07/start-using-lxd-2.0-on-ubuntu-16.04/</link>
      <pubDate>Sat, 07 May 2016 14:12:49 +0900</pubDate>
      
      <guid>/blog/2016/05/07/start-using-lxd-2.0-on-ubuntu-16.04/</guid>
      <description>

&lt;h2 id=&#34;参考記事&#34;&gt;参考記事&lt;/h2&gt;

&lt;p&gt;公式ドキュメントの&lt;a href=&#34;https://linuxcontainers.org/ja/lxd/getting-started-cli/&#34;&gt;Linux Containers - LXD - はじめに - コマンドライン&lt;/a&gt;によくまとまっているのですが、より詳細には &lt;a href=&#34;http://insights.ubuntu.com/2016/03/14/the-lxd-2-0-story-prologue/&#34;&gt;The LXD 2.0 Story (Prologue) | Ubuntu Insights&lt;/a&gt; にリストアップされている記事がわかりやすかったです。&lt;/p&gt;

&lt;h3 id=&#34;ubuntu-16-04-serverでのlxdの初期セットアップ&#34;&gt;Ubuntu 16.04 serverでのLXDの初期セットアップ&lt;/h3&gt;

&lt;p&gt;Ubuntu 16.04 serverならLXDはインストール済みなので、 &lt;code&gt;apt-get install lxd&lt;/code&gt; と &lt;code&gt;newgrp lxd&lt;/code&gt; は不要でした。&lt;/p&gt;

&lt;p&gt;LXCではコンテナ一覧表示は &lt;code&gt;lxc-ls&lt;/code&gt;、コンテナ作成は &lt;code&gt;lxc-create&lt;/code&gt; のように別々のコマンドになっていましたが、 LXDではそれぞれ &lt;code&gt;lxc list&lt;/code&gt;, &lt;code&gt;lxc launch&lt;/code&gt; と &lt;code&gt;lxc&lt;/code&gt; コマンドのサブコマンドになっています。&lt;/p&gt;

&lt;p&gt;また &lt;code&gt;lxd&lt;/code&gt; というプログラムもあります。 &lt;code&gt;man lxd&lt;/code&gt; と &lt;code&gt;man lxc&lt;/code&gt; してみると &lt;code&gt;lxd&lt;/code&gt; はコンテナのハイパーバイザのデーモンで、 &lt;code&gt;lxc&lt;/code&gt; はコンテナのハイパーバイザのクライアントです。&lt;/p&gt;

&lt;p&gt;まずバージョンを確認してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxd --version
2.0.0
$ lxc --version
2.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、 &lt;code&gt;lxc&lt;/code&gt; のほうは &lt;code&gt;lxc version&lt;/code&gt; と &lt;code&gt;version&lt;/code&gt; サブコマンドも用意されていますが、 &lt;code&gt;lxd version&lt;/code&gt; は &lt;code&gt;error: Unknown arguments&lt;/code&gt; とエラーになりました。&lt;/p&gt;

&lt;p&gt;コンテナ一覧を表示してみます。まだ1つもコンテナを作っていないので一覧は空です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
Generating a client certificate. This may take a minute...
If this is your first time using LXD, you should also run: sudo lxd init

+------+-------+------+------+------+-----------+
| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |
+------+-------+------+------+------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lxc list&lt;/code&gt; の出力の1行目にある通り、初回実行時にはクライアント証明書が生成されます。 &lt;code&gt;~/.config/lxc/client.key&lt;/code&gt; に秘密鍵、 &lt;code&gt;~/.config/lxc/client.crt&lt;/code&gt; に証明書が作られました。&lt;/p&gt;

&lt;p&gt;また、 &lt;code&gt;lxc list&lt;/code&gt; の出力の2行目に LXDを初めて使うときは &lt;code&gt;sudo lxd init&lt;/code&gt; を実行するようにも書かれていますので、実行します。&lt;/p&gt;

&lt;p&gt;すると、いくつか質問されるので入力していきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lxd init
sudo: unable to resolve host ubuntu-xenial
Name of the storage backend to use (dir or zfs): dir
Would you like LXD to be available over the network (yes/no)? no
Do you want to configure the LXD bridge (yes/no)? yes
Warning: Stopping lxd.service, but it can still be activated by:
  lxd.socket
LXD has been successfully configured.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1つ目はストレージバックアップの選択です。選択肢は &lt;code&gt;dir&lt;/code&gt; か &lt;code&gt;zfs&lt;/code&gt; ですが、上記では &lt;code&gt;dir&lt;/code&gt; にしました。&lt;/p&gt;

&lt;p&gt;2つ目はLXDをネットワーク越しで利用するかどうかです。上記では &lt;code&gt;no&lt;/code&gt; にしました。
すると上記の警告にあるとおり &lt;code&gt;lxd.service&lt;/code&gt; が停止されました。 &lt;code&gt;sudo systemctl status lxd&lt;/code&gt; で確認すると &lt;code&gt;Active:&lt;/code&gt; の右が &lt;code&gt;inactive (dead)&lt;/code&gt; になっていました。&lt;/p&gt;

&lt;p&gt;一方で、 &lt;code&gt;lxd.socket&lt;/code&gt; は稼働しています。 &lt;code&gt;sudo systemctl status lxd.socket&lt;/code&gt; で確認すると &lt;code&gt;Active:&lt;/code&gt; の右が &lt;code&gt;active (running)&lt;/code&gt; になっていました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/lib/systemd/system/lxd.socket&lt;/code&gt; を見ると &lt;code&gt;/var/lib/lxd/unix.socket&lt;/code&gt; というファイル名でUnixドメインソケットが作られていることがわかりました。&lt;/p&gt;

&lt;p&gt;3つ目はLXDのブリッジを設定するかどうかです。上記は &lt;code&gt;yes&lt;/code&gt; にしました。すると CUI でダイアログが次々開いて DHCPで発行するIPv4やIPv6のアドレスの範囲などを聞かれるので、順次入力していきます。ランダムなアドレスの範囲が事前入力されているので、特に変更不要な場合はenterキーを連打していけばOKでした。&lt;/p&gt;

&lt;p&gt;再度 &lt;code&gt;lxc list&lt;/code&gt; を実行してみると、今度はクライアント証明書を生成したとか、 &lt;code&gt;sudo lxc init&lt;/code&gt; を実行せよとかの文言は表示されなくなりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+------+-------+------+------+------+-----------+
| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |
+------+-------+------+------+------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;別パターンの初期化の検証&#34;&gt;別パターンの初期化の検証&lt;/h4&gt;

&lt;p&gt;このパターンではLXDをネットワーク越しに使うかの質問に &lt;code&gt;yes&lt;/code&gt; と答えました。すると、バインドするアドレスとポートを聞かれます。ポートは &lt;code&gt;8443&lt;/code&gt; がお勧めと書かれていますが、enterキー空打ちではだめで、ちゃんと値を入力する必要がありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lxd init
sudo: unable to resolve host ubuntu-xenial
Name of the storage backend to use (dir or zfs): dir
Would you like LXD to be available over the network (yes/no)? yes
Address to bind LXD to (not including port): 0.0.0.0
Port to bind LXD to (8443 recommended):
Invalid input, try again.

Port to bind LXD to (8443 recommended): 8443
Trust password for new clients:
Again:
Do you want to configure the LXD bridge (yes/no)? no
LXD has been successfully configured.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この設定の後に &lt;code&gt;sudo systemctl status lxd&lt;/code&gt; を実行すると &lt;code&gt;Active:&lt;/code&gt; の右は &lt;code&gt;active (running)&lt;/code&gt; になっていました。&lt;/p&gt;

&lt;p&gt;また、上記ではLXDブリッジを設定するかの質問に &lt;code&gt;no&lt;/code&gt; と答えてみました。この場合は CUIのダイアログは開かれず、すぐに &lt;code&gt;LXD has been successfully configured.&lt;/code&gt; が表示されて完了しました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ip a&lt;/code&gt; で確認すると、この場合も &lt;code&gt;lxdbr0&lt;/code&gt; というネットワークインターフェース自体は作成されていました。ただし、IPアドレスは設定されていない状態です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ip a
...(略)...
4: lxdbr0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN group default qlen 1000
    link/ether 0a:b4:d4:fa:b3:71 brd ff:ff:ff:ff:ff:ff
    inet6 fe80::8b4:d4ff:fefa:b371/64 scope link
       valid_lft forever preferred_lft forever
    inet6 fe80::1/64 scope link
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、その後 &lt;code&gt;lxc launch&lt;/code&gt; でコンテナを起動した後再度確認すると &lt;code&gt;lxdbr0&lt;/code&gt; の左の番号が &lt;code&gt;4:&lt;/code&gt; から &lt;code&gt;5:&lt;/code&gt; に変わっていて、IPv4アドレスも設定されていました。また &lt;code&gt;lxc.service&lt;/code&gt; も起動していました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo ss -antp&lt;/code&gt; で確認したところ、LXDをネットワーク越しに使う設定を &lt;code&gt;yes&lt;/code&gt; にしたときは &lt;code&gt;lxd&lt;/code&gt; のプロセスが指定したポート（上記の例では8443番ポート）をLISTENしていますが、 &lt;code&gt;no&lt;/code&gt; にしたときはLISTENしていませんでした。&lt;/p&gt;

&lt;h3 id=&#34;リモートとローカルのイメージ一覧表示&#34;&gt;リモートとローカルのイメージ一覧表示&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;lxc image&lt;/code&gt; サブコマンドでイメージを取り扱います。 &lt;code&gt;lxc image -h&lt;/code&gt; と入力すると使用方法が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lxc image list&lt;/code&gt; の説明の部分を以下に引用します。 &lt;code&gt;LANG&lt;/code&gt; 環境変数が &lt;code&gt;ja_JP.UTF8&lt;/code&gt; ならヘルプメッセージは日本語で表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc image list [remote:] [filter]
    LXD のイメージストア内のイメージを一覧表示します。プロパティでフィルタ
    を行う場合は、フィルタは &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; の形になります。フィルタはイメー
    ジハッシュの一部やイメージエイリアス名の一部も指定できます。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;英語のヘルプメッセージを見たい場合は &lt;code&gt;LANG=C&lt;/code&gt; をつけて &lt;code&gt;LANG=C lxc image&lt;/code&gt; のように実行すればOKです。 &lt;code&gt;lxc image list&lt;/code&gt; の英語ヘルプメッセージを以下に引用します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc image list [remote:] [filter]
    List images in the LXD image store. Filters may be of the
    &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; form for property based filtering, or part of the image
    hash or part of the image alias name.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リモートのイメージ一覧は &lt;code&gt;lxc image list images:&lt;/code&gt; で表示できます。最後の &lt;code&gt;:&lt;/code&gt; はリモートの指定か区別するために必要です。&lt;/p&gt;

&lt;p&gt;ローカルのイメージ一覧は &lt;code&gt;lxc image list&lt;/code&gt; で表示できます。1つもコンテナを作っていない時は空になります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[remote:]&lt;/code&gt; の部分に指定可能なリモートの一覧は &lt;code&gt;lxc remote list&lt;/code&gt; で確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc remote list
+-----------------+------------------------------------------+---------------+--------+--------+
|      NAME       |                   URL                    |   PROTOCOL    | PUBLIC | STATIC |
+-----------------+------------------------------------------+---------------+--------+--------+
| images          | https://images.linuxcontainers.org       | lxd           | YES    | NO     |
+-----------------+------------------------------------------+---------------+--------+--------+
| local (default) | unix://                                  | lxd           | NO     | YES    |
+-----------------+------------------------------------------+---------------+--------+--------+
| ubuntu          | https://cloud-images.ubuntu.com/releases | simplestreams | YES    | YES    |
+-----------------+------------------------------------------+---------------+--------+--------+
| ubuntu-daily    | https://cloud-images.ubuntu.com/daily    | simplestreams | YES    | YES    |
+-----------------+------------------------------------------+---------------+--------+--------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フィルタを指定してリモートのcentosのイメージ一覧を表示すると以下の3つがヒットしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc image list images: centos
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
|          ALIAS          | FINGERPRINT  | PUBLIC |            DESCRIPTION            |  ARCH  |  SIZE   |         UPLOAD DATE         |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| centos/6/amd64 (1 more) | 81c42e7d8c4e | yes    | Centos 6 (amd64) (20160507_02:16) | x86_64 | 52.23MB | May 7, 2016 at 3:15am (UTC) |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| centos/6/i386 (1 more)  | 74c61c775024 | yes    | Centos 6 (i386) (20160507_02:16)  | i686   | 52.16MB | May 7, 2016 at 3:16am (UTC) |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| centos/7/amd64 (1 more) | 9c8a52ca68e4 | yes    | Centos 7 (amd64) (20160507_02:16) | x86_64 | 62.93MB | May 7, 2016 at 3:16am (UTC) |
+-------------------------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;centos-7のコンテナを起動してみる&#34;&gt;CentOS 7のコンテナを起動してみる&lt;/h3&gt;

&lt;p&gt;起動に使用するのは &lt;code&gt;lxc launch&lt;/code&gt; サブコマンドです。 &lt;code&gt;lxc launch -h&lt;/code&gt; でヘルプが見られます。&lt;/p&gt;

&lt;p&gt;ここでは &lt;code&gt;images&lt;/code&gt; のリモートの &lt;code&gt;centos/7/amd64&lt;/code&gt; のエイリアスのイメージを起動して &lt;code&gt;cent01&lt;/code&gt; というコンテナ名を付けてみます。どれぐらい時間がかかるか計測するため &lt;code&gt;time&lt;/code&gt; コマンドを付けて実行してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time lxc launch images:centos/7/amd64 cent01
Creating cent01
Retrieving image: 100%
Starting cent01

real    0m58.036s
user    0m0.056s
sys     0m0.036s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Retrieving image: 100%&lt;/code&gt; と表示されているように初回はイメージのダウンロードを行うので少し時間がかかります。私の環境では1分弱でした。&lt;/p&gt;

&lt;p&gt;起動直後に &lt;code&gt;lxc list&lt;/code&gt; を実行すると、 IPv6アドレスは付与されていますが、 IPv4アドレスはまだ空です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  | IPV4 |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING |      | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数秒立ってから再度実行するとIPv4アドレスが付与されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  |         IPV4         |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING | 10.64.177.167 (eth0) | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この時点でローカルのイメージ一覧を表示してみると、CentOS 7のイメージが追加されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc image list
+-------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
| ALIAS | FINGERPRINT  | PUBLIC |            DESCRIPTION            |  ARCH  |  SIZE   |         UPLOAD DATE         |
+-------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
|       | 9c8a52ca68e4 | no     | Centos 7 (amd64) (20160507_02:16) | x86_64 | 62.93MB | May 7, 2016 at 7:13am (UTC) |
+-------+--------------+--------+-----------------------------------+--------+---------+-----------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じイメージで2つめのコンテナを起動してみると今度はローカルのイメージを使うので起動時間は短くてすみました。私の環境では約10秒でした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time lxc launch images:centos/7/amd64 cent02
Creating cent02
Starting cent02

real    0m10.189s
user    0m0.044s
sys     0m0.008s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動直後にコンテナ一覧を確認すると、今起動した &lt;code&gt;cent02&lt;/code&gt; コンテナのIPv4アドレスはやはり空です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  |         IPV4         |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING | 10.64.177.167 (eth0) | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent02 | RUNNING |                      | fd36:b946:6537:931e:216:3eff:fe18:680a (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数秒立ってから再度確認すると &lt;code&gt;centos02&lt;/code&gt; コンテナにもIPv4アドレスが付与されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc list
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
|  NAME  |  STATE  |         IPV4         |                     IPV6                      |    TYPE    | SNAPSHOTS |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent01 | RUNNING | 10.64.177.167 (eth0) | fd36:b946:6537:931e:216:3eff:fec9:2e18 (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
| cent02 | RUNNING | 10.64.177.34 (eth0)  | fd36:b946:6537:931e:216:3eff:fe18:680a (eth0) | PERSISTENT | 0         |
+--------+---------+----------------------+-----------------------------------------------+------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;コンテナ内でコマンドを実行する&#34;&gt;コンテナ内でコマンドを実行する&lt;/h3&gt;

&lt;p&gt;例えば &lt;code&gt;cent01&lt;/code&gt; コンテナで &lt;code&gt;bash&lt;/code&gt; を起動するには &lt;code&gt;lxc exec cent01 bash&lt;/code&gt; と実行します。するとコンテナ内で root ユーザになってプロンプトが表示されるので、好きなコマンドを入力して実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc exec cent01 bash
[root@cent01 ~]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
37: eth0@if38: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP qlen 1000
    link/ether 00:16:3e:5f:01:7e brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 10.155.92.101/24 brd 10.155.92.255 scope global dynamic eth0
       valid_lft 2508sec preferred_lft 2508sec
    inet6 fe80::216:3eff:fe5f:17e/64 scope link
       valid_lft forever preferred_lft forever
[root@cent01 ~]# ping -c 3 cent02
PING cent02.lxd (10.64.177.34) 56(84) bytes of data.
64 bytes from cent02.lxd (10.64.177.34): icmp_seq=1 ttl=64 time=0.034 ms
64 bytes from cent02.lxd (10.64.177.34): icmp_seq=2 ttl=64 time=0.068 ms
64 bytes from cent02.lxd (10.64.177.34): icmp_seq=3 ttl=64 time=0.081 ms

--- cent02.lxd ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1998ms
rtt min/avg/max/mdev = 0.034/0.061/0.081/0.019 ms
[root@cent01 ~]# exit
exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記の &lt;code&gt;ping&lt;/code&gt; の例でも分かる通り、コンテナ内から別のコンテナの名前を指定して通信可能です。 &lt;code&gt;ping&lt;/code&gt; の出力を見ると &lt;code&gt;.lxd&lt;/code&gt; というトップレベルドメインがつけられていて、 &lt;code&gt;ping -c 3 cent02.lxd&lt;/code&gt; でも大丈夫でした。この &lt;code&gt;.lxd&lt;/code&gt; という値は &lt;code&gt;/etc/default/lxd-bridge&lt;/code&gt; の &lt;code&gt;LXD_DOMAIN=&amp;quot;lxd&amp;quot;&lt;/code&gt; という設定で指定されています。&lt;/p&gt;

&lt;p&gt;Control-Dを押すか、&lt;code&gt;exit&lt;/code&gt; に続いてenterキーで &lt;code&gt;bash&lt;/code&gt; から抜けます。&lt;/p&gt;

&lt;p&gt;単一のコマンドを実行したい場合は &lt;code&gt;bash&lt;/code&gt; の代わりにコマンドを書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc exec cent01 ls /
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドにオプションを指定するとエラーになりますが、コマンドの前に &lt;code&gt;--&lt;/code&gt; を入れれば大丈夫です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lxc exec cent01 ls -a /
error: flag provided but not defined: -a
$ lxc exec cent01 -- ls -a /
.  ..  .autorelabel  bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ホストosを再起動するとコンテナは自動起動されます&#34;&gt;ホストOSを再起動するとコンテナは自動起動されます&lt;/h2&gt;

&lt;p&gt;LXCではホストOS起動時にコンテナを自動起動するには設定ファイルの編集が必要でしたが、LXDは特に設定は不要でした。　
ホストOSを再起動して &lt;code&gt;lxc list&lt;/code&gt; を実行してみると上記で作成した2つのコンテナのSTATEがRUNNINGになっていました。&lt;/p&gt;

&lt;h2 id=&#34;コンテナの停止と削除&#34;&gt;コンテナの停止と削除&lt;/h2&gt;

&lt;p&gt;停止は &lt;code&gt;lxc stop コンテナ名&lt;/code&gt; 、削除は &lt;code&gt;lxc delete コンテナ名&lt;/code&gt; で出来ます。が、 CentOS 7 のコンテナを停止するには以下の事前準備が必要でした。&lt;/p&gt;

&lt;h3 id=&#34;centos-7-のコンテナを停止可能にするための設定&#34;&gt;CentOS 7 のコンテナを停止可能にするための設定&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;cent01&lt;/code&gt; のところは実際のコンテナ名に置き換えて、各コンテナで実行が必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lxc exec cent01 -- sh -c &#39;ln -s /usr/lib/systemd/system/halt.target /etc/systemd/system/sigpwr.target &amp;amp;&amp;amp; systemctl daemon-reload&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この回避方法は &lt;a href=&#34;https://lists.linuxcontainers.org/pipermail/lxc-users/2014-February/006304.html&#34;&gt;[lxc-users] lxc-stop doesn&amp;rsquo;t stop centos, waits for the timeout&lt;/a&gt; で紹介されていました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lists.linuxcontainers.org/pipermail/lxc-users/2016-May/011602.html&#34;&gt;[lxc-users] lxc stop does not stop a CentOS 7 container&lt;/a&gt; で &lt;code&gt;images:&lt;/code&gt; で公開しているイメージにこの修正を取り込めないか問い合わせ中です。&lt;/p&gt;

&lt;h2 id=&#34;コンテナやイメージのファイルの在り処&#34;&gt;コンテナやイメージのファイルの在り処&lt;/h2&gt;

&lt;p&gt;コンテナのファイルは &lt;code&gt;/var/lib/lxd/containers/&lt;/code&gt; にありました。操作しているユーザのuidとgidは1000なのですが、コンテナのディレクトリは100000と異なっていました。どこかでマッピングを持っているのだと思いますが、未調査です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ls -l /var/lib/lxd/containers/
合計 24
drwxr-xr-x+ 4 100000 100000  4096  5月  6 18:56 cent01
drwxr-xr-x+ 4 100000 100000  4096  5月  7 03:18 cent02
-rw-r--r--  1 root   root   10756  5月  7 19:47 lxc-monitord.log
drwxr-xr-x+ 4 100000 100000  4096  5月  3 20:46 my-ubuntu
$ sudo ls -l /var/lib/lxd/containers/cent01
合計 12
-rw-r--r--  1 root   root    628  1月  1  1970 metadata.yaml
dr-xr-xr-x 18 100000 100000 4096  5月  6 18:56 rootfs
drwxr-xr-x  2 root   root   4096  5月  6 18:56 templates
1$ sudo ls -l /var/lib/lxd/containers/cent01/rootfs/
合計 64
lrwxrwxrwx  1 100000 100000    7  5月  6 11:25 bin -&amp;gt; usr/bin
dr-xr-xr-x  2 100000 100000 4096  8月 12  2015 boot
drwxr-xr-x  4 100000 100000 4096  5月  6 11:25 dev
drwxr-xr-x 55 100000 100000 4096  5月  7 12:13 etc
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 home
lrwxrwxrwx  1 100000 100000    7  5月  6 11:25 lib -&amp;gt; usr/lib
lrwxrwxrwx  1 100000 100000    9  5月  6 11:25 lib64 -&amp;gt; usr/lib64
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 media
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 mnt
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 opt
dr-xr-xr-x  2 100000 100000 4096  8月 12  2015 proc
dr-xr-x---  3 100000 100000 4096  5月  7 03:42 root
drwxr-xr-x  7 100000 100000 4096  5月  6 11:25 run
lrwxrwxrwx  1 100000 100000    8  5月  6 11:25 sbin -&amp;gt; usr/sbin
drwxr-xr-x  2 100000 100000 4096  5月  6 11:25 selinux
drwxr-xr-x  2 100000 100000 4096  8月 12  2015 srv
dr-xr-xr-x  2 100000 100000 4096  8月 12  2015 sys
drwxrwxrwt  7 100000 100000 4096  5月  7 12:54 tmp
drwxr-xr-x 13 100000 100000 4096  5月  6 11:25 usr
drwxr-xr-x 19 100000 100000 4096  5月  6 18:56 var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イメージのファイルは &lt;code&gt;/var/lib/lxd/images/&lt;/code&gt; にありました。 &lt;code&gt;lxc image list&lt;/code&gt; で表示されるフィンガープリント名のファイルとフィンガープリントに &lt;code&gt;.rootfs&lt;/code&gt; を追加した名前のファイルがあります。調べてみるとtar.xz形式のファイルになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ls -l /var/lib/lxd/images/
合計 205244
-rw-r--r-- 1 root root       588  5月  6 18:54 a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2
-rw-r--r-- 1 root root  65931516  5月  6 18:55 a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs
-rw-r--r-- 1 root root       792  5月  3 20:32 f4c4c60a6b752a381288ae72a1689a9da00f8e03b732c8d1b8a8fcd1a8890800
-rw-r--r-- 1 root root 144223868  5月  3 20:46 f4c4c60a6b752a381288ae72a1689a9da00f8e03b732c8d1b8a8fcd1a8890800.rootfs
$ sudo file /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2
/var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2: XZ compressed data
$ sudo file /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs
/var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs: XZ compressed data
$ sudo tar tvf /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2
-rw-r--r-- 0/0             239 1970-01-01 09:00 templates/hosts.tpl
-rw-r--r-- 0/0             628 1970-01-01 09:00 metadata.yaml
-rw-r--r-- 0/0              21 1970-01-01 09:00 templates/hostname.tpl
$ sudo tar tvf /var/lib/lxd/images/a027d59858d663fb2bc12b5ba767e92196a4aee8dbb2a607db53d718b91eb5d2.rootfs | head
dr-xr-xr-x 0/0               0 2016-05-06 11:25 ./
drwxr-xr-x 0/0               0 2016-05-06 11:25 ./dev/
crw-rw-rw- 0/0             5,2 2016-05-06 11:25 ./dev/ptmx
prw------- 0/0               0 2016-05-06 11:25 ./dev/initctl
crw-rw-rw- 0/0             1,7 2016-05-06 11:25 ./dev/full
crw------- 0/0             5,1 2016-05-06 11:25 ./dev/console
crw-rw-rw- 0/0             4,4 2016-05-06 11:25 ./dev/tty4
crw-rw-rw- 0/0             4,3 2016-05-06 11:25 ./dev/tty3
crw-rw-rw- 0/0             4,2 2016-05-06 11:25 ./dev/tty2
crw-rw-rw- 0/0             4,1 2016-05-06 11:25 ./dev/tty1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/var/lib/lxd/&lt;/code&gt; には他にもディレクトリやファイルが存在しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l /var/lib/lxd
合計 84
drwx--x--x 5 root root  4096  5月  7 12:54 containers
drwx--x--x 5 root root  4096  5月  7 12:54 devices
drwxr-xr-x 2 root root  4096  5月  7 19:41 devlxd
drwx------ 2 root root  4096  5月  7 06:13 images
-rw-r--r-- 1 root root 43008  5月  7 19:46 lxd.db
drwx------ 4 root root  4096  5月  3 20:46 security
-rw-r--r-- 1 root root  2004  5月  3 20:26 server.crt
-rw------- 1 root root  3247  5月  3 20:26 server.key
drwx--x--x 5 root root  4096  5月  7 12:54 shmounts
drwx------ 2 root root  4096  5月  3 20:26 snapshots
srw-rw---- 1 root lxd      0  5月  7 12:51 unix.socket
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04 LTSでLXD 2.0を試してみた</title>
      <link>/blog/2016/05/07/tried-lxd-2.0-on-ubuntu-16.04/</link>
      <pubDate>Sat, 07 May 2016 14:12:49 +0900</pubDate>
      
      <guid>/blog/2016/05/07/tried-lxd-2.0-on-ubuntu-16.04/</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2016/04/19/run_centos7_containers_on_lxc2/&#34;&gt;LXC 2.0でCentOS 7のコンテナを動かしてみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;でLXC 2.0を試しましたが、今度はLXD 2.0を試してみました。&lt;/p&gt;

&lt;p&gt;実は私は、コンテナをローカルホストでしか動かさないならLXC、リモートホストでも動かすならLXDという使い分けなのかなと漠然と思っていました。&lt;/p&gt;

&lt;p&gt;上記の記事ではrootユーザでコンテナを作成するという特権コンテナについて書きましたが、非rootユーザでコンテナを作成する非特権コンテナについては書いていませんでした。&lt;/p&gt;

&lt;p&gt;実は CentOS 7 の非特権コンテナも試していたのですが、 DHCP で IPアドレスが付与されないという現象が起きていました。私の当面の用途は開発環境構築でありホストOS側でroot権限はあることが前提なので非特権コンテナは調査しないことにしました。&lt;/p&gt;

&lt;p&gt;一方、LXDはデフォルトで非特権コンテナを作るようになっています。今回試してみたところ、 CentOS 7 のコンテナも DHCP で無事 IPアドレスが付与されました。&lt;/p&gt;

&lt;p&gt;root権限を使うのは必要最小限にするのが望ましいので、この状況を見ると今後新規に環境構築するならLXCよりもLXDを使うほうが良いかなと思います。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;a href=&#34;https://github.com/lxc/lxd&#34;&gt;https://github.com/lxc/lxd&lt;/a&gt; によると、LXD は lex-dee と発音するそうです。カタカナで書くとレックスディーもしくはレクスディーでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;記事リスト&#34;&gt;記事リスト&lt;/h2&gt;

&lt;p&gt;いろいろ試していたら記事が長くなってきたので分割しました。例によって他の方に向けた入門記事ではなく、自分用の調査メモです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/start-using-lxd-2.0-on-ubuntu-16.04/&#34;&gt;Ubuntu 16.04 LTSでLXD 2.0をセットアップして使ってみる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/script-to-check-running-status-of-lxd-container/&#34;&gt;LXCの特定の1つのコンテナの起動状態をシェルスクリプトで確認したいときのお勧めの方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/how-to-use-fixed-ip-address-for-a-lxd-container/&#34;&gt;LXDコンテナで固定IPアドレスを使うための設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/tried-ansible-lxd-connection-plugin/&#34;&gt;AnsibleのLXDコネクションプラグインを試してみた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/tried-lxd-rest-api-with-curl/&#34;&gt;LXDのREST APIをcurlで試してみた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/blog/blog/2016/05/07/tried-pylxd/&#34;&gt;LXDのREST APIクライアントライブラリpylxdを試してみた&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なお、記事によってコンテナのIPアドレスのネットワークが違う場合がありますが、何回か環境を作りなおして毎回ランダムなネットワークを使っているためなので気にしないでください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LXD 0.7ではlxc execでシェルの対話操作もできるようになっていました</title>
      <link>/blog/2015/04/23/try-lxd-0.7-with-vagrant/</link>
      <pubDate>Thu, 23 Apr 2015 00:08:30 +0900</pubDate>
      
      <guid>/blog/2015/04/23/try-lxd-0.7-with-vagrant/</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/2014/12/01/lxd-the-linux-container-daemon/&#34;&gt;LXDを試してみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;の記事を書いて以来、LXD触る時間を作れてなかったのですが、久々に試してみました。&lt;/p&gt;

&lt;p&gt;今では&lt;a href=&#34;https://github.com/lxc/lxd&#34;&gt;lxc/lxd&lt;/a&gt;にVagrantfileが同梱されているので、それを使うだけで簡単に試せます。&lt;/p&gt;

&lt;p&gt;VirtualBox 4.3.26, Vagrant 1.7.2, OS X Yosemiteという環境で試しました。&lt;/p&gt;

&lt;h2 id=&#34;操作手順&#34;&gt;操作手順&lt;/h2&gt;

&lt;h3 id=&#34;vagrantでvmを起動&#34;&gt;VagrantでVMを起動&lt;/h3&gt;

&lt;p&gt;まずOS X上で以下のコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/lxc/lxd
cd lxd
vagrant up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lxc/lxd/blob/lxd-0.7/Vagrantfile&#34;&gt;Vagrantfile&lt;/a&gt;を見てみると、Vagrantのシェルプロビジョナでgoとlxdをインストールするようになっています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lxc/lxd/blob/lxd-0.7/scripts/vagrant/install-lxd.sh&#34;&gt;lxd/install-lxd.sh at lxd-0.7 · lxc/lxd&lt;/a&gt;を見てみると、&lt;a href=&#34;https://github.com/lxc/lxd&#34;&gt;lxdのREADME&lt;/a&gt;と同様のセットアップ手順に加えてlxdをサービスとして登録して起動する処理まで含まれています。&lt;/p&gt;

&lt;h3 id=&#34;vmにログインしてlxcコマンドを試してみる&#34;&gt;VMにログインしてlxcコマンドを試してみる&lt;/h3&gt;

&lt;p&gt;以下のコマンドを実行してVMにログインします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以降のコマンドはVM上で実行します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lxc&lt;/code&gt; と &lt;code&gt;lxd&lt;/code&gt; にはPATHが通った状態になっていることを確認しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ which lxc
/home/vagrant/go/bin/lxc
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ which lxd
/home/vagrant/go/bin/lxd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バージョンを確認してみると、 &lt;code&gt;lxc&lt;/code&gt;, &lt;code&gt;lxd&lt;/code&gt; ともに0.7でした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxd --version
0.7
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc --version
0.7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lxc/lxd#first-steps&#34;&gt;lxdのREADMEのFirst steps&lt;/a&gt;に添って、ubuntuとdebianのイメージを取得します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ ./scripts/lxd-images import lxc ubuntu trusty amd64 --alias ubuntu --alias ubuntu/trusty
Downloading the GPG key for https://images.linuxcontainers.org
Downloading the image list for https://images.linuxcontainers.org
Validating the GPG signature of /tmp/tmpsccxc1fa/index.json.asc
Downloading the image: https://images.linuxcontainers.org/images/ubuntu/trusty/amd64/default/20150420_03:49/lxd.tar.xz
Validating the GPG signature of /tmp/tmpsccxc1fa/ubuntu-trusty-amd64-default-20150420_03:49.tar.xz.asc
Image imported as: c9176e837c0012d6d0eed221312ee9fc761765319701f57e65e63542ad9beade
Setup alias: ubuntu
Setup alias: ubuntu/trusty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;debianのほうは最初コピペミスでaliasに2回同じ値を指定してしまってエラーになりましたが、再度実行すると成功しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ scripts/lxd-images import lxc debian wheezy amd64 --alias debian --alias debian/wheezy --alias debian/wheezy
Downloading the GPG key for https://images.linuxcontainers.org
Downloading the image list for https://images.linuxcontainers.org
Validating the GPG signature of /tmp/tmp_d1gz0q6/index.json.asc
Downloading the image: https://images.linuxcontainers.org/images/debian/wheezy/amd64/default/20150419_22:42/lxd.tar.xz
Validating the GPG signature of /tmp/tmp_d1gz0q6/debian-wheezy-amd64-default-20150419_22:42.tar.xz.asc
Image imported as: cd398814f6e4e1e50799ba8249b80aa3558e5b05edf71a996a174def87569ae5
Setup alias: debian
Setup alias: debian/wheezy
Traceback (most recent call last):
  File &amp;quot;scripts/lxd-images&amp;quot;, line 410, in &amp;lt;module&amp;gt;
    args.func(parser, args)
  File &amp;quot;scripts/lxd-images&amp;quot;, line 367, in import_lxc
    setup_alias(parser, args, fingerprint)
  File &amp;quot;scripts/lxd-images&amp;quot;, line 330, in setup_alias
    lxd.aliases_create(alias, fingerprint)
  File &amp;quot;scripts/lxd-images&amp;quot;, line 83, in aliases_create
    raise Exception(&amp;quot;Failed to create alias: %s&amp;quot; % name)
Exception: Failed to create alias: debian/wheezy
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ scripts/lxd-images import lxc debian wheezy amd64 --alias debian --alias debian/wheezy --alias debian/wheezy/amd64
Downloading the GPG key for https://images.linuxcontainers.org
Downloading the image list for https://images.linuxcontainers.org
Validating the GPG signature of /tmp/tmpeqkwuvfw/index.json.asc
Downloading the image: https://images.linuxcontainers.org/images/debian/wheezy/amd64/default/20150419_22:42/lxd.tar.xz
Validating the GPG signature of /tmp/tmpeqkwuvfw/debian-wheezy-amd64-default-20150419_22:42.tar.xz.asc
This image is already in the store.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナを起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc launch ubuntuCreating container...done
Starting container...done
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc launch debian debian01
Creating container...done
Starting container...done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナの一覧を表示してみます。ubuntuのほうはコンテナ名を指定しなかったので、自動で付けられています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc list
+---------------------+---------+------------+------+-----------+
|        NAME         |  STATE  |    IPV4    | IPV6 | EPHEMERAL |
+---------------------+---------+------------+------+-----------+
| preterhuman-araceli | RUNNING | 10.0.3.188 |      | NO        |
| debian01            | RUNNING |            |      | NO        |
+---------------------+---------+------------+------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;debianのほうはIPアドレスが空になっていて、あれ？と思ったのですが、実行するタイミングが早すぎたようで、数秒立ってから再度実行するとアドレスが表示されました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc list
+---------------------+---------+------------+------+-----------+
|        NAME         |  STATE  |    IPV4    | IPV6 | EPHEMERAL |
+---------------------+---------+------------+------+-----------+
| preterhuman-araceli | RUNNING | 10.0.3.188 |      | NO        |
| debian01            | RUNNING | 10.0.3.42  |      | NO        |
+---------------------+---------+------------+------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以前未実装だった &lt;code&gt;lxc shell&lt;/code&gt; の代わりに &lt;code&gt;lxc exec&lt;/code&gt; でコマンド実行やシェルでの対話操作ができるようになっていました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lxc exec コンテナ名 コマンド 引数&lt;/code&gt; のように指定すると、コンテナ内でコマンドを実行できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
6: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:16:3e:01:bd:a1 brd ff:ff:ff:ff:ff:ff
    inet 10.0.3.42/24 brd 10.0.3.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::216:3eff:fe01:bda1/64 scope link
       valid_lft forever preferred_lft forever
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec preterhuman-araceli ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
4: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:16:3e:5e:6c:79 brd ff:ff:ff:ff:ff:ff
    inet 10.0.3.188/24 brd 10.0.3.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::216:3eff:fe5e:6c79/64 scope link
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;uname -a&lt;/code&gt; のようなコマンドを &lt;code&gt;lxc exec コンテナ名 コマンド 引数&lt;/code&gt; のように指定するとlxcのオプションと解釈するようで、以下のエラーになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec preterhuman-araceli uname -a
error: flag provided but not defined: -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナ名のあとに &lt;code&gt;--&lt;/code&gt; を入れれば回避出来ました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec preterhuman-araceli -- uname -a
Linux preterhuman-araceli 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、原因は不明なのですが、何回か実行してみると、時々何も出力されないことがありました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
Linux debian01 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 GNU/Linux
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
Linux debian01 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 GNU/Linux
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
Linux debian01 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 GNU/Linux
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
Linux debian01 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 GNU/Linux
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
Linux debian01 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 GNU/Linux
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
Linux debian01 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 GNU/Linux
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec debian01 -- uname -a
Linux debian01 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lxc exec コンテナ名 /bin/bash&lt;/code&gt; のようにコマンドにシェルを指定すると、コンテナ内でシェルが起動され対話操作が出来ました。ubuntuコンテナの実際の画面では &lt;code&gt;ls&lt;/code&gt; の結果もカラー表示されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$ lxc exec preterhuman-araceli /bin/bash
root@preterhuman-araceli:~# ls
root@preterhuman-araceli:~# pwd
/root
root@preterhuman-araceli:~# cd /
root@preterhuman-araceli:/# ls -l
total 60
drwxr-xr-x   2 root   root    4096 Apr 20 03:55 bin
drwxr-xr-x   2 root   root    4096 Apr 10  2014 boot
drwxr-xr-x   5 root   root     420 Apr 22 13:51 dev
drwxr-xr-x  63 root   root    4096 Apr 22 13:51 etc
drwxr-xr-x   3 root   root    4096 Apr 20 03:55 home
drwxr-xr-x  12 root   root    4096 Apr 20 03:54 lib
drwxr-xr-x   2 root   root    4096 Apr 20 03:54 lib64
drwxr-xr-x   2 root   root    4096 Apr 20 03:53 media
drwxr-xr-x   2 root   root    4096 Apr 10  2014 mnt
drwxr-xr-x   2 root   root    4096 Apr 20 03:53 opt
dr-xr-xr-x 109 nobody nogroup    0 Apr 22 13:51 proc
drwx------   2 root   root    4096 Apr 20 03:53 root
drwxr-xr-x   9 root   root     380 Apr 22 13:51 run
drwxr-xr-x   2 root   root    4096 Apr 20 03:55 sbin
drwxr-xr-x   2 root   root    4096 Apr 20 03:53 srv
dr-xr-xr-x  13 nobody nogroup    0 Apr 22 13:51 sys
drwxrwxrwt   2 root   root    4096 Apr 20 03:55 tmp
drwxr-xr-x  10 root   root    4096 Apr 20 03:53 usr
drwxr-xr-x  11 root   root    4096 Apr 20 03:53 var
root@preterhuman-araceli:/# ls
bin   dev  home  lib64  mnt  proc  run   srv  tmp  var
boot  etc  lib   media  opt  root  sbin  sys  usr
root@preterhuman-araceli:/# pwd
/
root@preterhuman-araceli:/# exit
vagrant@vagrant-ubuntu-trusty-64:~/go/src/github.com/lxc/lxd$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;以前試した時に比べて、かなり進歩してますね。&lt;/p&gt;

&lt;p&gt;ten_forwardさんのライブマイグレーションの記事とかも、今後試してみようと思います。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/defiant/20150415/1429089615&#34;&gt;lxd を使ったライブマイグレーション (1) - TenForwardの日記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/defiant/20150415/1429090896&#34;&gt;lxd を使ったライブマイグレーション (2) - TenForwardの日記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>