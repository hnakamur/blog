<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on hnakamur&#39;s blog</title>
    <link>https://hnakamur.github.io/blog/tags/golang/</link>
    <description>Recent content in Golang on hnakamur&#39;s blog</description>
    <generator>Hugo</generator>
    <language>ja-jp</language>
    <lastBuildDate>Thu, 30 Jun 2016 06:40:12 +0900</lastBuildDate>
    <atom:link href="https://hnakamur.github.io/blog/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>分散SQLデータベースCockroachDBのキーバリューストレージのデバッグコマンドを試してみた</title>
      <link>https://hnakamur.github.io/blog/2016/06/30/experiment-cockroachdb-key-value-store/</link>
      <pubDate>Thu, 30 Jun 2016 06:40:12 +0900</pubDate>
      <guid>https://hnakamur.github.io/blog/2016/06/30/experiment-cockroachdb-key-value-store/</guid>
      <description>&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;h/blog/2016/06/20/lsm-tree-and-rocksdb/&#34;&gt;LSM-TreeとRocksDB、TiDB、CockroachDBが気になる&lt;/a&gt; で紹介した &lt;a href=&#34;https://github.com/cockroachdb/cockroach#client-drivers&#34;&gt;CockroachDB&lt;/a&gt; は &lt;a href=&#34;https://github.com/cockroachdb/cockroach#what-is-cockroachdb&#34;&gt;What is CockroachDB?&lt;/a&gt; によるとスケールアウトできる分散SQLデータベースです。 &lt;a href=&#34;https://github.com/cockroachdb/cockroach#client-drivers&#34;&gt;PostgreSQLのワイヤープロトコルをサポート&lt;/a&gt; していて、 &lt;a href=&#34;https://github.com/cockroachdb/cockroach#quickstart&#34;&gt;Quickstart&lt;/a&gt; の例のようにPostgreSQLで扱えるSQLのサブセットが使えます。&lt;/p&gt;</description>
    </item>
    <item>
      <title>連番ファイル名の命名規則について実験してみた</title>
      <link>https://hnakamur.github.io/blog/2016/06/22/experimented_with_naming_for_many_sequential_numbered_files/</link>
      <pubDate>Wed, 22 Jun 2016 23:40:27 +0900</pubDate>
      <guid>https://hnakamur.github.io/blog/2016/06/22/experimented_with_naming_for_many_sequential_numbered_files/</guid>
      <description>&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;&#xA;&lt;p&gt;0〜1,000,000といった連番のファイルを作るときに、1つのディレクトリに全てのファイルを入れると、遅くなるとか取り扱いが面倒になるという懸念があります。&lt;/p&gt;</description>
    </item>
    <item>
      <title>sleuthというGoのライブラリでサービスディスカバリを試してみた</title>
      <link>https://hnakamur.github.io/blog/2016/06/15/tried-service-discovery-with-sleuth/</link>
      <pubDate>Wed, 15 Jun 2016 06:56:10 +0900</pubDate>
      <guid>https://hnakamur.github.io/blog/2016/06/15/tried-service-discovery-with-sleuth/</guid>
      <description>&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://darian.af/post/master-less-peer-to-peer-micro-service-autodiscovery-in-golang-with-sleuth/&#34;&gt;Service autodiscovery in Go with sleuth - darian.af&lt;/a&gt;という記事を見かけて試してみたのでメモです。&lt;/p&gt;&#xA;&lt;h2 id=&#34;githubcomursiformsleuthのセットアップ&#34;&gt;github.com/ursiform/sleuthのセットアップ&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ursiform/sleuth#installation&#34;&gt;Installation&lt;/a&gt;を見ながらセットアップします。&lt;/p&gt;&#xA;&lt;p&gt;いきなりgo getでインストールしてみるとZeroMQ version 4が必要というエラーメッセージが出ました。&lt;/p&gt;</description>
    </item>
    <item>
      <title>gistを作成するGoのCLIを見つけた</title>
      <link>https://hnakamur.github.io/blog/2016/06/14/go_cli_to_create_a_gist/</link>
      <pubDate>Tue, 14 Jun 2016 00:52:22 +0900</pubDate>
      <guid>https://hnakamur.github.io/blog/2016/06/14/go_cli_to_create_a_gist/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/delta24/gist&#34;&gt;delta24/gist: A command line gister in Go&lt;/a&gt;です。期待通りに動かない点があったのでプルリクエストを送ったら、すぐにマージされました。&lt;/p&gt;&#xA;&lt;h2 id=&#34;インストール&#34;&gt;インストール&lt;/h2&gt;&#xA;&lt;p&gt;Goはインストール済みという前提で、以下のコマンドを実行します。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Goのシリアライゼーションのベンチマークを自分でも試してみた</title>
      <link>https://hnakamur.github.io/blog/2016/06/13/tried_go_serialization_benchmarks/</link>
      <pubDate>Mon, 13 Jun 2016 23:34:16 +0900</pubDate>
      <guid>https://hnakamur.github.io/blog/2016/06/13/tried_go_serialization_benchmarks/</guid>
      <description>&lt;p&gt;2015年12月の記事ですが&lt;a href=&#34;http://qiita.com/shibukawa/items/878c5fe8ec09935fccd2&#34;&gt;最速という噂のFlatbuffersの速度のヒミツと、導入方法の紹介(Go) - Qiita&lt;/a&gt;を読んで、「gobは遅いのかー、残念」、「一方Flatbuffersは面倒そうだなー」と思っていました。&lt;/p&gt;</description>
    </item>
    <item>
      <title>GoでLTSV形式でログ出力するライブラリを書いた</title>
      <link>https://hnakamur.github.io/blog/2016/06/13/wrote_go_ltsvlog_library/</link>
      <pubDate>Mon, 13 Jun 2016 21:42:53 +0900</pubDate>
      <guid>https://hnakamur.github.io/blog/2016/06/13/wrote_go_ltsvlog_library/</guid>
      <description>&lt;h2 id=&#34;なぜ書いたか&#34;&gt;なぜ書いたか&lt;/h2&gt;&#xA;&lt;p&gt;Goで高機能なサードパーティのログ出力ライブラリと言えば&lt;a href=&#34;https://github.com/Sirupsen/logrus&#34;&gt;Sirupsen/logrus&lt;/a&gt;が有名です。私も&lt;a href=&#34;https://github.com/doloopwhile/logrusltsv&#34;&gt;doloopwhile/logrusltsv&lt;/a&gt;と組み合わせてLTSV形式のログ出力するのに使っていました。&lt;/p&gt;&#xA;&lt;p&gt;しかし、&lt;a href=&#34;http://methane.hatenablog.jp/entry/2015/09/17/logger_%E3%81%AE%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6_%5BGo%5D&#34;&gt;logger のパフォーマンスについて [Go] - methaneのブログ&lt;/a&gt;にも書かれていますが、&lt;a href=&#34;https://godoc.org/github.com/Sirupsen/logrus#WithFields&#34;&gt;logrus.WithFields&lt;/a&gt;は&lt;a href=&#34;https://godoc.org/github.com/Sirupsen/logrus#Fields&#34;&gt;Fields&lt;/a&gt;、つまり &lt;code&gt;map[string]interface{}&lt;/code&gt; の値を渡す必要があります。これはGCに負荷をかけそうというのも気になりますが、Goのmapは順不同なのでログ出力の際にキーの順番がソースに書いた順番と必ずしも一致しないというのがイマイチだよなーと思っていました。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Goで複数のリモートのワーカーにジョブを実行させるremoteworkersというパッケージを書いた</title>
      <link>https://hnakamur.github.io/blog/2016/06/12/wrote_remoteworkers_go_pacakge/</link>
      <pubDate>Sun, 12 Jun 2016 21:53:35 +0900</pubDate>
      <guid>https://hnakamur.github.io/blog/2016/06/12/wrote_remoteworkers_go_pacakge/</guid>
      <description>&lt;h2 id=&#34;なぜ書いたか&#34;&gt;なぜ書いたか&lt;/h2&gt;&#xA;&lt;p&gt;仕事で複数のサーバで同じ処理を実行して結果を集めたいというニーズがあって、各サーバをgRPCのサーバにするという実装でとりあえず実現していました。でも、出来れば処理を実行するワーカーサーバから制御サーバに接続して繋ぎっぱなしにしておいて、制御サーバからジョブを送り込む方式にしたいなーと思っていて、家で実装を進めていました。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Goで複数のリモートのワーカーにジョブを実行させるremoteworkersというパッケージを書いた</title>
      <link>https://hnakamur.github.io/blog/2016/06/12/wrote_remoteworkers_go_package/</link>
      <pubDate>Sun, 12 Jun 2016 21:53:00 +0900</pubDate>
      <guid>https://hnakamur.github.io/blog/2016/06/12/wrote_remoteworkers_go_package/</guid>
      <description>&lt;h2 id=&#34;なぜ書いたか&#34;&gt;なぜ書いたか&lt;/h2&gt;&#xA;&lt;p&gt;仕事で複数のサーバで同じ処理を実行して結果を集めたいというニーズがあって、各サーバをgRPCのサーバにするという実装でとりあえず実現していました。でも、出来れば処理を実行するワーカーサーバから制御サーバに接続して繋ぎっぱなしにしておいて、制御サーバからジョブを送り込む方式にしたいなーと思っていて、家で実装を進めていました。&lt;/p&gt;</description>
    </item>
    <item>
      <title>GoのMessagePackのライブラリのベンチマークをしてみた</title>
      <link>https://hnakamur.github.io/blog/2016/06/04/benchmark_go_msgpack_libraries/</link>
      <pubDate>Sat, 04 Jun 2016 22:17:52 +0900</pubDate>
      <guid>https://hnakamur.github.io/blog/2016/06/04/benchmark_go_msgpack_libraries/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://qiita.com/yosisa/items/f21d3476bc8d368d7494&#34;&gt;Go の msgpack ライブラリ比較 - Qiita&lt;/a&gt;の記事が最終更新日から1年以上経過しているとのことなので、現在の最新のコミットで試してみました。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;github.com/vmihailenco/msgpack&lt;/code&gt; を &lt;code&gt;go get&lt;/code&gt; すると&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ go get github.com/vmihailenco/msgpack&#xA;package github.com/vmihailenco/msgpack: code in directory /home/hnakamur/gocode/src/github.com/vmihailenco/msgpack expects import &amp;#34;gopkg.in/vmihailenco/msgpack.v2&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;と言われたので &lt;code&gt;go get gopkg.in/vmihailenco/msgpack.v2&lt;/code&gt; で取得し、この記事のコードの &lt;code&gt;&amp;quot;github.com/vmihailenco/msgpack&amp;quot;&lt;/code&gt; を &lt;code&gt;&amp;quot;gopkg.in/vmihailenco/msgpack.v2&amp;quot;&lt;/code&gt; に書き換え &lt;code&gt;msgpack_test.go&lt;/code&gt; という名前で保存して試しました。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go-daemonとgoのos.StartProcess()のコードを読んでみた</title>
      <link>https://hnakamur.github.io/blog/2016/04/23/go-daemon-and-golang-os-startprocess-code-reading/</link>
      <pubDate>Sat, 23 Apr 2016 16:45:09 +0900</pubDate>
      <guid>https://hnakamur.github.io/blog/2016/04/23/go-daemon-and-golang-os-startprocess-code-reading/</guid>
      <description>&lt;h2 id=&#34;発端-goでデーモンを書くのは無理と思っていたら実は出来るらしい&#34;&gt;発端: Goでデーモンを書くのは無理と思っていたら実は出来るらしい&lt;/h2&gt;&#xA;&lt;p&gt;Goでデーモンを書くのは無理と以前どこかで読んだ気がします。&#xA;ところが、Pythonで書かれた&lt;a href=&#34;https://github.com/graphite-project&#34;&gt;Graphite Project&lt;/a&gt;の&lt;a href=&#34;https://github.com/graphite-project/carbon&#34;&gt;carbon&lt;/a&gt;をGo言語で実装した&lt;a href=&#34;https://github.com/lomik/go-carbon&#34;&gt;lomik/go-carbon&lt;/a&gt;の Features に Run as daemon と書かれていました。どうやって実現しているのか気になって調べてみたのでメモです。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
