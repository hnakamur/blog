<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on hnakamur&#39;s blog at github</title>
    <link>/blog/tags/go/</link>
    <description>Recent content in Go on hnakamur&#39;s blog at github</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Sun, 31 May 2015 02:30:02 +0900</lastBuildDate>
    <atom:link href="/blog/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>goでglogを使うときのメモ</title>
      <link>/blog/2015/05/31/how_to_use_glog/</link>
      <pubDate>Sun, 31 May 2015 02:30:02 +0900</pubDate>
      
      <guid>/blog/2015/05/31/how_to_use_glog/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://blog.satotaichi.info/logging-frameworks-for-go/&#34;&gt;go言語におけるロギングについて&lt;/a&gt;の記事と&lt;a href=&#34;http://godoc.org/github.com/golang/glog&#34;&gt;glog - GoDoc&lt;/a&gt;を読んで試してみました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;flag.Parse()&lt;/code&gt; を呼ぶ必要があり、最後に &lt;code&gt;glog.Flush()&lt;/code&gt; を呼ぶ必要があるので &lt;code&gt;main&lt;/code&gt; で &lt;code&gt;defer&lt;/code&gt; で書いておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;flag&amp;quot;

	&amp;quot;github.com/golang/glog&amp;quot;
)

func main() {
	flag.Parse()
	defer glog.Flush()

	if glog.V(0) {
		glog.Info(&amp;quot;Hello, glog&amp;quot;)
	}

	glog.V(0).Info(&amp;quot;exiting&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ログレベルは &lt;code&gt;-v&lt;/code&gt; オプションで指定できるのですがデフォルト値は0なので、デフォルトで出力したいログはレベル0で書くようにします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://godoc.org/github.com/golang/glog#Verbose&#34;&gt;Verbose&lt;/a&gt;の説明によると、上の2つの書き方では前者のほうが実行時負荷が安上がりとのことです。これはログレベルの設定で出力を抑止した時に、 &lt;code&gt;Info&lt;/code&gt; の引数の評価をしなくて済むからです。&lt;/p&gt;

&lt;p&gt;使い分けるのも面倒なので、常に前者を使うことにします。&lt;/p&gt;

&lt;p&gt;ログファイル名は非公開関数 &lt;a href=&#34;https://github.com/golang/glog/blob/44145f04b68cf362d9c4df2182967c2275eaefed/glog_file.go#L83-L97&#34;&gt;glog.logName()&lt;/a&gt; の形式になります。&lt;/p&gt;

&lt;p&gt;ログのディレクトリは &lt;code&gt;-log_dir&lt;/code&gt; オプションで指定可能ですが、デフォルトでは &lt;a href=&#34;http://golang.org/pkg/os/#TempDir&#34;&gt;os.TempDir()&lt;/a&gt; になっています。&lt;/p&gt;

&lt;p&gt;OS Xの場合は環境変数 &lt;code&gt;$TMPDIR&lt;/code&gt; になります。セキュリティ上 &lt;code&gt;/tmp&lt;/code&gt; ではなくランダムは文字列のディレクトリになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo $TMPDIR
/var/folders/9p/r7jylfyd163bszlxvp0wk36h0000gn/T/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで、ログファイルを見るときは &lt;code&gt;less $TMPDIR/${プログラム名}.INFO&lt;/code&gt; とすればOKです。&lt;code&gt;go build&lt;/code&gt; でビルドしてプログラムを実行した時はその名前ですが、 &lt;code&gt;go run main.go&lt;/code&gt; のときは &lt;code&gt;main&lt;/code&gt; になるようで &lt;code&gt;$TMPDIR/main.INFO&lt;/code&gt; というファイルが出来ていました。&lt;/p&gt;

&lt;p&gt;このファイルはプログラム実行のたびに上書きされます。過去のログを見たいときは &lt;code&gt;less $TMPDIR/${プログラム名}&lt;/code&gt; まで入力しTABでファイル名補完して見るようにします。&lt;/p&gt;

&lt;p&gt;上記のサンプルで出力されたログは以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Log file created at: 2015/05/31 02:22:07
Running on machine: sunshine5
Binary: Built with gc go1.4.2 for darwin/amd64
Log line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg
I0531 02:22:07.343002   54353 main.go:14] Hello, glog
I0531 02:22:07.343897   54353 main.go:18] exiting
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ログの行フォーマットは4行目に書いてありますが、 &lt;a href=&#34;https://github.com/golang/glog/blob/44145f04b68cf362d9c4df2182967c2275eaefed/glog.go#L518-L534&#34;&gt;glog.header()のコメント&lt;/a&gt; に詳細な説明があります。&lt;/p&gt;

&lt;p&gt;各行の日付には年がないのですが、行のフォーマットは固定なので諦めましょう。ログファイルサイズ削減のために年は付けないようにしているのでしょう。先頭行に作成日時が年つきで書いてあるのでそちらを見れば良いです。&lt;/p&gt;

&lt;p&gt;スレッドIDやログ出力したファイル名と行番号が出るのが便利です。&lt;/p&gt;

&lt;p&gt;ということで開発時のデバッグログとしてはglog便利そうです。逆にシステムの運用ログとしては別のログライブラリのようが良いかもしれません。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>groongaのgoバインディングでWikipedia全文検索のサンプルウェブアプリを作ってみた</title>
      <link>/blog/2015/05/12/cgoroonga_wikipedia_search_webapp/</link>
      <pubDate>Tue, 12 May 2015 21:24:11 +0900</pubDate>
      
      <guid>/blog/2015/05/12/cgoroonga_wikipedia_search_webapp/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://hnakamur.github.io/blog/2015/04/27/cgoroonga/&#34;&gt;データ登録用にgroongaのC APIのgoバインディングを書いてみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;の続きで、APIを追加実装し、Wikipedia全文検索のサンプルウェブアプリを作ってみました。&lt;/p&gt;

&lt;h2 id=&#34;ソースコード:4c3e94caa0d90f3caef8e5ee8fd93962&#34;&gt;ソースコード&lt;/h2&gt;

&lt;p&gt;ウェブアプリのソースは
&lt;a href=&#34;https://github.com/hnakamur/cgoroonga/tree/master/examples/search_wikipedia_webapp&#34;&gt;https://github.com/hnakamur/cgoroonga/tree/master/examples/search_wikipedia_webapp&lt;/a&gt;
にあります。&lt;/p&gt;

&lt;p&gt;GroongaのC APIについては&lt;a href=&#34;http://groonga.org/ja/docs/reference/api.html&#34;&gt;7.20. API — Groonga v5.0.3ドキュメント&lt;/a&gt;を見つつ、ドキュメント化されていないものは&lt;a href=&#34;https://github.com/groonga/groonga&#34;&gt;groongaのソース&lt;/a&gt;を見て、goバインディングを作りました。&lt;/p&gt;

&lt;p&gt;goバインディングもウェブアプリもとりあえず全文検索の動作確認ができればいいやということで、ゆるい感じで書いています。&lt;/p&gt;

&lt;p&gt;ウェブアプリのサーバサイドのソースは
&lt;a href=&#34;https://github.com/hnakamur/cgoroonga/blob/master/examples/search_wikipedia_webapp/main.go&#34;&gt;https://github.com/hnakamur/cgoroonga/blob/master/examples/search_wikipedia_webapp/main.go&lt;/a&gt;
で、groongaのgoバインディングのソースは
&lt;a href=&#34;https://github.com/hnakamur/cgoroonga&#34;&gt;https://github.com/hnakamur/cgoroonga&lt;/a&gt;
の &lt;code&gt;*.go&lt;/code&gt; です。&lt;/p&gt;

&lt;h2 id=&#34;フロントエンドについては別記事で:4c3e94caa0d90f3caef8e5ee8fd93962&#34;&gt;フロントエンドについては別記事で&lt;/h2&gt;

&lt;p&gt;フロントエンドは&lt;a href=&#34;http://qiita.com/shibukawa/items/890d24874655439932ec&#34;&gt;最速MVCフレームワークMithril.jsの速度の秘密 - Qiita&lt;/a&gt;の記事を見て気になっていたので、&lt;a href=&#34;https://lhorie.github.io/mithril/&#34;&gt;Mithril&lt;/a&gt;で書いてみました。こちらについては別記事&lt;a href=&#34;/blog/blog/2015/05/12/tried_mithril_js/&#34;&gt;mithril.jsを試してみた&lt;/a&gt;に書きました。&lt;/p&gt;

&lt;h2 id=&#34;インデクスの作成:4c3e94caa0d90f3caef8e5ee8fd93962&#34;&gt;インデクスの作成&lt;/h2&gt;

&lt;p&gt;groongaコマンドで以下のようにして作成しました。約27分かかりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;column_create --table ArticleIndexes --name article_index --flags COLUMN_INDEX|WITH_POSITION|WITH_SECTION --type Articles --source _key,text&#39; | time groonga ~/work/groonga/db/wikipedia.db
[[0,1431052924.67975,1555.13576507568],true]
     1660.80 real      1135.40 user       146.29 sys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wikipediaのページタイトルと本文の両方を対象に検索したいので、 &lt;code&gt;--source&lt;/code&gt; には _keyカラム (タイトル) と text カラム (本文) の両方を指定しました。&lt;/p&gt;

&lt;h2 id=&#34;検索の応答は約80-250ms程度と満足な早さ:4c3e94caa0d90f3caef8e5ee8fd93962&#34;&gt;検索の応答は約80〜250ms程度と満足な早さ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;動作環境

&lt;ul&gt;
&lt;li&gt;マシン: MacBook Pro 15inch (Retina, Mid 2012) SSD&lt;/li&gt;
&lt;li&gt;CPU: Intel Core i7 2.6GHz&lt;/li&gt;
&lt;li&gt;RAM: 16GB 1600MHz DDR3&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;データサイズ

&lt;ul&gt;
&lt;li&gt;データファイルの合計サイズ: 188MB&lt;/li&gt;
&lt;li&gt;データ件数: 約193万件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ du -sm ~/work/groonga/db
18848 /Users/hnakamur/work/groonga/db
$ echo &#39;select Articles --limit 0&#39; | groonga ~/work/groonga/db/wikipedia.db
[[0,1431434283.68242,0.00117397308349609],[[[1932736],[[&amp;quot;_id&amp;quot;,&amp;quot;UInt32&amp;quot;],[&amp;quot;_key&amp;quot;,&amp;quot;ShortText&amp;quot;],[&amp;quot;text&amp;quot;,&amp;quot;Text&amp;quot;],[&amp;quot;updated_at&amp;quot;,&amp;quot;Time&amp;quot;]]]]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSON形式の検索APIの応答が約80〜250ms程度で、快適に検索できました。
Groongaすごいですね！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Goでdeferの処理中のエラーを返す書き方を工夫してみた</title>
      <link>/blog/2015/04/27/write_function_for_go_defer/</link>
      <pubDate>Mon, 27 Apr 2015 02:06:02 +0900</pubDate>
      
      <guid>/blog/2015/04/27/write_function_for_go_defer/</guid>
      <description>&lt;p&gt;go-nutsのメーリングリストの記事
&lt;a href=&#34;https://groups.google.com/d/msg/golang-nuts/qTTBENO_Em0/Y4MCVZZ3c5sJ&#34;&gt;https://groups.google.com/d/msg/golang-nuts/qTTBENO_Em0/Y4MCVZZ3c5sJ&lt;/a&gt;
によるとdeferで呼ばれた関数の戻り値は捨てられるそうです。
&lt;a href=&#34;https://groups.google.com/d/msg/golang-nuts/qTTBENO_Em0/UlI77BM2PUkJ&#34;&gt;https://groups.google.com/d/msg/golang-nuts/qTTBENO_Em0/UlI77BM2PUkJ&lt;/a&gt;
で戻り値の変数に代入するという方法が紹介されていました。&lt;/p&gt;

&lt;p&gt;これを参考に、deferでの後処理でエラーが起きた時はそのエラーを返す、ただし複数のエラーが起きた時は最初のエラーを返したいというときの書き方を考えてみました。&lt;/p&gt;

&lt;p&gt;最初に書いたのは、上の記事で紹介されていたように無名関数を即時呼び出しする方式です。
&lt;a href=&#34;https://github.com/hnakamur/cgoroonga/blob/70aafdeb2eb754505efe60afa1ae6d995831a063/examples/add_record/main.go&#34;&gt;https://github.com/hnakamur/cgoroonga/blob/70aafdeb2eb754505efe60afa1ae6d995831a063/examples/add_record/main.go&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func run() (err error) {
	err = grn.Init()
	if err != nil {
		return
	}
	defer func() {
		err2 := grn.Fin()
		if err2 != nil &amp;amp;&amp;amp; err == nil {
			err = err2
		}
	}()

	ctx, err := grn.CtxOpen(0)
	if err != nil {
		return
	}
	defer func() {
		err2 := ctx.Close()
		if err2 != nil &amp;amp;&amp;amp; err == nil {
			err = err2
		}
	}()

	var db *grn.Obj
	db, err = ctx.DBOpenOrCreate(&amp;quot;hello.db&amp;quot;, nil)
	if err != nil {
		return
	}
	defer func() {
		err2 := ctx.ObjClose(db)
		if err2 != nil &amp;amp;&amp;amp; err == nil {
			err = err2
		}
	}()

	keyType := ctx.At(grn.DB_SHORT_TEXT)
	table, err := ctx.TableOpenOrCreate(&amp;quot;table1&amp;quot;, &amp;quot;&amp;quot;,
		grn.OBJ_TABLE_HASH_KEY|grn.OBJ_PERSISTENT, keyType, nil)
	if err != nil {
		return
	}
	fmt.Printf(&amp;quot;table=%x\n&amp;quot;, table)
	defer func() {
		err2 := ctx.ObjClose(table)
		if err2 != nil &amp;amp;&amp;amp; err == nil {
			err = err2
		}
	}()
…(略)…
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでやりたいことは実現できているのですが、deferのところの行数が多すぎて読みにくいコードになっています。&lt;/p&gt;

&lt;p&gt;そこでこの部分を関数として定義するようにしてみました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/cgoroonga/blob/5eb6e092c4f6d53257b499cffacd51b8dd194ca3/examples/add_record/main.go&#34;&gt;https://github.com/hnakamur/cgoroonga/blob/5eb6e092c4f6d53257b499cffacd51b8dd194ca3/examples/add_record/main.go&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func run() (err error) {
	err = grn.Init()
	if err != nil {
		return
	}
	defer grn.FinDefer(&amp;amp;err)

	ctx, err := grn.CtxOpen(0)
	if err != nil {
		return
	}
	defer ctx.CloseDefer(&amp;amp;err)

	var db *grn.Obj
	db, err = ctx.DBOpenOrCreate(&amp;quot;hello.db&amp;quot;, nil)
	if err != nil {
		return
	}
	defer ctx.ObjCloseDefer(&amp;amp;err, db)

	keyType := ctx.At(grn.DB_SHORT_TEXT)
	table, err := ctx.TableOpenOrCreate(&amp;quot;table1&amp;quot;, &amp;quot;&amp;quot;,
		grn.OBJ_TABLE_HASH_KEY|grn.OBJ_PERSISTENT, keyType, nil)
	if err != nil {
		return
	}
	fmt.Printf(&amp;quot;table=%x\n&amp;quot;, table)
	defer ctx.ObjCloseDefer(&amp;amp;err, table)
…(略)…
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数定義は例えば &lt;code&gt;FinDefer&lt;/code&gt; なら
&lt;a href=&#34;https://github.com/hnakamur/cgoroonga/blob/master/init.go#L25-L30&#34;&gt;https://github.com/hnakamur/cgoroonga/blob/master/init.go#L25-L30&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func FinDefer(err *error) {
	err2 := Fin()
	if err2 != nil &amp;amp;&amp;amp; *err == nil {
		*err = err2
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようになります。他の関数も同様です。&lt;/p&gt;

&lt;p&gt;書き換えた &lt;code&gt;run()&lt;/code&gt; のほうが読みやすくていい感じです。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>