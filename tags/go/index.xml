<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on hnakamur&#39;s blog at github</title>
    <link>/blog/tags/go/</link>
    <description>Recent content in Go on hnakamur&#39;s blog at github</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Sat, 19 Dec 2015 01:45:25 +0900</lastBuildDate>
    <atom:link href="/blog/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>direnvでgo1.5.2とgo1.6beta1を切り替える設定</title>
      <link>/blog/2015/12/19/switch_go1.5.2_and_go1.6beta1_with_direnv/</link>
      <pubDate>Sat, 19 Dec 2015 01:45:25 +0900</pubDate>
      
      <guid>/blog/2015/12/19/switch_go1.5.2_and_go1.6beta1_with_direnv/</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;go1.6beta1がリリースされました。go1.5.2と切り替えて使いたいので、&lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;direnv/direnv&lt;/a&gt;用の設定を書きました。&lt;/p&gt;

&lt;h2 id=&#34;設定内容&#34;&gt;設定内容&lt;/h2&gt;

&lt;p&gt;以下の様な配置で使うことにしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;go1.5.2

&lt;ul&gt;
&lt;li&gt;goのインストールディレクトリ: /usr/local/go&lt;/li&gt;
&lt;li&gt;GOPATH: ~/gocode&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;go1.6beta1

&lt;ul&gt;
&lt;li&gt;goのインストールディレクトリ: /usr/local/go1.6beta1&lt;/li&gt;
&lt;li&gt;GOPATH: ~/gocode1.6&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まず、~/.bash_profileや~/.bashからはgoへのPATH設定やGOPATHの設定は削除します。&lt;/p&gt;

&lt;p&gt;次に以下のファイルを作成します。&lt;/p&gt;

&lt;p&gt;~/gocode/.envrc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GOPATH=$HOME/gocode
export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin
export GO15VENDOREXPERIMENT=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;~/gocode1.6/.envrc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GOROOT=/usr/local/go1.6beta1
export GOPATH=$HOME/gocode1.6
export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記の2つのファイルを有効にします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;direnv allow ~/gocode
direnv allow ~/gocode1.6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;go1.5.2を使うときは ~/gocode/ 配下のディレクトリにcdします。
すると~/gocode/.envrcがsourceされてgo1.5.2用の設定が有効になります。&lt;/p&gt;

&lt;p&gt;go1.6beta1を使うときは ~/gocode1.6/ 配下のディレクトリにcdします。
すると~/gocode/.envrcで有効にされたgo1.5.2用の設定はアンロードされて、~/gocode1.6/.envrcがsourceされgo1.6beta1用の設定が有効になります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mattn/gomにGoのvendoringサポートが追加されました</title>
      <link>/blog/2015/10/22/gom_got_go_vendoring_support/</link>
      <pubDate>Thu, 22 Oct 2015 01:22:10 +0900</pubDate>
      
      <guid>/blog/2015/10/22/gom_got_go_vendoring_support/</guid>
      <description>

&lt;p&gt;以前&lt;a href=&#34;http://deeeet.com/writing/2015/06/26/golang-dependency-vendoring/&#34;&gt;Go言語のDependency/Vendoringの問題と今後．gbあるいはGo1.5 | SOTA&lt;/a&gt;を読んだのですが、その時は様子見にしていました。&lt;/p&gt;

&lt;p&gt;しかし、仕事でGoを書くとなるとやはりVendoringは必要だろうと思い、遅ればせながら今回&lt;a href=&#34;https://getgb.io/examples/getting-started/&#34;&gt;gb&lt;/a&gt;, &lt;a href=&#34;https://github.com/tools/godep&#34;&gt;tools/godep&lt;/a&gt;, &lt;a href=&#34;https://github.com/mattn/gom&#34;&gt;mattn/gom&lt;/a&gt;を試してみました。&lt;/p&gt;

&lt;h2 id=&#34;gbの不満&#34;&gt;gbの不満&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://getgb.io/examples/getting-started/&#34;&gt;gb&lt;/a&gt;の例を見ると、自分のプロジェクトのトップディレクトリに &lt;code&gt;src/cmd&lt;/code&gt; あるいは &lt;code&gt;src/github.com/ユーザID/プロジェクト名&lt;/code&gt; というディレクトリを作ってそこにソースを置く必要があるようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://getgb.io/faq/#cannot-build-src-root&#34;&gt;FAQ&lt;/a&gt;にも&lt;a href=&#34;http://getgb.io/faq/#cannot-build-src-root&#34;&gt;Why can&amp;rsquo;t I place source in $PROJECT/src?&lt;/a&gt;という項があるので、これは仕様のようです。&lt;/p&gt;

&lt;p&gt;でもこれだと、自分のプロジェクトを他のプロジェクトで使いたい時に &lt;code&gt;go get&lt;/code&gt; で使えないですよね。
FAQに &amp;ldquo;Can I use gb if I am working on a Go library?&amp;rdquo; とか &amp;ldquo;Copying code is gross! Can I use git submodules?&amp;rdquo; とかあるんですが、git submoduleにせよgit subtreeにせよ面倒だなと思いました。&lt;/p&gt;

&lt;h2 id=&#34;godepsの不満&#34;&gt;godepsの不満&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tools/godep&#34;&gt;tools/godep&lt;/a&gt; の&amp;rdquo;Go 1.5 vendor/ experiment&amp;rdquo;の項を読んで試してみたところ、&lt;code&gt;go build&lt;/code&gt; が使用する環境変数 &lt;code&gt;GO15VENDOREXPERIMENT&lt;/code&gt; を &lt;code&gt;export GO15VENDOREXPERIMENT=1&lt;/code&gt; のように設定しておくと、そうでないときは &lt;code&gt;Godeps/_workspace/&lt;/code&gt; に置かれる依存ライブラリが &lt;code&gt;vendor/&lt;/code&gt; 以下に置かれるようになることがわかりました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vendor/&lt;/code&gt; を &lt;code&gt;.gitignore&lt;/code&gt; で除外してコミットしたいので、後から &lt;code&gt;Godeps/Godeps.json&lt;/code&gt; から &lt;code&gt;vendor/&lt;/code&gt; を再構成する必要があります。READMEには書いてないですが、 &lt;code&gt;godep get&lt;/code&gt; でダウンロードして、 &lt;code&gt;godep save&lt;/code&gt; で &lt;code&gt;vendor/&lt;/code&gt; に反映できることがわかりました。&lt;/p&gt;

&lt;p&gt;ただ、 &lt;code&gt;godep get&lt;/code&gt; でダウンロードする先は環境変数 &lt;code&gt;GOPATH&lt;/code&gt; で指しているディレクトリなんですよね。 &lt;code&gt;godep save&lt;/code&gt; は &lt;code&gt;$GOPATH&lt;/code&gt; から &lt;code&gt;vendor/&lt;/code&gt; に反映するコマンドです。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;code&gt;godep restore&lt;/code&gt; というコマンドもありますが、これは &lt;code&gt;vendor/&lt;/code&gt; から &lt;code&gt;$GOPATH&lt;/code&gt; に反映します。GoにVendoringサポートがなかったときは、これで &lt;code&gt;$GOPATH&lt;/code&gt; に反映してから &lt;code&gt;go build&lt;/code&gt; という手順も妥当な気がしますが、Vendoringがある今となってはグローバルの &lt;code&gt;$GOPATH&lt;/code&gt; 配下は触らずに &lt;code&gt;vendor/&lt;/code&gt; 以下を直接更新したいところです。&lt;/p&gt;

&lt;p&gt;とりあえずイシュー&lt;a href=&#34;https://github.com/tools/godep/issues/299&#34;&gt;Download dependency to vendor/ directory with godep get when GO15VENDOREXPERIMENT=1 · Issue #299 · tools/godep&lt;/a&gt; を立ててみたところ、同じことを考えていたというコメントがついていました。&lt;/p&gt;

&lt;h2 id=&#34;gomならバッチリ&#34;&gt;gomならバッチリ！&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mattn/gom&#34;&gt;mattn/gom&lt;/a&gt;を見ると&lt;a href=&#34;https://github.com/mattn/gom/issues/51&#34;&gt;Consider adding GO15VENDOREXPERIMENT support · Issue #51 · mattn/gom&lt;/a&gt;というイシューがあったので、対応するコードを書いて &lt;a href=&#34;https://github.com/mattn/gom/pull/57&#34;&gt;Support go15vendorexperiment by mattn · Pull Request #57 · mattn/gom&lt;/a&gt;で追加修正の上マージしていただきました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gom install&lt;/code&gt; では内部的に &lt;code&gt;go get&lt;/code&gt; を呼び出しているので、ターゲットディレクトリを &lt;code&gt;vendor/&lt;/code&gt; にしても &lt;code&gt;vendor/src/github.com/...&lt;/code&gt; のように &lt;code&gt;src&lt;/code&gt; フォルダが作られてしまいます。上の修正では対処療法的に &lt;code&gt;gom install&lt;/code&gt; 内で &lt;code&gt;vendor/*&lt;/code&gt; を &lt;code&gt;vendor/src/*&lt;/code&gt; に移動して、終わったら &lt;code&gt;vendor/src/*&lt;/code&gt; を &lt;code&gt;vendor/*&lt;/code&gt; に移動して対応しています。&lt;/p&gt;

&lt;p&gt;正確には最初の移動では &lt;code&gt;vendor/&lt;/code&gt; 以下の &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;pkg&lt;/code&gt;, &lt;code&gt;src&lt;/code&gt; は除外しています。&lt;/p&gt;

&lt;p&gt;これで、 &lt;code&gt;export GO15VENDOREXPERIMENT=1&lt;/code&gt; さえしておけば、 &lt;code&gt;gom install&lt;/code&gt; で &lt;code&gt;$GOPATH&lt;/code&gt; 配下は変更せずに直接 &lt;code&gt;vendor/&lt;/code&gt; 以下を更新できるようになりました。&lt;/p&gt;

&lt;p&gt;READMEには書いてないですが、 &lt;code&gt;gom lock&lt;/code&gt; を実行すれば &lt;code&gt;Gomfile.lock&lt;/code&gt; が作られて、以降の &lt;code&gt;gom install&lt;/code&gt; では依存ライブラリのバージョンを正確に反映できます。&lt;/p&gt;

&lt;p&gt;ということで、gomならバッチリ私の希望を満たしてくれることがわかりました。
mattnさん、便利なツールをありがとうございます！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Goでグローバルなバッファを使いまわしてスタックトレースを取得するライブラリを書いてみた</title>
      <link>/blog/2015/08/31/go_stacktrace_library_with_global_buffer/</link>
      <pubDate>Mon, 31 Aug 2015 00:43:56 +0900</pubDate>
      
      <guid>/blog/2015/08/31/go_stacktrace_library_with_global_buffer/</guid>
      <description>

&lt;h2 id=&#34;背景と経緯&#34;&gt;背景と経緯&lt;/h2&gt;

&lt;p&gt;Goでもエラー処理にpanicを使えばスタックトレースが出力されます。でも、ライブラリでは &lt;code&gt;panic&lt;/code&gt; するとエラー処理して続行したいときに困るのでpanicではなく &lt;code&gt;return err&lt;/code&gt; を使うのが普通です。すると今度はスタックトレースが取れないのが残念だと思っていました。エラーが出た箇所でログ出力はするとして、やはりスタックトレースがあるほうがその関数までの呼出経路がわかってデバッグが捗ります。&lt;/p&gt;

&lt;p&gt;標準ライブラリを見てみると、&lt;a href=&#34;http://golang.org/pkg/runtime/debug/#PrintStack&#34;&gt;runtime.debug.PrintStack()&lt;/a&gt; という便利そうな関数を見つけました。が、これは出力先が標準エラー出力固定となっています。私はログファイルに出したいんですよね。&lt;/p&gt;

&lt;p&gt;そこでドキュメントの関数のリンクをクリックしてソースを見てみます。
&lt;a href=&#34;http://golang.org/src/runtime/debug/stack.go?s=516:533#L15&#34;&gt;src/runtime/debug/stack.go - The Go Programming Language&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func PrintStack() {
  os.Stderr.Write(stack())
}

// Stack returns a formatted stack trace of the goroutine that calls it.
// For each routine, it includes the source line information and PC value,
// then attempts to discover, for Go functions, the calling function or
// method and the text of the line containing the invocation.
//
// Deprecated: Use package runtime&#39;s Stack instead.
func Stack() []byte {
  return stack()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;お、&lt;code&gt;Stack()&lt;/code&gt; のほうを使えば &lt;code&gt;[]byte&lt;/code&gt; で取得できるじゃないですか。あれ、でもdeprecatedなので &lt;a href=&#34;http://golang.org/pkg/runtime/#Stack&#34;&gt;runtime.Stack&lt;/a&gt; のほうを使えとあります。シグネチャ見ると &lt;code&gt;func Stack(buf []byte, all bool) int&lt;/code&gt; となっていて、こちらからバッファを渡す必要があるんですね。&lt;/p&gt;

&lt;p&gt;関数定義 &lt;a href=&#34;http://golang.org/src/runtime/mprof.go?s=15278:15314#L552&#34;&gt;src/runtime/mprof.go - The Go Programming Language&lt;/a&gt;を見てみると、バッファサイズが足りない場合は、途中までしか書かれないようです。またどれだけのサイズがあれば大丈夫かを調べる方法もないようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Stack(buf []byte, all bool) int {
  if all {
    stopTheWorld(&amp;quot;stack trace&amp;quot;)
  }

  n := 0
  if len(buf) &amp;gt; 0 {
    gp := getg()
    sp := getcallersp(unsafe.Pointer(&amp;amp;buf))
    pc := getcallerpc(unsafe.Pointer(&amp;amp;buf))
    systemstack(func() {
      g0 := getg()
      g0.writebuf = buf[0:0:len(buf)]
      goroutineheader(gp)
      traceback(pc, sp, 0, gp)
      if all {
        tracebackothers(gp)
      }
      n = len(g0.writebuf)
      g0.writebuf = nil
    })
  }

  if all {
    startTheWorld()
  }
  return n
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実はさっきの &lt;code&gt;stack()&lt;/code&gt; の定義&lt;a href=&#34;http://golang.org/src/runtime/debug/stack.go?s=516:533#L40&#34;&gt;src/runtime/debug/stack.go - The Go Programming Language&lt;/a&gt;を見ると&lt;a href=&#34;http://golang.org/pkg/runtime/#Caller&#34;&gt;runtime.Caller&lt;/a&gt;というより低レベルな関数があってこれを使って自前で実装すれば好きに作れそうではあります。&lt;/p&gt;

&lt;p&gt;しかし、私は手抜きで済ませたいので大きめのバッファをグローバルに予め確保しておいてそれを&lt;a href=&#34;http://golang.org/pkg/runtime/#Stack&#34;&gt;runtime.Stack&lt;/a&gt;に渡す方式にしました。
バッファを予め確保しておくのは、エラーが起きてからメモリ確保しようとして失敗するケースを避けたいからです。&lt;/p&gt;

&lt;p&gt;と言いつつ、&lt;a href=&#34;http://golang.org/pkg/runtime/#Stack&#34;&gt;runtime.Stack&lt;/a&gt;内でメモリ割り当てが発生するかまでは確認していません。&lt;/p&gt;

&lt;h2 id=&#34;実装と使い方&#34;&gt;実装と使い方&lt;/h2&gt;

&lt;p&gt;というわけで実装してみました。レポジトリは&lt;a href=&#34;https://github.com/hnakamur/stacktrace&#34;&gt;hnakamur/stacktrace&lt;/a&gt;で、ライセンスはMITです。&lt;/p&gt;

&lt;p&gt;使用例はこちらです。&lt;a href=&#34;https://github.com/hnakamur/stacktrace/blob/ed0a2c8b61528e59f349f6c108a84a6b9dd8e981/example/main.go&#34;&gt;example.go&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
  &amp;quot;errors&amp;quot;
  &amp;quot;log&amp;quot;

  &amp;quot;github.com/hnakamur/stacktrace&amp;quot;
)

func logErrorWithStackTrace(msg interface{}) {
  log.Printf(&amp;quot;error: %s\nstacktrace: %s\n&amp;quot;, msg, stacktrace.LockBufAndGetStackWithSkip(2))
  defer stacktrace.UnlockBuf()
}

func b() {
  err := errors.New(&amp;quot;some error&amp;quot;)
  logErrorWithStackTrace(err)
}

func a() {
  b()
}

func main() {
  a()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずお好みのロギングライブラリ用にスタックトレースを取得してログ出力する関数を定義します。この例の場合は &lt;code&gt;logErrorWithStackTrace&lt;/code&gt; です。メモリ割り当て回数を最低限にしたかったので、 &lt;code&gt;stacktrace.LockBufAndGetStackWithSkip()&lt;/code&gt; はグローバルバッファをロックした状態でそのまま返すようにしています。ですので使い終わったら、&lt;code&gt;stacktrace.UnlockBuf()&lt;/code&gt; でロックを解放する必要があります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;stacktrace.LockBufAndGetStackWithSkip()&lt;/code&gt; の引数で2を渡しているのはスタックトレースから &lt;code&gt;stacktrace.LockBufAndGetStackWithSkip&lt;/code&gt; と &lt;code&gt;logErrorWithStackTrace&lt;/code&gt; の2つを除外するためです。&lt;/p&gt;

&lt;p&gt;出力例は以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go run main.go
2015/08/31 01:24:42 error: some error
stacktrace: goroutine 1 [running]:
main.b()
        /Users/hnakamur/gocode/src/github.com/hnakamur/stacktrace/example/main.go:17 +0xce
main.a()
        /Users/hnakamur/gocode/src/github.com/hnakamur/stacktrace/example/main.go:21 +0x14
main.main()
        /Users/hnakamur/gocode/src/github.com/hnakamur/stacktrace/example/main.go:25 +0x14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでスタックトレース付きのエラーログを簡単に出力できて快適ですね！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cybozu Garoon APIのファイル管理の部分だけのgoライブラリを書いた</title>
      <link>/blog/2015/06/15/garoon_go_client/</link>
      <pubDate>Mon, 15 Jun 2015 20:24:16 +0900</pubDate>
      
      <guid>/blog/2015/06/15/garoon_go_client/</guid>
      <description>

&lt;h1 id=&#34;はじめに&#34;&gt;はじめに&lt;/h1&gt;

&lt;p&gt;Cybozu &lt;a href=&#34;https://cybozudev.zendesk.com/hc/ja/categories/200157760-Garoon-API&#34;&gt;Garoon API&lt;/a&gt;のファイル管理のうち、フォルダ一覧取得、フォルダ内のファイル一覧取得、ファイルダウンロードのAPIを呼び出すライブラリをGoで書いてみました。&lt;/p&gt;

&lt;p&gt;ただし、汎用的なライブラリではなく、自分が必要な機能のみを実装しています。レスポンスの中の項目も自分が必要な部分だけ取り出して残りは破棄しています。
&lt;a href=&#34;http://blog.sigbus.info/2015/01/p1.html&#34;&gt;sigbus.info: コードを書くことは無限の可能性を捨てて一つのやり方を選ぶということ&lt;/a&gt;を読んでから、汎用性をあまり気にせず自分の用途に合わせて書くようになって楽で良いです。&lt;/p&gt;

&lt;h1 id=&#34;実装方法についてのメモ&#34;&gt;実装方法についてのメモ&lt;/h1&gt;

&lt;p&gt;まず、Garoon APIの手動での呼び出し方は&lt;a href=&#34;http://qiita.com/yamasaki-masahide/items/fff1c84e65043ac4caf7&#34;&gt;garoon - Cybozu ガルーン API を使ってみる - Qiita&lt;/a&gt;を参考にして試してみました。&lt;/p&gt;

&lt;h2 id=&#34;リクエストのxml組み立て&#34;&gt;リクエストのXML組み立て&lt;/h2&gt;

&lt;p&gt;Garoon APIはSOAPなので、リクエストやレスポンスはXMLになります。&lt;/p&gt;

&lt;p&gt;リクエストを送るところは&lt;a href=&#34;http://qiita.com/yamasaki-masahide/items/03dfa6cd70ff20607b58&#34;&gt;Cybozu ガルーン API を golang で叩いてみる - Qiita&lt;/a&gt;を見たのですが、&lt;a href=&#34;http://qiita.com/ono_matope/items/70080cc33b75152c5c2a&#34;&gt;Goのencoding/xmlを使いこなす - Qiita&lt;/a&gt;を参考にMarshalXMLを実装する方式にしてみました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/pkg/encoding/xml/#Marshaler&#34;&gt;xml.Marshaler&lt;/a&gt;の &lt;code&gt;MarshalXML(e *Encoder, start StartElement) error&lt;/code&gt; は &lt;code&gt;start&lt;/code&gt; をエンコードするのが本来の使い方だとは思うのですが、下記の例のように &lt;code&gt;CabinetGetFolderInfo&lt;/code&gt; といったリクエスト本体を渡すと &lt;code&gt;soap:Envelope&lt;/code&gt; でラップしてエンコードしてくれる方が使うときに楽なので、 &lt;code&gt;MarshalXML&lt;/code&gt; 内でデータ構造を組み立ててエンコードするようにしてみました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;soap:Envelope xmlns:soap=&amp;quot;http://www.w3.org/2003/05/soap-envelope&amp;quot;&amp;gt;
  &amp;lt;soap:Header&amp;gt;
    &amp;lt;Action&amp;gt;CabinetGetFolderInfo&amp;lt;/Action&amp;gt;
    &amp;lt;Security&amp;gt;
      &amp;lt;UsernameToken&amp;gt;
        &amp;lt;Username&amp;gt;foo&amp;lt;/Username&amp;gt;
        &amp;lt;Password&amp;gt;password&amp;lt;/Password&amp;gt;
      &amp;lt;/UsernameToken&amp;gt;
    &amp;lt;/Security&amp;gt;
    &amp;lt;Timestamp&amp;gt;
      &amp;lt;Created&amp;gt;2010-08-12T14:45:00Z&amp;lt;/Created&amp;gt;
      &amp;lt;Expires&amp;gt;2037-08-12T14:45:00Z&amp;lt;/Expires&amp;gt;
    &amp;lt;/Timestamp&amp;gt;
    &amp;lt;Locale&amp;gt;jp&amp;lt;/Locale&amp;gt;
  &amp;lt;/soap:Header&amp;gt;
  &amp;lt;soap:Body&amp;gt;
    &amp;lt;CabinetGetFolderInfo&amp;gt;
      &amp;lt;parameters&amp;gt;&amp;lt;/parameters&amp;gt;
    &amp;lt;/CabinetGetFolderInfo&amp;gt;
  &amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;soap:Envelope&lt;/code&gt; でラップした構造を作るところは、&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/request.go#L44-L62&#34;&gt;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/request.go#L44-L62&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
func buildRequestStruct(h RequestHeader, apiName string, parameters interface{}) envelope {
	return envelope{
		Xmlns: &amp;quot;http://www.w3.org/2003/05/soap-envelope&amp;quot;,
		Header: header{
			Action:   apiName,
			Username: h.Username,
			Password: h.Password,
			Created:  h.Created,
			Expires:  h.Expires,
			Locale:   h.Locale,
		},
		Body: body{
			Content: bodyContent{
				XMLName:    xml.Name{Local: apiName},
				Parameters: parameters,
			},
		},
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で共通処理として実装し、各API用のリクエストの構造体では&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/cabinet.go#L16-L26&#34;&gt;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/cabinet.go#L16-L26&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type CabinetGetFolderInfoRequest struct {
	Header RequestHeader
}

func (r CabinetGetFolderInfoRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.Encode(buildRequestStruct(
		r.Header,
		&amp;quot;CabinetGetFolderInfo&amp;quot;,
		struct{}{},
	))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにして呼び出しています。&lt;/p&gt;

&lt;p&gt;また、日時の項目は構造体側では &lt;code&gt;time.Time&lt;/code&gt; にしたいところですが、&lt;a href=&#34;https://code.google.com/p/go/issues/detail?id=2771#c2&#34;&gt;Issue 2771 - go - encoding/xml: MarshalXML interface is not good enough - The Go Programming Language - Google Project Hosting&lt;/a&gt;の&lt;a href=&#34;https://code.google.com/p/go/issues/detail?id=2771#c2&#34;&gt;コメント#2&lt;/a&gt;を読んで &lt;code&gt;string&lt;/code&gt; にしました。&lt;/p&gt;

&lt;h2 id=&#34;レスポンスのパース処理&#34;&gt;レスポンスのパース処理&lt;/h2&gt;

&lt;p&gt;レスポンスのパースは&lt;a href=&#34;http://qiita.com/yamasaki-masahide/items/f20a2ca4700e00777303&#34;&gt;Cybozu ガルーン API のレスポンスのXMLを golang でパースする - Qiita&lt;/a&gt;を見たのですが、&lt;a href=&#34;http://blog.davidsingleton.org/parsing-huge-xml-files-with-go/&#34;&gt;Parsing huge XML files with Go - david singleton&lt;/a&gt;の方法のほうが楽なのでこちらを参考にしました。&lt;/p&gt;

&lt;p&gt;共通のユーテリティ関数としては
&lt;a href=&#34;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/response.go&#34;&gt;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/response.go&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var ResponseTagNotFoundError = errors.New(&amp;quot;response tag not found&amp;quot;)

func parseResponse(r io.Reader, localName string, v interface{}) error {
	decoder := xml.NewDecoder(r)
	for {
		t, _ := decoder.Token()
		if t == nil {
			break
		}
		switch se := t.(type) {
		case xml.StartElement:
			if se.Name.Local == localName {
				return decoder.DecodeElement(v, &amp;amp;se)
			}
		}
	}
	return ResponseTagNotFoundError
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように定義して、&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/cabinet.go#L115-L127&#34;&gt;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/cabinet.go#L115-L127&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func parseCabinetGetFolderInfoResponse(r io.Reader) (*CabinetGetFolderInfoResponse, error) {
	exclude := NewExclude(func(b byte) bool {
		return b == 0x08 || b == 0x0B
	})
	r2 := transform.NewReader(r, exclude)
	var resp CabinetGetFolderInfoResponse
	err := parseResponse(r2, &amp;quot;CabinetGetFolderInfoResponse&amp;quot;, &amp;amp;resp)
	if err != nil {
		return nil, err
	}
	resp.fillPath()
	return &amp;amp;resp, err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じで呼び出しています。&lt;/p&gt;

&lt;h2 id=&#34;レスポンスからu-0008などの制御文字を除去&#34;&gt;レスポンスからU+0008などの制御文字を除去&lt;/h2&gt;

&lt;p&gt;あと、レスポンスのXMLをそのまま&lt;a href=&#34;http://golang.org/pkg/encoding/xml/#Decoder&#34;&gt;xml.Decoder&lt;/a&gt;に渡すとUTF-8の不正なバイト列といったエラーが出ました。U+0008やU+000Bというデータが入っていたので、これを除去するようにしました。&lt;/p&gt;

&lt;p&gt;日本語の文字コード変換用のライブラリ&lt;a href=&#34;https://godoc.org/golang.org/x/text/encoding/japanese&#34;&gt;golang.org/x/text/encoding/japanese&lt;/a&gt;で使っているインターフェース&lt;a href=&#34;https://godoc.org/golang.org/x/text/transform#Transformer&#34;&gt;golang.org/x/text/transform/Transformer&lt;/a&gt;に合わせて実装しました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/cabinet.go#L28-L50&#34;&gt;https://github.com/hnakamur/garoonclient/blob/d8aceb8ae09c6094dd65a1623fc99ca89a1ccebd/cabinet.go#L28-L50&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type exclude struct {
	transform.NopResetter
	excluder func(byte) bool
}

func NewExclude(excluder func(byte) bool) transform.Transformer {
	return exclude{excluder: excluder}
}

func (e exclude) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
	for nSrc = 0; nSrc &amp;lt; len(src); nSrc++ {
		b := src[nSrc]
		if !e.excluder(b) {
			if nDst &amp;gt;= len(dst) {
				err = transform.ErrShortDst
				return
			}
			dst[nDst] = b
			nDst++
		}
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用するときは&lt;a href=&#34;https://godoc.org/golang.org/x/text/transform#NewReader&#34;&gt;golang.org/x/text/transform/NewReader&lt;/a&gt;を使います。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Cybozu Garoon APIの一部のクライアントライブラリをGoで実装しました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MarshalXMLを実装することで、構造体とXMLの構造がかなり違う場合でも、XMLに合わせて一々構造体を定義することなく楽に対応出来ました。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://golang.org/pkg/encoding/xml/#Decoder.Token&#34;&gt;xml.DecoderのToken&lt;/a&gt;を使うことでXMLの一部だけをパースしました。&lt;/li&gt;
&lt;li&gt;制御文字除去の処理を&lt;a href=&#34;https://godoc.org/golang.org/x/text/transform#Transformer&#34;&gt;golang.org/x/text/transform/Transformer&lt;/a&gt;インタフェースに合わせて実装しました。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Go言語用のメモリマップトファイルのライブラリを探してみた</title>
      <link>/blog/2015/06/03/go_mmap_libraries/</link>
      <pubDate>Wed, 03 Jun 2015 06:29:01 +0900</pubDate>
      
      <guid>/blog/2015/06/03/go_mmap_libraries/</guid>
      <description>

&lt;p&gt;ふとGo言語でメモリマップトファイルを扱えるライブラリってあるのかなと気になったので探してみました。&lt;/p&gt;

&lt;h2 id=&#34;標準ライブラリ&#34;&gt;標準ライブラリ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/&#34;&gt;Goのホームページ&lt;/a&gt;で&lt;a href=&#34;http://golang.org/search?q=mmap&#34;&gt;mmapで検索してみる&lt;/a&gt;とUnix系では実装があるみたいです。&lt;/p&gt;

&lt;p&gt;Did you mean: &lt;a href=&#34;http://golang.org/search?q=Mmap&#34;&gt;Mmap&lt;/a&gt; と表示されているのでクリックしてみるとsyscallパッケージに&lt;a href=&#34;http://golang.org/pkg/syscall/#Mmap&#34;&gt;Mmap&lt;/a&gt;があることがわかりました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/search?q=Munmap&#34;&gt;Munmapで検索してみる&lt;/a&gt;とこちらはMmapよりは実装されているOSが少ないです。syscallパッケージに&lt;a href=&#34;http://golang.org/pkg/syscall/#Munmap&#34;&gt;Mummap&lt;/a&gt;もあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/search?q=Msync&#34;&gt;Msyncで検索してみる&lt;/a&gt;と5件ヒットしますが、未実装となっていました。&lt;/p&gt;

&lt;p&gt;また、syscallパッケージにMmapとMunmapがあるといっても、Windowsでは実装されていません。&lt;/p&gt;

&lt;h2 id=&#34;github-com-edsrzf-mmap-go&#34;&gt;github.com/edsrzf/mmap-go&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ソース: &lt;a href=&#34;https://github.com/edsrzf/mmap-go&#34;&gt;edsrzf/mmap-go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GoDoc:  &lt;a href=&#34;https://godoc.org/github.com/edsrzf/mmap-go&#34;&gt;mmap - GoDoc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ライセンス: 3項BSD&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/edsrzf/mmap-go&#34;&gt;README&lt;/a&gt;によるとポータブルなAPIで、Linux (386, amd64), OS X, Windows (386)でテスト済みとのことです。&lt;/p&gt;

&lt;p&gt;mprotect, mincoreなどはサポートしていないのでそういうUnix特有の機能を使いたい場合はGustavo Niemeyerさんの&lt;a href=&#34;http://labix.org/gommap&#34;&gt;gommap&lt;/a&gt;がおすすめとのことです。&lt;/p&gt;

&lt;h2 id=&#34;github-com-tysontate-gommap&#34;&gt;github.com/tysontate/gommap&lt;/h2&gt;

&lt;p&gt;Gustavo Niemeyerさんの&lt;a href=&#34;http://labix.org/gommap&#34;&gt;gommap&lt;/a&gt;はプロジェクトがlaunchpat.netにホスティングされているので、github.comにミラーリングされていないかなと調べると&lt;a href=&#34;https://github.com/tysontate/gommap&#34;&gt;tysontate/gommap&lt;/a&gt;がありました。&lt;/p&gt;

&lt;p&gt;READMEによるとOS X用のパッチも適用済みとのことです。 &lt;code&gt;mmap_*.go&lt;/code&gt; のファイル名から判断すると対応OSはLinux (386, amd64), OS Xのようです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/edsrzf/mmap-go&#34;&gt;edsrzf/mmap-go&lt;/a&gt;の機能で足りる場合はそちらを、Unix限定になってもいいからmprotectとかを使いたい場合は&lt;a href=&#34;https://github.com/tysontate/gommap&#34;&gt;tysontate/gommap&lt;/a&gt;を使うのがよさそうです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LuaのGo実装GopherLuaを試してみた</title>
      <link>/blog/2015/06/03/tried_gopher_lua/</link>
      <pubDate>Wed, 03 Jun 2015 05:29:03 +0900</pubDate>
      
      <guid>/blog/2015/06/03/tried_gopher_lua/</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://inforno.net/articles/2015/02/15/gopher-lua-released&#34;&gt;inforno :: LuaのGo言語実装を公開しました&lt;/a&gt;を以前読んでましたが、試してなかったので試しました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.lua.org/about.html&#34;&gt;Lua: about&lt;/a&gt;の&amp;rdquo;What is Lua?&amp;ldquo;に&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;making it ideal for configuration, scripting, and rapid prototyping.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;とあるようにLuaは設定ファイルとして使うことも想定されています。&lt;/p&gt;

&lt;p&gt;ということで試してみました。&lt;/p&gt;

&lt;h2 id=&#34;gopherluaの利用例&#34;&gt;GopherLuaの利用例&lt;/h2&gt;

&lt;p&gt;hello.lua&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&amp;quot;hello&amp;quot;)

a = 2
b = {
    c = 4,
    d = a + 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;main.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/yuin/gopher-lua&amp;quot;
)

func main() {
	l := lua.NewState()
	defer l.Close()

	if err := l.DoFile(&amp;quot;hello.lua&amp;quot;); err != nil {
		panic(err)
	}

	a := l.GetGlobal(&amp;quot;a&amp;quot;)
	fmt.Printf(&amp;quot;a=%v\n&amp;quot;, a)

	b := l.GetGlobal(&amp;quot;b&amp;quot;).(*lua.LTable)
	b.ForEach(func(key, value lua.LValue) {
		fmt.Printf(&amp;quot;b.%v=%v\n&amp;quot;, key, value)
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go run main.go
hello
a=2
b.c=4
b.d=5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hello.luaに &lt;code&gt;print(&amp;quot;hello&amp;quot;)&lt;/code&gt; を入れているのはLuaからの出力を試してみたかったからで、実際に設定ファイルとして使うときは変数設定だけの使い方になるでしょう。&lt;/p&gt;

&lt;p&gt;上記では単に値を出力していますが、変数の値がプリミティブの場合は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://godoc.org/github.com/yuin/gopher-lua#LVAsBool&#34;&gt;LVAsBool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://godoc.org/github.com/yuin/gopher-lua#LVAsString&#34;&gt;LVAsString&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://godoc.org/github.com/yuin/gopher-lua#LVAsNumber&#34;&gt;LVAsNumber&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を使えばbool, string, LNumberに変換できます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://godoc.org/github.com/yuin/gopher-lua#LNumber&#34;&gt;LNumberの定義&lt;/a&gt; を見ると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type LNumber float64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっているので、Goでも数値として扱えます。&lt;/p&gt;

&lt;p&gt;なお、&lt;a href=&#34;http://www.lua.org/manual/5.3/manual.html#8.1&#34;&gt;Luaは5.3で数値に整数型が追加されています&lt;/a&gt;が、&lt;a href=&#34;https://github.com/yuin/gopher-lua&#34;&gt;gopher-lua&lt;/a&gt;はLua 5.1相当なので数値型は64bit浮動小数点数のみです。&lt;/p&gt;

&lt;p&gt;で、table (ハッシュテーブル) 型は &lt;code&gt;lua.LValue&lt;/code&gt; から &lt;code&gt;.(*lua.Table)&lt;/code&gt; でTableに変換できます。&lt;/p&gt;

&lt;p&gt;ちなみに、&lt;a href=&#34;http://www.lua.org/manual/5.1/manual.html#2.2&#34;&gt;2.2 – Values and Type - sLua 5.1 Reference Manual&lt;/a&gt;にあるようにLuaのtable型は連想配列と整数インデクスでの配列を兼用したデータ型となっています。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;設定ファイルをLuaで書くようにすると、上記の hello.lua で &lt;code&gt;b.d&lt;/code&gt; を &lt;code&gt;a + 3&lt;/code&gt; としているように変数や式が使えます。&lt;/p&gt;

&lt;p&gt;table型があるのでネストしたデータ構造も表現できます。&lt;/p&gt;

&lt;p&gt;ということで、Goのプログラムの設定ファイルをluaで書いて&lt;a href=&#34;https://github.com/yuin/gopher-lua&#34;&gt;gopher-lua&lt;/a&gt;で解釈するというのは、かなり便利そうですね。今後活用していきたいです。yuinさん、便利なライブラリをありがとうございます！&lt;/p&gt;

&lt;h2 id=&#34;2015-06-03-21-35-頃追記&#34;&gt;2015-06-03 21:35 頃追記&lt;/h2&gt;

&lt;p&gt;作者の方からご指摘頂いたのですが、LValueからTableへの変換方法はREADMEの&lt;a href=&#34;https://github.com/yuin/gopher-lua#data-model&#34;&gt;Data model&lt;/a&gt;に書いてありました。失礼いたしました。&lt;/p&gt;

&lt;p&gt;またLuaを設定ファイルとして使う場合は、そのためのライブラリも書かれているので、そちらを使うほうがよいそうです。
&lt;a href=&#34;http://inforno.net/articles/2015/03/23/gluamapper-released&#34;&gt;inforno :: GopherLuaを設定ファイルで使うライブラリを書きました&lt;/a&gt;をご参照ください。Goのstructの各フィールドの値をLuaのtableのデータに応じて設定してくれます。ますます便利ですね！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>goでglogを使うときのメモ</title>
      <link>/blog/2015/05/31/how_to_use_glog/</link>
      <pubDate>Sun, 31 May 2015 02:30:02 +0900</pubDate>
      
      <guid>/blog/2015/05/31/how_to_use_glog/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://blog.satotaichi.info/logging-frameworks-for-go/&#34;&gt;go言語におけるロギングについて&lt;/a&gt;の記事と&lt;a href=&#34;http://godoc.org/github.com/golang/glog&#34;&gt;glog - GoDoc&lt;/a&gt;を読んで試してみました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;flag.Parse()&lt;/code&gt; を呼ぶ必要があり、最後に &lt;code&gt;glog.Flush()&lt;/code&gt; を呼ぶ必要があるので &lt;code&gt;main&lt;/code&gt; で &lt;code&gt;defer&lt;/code&gt; で書いておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;flag&amp;quot;

	&amp;quot;github.com/golang/glog&amp;quot;
)

func main() {
	flag.Parse()
	defer glog.Flush()

	if glog.V(0) {
		glog.Info(&amp;quot;Hello, glog&amp;quot;)
	}

	glog.V(0).Info(&amp;quot;exiting&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ログレベルは &lt;code&gt;-v&lt;/code&gt; オプションで指定できるのですがデフォルト値は0なので、デフォルトで出力したいログはレベル0で書くようにします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://godoc.org/github.com/golang/glog#Verbose&#34;&gt;Verbose&lt;/a&gt;の説明によると、上の2つの書き方では前者のほうが実行時負荷が安上がりとのことです。これはログレベルの設定で出力を抑止した時に、 &lt;code&gt;Info&lt;/code&gt; の引数の評価をしなくて済むからです。&lt;/p&gt;

&lt;p&gt;使い分けるのも面倒なので、常に前者を使うことにします。&lt;/p&gt;

&lt;p&gt;ログファイル名は非公開関数 &lt;a href=&#34;https://github.com/golang/glog/blob/44145f04b68cf362d9c4df2182967c2275eaefed/glog_file.go#L83-L97&#34;&gt;glog.logName()&lt;/a&gt; の形式になります。&lt;/p&gt;

&lt;p&gt;ログのディレクトリは &lt;code&gt;-log_dir&lt;/code&gt; オプションで指定可能ですが、デフォルトでは &lt;a href=&#34;http://golang.org/pkg/os/#TempDir&#34;&gt;os.TempDir()&lt;/a&gt; になっています。&lt;/p&gt;

&lt;p&gt;OS Xの場合は環境変数 &lt;code&gt;$TMPDIR&lt;/code&gt; になります。セキュリティ上 &lt;code&gt;/tmp&lt;/code&gt; ではなくランダムは文字列のディレクトリになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo $TMPDIR
/var/folders/9p/r7jylfyd163bszlxvp0wk36h0000gn/T/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということで、ログファイルを見るときは &lt;code&gt;less $TMPDIR/${プログラム名}.INFO&lt;/code&gt; とすればOKです。&lt;code&gt;go build&lt;/code&gt; でビルドしてプログラムを実行した時はその名前ですが、 &lt;code&gt;go run main.go&lt;/code&gt; のときは &lt;code&gt;main&lt;/code&gt; になるようで &lt;code&gt;$TMPDIR/main.INFO&lt;/code&gt; というファイルが出来ていました。&lt;/p&gt;

&lt;p&gt;このファイルはプログラム実行のたびに上書きされます。過去のログを見たいときは &lt;code&gt;less $TMPDIR/${プログラム名}&lt;/code&gt; まで入力しTABでファイル名補完して見るようにします。&lt;/p&gt;

&lt;p&gt;上記のサンプルで出力されたログは以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Log file created at: 2015/05/31 02:22:07
Running on machine: sunshine5
Binary: Built with gc go1.4.2 for darwin/amd64
Log line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg
I0531 02:22:07.343002   54353 main.go:14] Hello, glog
I0531 02:22:07.343897   54353 main.go:18] exiting
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ログの行フォーマットは4行目に書いてありますが、 &lt;a href=&#34;https://github.com/golang/glog/blob/44145f04b68cf362d9c4df2182967c2275eaefed/glog.go#L518-L534&#34;&gt;glog.header()のコメント&lt;/a&gt; に詳細な説明があります。&lt;/p&gt;

&lt;p&gt;各行の日付には年がないのですが、行のフォーマットは固定なので諦めましょう。ログファイルサイズ削減のために年は付けないようにしているのでしょう。先頭行に作成日時が年つきで書いてあるのでそちらを見れば良いです。&lt;/p&gt;

&lt;p&gt;スレッドIDやログ出力したファイル名と行番号が出るのが便利です。&lt;/p&gt;

&lt;p&gt;ということで開発時のデバッグログとしてはglog便利そうです。逆にシステムの運用ログとしては別のログライブラリのようが良いかもしれません。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>groongaのgoバインディングでWikipedia全文検索のサンプルウェブアプリを作ってみた</title>
      <link>/blog/2015/05/12/cgoroonga_wikipedia_search_webapp/</link>
      <pubDate>Tue, 12 May 2015 21:24:11 +0900</pubDate>
      
      <guid>/blog/2015/05/12/cgoroonga_wikipedia_search_webapp/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://hnakamur.github.io/blog/2015/04/27/cgoroonga/&#34;&gt;データ登録用にgroongaのC APIのgoバインディングを書いてみた · hnakamur&amp;rsquo;s blog at github&lt;/a&gt;の続きで、APIを追加実装し、Wikipedia全文検索のサンプルウェブアプリを作ってみました。&lt;/p&gt;

&lt;h2 id=&#34;ソースコード&#34;&gt;ソースコード&lt;/h2&gt;

&lt;p&gt;ウェブアプリのソースは
&lt;a href=&#34;https://github.com/hnakamur/cgoroonga/tree/master/examples/search_wikipedia_webapp&#34;&gt;https://github.com/hnakamur/cgoroonga/tree/master/examples/search_wikipedia_webapp&lt;/a&gt;
にあります。&lt;/p&gt;

&lt;p&gt;GroongaのC APIについては&lt;a href=&#34;http://groonga.org/ja/docs/reference/api.html&#34;&gt;7.20. API — Groonga v5.0.3ドキュメント&lt;/a&gt;を見つつ、ドキュメント化されていないものは&lt;a href=&#34;https://github.com/groonga/groonga&#34;&gt;groongaのソース&lt;/a&gt;を見て、goバインディングを作りました。&lt;/p&gt;

&lt;p&gt;goバインディングもウェブアプリもとりあえず全文検索の動作確認ができればいいやということで、ゆるい感じで書いています。&lt;/p&gt;

&lt;p&gt;ウェブアプリのサーバサイドのソースは
&lt;a href=&#34;https://github.com/hnakamur/cgoroonga/blob/master/examples/search_wikipedia_webapp/main.go&#34;&gt;https://github.com/hnakamur/cgoroonga/blob/master/examples/search_wikipedia_webapp/main.go&lt;/a&gt;
で、groongaのgoバインディングのソースは
&lt;a href=&#34;https://github.com/hnakamur/cgoroonga&#34;&gt;https://github.com/hnakamur/cgoroonga&lt;/a&gt;
の &lt;code&gt;*.go&lt;/code&gt; です。&lt;/p&gt;

&lt;h2 id=&#34;フロントエンドについては別記事で&#34;&gt;フロントエンドについては別記事で&lt;/h2&gt;

&lt;p&gt;フロントエンドは&lt;a href=&#34;http://qiita.com/shibukawa/items/890d24874655439932ec&#34;&gt;最速MVCフレームワークMithril.jsの速度の秘密 - Qiita&lt;/a&gt;の記事を見て気になっていたので、&lt;a href=&#34;https://lhorie.github.io/mithril/&#34;&gt;Mithril&lt;/a&gt;で書いてみました。こちらについては別記事&lt;a href=&#34;/blog/blog/2015/05/12/tried_mithril_js/&#34;&gt;mithril.jsを試してみた&lt;/a&gt;に書きました。&lt;/p&gt;

&lt;h2 id=&#34;インデクスの作成&#34;&gt;インデクスの作成&lt;/h2&gt;

&lt;p&gt;groongaコマンドで以下のようにして作成しました。約27分かかりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;column_create --table ArticleIndexes --name article_index --flags COLUMN_INDEX|WITH_POSITION|WITH_SECTION --type Articles --source _key,text&#39; | time groonga ~/work/groonga/db/wikipedia.db
[[0,1431052924.67975,1555.13576507568],true]
     1660.80 real      1135.40 user       146.29 sys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wikipediaのページタイトルと本文の両方を対象に検索したいので、 &lt;code&gt;--source&lt;/code&gt; には _keyカラム (タイトル) と text カラム (本文) の両方を指定しました。&lt;/p&gt;

&lt;h2 id=&#34;検索の応答は約80-250ms程度と満足な早さ&#34;&gt;検索の応答は約80〜250ms程度と満足な早さ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;動作環境

&lt;ul&gt;
&lt;li&gt;マシン: MacBook Pro 15inch (Retina, Mid 2012) SSD&lt;/li&gt;
&lt;li&gt;CPU: Intel Core i7 2.6GHz&lt;/li&gt;
&lt;li&gt;RAM: 16GB 1600MHz DDR3&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;データサイズ

&lt;ul&gt;
&lt;li&gt;データファイルの合計サイズ: 188MB&lt;/li&gt;
&lt;li&gt;データ件数: 約193万件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ du -sm ~/work/groonga/db
18848 /Users/hnakamur/work/groonga/db
$ echo &#39;select Articles --limit 0&#39; | groonga ~/work/groonga/db/wikipedia.db
[[0,1431434283.68242,0.00117397308349609],[[[1932736],[[&amp;quot;_id&amp;quot;,&amp;quot;UInt32&amp;quot;],[&amp;quot;_key&amp;quot;,&amp;quot;ShortText&amp;quot;],[&amp;quot;text&amp;quot;,&amp;quot;Text&amp;quot;],[&amp;quot;updated_at&amp;quot;,&amp;quot;Time&amp;quot;]]]]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSON形式の検索APIの応答が約80〜250ms程度で、快適に検索できました。
Groongaすごいですね！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Goでdeferの処理中のエラーを返す書き方を工夫してみた</title>
      <link>/blog/2015/04/27/write_function_for_go_defer/</link>
      <pubDate>Mon, 27 Apr 2015 02:06:02 +0900</pubDate>
      
      <guid>/blog/2015/04/27/write_function_for_go_defer/</guid>
      <description>&lt;p&gt;go-nutsのメーリングリストの記事
&lt;a href=&#34;https://groups.google.com/d/msg/golang-nuts/qTTBENO_Em0/Y4MCVZZ3c5sJ&#34;&gt;https://groups.google.com/d/msg/golang-nuts/qTTBENO_Em0/Y4MCVZZ3c5sJ&lt;/a&gt;
によるとdeferで呼ばれた関数の戻り値は捨てられるそうです。
&lt;a href=&#34;https://groups.google.com/d/msg/golang-nuts/qTTBENO_Em0/UlI77BM2PUkJ&#34;&gt;https://groups.google.com/d/msg/golang-nuts/qTTBENO_Em0/UlI77BM2PUkJ&lt;/a&gt;
で戻り値の変数に代入するという方法が紹介されていました。&lt;/p&gt;

&lt;p&gt;これを参考に、deferでの後処理でエラーが起きた時はそのエラーを返す、ただし複数のエラーが起きた時は最初のエラーを返したいというときの書き方を考えてみました。&lt;/p&gt;

&lt;p&gt;最初に書いたのは、上の記事で紹介されていたように無名関数を即時呼び出しする方式です。
&lt;a href=&#34;https://github.com/hnakamur/cgoroonga/blob/70aafdeb2eb754505efe60afa1ae6d995831a063/examples/add_record/main.go&#34;&gt;https://github.com/hnakamur/cgoroonga/blob/70aafdeb2eb754505efe60afa1ae6d995831a063/examples/add_record/main.go&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func run() (err error) {
	err = grn.Init()
	if err != nil {
		return
	}
	defer func() {
		err2 := grn.Fin()
		if err2 != nil &amp;amp;&amp;amp; err == nil {
			err = err2
		}
	}()

	ctx, err := grn.CtxOpen(0)
	if err != nil {
		return
	}
	defer func() {
		err2 := ctx.Close()
		if err2 != nil &amp;amp;&amp;amp; err == nil {
			err = err2
		}
	}()

	var db *grn.Obj
	db, err = ctx.DBOpenOrCreate(&amp;quot;hello.db&amp;quot;, nil)
	if err != nil {
		return
	}
	defer func() {
		err2 := ctx.ObjClose(db)
		if err2 != nil &amp;amp;&amp;amp; err == nil {
			err = err2
		}
	}()

	keyType := ctx.At(grn.DB_SHORT_TEXT)
	table, err := ctx.TableOpenOrCreate(&amp;quot;table1&amp;quot;, &amp;quot;&amp;quot;,
		grn.OBJ_TABLE_HASH_KEY|grn.OBJ_PERSISTENT, keyType, nil)
	if err != nil {
		return
	}
	fmt.Printf(&amp;quot;table=%x\n&amp;quot;, table)
	defer func() {
		err2 := ctx.ObjClose(table)
		if err2 != nil &amp;amp;&amp;amp; err == nil {
			err = err2
		}
	}()
…(略)…
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでやりたいことは実現できているのですが、deferのところの行数が多すぎて読みにくいコードになっています。&lt;/p&gt;

&lt;p&gt;そこでこの部分を関数として定義するようにしてみました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hnakamur/cgoroonga/blob/5eb6e092c4f6d53257b499cffacd51b8dd194ca3/examples/add_record/main.go&#34;&gt;https://github.com/hnakamur/cgoroonga/blob/5eb6e092c4f6d53257b499cffacd51b8dd194ca3/examples/add_record/main.go&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func run() (err error) {
	err = grn.Init()
	if err != nil {
		return
	}
	defer grn.FinDefer(&amp;amp;err)

	ctx, err := grn.CtxOpen(0)
	if err != nil {
		return
	}
	defer ctx.CloseDefer(&amp;amp;err)

	var db *grn.Obj
	db, err = ctx.DBOpenOrCreate(&amp;quot;hello.db&amp;quot;, nil)
	if err != nil {
		return
	}
	defer ctx.ObjCloseDefer(&amp;amp;err, db)

	keyType := ctx.At(grn.DB_SHORT_TEXT)
	table, err := ctx.TableOpenOrCreate(&amp;quot;table1&amp;quot;, &amp;quot;&amp;quot;,
		grn.OBJ_TABLE_HASH_KEY|grn.OBJ_PERSISTENT, keyType, nil)
	if err != nil {
		return
	}
	fmt.Printf(&amp;quot;table=%x\n&amp;quot;, table)
	defer ctx.ObjCloseDefer(&amp;amp;err, table)
…(略)…
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数定義は例えば &lt;code&gt;FinDefer&lt;/code&gt; なら
&lt;a href=&#34;https://github.com/hnakamur/cgoroonga/blob/master/init.go#L25-L30&#34;&gt;https://github.com/hnakamur/cgoroonga/blob/master/init.go#L25-L30&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func FinDefer(err *error) {
	err2 := Fin()
	if err2 != nil &amp;amp;&amp;amp; *err == nil {
		*err = err2
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようになります。他の関数も同様です。&lt;/p&gt;

&lt;p&gt;書き換えた &lt;code&gt;run()&lt;/code&gt; のほうが読みやすくていい感じです。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>