<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja-jp" lang="ja-jp">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.133.1">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>uint64で高速にLog2を計算する方法を知った &middot; hnakamur&#39;s blog</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/copy-button.css">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://hnakamur.github.io/blog/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://hnakamur.github.io/blog/favicon.png">

  
  


<script async src="https://www.googletagmanager.com/gtag/js?id=G-KMMXGG2Z56"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-KMMXGG2Z56');
</script>



</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://hnakamur.github.io/blog/"><h1>hnakamur&#39;s blog</h1></a>
      <p class="lead">
       my tech memo 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://hnakamur.github.io/blog/"> blog home </a></li><li><a href="https://github.com/hnakamur"> github @hnakamur </a></li><li><a href="https://twitter.com/hnakamur2"> twitter @hnakamur2 </a></li>
      </ul>
    </nav>

    <p>powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://pages.github.com/">GitHub Pages</a></p>
    <p>&copy; 2024. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>uint64で高速にLog2を計算する方法を知った</h1>
  <time datetime=2023-01-03T17:09:58&#43;0900 class="post-date">2023-01-03</time>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#はじめに">はじめに</a></li>
    <li><a href="#2022-01-10追記-その後さらに更新しました">2022-01-10追記 その後さらに更新しました</a></li>
    <li><a href="#2022-01-04追記-herumiさんのツイートでさらに別の実装を知った">2022-01-04追記 herumiさんのツイートでさらに別の実装を知った</a></li>
    <li><a href="#アルゴリズム">アルゴリズム</a>
      <ul>
        <li><a href="#一番近い2のべき乗から1を引いた値の計算">一番近い2のべき乗から1を引いた値の計算</a></li>
        <li><a href="#テーブルをひくときのインデクスの計算">テーブルをひくときのインデクスの計算</a></li>
      </ul>
    </li>
    <li><a href="#正しい結果が出る値の範囲を調べてみた">正しい結果が出る値の範囲を調べてみた</a></li>
    <li><a href="#ルックアップテーブルの作り方を確認">ルックアップテーブルの作り方を確認</a></li>
    <li><a href="#ベンチマーク">ベンチマーク</a></li>
  </ul>
</nav>
  <h2 id="はじめに">はじめに</h2>
<p><a href="https://twitter.com/kazuho/status/1610109662346752002">kazuhoさんのツイート</a>とソースを見て、本題のパーセンタイル値をインクリメンタルに更新する方法の前に、
<a href="https://github.com/h2o/h2o/blob/0f08b675c8244fc4552a93e9b35271ecf5e0f8fa/deps/libgkc/gkc.c#L109-L127"><code>static uint64_t ullog2(uint64_t x)</code></a>というuint64の整数のlog2を高速に計算する関数に興味がわいて調べてみたのでメモです。</p>
<p>試したコードは<a href="https://github.com/hnakamur/log2_experiment">hnakamur/log2_experiment</a>に置いてます。</p>
<h2 id="2022-01-10追記-その後さらに更新しました">2022-01-10追記 その後さらに更新しました</h2>
<p>2022-01-04追記の説明、今から見ると自分でもよくわかりませんが、<code>x=0</code>では呼ばないという前提で以下のように変えました。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// ILog2 calculates log2 of a uint64 value.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Ported from
</span></span></span><span class="line"><span class="cl"><span class="c1">// https://github.com/h2o/h2o/pull/3177/files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">ILog2</span><span class="p">(</span><span class="nx">x</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">63</span> <span class="o">-</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">bits</span><span class="p">.</span><span class="nf">LeadingZeros64</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>元の<code>x |= (x &gt;&gt; 1)</code>などを並べたコードも条件分岐がないというのが利点とあったので、上のコードも条件分岐無しのほうが良いかなということで。</p>
<p>なお、<code>bits.LeadingZeros64(x)</code>も <code>__builtin_clzll(x)</code>も<code>x=0</code>のときは64になるのは同じでした。上の関数は<code>x=0</code>では呼ばない前提です。</p>
<p><a href="https://twitter.com/herumi/status/1610586811860127745">herumiさんとのその後のやり取り</a>で、倍精度浮動小数点数での<code>math.Log(float64)</code>のほうが正しくないケースがあると教えていただきました。</p>
<p>そこで<a href="https://www.mpfr.org/">The GNU MPFR Library</a>というライブラリを使って<a href="https://github.com/hnakamur/log2_experiment/blob/47873251e237dc5fdf43cdf20500aadc4ae9d3dd/c/ilog2_ref.c">ilog2_ref.c</a>でlog2をfloat64より高精度で計算して<code>63 - __builtin_clzll(x)</code>と比べてみた<a href="https://github.com/hnakamur/log2_experiment/blob/47873251e237dc5fdf43cdf20500aadc4ae9d3dd/c/ilog2_test.c">ilog2_test.c</a>ところ、<code>x&gt;=1</code>について<a href="https://github.com/hnakamur/log2_experiment/blob/47873251e237dc5fdf43cdf20500aadc4ae9d3dd/c/ilog2_test.c#L77-L89">check_fn</a>で指定した入力値については全て一致することが確認できました。そして、テストしてない値についても<code>__builtin_clzll(x)</code>が同じ値になればそこから先は同じなので、<code>x&gt;=1</code>については大丈夫だという確信が持てました。</p>
<p>Goの<code>bits.LeadingZeros64(x)</code>は<code>__builtin_clzll(x)</code>と同等なのでこちらも大丈夫です。念のため<a href="https://github.com/hnakamur/log2_experiment/blob/47873251e237dc5fdf43cdf20500aadc4ae9d3dd/c/ilog2_ref.c">ilog2_ref.c</a>の出力と突き合わせる<a href="https://github.com/hnakamur/log2_experiment/blob/47873251e237dc5fdf43cdf20500aadc4ae9d3dd/log2_test.go">テスト</a>も書いて確認しました。</p>
<h2 id="2022-01-04追記-herumiさんのツイートでさらに別の実装を知った">2022-01-04追記 herumiさんのツイートでさらに別の実装を知った</h2>
<ul>
<li><a href="https://twitter.com/herumi/status/1610248792254844929">一旦doubleに変換する方式</a></li>
<li><code>__builtin_clzll</code>を使う方式。<a href="https://github.com/h2o/h2o/pull/3177">Ilog2 by herumi · Pull Request #3177 · h2o/h2o</a>。
<ul>
<li><a href="https://github.com/herumi/misc/blob/main/ilog2.c">テストコード</a></li>
</ul>
</li>
</ul>
<p>これを見て自分でも試してみました。</p>
<ul>
<li><a href="https://wandbox.org/permlink/a103Ixk5NYiYfpAL">math.hのlogと比較してみました</a>。</li>
<li><a href="https://github.com/hnakamur/log2_experiment/commit/87c3d50d211a3ba4c6f38ee65074c81dd45b3a32">Goに移植してみた</a></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// ILog2 calculates log2 of a uint64 value.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Ported from
</span></span></span><span class="line"><span class="cl"><span class="c1">// https://github.com/h2o/h2o/pull/3177/files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">ILog2</span><span class="p">(</span><span class="nx">x</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">63</span> <span class="o">-</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">bits</span><span class="p">.</span><span class="nf">LeadingZeros64</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ILog2B calculates log2 of a uint64 value.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Ported from
</span></span></span><span class="line"><span class="cl"><span class="c1">// https://twitter.com/herumi/status/1610248792254844929
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">ILog2B</span><span class="p">(</span><span class="nx">x</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">f</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Float64bits</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">v</span><span class="o">&gt;&gt;</span><span class="mi">52</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1023</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>そもそもlogは0では無限大になるので上のILog2の<code>return 0</code>は変ではあるのですが、Cでの実装の結果に合わせるとこれが必要でした。</p>
<p>math.Logを使う方式と比較したテストの結果は以下のようになりました。</p>
<pre tabindex="0"><code>=== RUN   TestILog2
    log2_test.go:45: result mismatch, x=0, got=0, want=-9223372036854775808
    log2_test.go:45: result mismatch, x=1ffffffffffff, got=48, want=49
    log2_test.go:45: result mismatch, x=3ffffffffffff, got=49, want=50
    log2_test.go:45: result mismatch, x=7ffffffffffff, got=50, want=51
    log2_test.go:45: result mismatch, x=fffffffffffff, got=51, want=52
    log2_test.go:45: result mismatch, x=1fffffffffffff, got=52, want=53
    log2_test.go:45: result mismatch, x=3fffffffffffff, got=53, want=54
    log2_test.go:45: result mismatch, x=7fffffffffffff, got=54, want=55
    log2_test.go:45: result mismatch, x=ffffffffffffff, got=55, want=56
    log2_test.go:45: result mismatch, x=1ffffffffffffff, got=56, want=57
    log2_test.go:45: result mismatch, x=3ffffffffffffff, got=57, want=58
    log2_test.go:45: result mismatch, x=7ffffffffffffff, got=58, want=59
    log2_test.go:45: result mismatch, x=fffffffffffffff, got=59, want=60
    log2_test.go:45: result mismatch, x=1fffffffffffffff, got=60, want=61
    log2_test.go:45: result mismatch, x=3fffffffffffffff, got=61, want=62
    log2_test.go:45: result mismatch, x=7fffffffffffffff, got=62, want=63
    log2_test.go:45: result mismatch, x=ffffffffffffffff, got=63, want=64
--- FAIL: TestILog2 (0.00s)
=== RUN   TestILog2B
    log2_test.go:45: result mismatch, x=0, got=-1023, want=-9223372036854775808
    log2_test.go:45: result mismatch, x=1ffffffffffff, got=48, want=49
    log2_test.go:45: result mismatch, x=3ffffffffffff, got=49, want=50
    log2_test.go:45: result mismatch, x=7ffffffffffff, got=50, want=51
    log2_test.go:45: result mismatch, x=fffffffffffff, got=51, want=52
    log2_test.go:45: result mismatch, x=1fffffffffffff, got=52, want=53
--- FAIL: TestILog2B (0.00s)
=== RUN   TestLog2ByAvernar
    log2_test.go:45: result mismatch, x=0, got=0, want=-9223372036854775808
    log2_test.go:45: result mismatch, x=1ffffffffffff, got=48, want=49
    log2_test.go:45: result mismatch, x=3ffffffffffff, got=49, want=50                                                                                                                                                  log2_test.go:45: result mismatch, x=7ffffffffffff, got=50, want=51                                                                                                                                                  log2_test.go:45: result mismatch, x=fffffffffffff, got=51, want=52                                                                                                                                                  log2_test.go:45: result mismatch, x=1fffffffffffff, got=52, want=53                                                                                                                                                 log2_test.go:45: result mismatch, x=3fffffffffffff, got=53, want=54                                                                                                                                                 log2_test.go:45: result mismatch, x=7fffffffffffff, got=54, want=55
    log2_test.go:45: result mismatch, x=ffffffffffffff, got=55, want=56
    log2_test.go:45: result mismatch, x=1ffffffffffffff, got=56, want=57
    log2_test.go:45: result mismatch, x=3ffffffffffffff, got=57, want=58
    log2_test.go:45: result mismatch, x=7ffffffffffffff, got=58, want=59
    log2_test.go:45: result mismatch, x=fffffffffffffff, got=59, want=60
    log2_test.go:45: result mismatch, x=1fffffffffffffff, got=60, want=61
    log2_test.go:45: result mismatch, x=3fffffffffffffff, got=61, want=62
    log2_test.go:45: result mismatch, x=7fffffffffffffff, got=62, want=63
    log2_test.go:45: result mismatch, x=ffffffffffffffff, got=63, want=64
--- FAIL: TestLog2ByAvernar (0.00s)
</code></pre><p>ベンチマークの結果。</p>
<pre tabindex="0"><code>$ go test -v -run ^$ -bench . -benchmem
goos: linux
goarch: amd64
pkg: github.com/hnakamur/log2_experiment
cpu: AMD Ryzen 7 PRO 4750GE with Radeon Graphics
BenchmarkILog2
BenchmarkILog2-16                4560423               245.8 ns/op             0 B/op          0 allocs/op
BenchmarkILog2B
BenchmarkILog2B-16               4428868               247.3 ns/op             0 B/op          0 allocs/op
BenchmarkLogByAvernar
BenchmarkLogByAvernar-16          782736              1566 ns/op               0 B/op          0 allocs/op
BenchmarkLogByAvernarU8
BenchmarkLogByAvernarU8-16        794042              1561 ns/op               0 B/op          0 allocs/op
BenchmarkLogByStdlib
BenchmarkLogByStdlib-16            80896             15269 ns/op               0 B/op          0 allocs/op
PASS
ok      github.com/hnakamur/log2_experiment     7.322s
</code></pre><h2 id="アルゴリズム">アルゴリズム</h2>
<h3 id="一番近い2のべき乗から1を引いた値の計算">一番近い2のべき乗から1を引いた値の計算</h3>
<p><a href="https://stackoverflow.com/questions/68677658/how-does-one-find-the-floor-of-the-log-base-2-of-an-n-bit-integer-using-bitwise">algorithm - How does one find the floor of the log-base-2 of an n-bit integer using bitwise operators? - Stack Overflow</a>の<a href="https://stackoverflow.com/a/68681396/1391518">回答</a>の1によると以下のコードはx以上の一番近い2のべき乗から1を引いた値を計算しているそうです。</p>
<pre tabindex="0"><code>    x |= (x &gt;&gt; 1);
    x |= (x &gt;&gt; 2);
    x |= (x &gt;&gt; 4);
    x |= (x &gt;&gt; 8);
    x |= (x &gt;&gt; 16);
    x |= (x &gt;&gt; 32);
</code></pre><p>その後の説明を読んでもピンとこなかったのですが、実際に試すとわかりました(なお以下のコードはちゃんとしたテストではないですが、ちょっと結果を見たいときに私はこういうことをしています)。</p>
<pre tabindex="0"><code>func TestDebugPow2Minus1Good(t *testing.T) {
	fDebug := func(n uint64) uint64 {
		fmt.Printf(&#34;fDebug start n=%#0b\n&#34;, n)
		n |= n &gt;&gt; 1
		fmt.Printf(&#34;fDebug #1    n=%#0b\n&#34;, n)
		n |= n &gt;&gt; 2
		fmt.Printf(&#34;fDebug #2    n=%#0b\n&#34;, n)
		n |= n &gt;&gt; 4
		fmt.Printf(&#34;fDebug #3    n=%#0b\n&#34;, n)
		n |= n &gt;&gt; 8
		fmt.Printf(&#34;fDebug #4    n=%#0b\n&#34;, n)
		n |= n &gt;&gt; 16
		fmt.Printf(&#34;fDebug #5    n=%#0b\n&#34;, n)
		n |= n &gt;&gt; 32
		fmt.Printf(&#34;fDebug final n=%#0b\n&#34;, n)
		return n
	}
	fDebug(0x80000000000)
}
</code></pre><pre tabindex="0"><code>$ go test -v -run TestDebugPow2Minus1Good
=== RUN   TestDebugPow2Minus1
fDebug start n=0b10000000000000000000000000000000000000000000
fDebug #1    n=0b11000000000000000000000000000000000000000000
fDebug #2    n=0b11110000000000000000000000000000000000000000
fDebug #3    n=0b11111111000000000000000000000000000000000000
fDebug #4    n=0b11111111111111110000000000000000000000000000
fDebug #5    n=0b11111111111111111111111111111111000000000000
fDebug final n=0b11111111111111111111111111111111111111111111
…(略)…
</code></pre><p>シフトの量を変えて繰り返すと一番左の1のビットの右が全て1になるというわけです。</p>
<p>途中で<code>|=</code>でnを更新しているのは重要です。下記はそうしないとうまくいかないことを確認したものです。</p>
<pre tabindex="0"><code>func TestDebugPow2Minus1Bad(t *testing.T) {
	gDebug := func(n uint64) uint64 {
		fmt.Printf(&#34;gDebug start n=%#0b\n&#34;, n)
		n1 := n &gt;&gt; 1
		fmt.Printf(&#34;gDebug      n1=%#0b, n|n1=%#0b\n&#34;, n1, n|n1)
		n2 := n &gt;&gt; 2
		fmt.Printf(&#34;gDebug      n2=%#0b, n|n1|n2=%#0b\n&#34;, n2, n|n1|n2)
		n4 := n &gt;&gt; 4
		fmt.Printf(&#34;gDebug      n4=%#0b, n|n1|n2|n4=%#0b\n&#34;, n4, n|n1|n2|n4)
		n8 := n &gt;&gt; 8
		fmt.Printf(&#34;gDebug      n8=%#0b, n|n1|n2|n4|n8=%#0b\n&#34;, n8, n|n1|n2|n4|n8)
		n16 := n &gt;&gt; 16
		fmt.Printf(&#34;gDebug     n16=%#0b, n|n1|n2|n4|n8|n16=%#0b\n&#34;, n16, n|n1|n2|n4|n8|n16)
		n32 := n &gt;&gt; 32
		fmt.Printf(&#34;gDebug     n32=%#0b, n|n1|n2|n4|n8|n16|n32=%#0b\n&#34;, n32, n|n1|n2|n4|n8|n16|n32)
		return n | n1 | n2 | n4 | n8 | n16 | n32
	}
	gDebug(0x80000000000)
}
</code></pre><pre tabindex="0"><code>$ go test -v -run TestDebugPow2Minus1Bad
=== RUN   TestDebugPow2Minus1Bad
gDebug start n=0b10000000000000000000000000000000000000000000
gDebug      n1=0b1000000000000000000000000000000000000000000, n|n1=0b11000000000000000000000000000000000000000000
gDebug      n2=0b100000000000000000000000000000000000000000, n|n1|n2=0b11100000000000000000000000000000000000000000
gDebug      n4=0b1000000000000000000000000000000000000000, n|n1|n2|n4=0b11101000000000000000000000000000000000000000
gDebug      n8=0b100000000000000000000000000000000000, n|n1|n2|n4|n8=0b11101000100000000000000000000000000000000000
gDebug     n16=0b1000000000000000000000000000, n|n1|n2|n4|n8|n16=0b11101000100000001000000000000000000000000000
gDebug     n32=0b100000000000, n|n1|n2|n4|n8|n16|n32=0b11101000100000001000000000000000100000000000
…(略)…
</code></pre><h3 id="テーブルをひくときのインデクスの計算">テーブルをひくときのインデクスの計算</h3>
<p><a href="https://github.com/h2o/h2o/blob/0f08b675c8244fc4552a93e9b35271ecf5e0f8fa/deps/libgkc/gkc.c#L126">h2o/gkc.c at master · h2o/h2o</a>の<code>((x &amp; ~(x&gt;&gt;1))*debruijn_magic)&gt;&gt;58</code>の<code>(x &amp; ~(x&gt;&gt;1)</code>の部分は1番左のビットの残して右側の1が並んだ部分を0クリアしているんですね。シフトが58なのは上の<a href="https://stackoverflow.com/a/68681396/1391518">回答</a>の3に説明がありました。64ビットの場合はlog2(64)=6ビットだけが必要ということで(64-6)=58ビット右シフトしているとのことです。</p>
<p><a href="https://stackoverflow.com/questions/11376288/fast-computing-of-log2-for-64-bit-integers/23000588#23000588">c - Fast computing of log2 for 64-bit integers - Stack Overflow</a>に32ビットの例もあって、そちらはlog2(32)=5ビットなので(32-5)=27ビット右シフトしています。</p>
<p><a href="https://stackoverflow.com/questions/68677658/how-does-one-find-the-floor-of-the-log-base-2-of-an-n-bit-integer-using-bitwise#comment121383127_68681396">上の回答のコメント</a>に
<a href="https://en.wikipedia.org/wiki/De_Bruijn_sequence">de Bruijn sequence - Wikipedia</a>の<a href="https://en.wikipedia.org/wiki/De_Bruijn_sequence#Construction">Construction</a>へのリンクが貼られていました。</p>
<p>さらに探すと<a href="https://stackoverflow.com/questions/11376288/fast-computing-of-log2-for-64-bit-integers">c - Fast computing of log2 for 64-bit integers - Stack Overflow</a>の<a href="https://stackoverflow.com/questions/11376288/fast-computing-of-log2-for-64-bit-integers/23000588#23000588">Avernarさんの回答</a>で<code>((x &amp; ~(x&gt;&gt;1))*debruijn_magic)&gt;&gt;58</code>の<code>((x &amp; ~(x&gt;&gt;1))</code>をせずに<code>(x*C)&gt;&gt;58</code>で済むようなCとルックアップテーブルを使う方法も紹介されていました。Cはde Bruijn sequenceのB(2, 6)の1つである0x07EDD5E59A4E28C2を2で割った値です。</p>
<p>そこからリンクされていた<a href="http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogDeBruijn">Find the log base 2 of an N-bit integer in O(lg(N)) operations with multiply and lookup</a>に</p>
<blockquote>
<p>On December 10, 2009, Mark Dickinson shaved off a couple operations by requiring v be rounded up to one less than the next power of 2 rather than the power of 2.</p>
</blockquote>
<p>とありました。</p>
<p>さらに、そこから<a href="http://graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightMultLookup">Count the consecutive zero bits (trailing) on the right with multiply and lookup</a>へのリンクもあり</p>
<blockquote>
<p>More information can be found by reading the paper Using de Bruijn Sequences to Index 1 in a Computer Word by Charles E. Leiserson, Harald Prokof, and Keith H. Randall.</p>
</blockquote>
<p>と書かれていました。ここはリンク切れでしたが検索すると <a href="http://supertech.csail.mit.edu/papers/debruijn.pdf">http://supertech.csail.mit.edu/papers/debruijn.pdf</a> にありました。</p>
<p>これを読むとルックアップテーブルはパーフェクトハッシュになっているそうです。それを知って改めて実装のルックアップテーブルを見ると0～63が1回ずつ出現していることに気付いてなるほどとなりました。</p>
<h2 id="正しい結果が出る値の範囲を調べてみた">正しい結果が出る値の範囲を調べてみた</h2>
<p>まず入力が0の場合はmath.Log2(0)はマイナス無限大ですが、今回の実装は0になります。</p>
<p>次に、あるxまでは正しい結果を返し、それを超えると正しくない結果を返すと仮定して(この仮定が正しいかは不明)、正しい結果(<code>math.Floor(math.Log2(x))</code>)を返すxの最大値を調べてみると0xffffffffffff4bffでした。
0xffffffffffff4bff+1～0xffffffffffffffff(=math.MaxUint64)では正しい値は64ですが、今回の実装は63を返します。</p>
<p><a href="https://github.com/flyingmutant/rapid">flyingmutant/rapid: Rapid is a Go library for property-based testing that supports state machine (&ldquo;stateful&rdquo; or &ldquo;model-based&rdquo;) testing and fully automatic test case minimization (&ldquo;shrinking&rdquo;)</a>を使って1～0xffffffffffff4bffの値で1億回(100,000,000)テストしてみた範囲では全て正しい値を返していました。</p>
<pre tabindex="0"><code>$ go test -v -run TestLog2ByAvernarPropertyEqualToStdlib -rapid.checks=100000000
=== RUN   TestLog2ByAvernarPropertyEqualToStdlib
    log2_test.go:118: [rapid] OK, passed 100000000 tests (48.773136105s)
--- PASS: TestLog2ByAvernarPropertyEqualToStdlib (48.77s)
PASS
ok      github.com/hnakamur/log2_experiment     48.779s
</code></pre><h2 id="ルックアップテーブルの作り方を確認">ルックアップテーブルの作り方を確認</h2>
<p>以下のコードを書いて生成したテーブルが<a href="https://stackoverflow.com/questions/11376288/fast-computing-of-log2-for-64-bit-integers/23000588#23000588">Avernarさんの回答</a>のテーブルに一致することを確認しました。</p>
<pre tabindex="0"><code>func buildTable(c uint64) []uint8 {
	v := make([]uint8, 64)
	for i := uint64(0); i &lt; 64; i++ {
		x := uint64(1) &lt;&lt; i
		x |= x - 1
		v[(x*c)&gt;&gt;58] = uint8(i)
	}
	return v
}

var u8Table = []uint8{
	0, 58, 1, 59, 47, 53, 2, 60, 39, 48, 27, 54, 33, 42, 3, 61,
	51, 37, 40, 49, 18, 28, 20, 55, 30, 34, 11, 43, 14, 22, 4, 62,
	57, 46, 52, 38, 26, 32, 41, 50, 36, 17, 19, 29, 10, 13, 21, 56,
	45, 25, 31, 35, 16, 9, 12, 44, 24, 15, 8, 23, 7, 6, 5, 63,
}
</code></pre><pre tabindex="0"><code>func TestBuildTableAvernar(t *testing.T) {
	got := buildTable(0x03f6eaf2cd271461)
	want := u8Table
	if !slices.Equal(got, want) {
		t.Errorf(&#34;table mismatch, got=%v, want=%v&#34;, got, want)
	}
}
</code></pre><p><a href="https://stackoverflow.com/a/11398748/1391518">Desmond Humeさんの回答</a>では<code>(value - (value &gt;&gt; 1))*0x07EDD5E59A4E28C2)</code>としているのに対し、<a href="https://stackoverflow.com/questions/11376288/fast-computing-of-log2-for-64-bit-integers/23000588#23000588">Avernarさんの回答</a>では<code>(value - (value &gt;&gt; 1))</code>の部分を<code>value</code>と2倍弱にする代わりに0x07EDD5E59A4E28C2を半分にした値を使っているのでなんとなく帳尻があっているのかなとぼんやり思いました。</p>
<p><a href="https://stackoverflow.com/questions/11376288/fast-computing-of-log2-for-64-bit-integers/23000588#23000588">Avernarさんの回答</a>のルックアップテーブルは<a href="https://stackoverflow.com/a/11398748/1391518">Desmond Humeさんの回答</a>のルックアップテーブル(下記に抜粋)を1つ左にローテートしたものになっていることに気付きました。</p>
<pre tabindex="0"><code>const int tab64[64] = {
    63,  0, 58,  1, 59, 47, 53,  2,
    60, 39, 48, 27, 54, 33, 42,  3,
    61, 51, 37, 40, 49, 18, 28, 20,
    55, 30, 34, 11, 43, 14, 22,  4,
    62, 57, 46, 52, 38, 26, 32, 41,
    50, 36, 17, 19, 29, 10, 13, 21,
    56, 45, 25, 31, 35, 16,  9, 12,
    44, 24, 15,  8, 23,  7,  6,  5};
</code></pre><p>de Bruijn sequence自体はローテートした値でも良いのですが、自分で2つほど試してみたところ<code>(x*C)&gt;&gt;58</code>のCはどんなB(2, 6)の半分でも良いわけではないということが分かりました。<a href="https://stackoverflow.com/questions/11376288/fast-computing-of-log2-for-64-bit-integers#comment75512059_23000588">nwellnhofさんのコメント</a>に<code>0x07EDD5E59A4E28C2</code>は先頭に0が6ビット連続して、その後に1が6ビット連続しているのが良いのではないかとあったのですが、私にはよくわかりませんでした。</p>
<p>先頭に0が6ビット連続して、その後に1が6ビット連続していること自体は以下のテストで確認できました(実際はwantを空文字で実行してエラーメッセージからコピペしました)。</p>
<pre tabindex="0"><code>func TestBinAvernarDeBruijn(t *testing.T) {
	got := fmt.Sprintf(&#34;%#064b&#34;, 0x07EDD5E59A4E28C2)
	want := &#34;0b0000011111101101110101011110010110011010010011100010100011000010&#34;
	if got != want {
		t.Errorf(&#34;result mismatch, got=%s, want=%s&#34;, got, want)
	}
}
</code></pre><h2 id="ベンチマーク">ベンチマーク</h2>
<ul>
<li>Log2は<a href="https://github.com/h2o/h2o/blob/0f08b675c8244fc4552a93e9b35271ecf5e0f8fa/deps/libgkc/gkc.c#L109-L127">h2o内のullog2</a>の移植版</li>
<li>LogByAvernarは<a href="https://stackoverflow.com/questions/11376288/fast-computing-of-log2-for-64-bit-integers/23000588#23000588">Avernarさんの回答</a>の移植版</li>
<li>LogByAvernarU8は<a href="https://stackoverflow.com/questions/11376288/fast-computing-of-log2-for-64-bit-integers/23000588#23000588">Avernarさんの回答</a>のルックアップテーブルを<code>[]uint64</code>から<code>[]uint8</code>に買えた版</li>
</ul>
<pre tabindex="0"><code>hnakamur@thinkcentre2:~/ghq/github.com/hnakamur/log2_experiment$ go test -v -run ^$ -bench . -benchmem
goos: linux
goarch: amd64
pkg: github.com/hnakamur/log2_experiment
cpu: AMD Ryzen 7 PRO 4750GE with Radeon Graphics
BenchmarkLog2
BenchmarkLog2-16                  616564              1840 ns/op               0 B/op          0 allocs/op
BenchmarkLogByAvernar
BenchmarkLogByAvernar-16           793698              1554 ns/op               0 B/op          0 allocs/op
BenchmarkLogByAvernarU8
BenchmarkLogByAvernarU8-16         751774              1570 ns/op               0 B/op          0 allocs/op
BenchmarkLogByStdlib
BenchmarkLogByStdlib-16            78012             15425 ns/op               0 B/op          0 allocs/op
PASS
ok      github.com/hnakamur/log2_experiment     6.681s
hnakamur@thinkcentre2:~/ghq/github.com/hnakamur/log2_experiment$ go test -v -run ^$ -bench . -benchmem
goos: linux
goarch: amd64
pkg: github.com/hnakamur/log2_experiment
cpu: AMD Ryzen 7 PRO 4750GE with Radeon Graphics
BenchmarkLog2
BenchmarkLog2-16                  650958              1871 ns/op               0 B/op          0 allocs/op
BenchmarkLogByAvernar
BenchmarkLogByAvernar-16           793904              1551 ns/op               0 B/op          0 allocs/op
BenchmarkLogByAvernarU8
BenchmarkLogByAvernarU8-16         754802              1537 ns/op               0 B/op          0 allocs/op
BenchmarkLogByStdlib
BenchmarkLogByStdlib-16            77786             14849 ns/op               0 B/op          0 allocs/op
PASS
ok      github.com/hnakamur/log2_experiment     7.297s
hnakamur@thinkcentre2:~/ghq/github.com/hnakamur/log2_experiment$ go test -v -run ^$ -bench . -benchmem
goos: linux
goarch: amd64
pkg: github.com/hnakamur/log2_experiment
cpu: AMD Ryzen 7 PRO 4750GE with Radeon Graphics
BenchmarkLog2
BenchmarkLog2-16                  628119              1896 ns/op               0 B/op          0 allocs/op
BenchmarkLogByAvernar
BenchmarkLogByAvernar-16           745449              1553 ns/op               0 B/op          0 allocs/op
BenchmarkLogByAvernarU8
BenchmarkLogByAvernarU8-16         677878              1564 ns/op               0 B/op          0 allocs/op
BenchmarkLogByStdlib
BenchmarkLogByStdlib-16            66051             15387 ns/op               0 B/op          0 allocs/op
PASS
ok      github.com/hnakamur/log2_experiment     6.174s
</code></pre>
</div>


<script src="https://hnakamur.github.io/blog/js/copy-button.js"></script>
    </main>
  </body>
</html>
