<!DOCTYPE html>
<html lang="ja">
<head>
        <meta charset="utf-8" />
        <title>zerologを参考にしてltsvlogを改良してみた</title>
        <link rel="stylesheet" href="../../../../theme/css/main.css" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="../../../../">hnakamur's blog at github </a></h1>
                <nav><ul>
                    <li class="active"><a href="../../../../category/blog.html">blog</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="../../../../2017/05/28/improve-ltsvlog-with-referring-to-zerolog/" rel="bookmark"
           title="Permalink to zerologを参考にしてltsvlogを改良してみた">zerologを参考にしてltsvlogを改良してみた</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-05-28T21:52:00+09:00">
                Published: 2017-05-28
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://hnakamur.github.io">Hiroaki Nakamura</a>
        </address>
<p>In <a href="../../../../category/blog.html">blog</a>.</p>
<p>tags: <a href="../../../../tag/ltsv-go-benchmark.html">ltsv go benchmark</a> </p>
</footer><!-- /.post-info -->      <div class="section" id="id1">
<h2>はじめに</h2>
<p>こちらも少し前の話なのですがブログに書いておきます。</p>
<p><a class="reference external" href="https://twitter.com/mattn_jp/status/864993516149022720">( ꒪⌓꒪)さんのツイート: &quot;zero allocation をうたう logger #golang / “GitHub - rs/zerolog: Zero Allocation JSON Logger” https://t.co/3t2qt9Qgbm&quot;</a> というmattnさんのツイートを見かけて
<a class="reference external" href="https://github.com/rs/zerolog">rs/zerolog: Zero Allocation JSON Logger</a>
zerologの仕組みを調べ、自作のLTSVログ出力ライブラリ
<a class="reference external" href="https://github.com/hnakamur/ltsvlog">hnakamur/ltsvlog: a minimalist LTSV logging library in Go</a>
を改善してみたメモです。</p>
</div>
<div class="section" id="zerolog">
<h2>zerologの仕組み</h2>
<p>zerologはJSON形式でログ出力する構造化ログライブラリです。
<a class="reference external" href="https://godoc.org/github.com/rs/zerolog">zerolog - GoDoc</a>
を見ると <code>Logger</code> の <code>Info</code> や <code>Debug</code> を呼ぶと <code>*Event</code> が返されるようになっています。</p>
<p>そして <code>*Event</code> の <code>Str</code> メソッドにキーと値を指定して呼ぶと</p>
<p><a class="reference external" href="https://github.com/rs/zerolog/blob/bf4b44614c4fe42f071ba7162e4898edaef8fa1e/event.go#L110-L117">zerolog/event.go#L110-L117 at bf4b44614c4fe42f071ba7162e4898edaef8fa1e · rs/zerolog</a></p>
<p>のように <code>[]byte</code> のバッファに文字列を追加するようになっています。</p>
<p>最後に <code>Msg</code> か <code>Msgf</code> メソッドを呼び出すと指定したメッセージをバッファに追加した上でログ出力されます。</p>
<p>そして <code>[]byte</code> のバッファを
<a class="reference external" href="https://github.com/rs/zerolog/blob/bf4b44614c4fe42f071ba7162e4898edaef8fa1e/event.go#L10-L16">zerolog/event.go#L10-L16 at bf4b44614c4fe42f071ba7162e4898edaef8fa1e · rs/zerolog</a>
のように <code>sync.Pool</code> で管理して再利用することでゼロアロケーションを実現しているという仕組みになっていました。</p>
</div>
<div class="section" id="id2">
<h2>ベンチマークでメモリ割り当てや実行速度の改善具合を調べる</h2>
<p>以下の記事を参考にしながら、いろいろ試行錯誤して自作のログライブラリを改善してみました。</p>
<ul class="simple">
<li><a class="reference external" href="http://dsas.blog.klab.org/archives/52191778.html">DSAS開発者の部屋:Goでアロケーションに気をつけたコードを書く方法</a></li>
<li><a class="reference external" href="https://mattn.kaoriya.net/software/lang/go/20161019124907.htm">Big Sky :: golang でパフォーマンスチューニングする際に気を付けるべきこと</a></li>
<li><a class="reference external" href="http://deeeet.com/writing/2016/05/29/go-flame-graph/">GolangでFlame Graphを描く | SOTA</a></li>
</ul>
<p>ベンチマーク比較ツールの
<a class="reference external" href="https://github.com/rsc/benchstat">rsc/benchstat: Benchstat computes and compares statistics about benchmarks.</a>
は
<a class="reference external" href="https://godoc.org/golang.org/x/perf/cmd/benchstat">benchstat - GoDoc</a>
に移動していました。
さらに
<a class="reference external" href="https://godoc.org/golang.org/x/tools/cmd/benchcmp">benchcmp - GoDoc</a>
というのもありました。
改善前後の比較という意味でbenchcmpのほうが名前がわかりやすいと思ってしばらくそちらを使っていました。が、今改めてドキュメントを見比べてみると、ベンチマークを複数回実行して比較するにはbenchstatのほうが良さそうです。</p>
<p>benchstatは以下のコマンドでインストールします。</p>
<div class="highlight"><pre><span></span><span class="go">go get -u golang.org/x/perf/cmd/benchstat/...</span>
</pre></div>
<p>ベンチマークを書いたら改善前の状態で一旦ベンチマークを取ります。</p>
<div class="highlight"><pre><span></span><span class="go">go test -count=10 -run=NONE -bench . -benchmem -cpuprofile=cpu-old.prof | tee old.log</span>
</pre></div>
<p>コードを改善したら再度ベンチマークを取ります。</p>
<div class="highlight"><pre><span></span><span class="go">go test -count=10 -run=NONE -bench . -benchmem -cpuprofile=cpu-new.prof | tee new.log</span>
</pre></div>
<p>benchstatを実行して改善度合いを確認します。</p>
<div class="highlight"><pre><span></span><span class="gp">hnakamur@express:~/go/src/github.com/hnakamur/ltsvlog$</span> benchstat old.log new.log
<span class="go">name            old time/op    new time/op    delta</span>
<span class="go">Info-2            1.90µs ± 1%    1.60µs ± 1%     -16.00%  (p=0.000 n=9+10)</span>
<span class="go">ErrWithStack-2    13.9µs ± 1%    18.3µs ± 4%     +31.11%  (p=0.000 n=9+9)</span>

<span class="go">name            old alloc/op   new alloc/op   delta</span>
<span class="go">Info-2             32.0B ± 0%      0.0B         -100.00%  (p=0.000 n=10+10)</span>
<span class="go">ErrWithStack-2     80.0B ± 0%   8260.0B ± 0%  +10225.00%  (p=0.000 n=10+7)</span>

<span class="go">name            old allocs/op  new allocs/op  delta</span>
<span class="go">Info-2              2.00 ± 0%      0.00         -100.00%  (p=0.000 n=10+10)</span>
<span class="go">ErrWithStack-2      4.00 ± 0%      3.00 ± 0%     -25.00%  (p=0.000 n=10+10)</span>
</pre></div>
<p>またgo-torchでフレームグラフのsvgファイルを出力してブラウザなどで表示し、ベンチマークで実行しているコードのどの部分が主に時間がかかっているかを確認します。</p>
<p>go-torchは</p>
<div class="highlight"><pre><span></span><span class="go">go get -u github.com/uber/go-torch/...</span>
</pre></div>
<p>でインストールして</p>
<div class="highlight"><pre><span></span><span class="go">go-torch -f torch-new.svg cpu-new.prof</span>
</pre></div>
<p>で実行します。</p>
</div>
<div class="section" id="ltsvlogapi">
<h2>ltsvlogのAPIの設計メモ</h2>
<div class="section" id="infodebugeventlog">
<h3>InfoとDebugはEventのLogメソッドでログ出力</h3>
<p>zerologはEventのMsgかMsgfメソッドを呼び出すとメッセージを追加したうえでログ出力するというAPIになっています。私はメッセージの位置をもっと前にしたいのでログ出力にはLogという専用のメソッドを追加することにしました。</p>
</div>
<div class="section" id="id3">
<h3>エラーにスタックトレースとキーバリューを付与して呼び出しの上位階層でログ出力</h3>
<p>エラーは1回発生したら、理想的には1回だけログに書くようにしたいところです。</p>
<p>Goのコアチームでは呼び出し階層の上位でエラーを受け取ったら
<code>return fmt.Errorf(&quot;failed to connect to server, err=%v&quot;, err)</code>
のような感じでエラーのコンテキスト情報を追加して1段ずつ上に上げるのが定番のようです。</p>
<p>ですが、私はスタックトレースのほうが便利だと思うのでスタックトレースを使っています。
上記のような文言を他と重複せずに付け分けるのは大変ですがスタックトレースがあればどういう経路で呼び出されたか一目瞭然なのでありがたいです。</p>
<p>また、エラーが発生箇所でエラーに関連する変数の値も出力したいです。
これらを総合するとエラーにスタックトレースや関連する変数の値を付与しておいて、呼び出し階層の上位にエラーを返していき、上位でそれらの情報をログ出力できると良いと思います。
構造化ログならぬ構造化エラーとでも言いましょうか。</p>
<p><a class="reference external" href="https://github.com/pkg/errors">pkg/errors: Simple error handling primitives</a> ではスタックトレースの付与は出来るのですが、キーバリューの追加はデザインディシジョンとして含めない決定がされていました。知らずにイシューを立ててコメントを受けてその事実を知りました。</p>
<p>今回の方式はGoのコアチームの流儀と違うので導入すべきか悩んだのですが、ついに導入してみました。
<code>return ltsvlog.Err(err).String(&quot;key&quot;, &quot;value&quot;).Stack(&quot;&quot;)</code> のような感じでエラーを返して、
呼び出し階層の上位で <code>ltsvlog.Logger.Err(err)</code> でログ出力します。</p>
<p>その場でログ出力する場合はこれらを組み合わせて
<code>ltsvlog.Logger.Err(ltsvlog.Err(err).String(&quot;key&quot;, &quot;value&quot;).Stack(&quot;&quot;))</code> でログ出力します。</p>
<p>LTSVの1項目としてキー・バリューを出力できるので、後からログを検索しやすいのが利点だと考えています。</p>
<p>個々のエラーログ呼び出しをもうちょっとコンパクトに書けるようにできないかと、Goのコアチームの方式と共存できないかは今後考えてみたいと思います。</p>
</div>
</div>
<div class="section" id="ltsvlog">
<h2>ltsvlogの速度改善のメモ</h2>
<div class="section" id="id4">
<h3>日時のフォーマット</h3>
<p>フレームグラフを作ってみてみると日時のフォーマットはかなり重い処理でした。
<a class="reference external" href="https://github.com/uber-go/zap">uber-go/zap: Blazing fast, structured, leveled logging in Go.</a> では開発時は日時をフォーマットし、プロダクションではタイムスタンプを出力することで高速化を図っていました。
でも私としては常に日時をフォーマットのほうが好みです。
Goの標準ライブラリのlogパッケージではtimeのFormatを使わず、固定フォーマットで年月日時分秒をゼロパディングして文字列化する処理をlogパッケージのプライベート関数itoaで行って高速化を図っていました。
ltsvlogはこのコードをコピーして改変して利用しています。</p>
<p>logのitoaは1の位から始めて次は10の位と順番に数値の文字列を埋めていくようになっています。
そして年月日時分秒のゼロパディングありの固定長とファイルの行数のゼロパディング無しの可変長の両方の用途があるため、一旦内部バッファで文字列を生成してから出力先にコピーしなおしていました。</p>
<p>ゼロパディングありの固定長の用途に限定すれば、最初から出力先で文字列を組み立てるようにすると最後のコピーが無くせて12%前後の高速化が出来ました。
<a class="reference external" href="https://go-review.googlesource.com/c/42891/">log: Optimize formatting time in header with avoiding buffer copy in ioa (Ic4072cd8) · Gerrit Code Review</a>
でGo標準ライブラリのlogパッケージにもフィードバックを送っています（取り込まれるかは未定）。</p>
<p>ltsvlogではログの日時のタイムゾーンはUTC固定で精度もマイクロ秒に固定しています。
タイムゾーンを出力するにはtimeパッケージのFormatメソッドを使うしかなさそうなので避けたいのと、タイムゾーンによってはサマータイムがあってややこしいので、システム的な日時はUTC固定のほうが良いという判断にしました。</p>
<p>また精度も短時間の処理の前後でログ出力するとミリ秒では足りないケースもありそうで、かといってナノ秒までは不要だろうということでマイクロ秒固定にしました。速度的にもナノ秒まで出すよりマイクロ秒のほうが速かったです。記録取ってなかったので改善率はうろ覚えですが1～3%ぐらいだった気がします。</p>
</div>
<div class="section" id="sync-pool">
<h3>sync.Poolは使うとかえってメモリ割り当てが増えて遅くなることもあった</h3>
<p>まず基本方針として、文字列を作るときにメモリ割り当てを減らすには、個々の文字列を作ってから <code>+</code> 演算子や <code>fmt.Sprintf</code> で連結するのではなく、 <code>[]byte</code> のバッファに対して <code>buf = append(buf, &quot;string&quot;...)</code> や <a class="reference external" href="https://golang.org/pkg/strconv/">strconv - The Go Programming Language</a> の <code>AppendInt</code> のような関数を使うのが良いようです。これは私が試行錯誤した範囲ではそのようだというところで、違う場合もあるかもしれません。</p>
<p>で、次は <code>[]byte</code> のバッファを毎回割り当てるのではなく <code>sync.Pool</code> を使って再利用するのが良いようです。</p>
<p>ですが、
<a class="reference external" href="https://github.com/hnakamur/ltsvlog/blob/v1.5.1/log.go#L335-L348">ltsvlog/log.go#L335-L348 at v1.5.1 · hnakamur/ltsvlog</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">appendUTCTime</span><span class="p">(</span><span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
        <span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">UTC</span><span class="p">()</span>
        <span class="nx">tmp</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;0000-00-00T00:00:00.000000Z&quot;</span><span class="p">)</span>
        <span class="nx">year</span><span class="p">,</span> <span class="nx">month</span><span class="p">,</span> <span class="nx">day</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Date</span><span class="p">()</span>
        <span class="nx">hour</span><span class="p">,</span> <span class="nx">min</span><span class="p">,</span> <span class="nx">sec</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Clock</span><span class="p">()</span>
        <span class="nx">itoa</span><span class="p">(</span><span class="nx">tmp</span><span class="p">[:</span><span class="mi">4</span><span class="p">],</span> <span class="nx">year</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="nx">itoa</span><span class="p">(</span><span class="nx">tmp</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">7</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="nx">month</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="nx">itoa</span><span class="p">(</span><span class="nx">tmp</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">10</span><span class="p">],</span> <span class="nx">day</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="nx">itoa</span><span class="p">(</span><span class="nx">tmp</span><span class="p">[</span><span class="mi">11</span><span class="p">:</span><span class="mi">13</span><span class="p">],</span> <span class="nx">hour</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="nx">itoa</span><span class="p">(</span><span class="nx">tmp</span><span class="p">[</span><span class="mi">14</span><span class="p">:</span><span class="mi">16</span><span class="p">],</span> <span class="nx">min</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="nx">itoa</span><span class="p">(</span><span class="nx">tmp</span><span class="p">[</span><span class="mi">17</span><span class="p">:</span><span class="mi">19</span><span class="p">],</span> <span class="nx">sec</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="nx">itoa</span><span class="p">(</span><span class="nx">tmp</span><span class="p">[</span><span class="mi">20</span><span class="p">:</span><span class="mi">26</span><span class="p">],</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Nanosecond</span><span class="p">()</span><span class="o">/</span><span class="mf">1e3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">append</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">tmp</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>のtmpをsync.Poolを使うようにしてみたらメモリ割り当てがむしろ増えて速度も遅くなってしまいました。
関数内で確保して使い終わるケースでは素直に確保するほうが良いようです。
Goのコンパイラで出力されるGoのアセンブラのコードを見てみれば良いのでしょうが、そこまではしていません。</p>
</div>
</div>
<div class="section" id="id5">
<h2>おわりに</h2>
<p>zerologの手法を真似することで、ltsvlogでもシンプルなケースではメモリ割り当てゼロでログ出力できるようになりました。</p>
<p><a class="reference external" href="https://github.com/hnakamur/go-log-benchmarks">hnakamur/go-log-benchmarks</a> に私が気になるログライブラリのベンチマーク結果を載せています。ベンチマークと言ってもそれぞれのライブラリで出力している内容が異なるのでフェアな比較ではありませんが、おおまかな目安としては良いかなということで。</p>
</div>

    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is a custom version based on <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

    <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-53263855-1', 'auto');
    ga('send', 'pageview');
    </script>
</body>
</html>