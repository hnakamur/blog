<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja-jp" lang="ja-jp">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.98.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>LuaJIT FFIでモジュールを書く時のハウツー &middot; hnakamur&#39;s blog</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/copy-button.css">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://hnakamur.github.io/blog/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://hnakamur.github.io/blog/favicon.png">

  
  


<script async src="https://www.googletagmanager.com/gtag/js?id=G-KMMXGG2Z56"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-KMMXGG2Z56');
</script>



</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://hnakamur.github.io/blog/"><h1>hnakamur&#39;s blog</h1></a>
      <p class="lead">
       my tech memo 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://hnakamur.github.io/blog/"> blog home </a></li><li><a href="https://github.com/hnakamur"> github @hnakamur </a></li><li><a href="https://twitter.com/hnakamur2"> twitter @hnakamur2 </a></li>
      </ul>
    </nav>

    <p>powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://pages.github.com/">GitHub Pages</a></p>
    <p>&copy; 2022. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>LuaJIT FFIでモジュールを書く時のハウツー</h1>
  <time datetime=2020-03-21T23:10:18&#43;0900 class="post-date">2020-03-21</time>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#はじめに">はじめに</a></li>
    <li><a href="#背景-なぜ-c-言語で-lua-用のモジュールを書くのではなく-luajit-ffi-でモジュールを書くのか">背景: なぜ C 言語で Lua 用のモジュールを書くのではなく LuaJIT FFI でモジュールを書くのか</a></li>
    <li><a href="#参考資料">参考資料</a></li>
    <li><a href="#c-言語で書かれた共有ライブラリをロードして-lua-から呼び出す">C 言語で書かれた共有ライブラリをロードして Lua から呼び出す。</a></li>
    <li><a href="#c-言語で書かれたライブラリの関数宣言型定義定数を-fficdef-に書く">C 言語で書かれたライブラリの関数宣言、型定義、定数を <code>ffi.cdef</code> に書く</a>
      <ul>
        <li><a href="#c-言語で書かれたライブラリのヘッダーを検索する">C 言語で書かれたライブラリのヘッダーを検索する</a></li>
        <li><a href="#実行時に使いたいライブラリーのヘッダーファイルを参照する">実行時に使いたいライブラリーのヘッダーファイルを参照する</a></li>
        <li><a href="#関数の呼び出しに必要な宣言を探して追加していく">関数の呼び出しに必要な宣言を探して追加していく</a></li>
        <li><a href="#define-での数値定数の定義は-enum-で書き換える"><code>#define</code> での数値定数の定義は <code>enum</code> で書き換える</a></li>
        <li><a href="#ifdef-の定数定義がどうなっているか調べる"><code>#ifdef</code> の定数定義がどうなっているか調べる</a></li>
        <li><a href="#c-言語で書かれたライブラリの構造体と-fficdef-に書いた構造体のサイズやフィールドのオフセットが一致するか確認">C 言語で書かれたライブラリの構造体と <code>ffi.cdef</code> に書いた構造体のサイズやフィールドのオフセットが一致するか確認</a></li>
      </ul>
    </li>
    <li><a href="#lua-から-c-言語で書かれたライブラリの関数を呼び出す">Lua から C 言語で書かれたライブラリの関数を呼び出す</a>
      <ul>
        <li><a href="#c-言語で書かれたライブラリと-lua-のコードで引数や戻り値の受け渡す際の型変換">C 言語で書かれたライブラリと Lua のコードで引数や戻り値の受け渡す際の型変換</a></li>
        <li><a href="#c-言語の-int-の戻り値を-lua-の-if-文で-boolean-として扱う場合の注意">C 言語の int の戻り値を Lua の if 文で boolean として扱う場合の注意</a></li>
        <li><a href="#エラーの返し方とエラー処理">エラーの返し方とエラー処理</a></li>
        <li><a href="#エラーで抜ける際の後処理をすっきり書く方法">エラーで抜ける際の後処理をすっきり書く方法</a></li>
      </ul>
    </li>
    <li><a href="#おわりに">おわりに</a></li>
  </ul>
</nav>
  <h2 id="はじめに">はじめに</h2>
<p><a href="/blog/2020/03/17/xmlsec-verify-code-reading/">XMLSecでの証明書検証のコードリーディング · hnakamur&rsquo;s blog</a> の結果を元に <a href="https://github.com/hnakamur/nginx-lua-saml-service-provider">hnakamur/nginx-lua-saml-service-provider</a> で SAML レスポンスを検証する処理を外部コマンド呼び出し方式から LuaJIT FFI でのライブラリ関数呼び出し方式に書き換えました。
<a href="https://github.com/hnakamur/nginx-lua-saml-service-provider/pull/4">Add response:verify_response_memory method by hnakamur · Pull Request #4 · hnakamur/nginx-lua-saml-service-provider</a></p>
<p>今回の作業で LuaJIT FFI でモジュールを書く際の知見が少し溜まったのでメモしておきます。とは言ってもガーベジコレクションといった深いところは触ってないので対象外です。</p>
<h2 id="背景-なぜ-c-言語で-lua-用のモジュールを書くのではなく-luajit-ffi-でモジュールを書くのか">背景: なぜ C 言語で Lua 用のモジュールを書くのではなく LuaJIT FFI でモジュールを書くのか</h2>
<p>場合によりますが、そのほうが動作が速いからです。 <a href="https://nullprogram.com/blog/2018/05/27/">When FFI Function Calls Beat Native C « null program</a> に詳しい説明があります。</p>
<h2 id="参考資料">参考資料</h2>
<ul>
<li><a href="http://www.lua.org/manual/5.1/index.html">Lua 5.1 Reference Manual - contents</a>
<ul>
<li><a href="https://luajit.org/extensions.html">Extensions</a> に書かれているように LuaJIT は Lua 5.1 (と 5.2 の一部の機能）互換ですので Lua 5.1 のドキュメントは重要です。</li>
</ul>
</li>
<li>LuaJIT の FFI 関連の公式ドキュメント: <a href="https://luajit.org/ext_ffi.html">FFI Library</a> と左のメニューにある子供のページ。
<ul>
<li>重要なことがいろいろ書いてあるので頑張って読みましょう。情報の密度が高くて一度に理解できないので、必要に応じて何度も参照します。</li>
</ul>
</li>
<li>実例: <a href="https://github.com/openresty/lua-resty-core/">openresty/lua-resty-core</a> など <a href="https://github.com/openresty">OpenResty</a> の <code>lua-resty-*</code> のプロジェクト群で <code>require &quot;ffi&quot;</code> で検索。
<ul>
<li><a href="https://github.com/openresty/lua-nginx-module">openresty/lua-nginx-module: Embed the Power of Lua into NGINX HTTP servers</a> には C 言語で書かれた Lua 用のモジュールが含まれていますが <a href="https://github.com/openresty/lua-nginx-module/tree/3908769d39b40b6973cc2e2002cff8d5b3169b13#lua_load_resty_core">lua_load_resty_core</a> の説明にあるように v0.10.15 から <code>resty.core</code> モジュールは <a href="https://github.com/openresty/lua-resty-core">openresty/lua-resty-core: New FFI-based API for lua-nginx-module</a> に移行しています。他にも <a href="https://github.com/openresty">OpenResty</a> には LuaJIT FFI で書かれたモジュールが多数あり、私はこれらのコードをお手本にしています。</li>
</ul>
</li>
<li><a href="https://luajit.org/extensions.html">Extensions</a> からリンクされている <a href="https://bitop.luajit.org/">Lua Bit Operations Module</a> と <a href="https://bitop.luajit.org/api.html">BitOp API Functions</a>
<ul>
<li>LuaJIT に組み込みの bit モジュールの関数でビット操作を行うことができます。</li>
</ul>
</li>
</ul>
<h2 id="c-言語で書かれた共有ライブラリをロードして-lua-から呼び出す">C 言語で書かれた共有ライブラリをロードして Lua から呼び出す。</h2>
<p><a href="https://luajit.org/ext_ffi_tutorial.html">FFI Tutorial</a> の例を見ると標準ライブラリの場合は以下のようなコードになります。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">ffi</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="s2">&#34;ffi&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ffi.cdef</span><span class="s">[[
</span></span></span><span class="line"><span class="cl"><span class="s">int poll(struct pollfd *fds, unsigned long nfds, int timeout);
</span></span></span><span class="line"><span class="cl"><span class="s">]]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ffi.C</span><span class="p">.</span><span class="n">poll</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span>
</span></span></code></pre></div><p>標準ライブラリ以外の場合は Accessing the zlib Compression Library の項に書いてあるように上記とは少し違うコードになります。以下は libxml2 の例です。</p>
<p><code>ffi.load</code> の引数に指定する文字列は使用する共有ライブラリのファイル名から先頭の <code>lib</code> と拡張子の <code>.so</code> を除いたものになります。下記の例だと <code>libxml2.so</code> なので <code>&quot;xml2&quot;</code> になるわけです。</p>
<p><code>ffi.cdef</code> には C 言語の宣言の書式で書くのでライブラリ名は関係しません。
一方 Lua から C の共有ライブラリ内の関数を呼び出すときは <code>ffi.load</code> の戻り値の table 内のフィールドに設定された関数を呼び出すことになります。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">ffi</span> <span class="o">=</span> <span class="n">require</span> <span class="s2">&#34;ffi&#34;</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">xml2</span> <span class="o">=</span> <span class="n">ffi.load</span><span class="p">(</span><span class="s2">&#34;xml2&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ffi.cdef</span><span class="s">[[
</span></span></span><span class="line"><span class="cl"><span class="s">void xmlInitParser(void);
</span></span></span><span class="line"><span class="cl"><span class="s">]]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">xml2.xmlInitParser</span><span class="p">()</span>
</span></span></code></pre></div><p>Lua の文法についての補足ですが <code>ffi.cdef</code> の後の <code>[[</code> から <code>]]</code> までは複数行文字列リテラルです（ <a href="http://www.lua.org/manual/5.1/manual.html#2.1">2.1 – Lexical Conventions</a> 参照）。
また、Lua では関数呼び出しの際に引数が table 1 つか文字列が 1 つのときは括弧を省略できるというシンタクスシュガーがあります（ <a href="http://www.lua.org/manual/5.1/manual.html#2.5.8">2.5.8 – Function Calls</a> 参照）。。
ということで、 <code>ffi.cdef</code> の箇所は複数行文字列リテラルを引数として関数を呼び出しているというわけです。</p>
<h2 id="c-言語で書かれたライブラリの関数宣言型定義定数を-fficdef-に書く">C 言語で書かれたライブラリの関数宣言、型定義、定数を <code>ffi.cdef</code> に書く</h2>
<p><a href="https://luajit.org/ext_ffi_api.html#ffi_cdef">ffi.cdef(def)</a> のドキュメントに書かれていますが、引数の複数行文字列に書かれた C 言語の宣言の内容は Ｃ のプリプロセッサーにはかけられません。</p>
<p>このため <code>#define</code> や <code>#ifdef</code> などは含まないように適宜書き換えが必要になります。</p>
<p>FFI ライブラリに同梱されている C のパーサーがサポートしている範囲は <a href="https://luajit.org/ext_ffi_semantics.html#clang">C Language Support</a> に書かれています。</p>
<p>LuaJIT FFI でモジュールを書くときに一番大変なのがこの書き換えです。</p>
<p><a href="https://github.com/koreader/ffi-cdecl">koreader/ffi-cdecl: Automated C declaration extraction for FFI interfaces</a> というツールを見かけて一度試してみたのですが、うまく行かず空の <code>ffi.cdef</code> が生成されたので諦めて手動で書き換えています。</p>
<p>一方で、これさえ出来れば後は非常に簡単です。</p>
<h3 id="c-言語で書かれたライブラリのヘッダーを検索する">C 言語で書かれたライブラリのヘッダーを検索する</h3>
<h3 id="実行時に使いたいライブラリーのヘッダーファイルを参照する">実行時に使いたいライブラリーのヘッダーファイルを参照する</h3>
<p>例えば Ubuntu で libxml2 パッケージの共有ライブラリを呼び出す場合は libxml2-dev パッケージをインストールします。実行時には dev パッケージは不要です。</p>
<h3 id="関数の呼び出しに必要な宣言を探して追加していく">関数の呼び出しに必要な宣言を探して追加していく</h3>
<p>私の場合はまず関数呼び出しを書いてファイルに保存し luajit で実行して出たエラーに対して修正するというサイクルで進めています。</p>
<p>例えば</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">ffi</span> <span class="o">=</span> <span class="n">require</span> <span class="s2">&#34;ffi&#34;</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">xml2</span> <span class="o">=</span> <span class="n">ffi.load</span><span class="p">(</span><span class="s2">&#34;xml2&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ffi.cdef</span><span class="s">[[
</span></span></span><span class="line"><span class="cl"><span class="s">]]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">xml2.xmlInitParser</span><span class="p">()</span>
</span></span></code></pre></div><p>という内容を <code>test.lua</code> というファイル名で保存し</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="go">luajit test.lua
</span></span></span></code></pre></div><p>と実行すると</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> luajit test.lua
</span></span><span class="line"><span class="cl"><span class="go">luajit: test.lua:7: missing declaration for symbol &#39;xmlInitParser&#39;
</span></span></span><span class="line"><span class="cl"><span class="go">stack traceback:
</span></span></span><span class="line"><span class="cl"><span class="go">        [C]: in function &#39;__index&#39;
</span></span></span><span class="line"><span class="cl"><span class="go">        test.lua:7: in main chunk
</span></span></span><span class="line"><span class="cl"><span class="go">        [C]: at 0x561836ac34a0
</span></span></span></code></pre></div><p>のようにエラーが出ます。</p>
<p><code>dpkg -L libxml2-dev</code> でファイル一覧を確認し、使いたい関数の宣言を探します。
以下は <code>ag</code> コマンドで <code>xmlInitParser</code> を検索する例です。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="go">ag xmlInitParser /usr/include/libxml2/
</span></span></span></code></pre></div><p>すると</p>
<pre tabindex="0"><code>XMLPUBFUN void XMLCALL
                xmlInitParser           (void);
</code></pre><p>という宣言が見つかりますので <code>#define</code> されているマクロを消して</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">ffi.cdef</span><span class="s">[[
</span></span></span><span class="line"><span class="cl"><span class="s">void xmlInitParser(void);
</span></span></span><span class="line"><span class="cl"><span class="s">]]</span>
</span></span></code></pre></div><p>のように書くか、マクロをコメントアウトして</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">ffi.cdef</span><span class="s">[[
</span></span></span><span class="line"><span class="cl"><span class="s">/* XMLPUBFUN */ void /* XMLCALL */
</span></span></span><span class="line"><span class="cl"><span class="s">                xmlInitParser           (void);
</span></span></span><span class="line"><span class="cl"><span class="s">]]</span>
</span></span></code></pre></div><p>のように書きます。</p>
<p>この例だと引数と戻り値は <code>void</code> なのでこれで完了です。</p>
<p>再度 luajit で実行すると今度はエラーなしで実行できました。</p>
<p>引数や戻り値に <code>typedef</code> された型がある場合は、その宣言も探して <code>ffi.cdef</code> に追加していきます。</p>
<p>型定義を検索する場合は</p>
<pre tabindex="0"><code>ag &#39;typedef.*型名&#39; /usr/include/
</code></pre><p>などとまずは限定して検索して、もし見つからない場合は `&rsquo;#define.*型名&rsquo; も試し、それでもだめなら諦めて単に型名で検索して結果の中から頑張って探します。</p>
<p>例えば以下のような例で <code>xmlSecPtrListId</code> を検索するときは <code>typedef.*xmlSecPtrListId</code> はヒットしないので単に <code>xmlSecPtrListId</code> で探して頑張ることになります。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">_xmlSecPtrListKlass</span> <span class="n">xmlSecPtrListKlass</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                         <span class="o">*</span><span class="n">xmlSecPtrListId</span><span class="p">;</span>
</span></span></code></pre></div><p>一方下記の例のように <code>*Ptr</code> は最後になるというパターンが決まっていれば <code>xmlSecPtrListPtr;</code> で検索するという手もあります。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_xmlSecPtrList</span> <span class="n">xmlSecPtrList</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="o">*</span><span class="n">xmlSecPtrListPtr</span><span class="p">;</span>
</span></span></code></pre></div><p>この辺はライブラリ毎の書き方にも依存するのでヘッダーファイルを見てみて法則性を見つけて試す感じです。</p>
<p>さらに次の関数呼び出しを Lua ファイルに追加して同じ手順を繰り返します。</p>
<p>これによって自分が書きたいプログラムについて最低限必要な宣言だけで済ませることができます。</p>
<h3 id="define-での数値定数の定義は-enum-で書き換える"><code>#define</code> での数値定数の定義は <code>enum</code> で書き換える</h3>
<p>例えば以下のように書き換えます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">ffi.cdef</span><span class="s">[[
</span></span></span><span class="line"><span class="cl"><span class="s">// #define XML_DETECT_IDS              2
</span></span></span><span class="line"><span class="cl"><span class="s">enum {
</span></span></span><span class="line"><span class="cl"><span class="s">  XML_DETECT_IDS        = 2,
</span></span></span><span class="line"><span class="cl"><span class="s">};
</span></span></span><span class="line"><span class="cl"><span class="s">]]</span>
</span></span></code></pre></div><p>ただこれは私がそうしているというだけで、もっと良い方法があるかもしれません。</p>
<h3 id="ifdef-の定数定義がどうなっているか調べる"><code>#ifdef</code> の定数定義がどうなっているか調べる</h3>
<h4 id="pkg-config-で定数定義されているか見てみる">pkg-config で定数定義されているか見てみる</h4>
<p>例えば libxmlsec1 の <code>xmlSecSize</code> を以下のように検索して</p>
<pre tabindex="0"><code>ag &#39;#define.*xmlSecSize&#39; /usr/include/xmlsec1/
</code></pre><p>以下のように定義されているのがわかりました。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#ifdef XMLSEC_NO_SIZE_T
</span></span></span><span class="line"><span class="cl"><span class="cp">#define xmlSecSize                              unsigned int
</span></span></span><span class="line"><span class="cl"><span class="cp">#else </span><span class="cm">/* XMLSEC_NO_SIZE_T */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define xmlSecSize                              size_t
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="cm">/* XMLSEC_NO_SIZE_T */</span><span class="cp">
</span></span></span></code></pre></div><p>libxmlsec1-dev パッケージに pkgconfig のファイルが含まれるか調べます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> dpkg -L libxmlsec1-dev <span class="p">|</span> grep pkgconfig/
</span></span><span class="line"><span class="cl"><span class="go">/usr/lib/x86_64-linux-gnu/pkgconfig/xmlsec1-gcrypt.pc
</span></span></span><span class="line"><span class="cl"><span class="go">/usr/lib/x86_64-linux-gnu/pkgconfig/xmlsec1-gnutls.pc
</span></span></span><span class="line"><span class="cl"><span class="go">/usr/lib/x86_64-linux-gnu/pkgconfig/xmlsec1-nss.pc
</span></span></span><span class="line"><span class="cl"><span class="go">/usr/lib/x86_64-linux-gnu/pkgconfig/xmlsec1-openssl.pc
</span></span></span><span class="line"><span class="cl"><span class="go">/usr/lib/x86_64-linux-gnu/pkgconfig/xmlsec1.pc
</span></span></span></code></pre></div><p>以下のようにして cflags を確認します。 <code>--libs</code> 引数には上記の <code>*.pc</code> ファイルのベース名を指定します。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> pkg-config --cflags --libs xmlsec1
</span></span><span class="line"><span class="cl"><span class="go">-D__XMLSEC_FUNCTION__=__func__ -DXMLSEC_NO_SIZE_T -DXMLSEC_NO_GOST=1 -DXMLSEC_NO_GOST2012=1 -DXMLSEC_NO_CRYPTO_DYNAMIC_LOADING=1 -DXMLSEC_CRYPTO_OPENSSL=1 -I/usr/include/xmlsec1 -I/usr/include/libxml2 -lxmlsec1-openssl -lxmlsec1 -lssl -lcrypto -lxslt -lxml2
</span></span></span></code></pre></div><p><code>-DXMLSEC_NO_SIZE_T</code> が含まれていますので <code>XMLSEC_NO_SIZE_T</code> は定義されています。</p>
<p>ということで <code>ffi.cdef</code> には以下のように書きます。ビルド時の設定によって変わることが後から確認できるように元の定義をコメントアウトして残すようにしてます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">ffi.cdef</span><span class="s">[[
</span></span></span><span class="line"><span class="cl"><span class="s">// #ifdef XMLSEC_NO_SIZE_T
</span></span></span><span class="line"><span class="cl"><span class="s">// #define xmlSecSize                              unsigned int
</span></span></span><span class="line"><span class="cl"><span class="s">// #else /* XMLSEC_NO_SIZE_T */
</span></span></span><span class="line"><span class="cl"><span class="s">// #define xmlSecSize                              size_t
</span></span></span><span class="line"><span class="cl"><span class="s">// #endif /* XMLSEC_NO_SIZE_T */
</span></span></span><span class="line"><span class="cl"><span class="s">typedef unsigned int                            xmlSecSize;
</span></span></span><span class="line"><span class="cl"><span class="s">]]</span>
</span></span></code></pre></div><p>pkgconfig の <code>*.pc</code> ファイル名の命名規則はパッケージによって違うので都度確認が必要です。例えば libxml2-dev の場合は以下のようになっていました。</p>
<pre tabindex="0"><code>$ dpkg -L libxml2-dev | grep pkgconfig/
/usr/lib/x86_64-linux-gnu/pkgconfig/libxml-2.0.pc
</code></pre><h4 id="deb-パッケージをビルドして生成された-configstatus-や-configh-を確認してみる">deb パッケージをビルドして生成された config.status や config.h を確認してみる</h4>
<p>例えば libxmlsec1 の <code>struct _xmlSecKeyInfoCtx</code> は以下のような定義になっていました。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">_xmlSecKeyInfoCtx</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// …略…
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#ifndef XMLSEC_NO_XMLENC
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cm">/* EncryptedKey */</span>
</span></span><span class="line"><span class="cl">    <span class="n">xmlSecEncCtxPtr</span>                     <span class="n">encCtx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span>                                 <span class="n">maxEncryptedKeyLevel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="cm">/* XMLSEC_NO_XMLENC */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// …略…
</span></span></span></code></pre></div><p>上記の <code>pkgconfig --cflags</code> の出力には <code>XMLSEC_NO_XMLENC</code> を定義する設定は無いので未定義かもしれませんが、別の箇所で定義されているかもしれません。</p>
<p>確認するために deb のソースパッケージを取得してビルドし、生成された config.status や config.h を確認してみました。</p>
<p>作業ディレクトリを作成してそこに <code>cd</code> します。その後以下のコマンドで libxmlsec1 の deb ソースパッケージを取得します。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="go">apt source libxmlsec1
</span></span></span></code></pre></div><p>以下のようにファイルが取得され、 xmlsec1-1.2.25/ ディレクトリに upstream の tarball xmlsec1_1.2.25.orig.tar.gz と debian/ のファイル群の xmlsec1_1.2.25-1build1.debian.tar.xz が展開されます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="go">~/libxmlsec1-work$ ls -F
</span></span></span><span class="line"><span class="cl"><span class="go">xmlsec1-1.2.25/                       xmlsec1_1.2.25-1build1.dsc
</span></span></span><span class="line"><span class="cl"><span class="go">xmlsec1_1.2.25-1build1.debian.tar.xz  xmlsec1_1.2.25.orig.tar.gz
</span></span></span></code></pre></div><p>xmlsec1-1.2.25 ディレクトリに移動し</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="go">~/libxmlsec1-work$ cd xmlsec1-1.2.25/
</span></span></span><span class="line"><span class="cl"><span class="go">~/libxmlsec1-work/xmlsec1-1.2.25$
</span></span></span></code></pre></div><p>以下のコマンドで libxmlsec1 パッケージのビルドに必要なパッケージをまとめてインストールするための deb パッケージを生成してインストールします。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo mk-build-deps -i
</span></span><span class="line"><span class="cl"><span class="go">…(略)…
</span></span></span><span class="line"><span class="cl"><span class="go">dpkg-deb: building package &#39;xmlsec1-build-deps&#39; in &#39;../xmlsec1-build-deps_1.2.25-1build1_all.deb&#39;.
</span></span></span><span class="line"><span class="cl"><span class="go">…(略)…
</span></span></span><span class="line"><span class="cl"><span class="go">Setting up xmlsec1-build-deps (1.2.25-1build1) ...
</span></span></span></code></pre></div><p>deb パッケージをビルドするときにソースディレクトリに余分なファイルがあるとエラーになるので親ディレクトリに移動しておきます</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> mv xmlsec1-build-deps_1.2.25-1build1_all.deb ..
</span></span></code></pre></div><p>以下のコマンドで deb パッケージをビルドします。 <code>man dpkg-buildpackage</code> を見ても configure のみ行うオプションが見当たらないのでバイナリパッケージをビルドするオプション <code>-b</code> を指定します。またパッケージを配布するわけはなく署名は不要なので <code>--no-sign</code> も指定しています。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> dpkg-buildpackage -b --no-sign
</span></span></code></pre></div><p>ビルドが終わったら（あるいは出力を見て configure が終わったところで Ctrl-C で止めてもいいかもしれません）、先程インストールした依存パッケージの deb をアンインストールしておきます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="go">sudo dpkg -e ../xmlsec1-build-deps_1.2.25-1build1_all.deb
</span></span></span></code></pre></div><p>以下のコマンドで configure で生成された config.h と config.status のパスを調べます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> find . -name config.h -or -name config.status
</span></span><span class="line"><span class="cl"><span class="go">./config.h
</span></span></span><span class="line"><span class="cl"><span class="go">./config.status
</span></span></span></code></pre></div><p>この中で <code>XMLSEC_NO_XMLENC</code> を検索してみると定義していないことが確認できました。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> grep XMLSEC_NO_XMLENC <span class="k">$(</span>find . -name config.h -or -name config.status<span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="go">./config.status:S[&#34;XMLSEC_NO_XMLENC&#34;]=&#34;0&#34;
</span></span></span><span class="line"><span class="cl"><span class="go">./config.status:S[&#34;XMLSEC_NO_XMLENC_FALSE&#34;]=&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="go">./config.status:S[&#34;XMLSEC_NO_XMLENC_TRUE&#34;]=&#34;#&#34;
</span></span></span></code></pre></div><p>ということで <code>ffi.cdef</code> では以下のように書きます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">ffi.cdef</span><span class="s">[[
</span></span></span><span class="line"><span class="cl"><span class="s">struct _xmlSecKeyInfoCtx {
</span></span></span><span class="line"><span class="cl"><span class="s">// …略…
</span></span></span><span class="line"><span class="cl"><span class="s">// #ifndef XMLSEC_NO_XMLENC
</span></span></span><span class="line"><span class="cl"><span class="s">    /* EncryptedKey */
</span></span></span><span class="line"><span class="cl"><span class="s">    xmlSecEncCtxPtr                     encCtx;
</span></span></span><span class="line"><span class="cl"><span class="s">    int                                 maxEncryptedKeyLevel;
</span></span></span><span class="line"><span class="cl"><span class="s">// #endif /* XMLSEC_NO_XMLENC */
</span></span></span><span class="line"><span class="cl"><span class="s">// …略…
</span></span></span><span class="line"><span class="cl"><span class="s">};
</span></span></span><span class="line"><span class="cl"><span class="s">]]</span>
</span></span></code></pre></div><p>この例では config.h と config.status を見ましたが、ソフトウェアによっては違うファイルにマクロ定義が生成される場合もありますので、適宜調べてください。</p>
<h3 id="c-言語で書かれたライブラリの構造体と-fficdef-に書いた構造体のサイズやフィールドのオフセットが一致するか確認">C 言語で書かれたライブラリの構造体と <code>ffi.cdef</code> に書いた構造体のサイズやフィールドのオフセットが一致するか確認</h3>
<p>上記の <code>pkg-config --cflags</code> で調べた例</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">ffi.cdef</span><span class="s">[[
</span></span></span><span class="line"><span class="cl"><span class="s">// #ifdef XMLSEC_NO_SIZE_T
</span></span></span><span class="line"><span class="cl"><span class="s">// #define xmlSecSize                              unsigned int
</span></span></span><span class="line"><span class="cl"><span class="s">// #else /* XMLSEC_NO_SIZE_T */
</span></span></span><span class="line"><span class="cl"><span class="s">// #define xmlSecSize                              size_t
</span></span></span><span class="line"><span class="cl"><span class="s">// #endif /* XMLSEC_NO_SIZE_T */
</span></span></span><span class="line"><span class="cl"><span class="s">typedef unsigned int                            xmlSecSize;
</span></span></span><span class="line"><span class="cl"><span class="s">]]</span><span class="p">]</span>
</span></span></code></pre></div><p>はさも最初からそうやって調べたように書いてますが、実際は分かってなくて逆の分岐の宣言を以下のように書いて開発していました。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">ffi.cdef</span><span class="s">[[
</span></span></span><span class="line"><span class="cl"><span class="s">typedef size_t xmlSecSize;
</span></span></span><span class="line"><span class="cl"><span class="s">]]</span><span class="p">]</span>
</span></span></code></pre></div><p>すると関数の実行自体は出来るのですが、挙動がおかしいことに気づきました。
具体的には実行結果として 0 か 1 が入るはずの構造体のフィールドを出力してい見ると全然違う値が表示されるという現象でした。</p>
<p>具体的には下記の <code>struct _xmlSecDSigCtx</code> の <code>status</code> フィールドです。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">_xmlSecDSigCtx</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* these data user can set before performing the operation */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span>                       <span class="n">userData</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span>                <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span>                <span class="n">flags2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">xmlSecKeyInfoCtx</span>            <span class="n">keyInfoReadCtx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">xmlSecKeyInfoCtx</span>            <span class="n">keyInfoWriteCtx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">xmlSecTransformCtx</span>          <span class="n">transformCtx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">xmlSecTransformUriType</span>      <span class="n">enabledReferenceUris</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">xmlSecPtrListPtr</span>            <span class="n">enabledReferenceTransforms</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">xmlSecTransformCtxPreExecuteCallback</span> <span class="n">referencePreExecuteCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">xmlSecTransformId</span>           <span class="n">defSignMethodId</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">xmlSecTransformId</span>           <span class="n">defC14NMethodId</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">xmlSecTransformId</span>           <span class="n">defDigestMethodId</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* these data are returned */</span>
</span></span><span class="line"><span class="cl">    <span class="n">xmlSecKeyPtr</span>                <span class="n">signKey</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">xmlSecTransformOperation</span>    <span class="n">operation</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">xmlSecBufferPtr</span>             <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">xmlSecDSigStatus</span>            <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//…(略)…
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>そこで Lua は <a href="https://luajit.org/ext_ffi_api.html#ffi_cdef">ffi.* API Functions</a> の <code>ffi.sizeof</code> と <code>ffi.offsetof</code> を使い、 C では <code>sizeof</code> と <code>offsetof</code> を使って構造体のサイズとフィールドのオフセットを表示して比較してみました。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span><span class="n">string.format</span><span class="p">(</span><span class="s2">&#34;sizeof(struct _xmlSecDSigCtx)=%d&#34;</span><span class="p">,</span> <span class="n">ffi.sizeof</span><span class="p">(</span><span class="s2">&#34;struct _xmlSecDSigCtx&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span><span class="n">string.format</span><span class="p">(</span><span class="s2">&#34;offsetof(struct _xmlSecDSigCtx, stattus)=%d&#34;</span><span class="p">,</span> <span class="n">ffi.offsetof</span><span class="p">(</span><span class="s2">&#34;struct _xmlSecDSigCtx&#34;</span><span class="p">,</span> <span class="s2">&#34;status&#34;</span><span class="p">))</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">printf</span><span class="p">(</span><span class="s">&#34;sizeof(struct _xmlSecDSigCtx)=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">_xmlSecDSigCtx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">printf</span><span class="p">(</span><span class="s">&#34;offsetof(struct _xmlSecDSigCtx, stattus)=%d&#34;</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">_xmlSecDSigCtx</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
</span></span></code></pre></div><p>これでずれていることが分かったら先頭と <code>status</code> の真ん中あたりのフィールドのオフセットを比較してという感じで繰り返し比較して原因の箇所を特定します。</p>
<p>その後上述の <code>pkg-config --cflags</code> の方法を思いついて確定したという感じです。</p>
<h2 id="lua-から-c-言語で書かれたライブラリの関数を呼び出す">Lua から C 言語で書かれたライブラリの関数を呼び出す</h2>
<h3 id="c-言語で書かれたライブラリと-lua-のコードで引数や戻り値の受け渡す際の型変換">C 言語で書かれたライブラリと Lua のコードで引数や戻り値の受け渡す際の型変換</h3>
<p><a href="https://luajit.org/ext_ffi_semantics.html#clang">C Type Conversion Rules</a> に C からの戻り値から Lua の変数に値を受け取る際の変換と、 Lua の値を C の関数の引数へ渡す際の変換の表がありますのでこれに沿って変換します。</p>
<p>多くの型はそのまま渡せます。気を付けるのは戻り値の受け取りで C の <code>char *</code> の文字列は <code>ffi.tostring</code> 関数で Lua の文字列に変換する必要がある点です。
C での整数は値が 52bit の範囲ならそのまま Lua の変数で受け取れます。
<a href="http://www.lua.org/manual/5.1/manual.html#2.2">2.2 – Values and Types</a> に書かれているように Lua の number 型は倍精度浮動小数点数ですので、 52bit の範囲を超える整数値は <code>tonumber</code> 関数で変換する必要があります。が精度が落ちて違う値になる場合があります。</p>
<p>LuaJIT で 64bit 整数を扱いたいというイシューが <a href="https://github.com/LuaJIT/LuaJIT/issues/182">64-bit Integer Hack · Issue #182 · LuaJIT/LuaJIT</a> にあるのですが却下されています。
Lua 側では扱わず <code>ffi.new</code> でメモリ領域を割り当てて C 側で扱う必要があるそうです（私自身は試してないです）。</p>
<p>あと引数に渡すほうは <code>const char *</code> の場合は Lua の文字列をそのまま渡せますが、 <code>const</code> なしの <code>char *</code> で C 側で変更するときは <a href="https://stackoverflow.com/a/33485288/1391518">https://stackoverflow.com/a/33485288/1391518</a> にあるように <code>ffi.new</code> でメモリ割り当てしてコピーして渡す必要があります。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">text</span> <span class="o">=</span> <span class="s2">&#34;text&#34;</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">c_str</span> <span class="o">=</span> <span class="n">ffi.new</span><span class="p">(</span><span class="s2">&#34;char[?]&#34;</span><span class="p">,</span> <span class="o">#</span><span class="n">text</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ffi.copy</span><span class="p">(</span><span class="n">c_str</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">lib.drawText</span><span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">,</span> <span class="n">c_str</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="c-言語の-int-の戻り値を-lua-の-if-文で-boolean-として扱う場合の注意">C 言語の int の戻り値を Lua の if 文で boolean として扱う場合の注意</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">xmlStrEqual</span>              <span class="p">(</span><span class="k">const</span> <span class="n">xmlChar</span> <span class="o">*</span><span class="n">str1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="k">const</span> <span class="n">xmlChar</span> <span class="o">*</span><span class="n">str2</span><span class="p">);</span>
</span></span></code></pre></div><p>という関数があって</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="nf">xmlStrEqual</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="cm">/* …(略)… */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>のように利用しているコードを</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kr">if</span> <span class="n">xmlsec1.xmlStrEqual</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">)</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">   <span class="c1">--  …(略)…</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span></code></pre></div><p>のように書き換えて常に <code>if</code> 文の中身が実行されてハマりました。</p>
<p>理由は Lua の <code>if</code>, <code>while</code>, <code>repeat ... until</code> の条件式では <code>false</code> と <code>nil</code> が <code>false</code> 扱いになり、それ以外の値は全て <code>true</code> 扱いになるからです（  <a href="http://www.lua.org/manual/5.1/manual.html#2.4.4">2.4.4 – Control Structures</a> 参照）。</p>
<p>上記の <code>xmlStrEqual</code> 関数は一致の場合は 1 、不一致の場合は 0 を返すので、正しくは</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kr">if</span> <span class="n">xmlsec1.xmlStrEqual</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">   <span class="c1">--  …(略)…</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span></code></pre></div><p>か</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kr">if</span> <span class="n">xmlsec1.xmlStrEqual</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">)</span> <span class="o">~=</span> <span class="mi">0</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">   <span class="c1">--  …(略)…</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span></code></pre></div><p>と書く必要があります。
Lua の <code>~=</code> は C でいう <code>!=</code> です（ <a href="http://www.lua.org/manual/5.1/manual.html#2.5.2">2.5.2 – Relational Operators</a> 参照）。</p>
<p><code>同様に C の </code>!xmlStrEqual(str1, str2)<code>は Lua では</code>not xmlsec1.xmlStrEqual(str1, str2)<code>ではなく</code>xmlsec1.xmlStrEqual(str1, str2) ~= 1<code>または</code>xmlsec1.xmlStrEqual(str1, str2) == 0` と書く必要があります。
定数を定義するかラップした関数を定義したほうが良いかもしれません。</p>
<h3 id="エラーの返し方とエラー処理">エラーの返し方とエラー処理</h3>
<p>Lua にはエラー関連の関数として <a href="http://www.lua.org/manual/5.1/manual.html#pdf-error">error</a>, <a href="http://www.lua.org/manual/5.1/manual.html#pdf-pcall">pcall</a>, <a href="http://www.lua.org/manual/5.1/manual.html#pdf-xpcall">xpcall</a> が用意されています。
大雑把に言うと Go 言語の panic と recover に近いです。</p>
<p>ですが、これを使わない道もあります。
Lua の関数は複数の値を返せるので 2 つめ以降に err の値を返すという方式です。</p>
<p>例えば <a href="https://github.com/openresty/lua-nginx-module">lua-nginx-module</a> の
<a href="https://github.com/openresty/lua-nginx-module#ngxreqget_uri_args">ngx.req.get_uri_args</a> のシグネチャは <code>args, err = ngx.req.get_uri_args(max_args?)</code> となっています。</p>
<p><code>err</code> はエラーなしの時は <code>nil</code> を返し、 エラーありの場合はエラーメッセージの文字列を返すのが定番の方法です。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">args</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">ngx.req</span><span class="p">.</span><span class="n">get_uri_args</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kr">if</span> <span class="n">err</span> <span class="o">~=</span> <span class="kc">nil</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">   <span class="c1">-- エラー処理</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span></code></pre></div><p>Go に近い感覚で書けますし、実行時の処理としても軽いと思いますので LuaJIT FFI で関数を書くときはこちらの方式が良いです。</p>
<h3 id="エラーで抜ける際の後処理をすっきり書く方法">エラーで抜ける際の後処理をすっきり書く方法</h3>
<p>関数内で複数の変数を初期化して最後で後処理するような場合、 C だと後処理の箇所にラベルを付けてエラーのときは goto で飛ぶのが良くあります。また Go では defer を使って後処理する方法があります。</p>
<p>Lua には goto も defer も無いのですが関数クロージャーは使えますので、無名関数の即時呼び出しを使って以下のようにすれば、すっきり書けます。</p>
<p>以下の例では <code>initA</code> は失敗の場合は戻り値が <code>nil</code> になり、 <code>initB</code> は第 2 引数で err を返すという想定です。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kr">function</span> <span class="nf">foo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="kd">local</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">    <span class="kd">local</span> <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="kr">function</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span> <span class="o">=</span> <span class="n">initA</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="kr">if</span> <span class="n">a</span> <span class="o">==</span> <span class="kc">nil</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">            <span class="kr">return</span> <span class="s2">&#34;failed to initialize A&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="kr">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">b</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">initB</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="kr">if</span> <span class="n">err</span> <span class="o">~=</span> <span class="kc">nil</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">            <span class="kr">return</span> <span class="n">string.format</span><span class="p">(</span><span class="s2">&#34;failed to initialize B: %s&#34;</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="kr">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">-- a と b を使った処理</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kr">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="kr">end</span><span class="p">)()</span>
</span></span><span class="line"><span class="cl">    <span class="kr">if</span> <span class="n">b</span> <span class="o">~=</span> <span class="kc">nil</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">        <span class="n">destroyB</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kr">end</span>
</span></span><span class="line"><span class="cl">    <span class="kr">if</span> <span class="n">a</span> <span class="o">~=</span> <span class="kc">nil</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">        <span class="n">destroyA</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kr">end</span>
</span></span><span class="line"><span class="cl">    <span class="kr">return</span> <span class="n">err</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span></code></pre></div><p>インデントが一段深くなるのが唯一の欠点ですが、それ以外は満足できると思います。</p>
<h2 id="おわりに">おわりに</h2>
<p><a href="https://github.com/openresty/lua-nginx-module#ngxreqget_uri_args">openresty/lua-nginx-module</a> と LuaJIT FFI の組み合わせは nginx をフロントに立てているときに、ちょっとした処理を高速に処理して低レイテンシーを実現したいときには魅力的な選択肢だと考えています。</p>
<p>リバースプロキシーで他のプロセスと通信する方式に比べて、 nginx のワーカープロセス内で処理を実行できるので通信が不要という利点は大きいと私は思います。</p>
<p>一方で LuaJIT の懸念材料としては LuaJIT の元々の作者である Mike Pall さんが別の仕事で忙しくて LuaJIT のメインの開発からは外れているという点があります （<a href="https://www.reddit.com/r/programming/comments/3gin5e/luajits_main_developer_is_retiring_and_is_looking/">LuaJIT&rsquo;s main developer is retiring and is looking for new developers : programming</a>, <a href="https://github.com/LuaJIT/LuaJIT/issues/45">Clone Mike Pall · Issue #45 · LuaJIT/LuaJIT</a> 参照）。
<a href="https://github.com/openresty/luajit2">openresty/luajit2: OpenResty&rsquo;s Branch of LuaJIT 2</a> などいくつかフォークもありますが、今後どうなっていくかはなんとも言えません。</p>
<p>ということで 2020-03-05 に出た <a href="https://istio.io/blog/2020/wasm-announce/">Istio / Redefining extensibility in proxies - introducing WebAssembly to Envoy and Istio</a> という記事が気になっていて今後調査していきたいと思っています。</p>

</div>


<script src="https://hnakamur.github.io/blog/js/copy-button.js"></script>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-KMMXGG2Z56', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  </body>
</html>
