<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja-jp" lang="ja-jp">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.101.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>carbon-relay-ngのAggregationについてのコードリーディング &middot; hnakamur&#39;s blog</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/copy-button.css">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://hnakamur.github.io/blog/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://hnakamur.github.io/blog/favicon.png">

  
  


<script async src="https://www.googletagmanager.com/gtag/js?id=G-KMMXGG2Z56"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-KMMXGG2Z56');
</script>



</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://hnakamur.github.io/blog/"><h1>hnakamur&#39;s blog</h1></a>
      <p class="lead">
       my tech memo 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://hnakamur.github.io/blog/"> blog home </a></li><li><a href="https://github.com/hnakamur"> github @hnakamur </a></li><li><a href="https://twitter.com/hnakamur2"> twitter @hnakamur2 </a></li>
      </ul>
    </nav>

    <p>powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://pages.github.com/">GitHub Pages</a></p>
    <p>&copy; 2022. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>carbon-relay-ngのAggregationについてのコードリーディング</h1>
  <time datetime=2020-06-16T21:49:01&#43;0900 class="post-date">2020-06-16</time>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#はじめに">はじめに</a></li>
    <li><a href="#sum-構造体の定義">Sum 構造体の定義</a></li>
    <li><a href="#processor-インターフェース">Processor インターフェース</a></li>
    <li><a href="#processor-インターフェースの-add-メソッドの呼び出し箇所">Processor インターフェースの Add メソッドの呼び出し箇所</a></li>
    <li><a href="#processor-インターフェースの-flush-メソッドの呼び出し箇所">Processor インターフェースの Flush メソッドの呼び出し箇所</a></li>
    <li><a href="#aggregator-構造体">Aggregator 構造体</a></li>
    <li><a href="#横道-aggregator-の-matchwithcache-メソッド">横道: Aggregator の matchWithCache メソッド</a></li>
    <li><a href="#aggregator-の-addorcreate-メソッドを見返す">Aggregator の AddOrCreate メソッドを見返す</a></li>
    <li><a href="#aggregator-の-run-の呼び出し箇所">Aggregator の run の呼び出し箇所</a></li>
    <li><a href="#2020-06-17-追記-recache-フィールドで排他制御が必要な理由が判明">2020-06-17 追記 <code>reCache</code> フィールドで排他制御が必要な理由が判明</a></li>
  </ul>
</nav>
  <h2 id="はじめに">はじめに</h2>
<p><a href="https://github.com/grafana/carbon-relay-ng/">grafana/carbon-relay-ng: Fast carbon relay+aggregator with admin interfaces for making changes online - production ready</a> の <a href="https://github.com/grafana/carbon-relay-ng/blob/2dc70e909221a0408ca0505759f9e8f290c1d6f9/aggregator/aggregator.go">aggregator/aggregator.go</a> と <a href="https://github.com/grafana/carbon-relay-ng/blob/2dc70e909221a0408ca0505759f9e8f290c1d6f9/aggregator/processor.go">aggregator/processor.go</a> あたりのコードを読んだメモです。</p>
<p>今回の焦点は <code>Sum</code> の実装とその使われ方です。</p>
<h2 id="sum-構造体の定義">Sum 構造体の定義</h2>
<p><a href="https://github.com/grafana/carbon-relay-ng/blob/2dc70e909221a0408ca0505759f9e8f290c1d6f9/aggregator/processor.go#L282-L301">aggregator/processor.go#L282-L301</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Sum aggregates to sum
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Sum</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">sum</span> <span class="kt">float64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewSum</span><span class="p">(</span><span class="nx">val</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">ts</span> <span class="kt">uint32</span><span class="p">)</span> <span class="nx">Processor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Sum</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sum</span><span class="p">:</span> <span class="nx">val</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Sum</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">val</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">ts</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">s</span><span class="p">.</span><span class="nx">sum</span> <span class="o">+=</span> <span class="nx">val</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Sum</span><span class="p">)</span> <span class="nf">Flush</span><span class="p">()</span> <span class="p">([]</span><span class="nx">processorResult</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">[]</span><span class="nx">processorResult</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span><span class="nx">fcnName</span><span class="p">:</span> <span class="s">&#34;sum&#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">:</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sum</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="processor-インターフェース">Processor インターフェース</h2>
<p><a href="https://github.com/grafana/carbon-relay-ng/blob/2dc70e909221a0408ca0505759f9e8f290c1d6f9/aggregator/processor.go#L303-L310">aggregator/processor.go#L303-L310</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Processor</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Add adds a point to aggregate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">Add</span><span class="p">(</span><span class="nx">val</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">ts</span> <span class="kt">uint32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Flush returns the aggregated value(s) and true if it is valid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the only reason why it would be non-valid is for aggregators that need
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// more than 1 value but they didn&#39;t have enough to produce a useful result.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">Flush</span><span class="p">()</span> <span class="p">([]</span><span class="nx">processorResult</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="processor-インターフェースの-add-メソッドの呼び出し箇所">Processor インターフェースの Add メソッドの呼び出し箇所</h2>
<p><a href="https://github.com/grafana/carbon-relay-ng/blob/2dc70e909221a0408ca0505759f9e8f290c1d6f9/aggregator/aggregator.go#L126-L166">aggregator/aggregator.go#L126-L166</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">Aggregator</span><span class="p">)</span> <span class="nf">AddOrCreate</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ts</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">quantized</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">rangeTracker</span><span class="p">.</span><span class="nf">Sample</span><span class="p">(</span><span class="nx">ts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nx">agg</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">aggregations</span><span class="p">[</span><span class="nx">quantized</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">proc</span> <span class="nx">Processor</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">proc</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">agg</span><span class="p">.</span><span class="nx">state</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// if both levels already exist, we only need to add the value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">agg</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">      <span class="nx">proc</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">ts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// first level doesn&#39;t exist. create it and add the ts to the list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// (second level will be created below)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">a</span><span class="p">.</span><span class="nx">tsList</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">tsList</span><span class="p">,</span> <span class="nx">quantized</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">tsList</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">tsList</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">tsList</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">quantized</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">sort</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="nf">TsSlice</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">tsList</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">agg</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">aggregation</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">state</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Processor</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">a</span><span class="p">.</span><span class="nx">aggregations</span><span class="p">[</span><span class="nx">quantized</span><span class="p">]</span> <span class="p">=</span> <span class="nx">agg</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// first level exists but we need to create the 2nd level.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// note, we only flush where for a given value of now, quantized &lt; now-wait
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// this means that as long as the clock doesn&#39;t go back in time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// we never recreate a previously created bucket (and reflush with same key and ts)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// a consequence of this is, that if your data stream runs consistently significantly behind
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// real time, it may never be included in aggregates, but it&#39;s up to you to configure your wait
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// parameter properly. You can use the rangeTracker and numTooOld metrics to help with this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="nx">quantized</span> <span class="p">&gt;</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nf">now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span><span class="o">-</span><span class="nx">a</span><span class="p">.</span><span class="nx">Wait</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">agg</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="nx">proc</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">procConstr</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">ts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">agg</span><span class="p">.</span><span class="nx">state</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">proc</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">numTooOld</span><span class="p">.</span><span class="nf">Inc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>Aggregator</code> の <code>AddOrCreate</code> は <code>run</code> メソッドから呼ばれています。</p>
<p><a href="https://github.com/grafana/carbon-relay-ng/blob/2dc70e909221a0408ca0505759f9e8f290c1d6f9/aggregator/aggregator.go#L281-L351">aggregator/aggregator.go#L281-L351</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">Aggregator</span><span class="p">)</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">a</span><span class="p">.</span><span class="nx">in</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// note, we rely here on the fact that the packet has already been validated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">outKey</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">matchWithCache</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">continue</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nx">a</span><span class="p">.</span><span class="nx">numIn</span><span class="p">.</span><span class="nf">Inc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nx">ts</span> <span class="o">:=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">ts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nx">quantized</span> <span class="o">:=</span> <span class="nx">ts</span> <span class="o">-</span> <span class="p">(</span><span class="nx">ts</span> <span class="o">%</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Interval</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nx">a</span><span class="p">.</span><span class="nf">AddOrCreate</span><span class="p">(</span><span class="nx">outKey</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">ts</span><span class="p">,</span> <span class="nx">quantized</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">now</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">a</span><span class="p">.</span><span class="nx">tick</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="nx">thresh</span> <span class="o">:=</span> <span class="nx">now</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Wait</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nx">a</span><span class="p">.</span><span class="nf">Flush</span><span class="p">(</span><span class="nb">uint</span><span class="p">(</span><span class="nx">thresh</span><span class="p">.</span><span class="nf">Unix</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// if cache is enabled, clean it out of stale entries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// it&#39;s not ideal to block our channel while flushing AND cleaning up the cache
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// ideally, these operations are interleaved in time, but we can optimize that later
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// this is a simple heuristic but should make the cache always converge on only active data (without memory leaks)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// even though some cruft may temporarily linger a bit longer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// WARNING: this relies on Go&#39;s map implementation detail which randomizes iteration order, in order for us to reach
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// the entire keyspace. This may stop working properly with future go releases.  Will need to come up with smth better.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">reCache</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">cutoff</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">now</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Wait</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">).</span><span class="nf">Unix</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="nx">a</span><span class="p">.</span><span class="nx">reCacheMutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span><span class="p">.</span><span class="nx">reCache</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">seen</span> <span class="p">&lt;</span> <span class="nx">cutoff</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">delete</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">reCache</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span> <span class="c1">// stop looking when we don&#39;t see old entries. we&#39;ll look again soon enough.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">a</span><span class="p">.</span><span class="nx">reCacheMutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">a</span><span class="p">.</span><span class="nx">snapReq</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="nx">aggsCopy</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">uint</span><span class="p">]</span><span class="o">*</span><span class="nx">aggregation</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="nx">quant</span><span class="p">,</span> <span class="nx">aggReal</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span><span class="p">.</span><span class="nx">aggregations</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">stateCopy</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Processor</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">aggReal</span><span class="p">.</span><span class="nx">state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">stateCopy</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">aggsCopy</span><span class="p">[</span><span class="nx">quant</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">aggregation</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">state</span><span class="p">:</span> <span class="nx">stateCopy</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">count</span><span class="p">:</span> <span class="nx">aggReal</span><span class="p">.</span><span class="nx">count</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Aggregator</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Fun</span><span class="p">:</span>          <span class="nx">a</span><span class="p">.</span><span class="nx">Fun</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">procConstr</span><span class="p">:</span>   <span class="nx">a</span><span class="p">.</span><span class="nx">procConstr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Matcher</span><span class="p">:</span>      <span class="nx">a</span><span class="p">.</span><span class="nx">Matcher</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">OutFmt</span><span class="p">:</span>       <span class="nx">a</span><span class="p">.</span><span class="nx">OutFmt</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Cache</span><span class="p">:</span>        <span class="nx">a</span><span class="p">.</span><span class="nx">Cache</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Interval</span><span class="p">:</span>     <span class="nx">a</span><span class="p">.</span><span class="nx">Interval</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Wait</span><span class="p">:</span>         <span class="nx">a</span><span class="p">.</span><span class="nx">Wait</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">DropRaw</span><span class="p">:</span>      <span class="nx">a</span><span class="p">.</span><span class="nx">DropRaw</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">aggregations</span><span class="p">:</span> <span class="nx">aggsCopy</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">now</span><span class="p">:</span>          <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Key</span><span class="p">:</span>          <span class="nx">a</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nx">a</span><span class="p">.</span><span class="nx">snapResp</span> <span class="o">&lt;-</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">a</span><span class="p">.</span><span class="nx">shutdown</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="nx">thresh</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Wait</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nx">a</span><span class="p">.</span><span class="nf">Flush</span><span class="p">(</span><span class="nb">uint</span><span class="p">(</span><span class="nx">thresh</span><span class="p">.</span><span class="nf">Unix</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">      <span class="nx">a</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="processor-インターフェースの-flush-メソッドの呼び出し箇所">Processor インターフェースの Flush メソッドの呼び出し箇所</h2>
<p><a href="https://github.com/grafana/carbon-relay-ng/blob/2dc70e909221a0408ca0505759f9e8f290c1d6f9/aggregator/aggregator.go#L168-L218">aggregator/aggregator.go#L168-L218</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Flush finalizes and removes aggregations that are due
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">Aggregator</span><span class="p">)</span> <span class="nf">Flush</span><span class="p">(</span><span class="nx">cutoff</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">flushWaiting</span><span class="p">.</span><span class="nf">Inc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nx">flushes</span><span class="p">.</span><span class="nf">Add</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="nx">flushWaiting</span><span class="p">.</span><span class="nf">Dec</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">defer</span> <span class="nx">flushes</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">pos</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// will track the pos of the last ts position that was successfully processed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ts</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span><span class="p">.</span><span class="nx">tsList</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">ts</span> <span class="p">&gt;</span> <span class="nx">cutoff</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">agg</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">aggregations</span><span class="p">[</span><span class="nx">ts</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">proc</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">agg</span><span class="p">.</span><span class="nx">state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">results</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">proc</span><span class="p">.</span><span class="nf">Flush</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">a</span><span class="p">.</span><span class="nx">out</span> <span class="o">&lt;-</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s %f %d&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">results</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">val</span><span class="p">,</span> <span class="nx">ts</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">          <span class="nx">a</span><span class="p">.</span><span class="nx">numFlushed</span><span class="p">.</span><span class="nf">Inc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">result</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">results</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">a</span><span class="p">.</span><span class="nx">out</span> <span class="o">&lt;-</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s.%s %f %d&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">result</span><span class="p">.</span><span class="nx">fcnName</span><span class="p">,</span> <span class="nx">result</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">ts</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="nx">a</span><span class="p">.</span><span class="nx">numFlushed</span><span class="p">.</span><span class="nf">Inc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">aggregatorReporter</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">aggregatorReporter</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">ts</span><span class="p">),</span> <span class="nx">agg</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nb">delete</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">aggregations</span><span class="p">,</span> <span class="nx">ts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pos</span> <span class="p">=</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// now we must delete all the timestamps from the ordered list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="nx">pos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// we didn&#39;t process anything, so no action needed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">tsList</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// we went through all of them. can just reset the slice
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">a</span><span class="p">.</span><span class="nx">tsList</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">tsList</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// adjust the slice to only contain the timestamps that still need processing,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// reusing the backing array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nb">copy</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">tsList</span><span class="p">[</span><span class="mi">0</span><span class="p">:],</span> <span class="nx">a</span><span class="p">.</span><span class="nx">tsList</span><span class="p">[</span><span class="nx">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="p">.</span><span class="nx">tsList</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">tsList</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">tsList</span><span class="p">)</span><span class="o">-</span><span class="nx">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//fmt.Println(&#34;flush done for &#34;, a.now().Unix(), &#34;. agg size now&#34;, len(a.aggregations), a.now())
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p><code>Aggregator</code> の <code>Flush</code> メソッドは <code>run</code> メソッド内の 2 箇所から呼ばれています。</p>
<h2 id="aggregator-構造体">Aggregator 構造体</h2>
<p><a href="https://github.com/grafana/carbon-relay-ng/blob/2dc70e909221a0408ca0505759f9e8f290c1d6f9/aggregator/aggregator.go#L16-L53">aggregator/aggregator.go#L16-L53</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Aggregator</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Fun</span>          <span class="kt">string</span> <span class="s">`json:&#34;fun&#34;`</span>
</span></span><span class="line"><span class="cl">  <span class="nx">procConstr</span>   <span class="kd">func</span><span class="p">(</span><span class="nx">val</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">ts</span> <span class="kt">uint32</span><span class="p">)</span> <span class="nx">Processor</span>
</span></span><span class="line"><span class="cl">  <span class="nx">in</span>           <span class="kd">chan</span> <span class="nx">msg</span>    <span class="s">`json:&#34;-&#34;`</span> <span class="c1">// incoming metrics, already split in 3 fields
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">out</span>          <span class="kd">chan</span> <span class="p">[]</span><span class="kt">byte</span> <span class="c1">// outgoing metrics
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">Matcher</span>      <span class="nx">matcher</span><span class="p">.</span><span class="nx">Matcher</span>
</span></span><span class="line"><span class="cl">  <span class="nx">OutFmt</span>       <span class="kt">string</span>
</span></span><span class="line"><span class="cl">  <span class="nx">outFmt</span>       <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Cache</span>        <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">  <span class="nx">reCache</span>      <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">CacheEntry</span>
</span></span><span class="line"><span class="cl">  <span class="nx">reCacheMutex</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Interval</span>     <span class="kt">uint</span>                  <span class="c1">// expected interval between values in seconds, we will quantize to make sure alginment to interval-spaced timestamps
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">Wait</span>         <span class="kt">uint</span>                  <span class="c1">// seconds to wait after quantized time value before flushing final outcome and ignoring future values that are sent too late.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">DropRaw</span>      <span class="kt">bool</span>                  <span class="c1">// drop raw values &#34;consumed&#34; by this aggregator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">tsList</span>       <span class="p">[]</span><span class="kt">uint</span>                <span class="c1">// ordered list of quantized timestamps, so we can flush in correct order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">aggregations</span> <span class="kd">map</span><span class="p">[</span><span class="kt">uint</span><span class="p">]</span><span class="o">*</span><span class="nx">aggregation</span> <span class="c1">// aggregations in process: one for each quantized timestamp and output key, i.e. for each output metric.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">snapReq</span>      <span class="kd">chan</span> <span class="kt">bool</span>             <span class="c1">// chan to issue snapshot requests on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">snapResp</span>     <span class="kd">chan</span> <span class="o">*</span><span class="nx">Aggregator</span>      <span class="c1">// chan on which snapshot response gets sent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">shutdown</span>     <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>         <span class="c1">// chan used internally to shut down
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">wg</span>           <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>        <span class="c1">// tracks worker running state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">now</span>          <span class="kd">func</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>      <span class="c1">// returns current time. wraps time.Now except in some unit tests
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">tick</span>         <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>      <span class="c1">// controls when to flush
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="nx">Key</span>        <span class="kt">string</span>
</span></span><span class="line"><span class="cl">  <span class="nx">numIn</span>      <span class="nx">metrics</span><span class="p">.</span><span class="nx">Counter</span>
</span></span><span class="line"><span class="cl">  <span class="nx">numFlushed</span> <span class="nx">metrics</span><span class="p">.</span><span class="nx">Counter</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">aggregation</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">count</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">  <span class="nx">state</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Processor</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">msg</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">buf</span> <span class="p">[][]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">  <span class="nx">val</span> <span class="kt">float64</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ts</span>  <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="横道-aggregator-の-matchwithcache-メソッド">横道: Aggregator の matchWithCache メソッド</h2>
<p><code>Aggregator</code> の <code>run</code> メソッドで呼ばれている <code>matchWithCache</code> メソッドも見てみます。</p>
<p><a href="https://github.com/grafana/carbon-relay-ng/blob/2dc70e909221a0408ca0505759f9e8f290c1d6f9/aggregator/aggregator.go#L252-L279">aggregator/aggregator.go#L252-L279</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// matchWithCache returns whether there was a match, and under which key, if so.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">Aggregator</span><span class="p">)</span> <span class="nf">matchWithCache</span><span class="p">(</span><span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">reCache</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Matcher</span><span class="p">.</span><span class="nf">MatchRegexAndExpand</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">outFmt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="p">.</span><span class="nx">reCacheMutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">outKey</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">ok</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">  <span class="nx">entry</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">reCache</span><span class="p">[</span><span class="nb">string</span><span class="p">(</span><span class="nx">key</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">entry</span><span class="p">.</span><span class="nx">seen</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nf">now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="nx">a</span><span class="p">.</span><span class="nx">reCache</span><span class="p">[</span><span class="nb">string</span><span class="p">(</span><span class="nx">key</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">entry</span>
</span></span><span class="line"><span class="cl">    <span class="nx">a</span><span class="p">.</span><span class="nx">reCacheMutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">match</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">outKey</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Matcher</span><span class="p">.</span><span class="nf">MatchRegexAndExpand</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">outFmt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="p">.</span><span class="nx">reCache</span><span class="p">[</span><span class="nb">string</span><span class="p">(</span><span class="nx">key</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">CacheEntry</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ok</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">outKey</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nb">uint32</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nf">now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="p">.</span><span class="nx">reCacheMutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">outKey</span><span class="p">,</span> <span class="nx">ok</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>ここでは <code>reCache</code> フィールドへのアクセスを <code>reCacheMutex</code> で排他制御しています。
<code>reCache</code> は正規表現 (Regular Expression) のキャッシュです。</p>
<h2 id="aggregator-の-addorcreate-メソッドを見返す">Aggregator の AddOrCreate メソッドを見返す</h2>
<p>一方、 <code>AddOrCreate</code> メソッドを見返すと <code>aggregations</code> フィールドへのアクセスは排他制御していません。これは data race にならないのでしょうか、気になるところです。</p>
<p>Aggregator の 1 インスタンスの run メソッドが 1 つの goroutine からのみ呼ばれるのであれば大丈夫そうな気もします。
でもそれなら <code>reCacheMutex</code> も不要なのではないかという話もあります。</p>
<h2 id="aggregator-の-run-の呼び出し箇所">Aggregator の run の呼び出し箇所</h2>
<p><code>Aggregator</code> の <code>NewMocked</code> メソッドから呼ばれています。
<code>NewMocked</code> は <code>New</code> メソッドと <code>aggregator_test.go</code> 内のテストコードから呼ばれています。
現在時刻を <code>time.Now()</code> で取得するのではなく、チャンネルで受け渡すことによってテストの際に実時間と異なる時間を指定して動かすためにこのようになっています。</p>
<p><a href="https://github.com/grafana/carbon-relay-ng/blob/2dc70e909221a0408ca0505759f9e8f290c1d6f9/aggregator/aggregator.go#L55-L95">aggregator/aggregator.go#L55-L95</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// New creates an aggregator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">fun</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">matcher</span> <span class="nx">matcher</span><span class="p">.</span><span class="nx">Matcher</span><span class="p">,</span> <span class="nx">outFmt</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">cache</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">interval</span><span class="p">,</span> <span class="nx">wait</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">dropRaw</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">out</span> <span class="kd">chan</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Aggregator</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">clock</span><span class="p">.</span><span class="nf">AlignedTick</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">interval</span><span class="p">)</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">wait</span><span class="p">)</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">NewMocked</span><span class="p">(</span><span class="nx">fun</span><span class="p">,</span> <span class="nx">matcher</span><span class="p">,</span> <span class="nx">outFmt</span><span class="p">,</span> <span class="nx">cache</span><span class="p">,</span> <span class="nx">interval</span><span class="p">,</span> <span class="nx">wait</span><span class="p">,</span> <span class="nx">dropRaw</span><span class="p">,</span> <span class="nx">out</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">,</span> <span class="nx">ticker</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewMocked</span><span class="p">(</span><span class="nx">fun</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">matcher</span> <span class="nx">matcher</span><span class="p">.</span><span class="nx">Matcher</span><span class="p">,</span> <span class="nx">outFmt</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">cache</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">interval</span><span class="p">,</span> <span class="nx">wait</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">dropRaw</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">out</span> <span class="kd">chan</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">inBuf</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">now</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">tick</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Aggregator</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">procConstr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">GetProcessorConstructor</span><span class="p">(</span><span class="nx">fun</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">a</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Aggregator</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Fun</span><span class="p">:</span>          <span class="nx">fun</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">procConstr</span><span class="p">:</span>   <span class="nx">procConstr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">in</span><span class="p">:</span>           <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">inBuf</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">out</span><span class="p">:</span>          <span class="nx">out</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Matcher</span><span class="p">:</span>      <span class="nx">matcher</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">OutFmt</span><span class="p">:</span>       <span class="nx">outFmt</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">outFmt</span><span class="p">:</span>       <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">outFmt</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Cache</span><span class="p">:</span>        <span class="nx">cache</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Interval</span><span class="p">:</span>     <span class="nx">interval</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Wait</span><span class="p">:</span>         <span class="nx">wait</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">DropRaw</span><span class="p">:</span>      <span class="nx">dropRaw</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">aggregations</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">uint</span><span class="p">]</span><span class="o">*</span><span class="nx">aggregation</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">snapReq</span><span class="p">:</span>      <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">snapResp</span><span class="p">:</span>     <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">Aggregator</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">shutdown</span><span class="p">:</span>     <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">now</span><span class="p">:</span>          <span class="nx">now</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tick</span><span class="p">:</span>         <span class="nx">tick</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">cache</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">a</span><span class="p">.</span><span class="nx">reCache</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">CacheEntry</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="p">.</span><span class="nf">setKey</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="p">.</span><span class="nx">numIn</span> <span class="p">=</span> <span class="nx">stats</span><span class="p">.</span><span class="nf">Counter</span><span class="p">(</span><span class="s">&#34;unit=Metric.direction=in.aggregator=&#34;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="p">.</span><span class="nx">numFlushed</span> <span class="p">=</span> <span class="nx">stats</span><span class="p">.</span><span class="nf">Counter</span><span class="p">(</span><span class="s">&#34;unit=Metric.direction=out.aggregator=&#34;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">go</span> <span class="nx">a</span><span class="p">.</span><span class="nf">run</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">a</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>でこれを見ると <code>Aggregator</code> のインスタンスごとに 1 つの goroutine で <code>run</code> メソッドを実行しています。</p>
<p>一方で正規表現のキャッシュですが、キャッシュを使う設定の時は <code>cache</code> が <code>true</code> になっていて <code>reCache</code> フィールドには上記で <code>make</code> で Aggregator の 1 インスタンスごとに個別の <code>map</code> を作っています。
<code>reCache</code> を参照しているのは <code>matchWithCache</code> と <code>run</code> メソッドだけですので <code>reCacheMutex</code> は不要そうな気がします。</p>
<p><code>git log --follow -p aggregator/aggregator.go</code> でログを見てみると
<a href="https://github.com/grafana/carbon-relay-ng/commit/3939706acdd577ad905b4f04cbf226ca16e417ff">fix race condition in aggregator match cache · grafana/carbon-relay-ng@3939706</a> で <code>reCacheMutex</code> が追加されています。
このときは <code>*sync.Mutex</code> とポインターでしたが
<a href="https://github.com/grafana/carbon-relay-ng/commit/51a241e466aeffbef86172eaa95b6c91fd8b001e">cleanup &amp; simplify · grafana/carbon-relay-ng@51a241e</a>
で <code>sync.Mutex</code> とポインターなしの型に変更されています。</p>
<p>この 2 つのコミットは <a href="https://github.com/grafana/carbon-relay-ng/pull/273">Cache mutex2 by Dieterbe · Pull Request #273 · grafana/carbon-relay-ng</a> のプルリクエストに含まれています。
これともとになった <a href="https://github.com/grafana/carbon-relay-ng/pull/271">fix race condition in aggregator match cache by DanCech · Pull Request #271 · grafana/carbon-relay-ng</a> も見てみましたが、全く説明がなく、関連するイシューも無いので背景は不明でした。</p>
<p>うーん、なぜ <code>reCache</code> フィールドは排他制御が必要で <code>aggregations</code> フィールドは不要なのか、謎です。</p>
<h2 id="2020-06-17-追記-recache-フィールドで排他制御が必要な理由が判明">2020-06-17 追記 <code>reCache</code> フィールドで排他制御が必要な理由が判明</h2>
<p><code>Aggregator</code> の <code>matchWithCache</code> メソッドは <code>run</code> メソッド以外に <code>AddMaybe</code> メソッドでも呼ばれていました。</p>
<p><a href="https://github.com/grafana/carbon-relay-ng/blob/2dc70e909221a0408ca0505759f9e8f290c1d6f9/aggregator/aggregator.go#L225-L244">aggregator/aggregator.go#L225-L244</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">Aggregator</span><span class="p">)</span> <span class="nf">AddMaybe</span><span class="p">(</span><span class="nx">buf</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">ts</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">!</span><span class="nx">a</span><span class="p">.</span><span class="nx">Matcher</span><span class="p">.</span><span class="nf">PreMatch</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">DropRaw</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">matchWithCache</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="p">.</span><span class="nx">in</span> <span class="o">&lt;-</span> <span class="nx">msg</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">buf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">val</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ts</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nx">DropRaw</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>そして <code>AddMaybe</code> メソッドは <code>Table</code> の <code>dispatch</code> メソッドから呼ばれていました。</p>
<p><a href="https://github.com/grafana/carbon-relay-ng/blob/2dc70e909221a0408ca0505759f9e8f290c1d6f9/table/table.go#L109-L177">table/table.go#L109-L177</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Dispatch is the entrypoint to send data into the table.
</span></span></span><span class="line"><span class="cl"><span class="c1">// it dispatches incoming metrics into matching aggregators and routes,
</span></span></span><span class="line"><span class="cl"><span class="c1">// after checking against the blacklist
</span></span></span><span class="line"><span class="cl"><span class="c1">// buf is assumed to have no whitespace at the end
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">table</span> <span class="o">*</span><span class="nx">Table</span><span class="p">)</span> <span class="nf">Dispatch</span><span class="p">(</span><span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">buf_copy</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="nb">copy</span><span class="p">(</span><span class="nx">buf_copy</span><span class="p">,</span> <span class="nx">buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nx">log</span><span class="p">.</span><span class="nf">Tracef</span><span class="p">(</span><span class="s">&#34;table received packet %s&#34;</span><span class="p">,</span> <span class="nx">buf_copy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">table</span><span class="p">.</span><span class="nx">numIn</span><span class="p">.</span><span class="nf">Inc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">conf</span> <span class="o">:=</span> <span class="nx">table</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">TableConfig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ts</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m20</span><span class="p">.</span><span class="nf">ValidatePacket</span><span class="p">(</span><span class="nx">buf_copy</span><span class="p">,</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">Validation_level_legacy</span><span class="p">.</span><span class="nx">Level</span><span class="p">,</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">Validation_level_m20</span><span class="p">.</span><span class="nx">Level</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">table</span><span class="p">.</span><span class="nx">bad</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">buf_copy</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">table</span><span class="p">.</span><span class="nx">numInvalid</span><span class="p">.</span><span class="nf">Inc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">Validate_order</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">err</span> <span class="p">=</span> <span class="nx">validate</span><span class="p">.</span><span class="nf">Ordered</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">ts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">table</span><span class="p">.</span><span class="nx">bad</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">buf_copy</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nx">table</span><span class="p">.</span><span class="nx">numOutOfOrder</span><span class="p">.</span><span class="nf">Inc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">fields</span> <span class="o">:=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">Fields</span><span class="p">(</span><span class="nx">buf_copy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">matcher</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">blacklist</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">matcher</span><span class="p">.</span><span class="nf">Match</span><span class="p">(</span><span class="nx">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">table</span><span class="p">.</span><span class="nx">numBlacklist</span><span class="p">.</span><span class="nf">Inc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nx">log</span><span class="p">.</span><span class="nf">Tracef</span><span class="p">(</span><span class="s">&#34;table dropped %s, matched blacklist entry %s&#34;</span><span class="p">,</span> <span class="nx">buf_copy</span><span class="p">,</span> <span class="nx">matcher</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">rw</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">rewriters</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nx">rw</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">aggregator</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">aggregators</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// we rely on incoming metrics already having been validated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">dropRaw</span> <span class="o">:=</span> <span class="nx">aggregator</span><span class="p">.</span><span class="nf">AddMaybe</span><span class="p">(</span><span class="nx">fields</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">dropRaw</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">log</span><span class="p">.</span><span class="nf">Tracef</span><span class="p">(</span><span class="s">&#34;table dropped %s, matched dropRaw aggregator %s&#34;</span><span class="p">,</span> <span class="nx">buf_copy</span><span class="p">,</span> <span class="nx">aggregator</span><span class="p">.</span><span class="nx">Matcher</span><span class="p">.</span><span class="nx">Regex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">final</span> <span class="o">:=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">fields</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34; &#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">routed</span> <span class="o">:=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">route</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">routes</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">route</span><span class="p">.</span><span class="nf">Match</span><span class="p">(</span><span class="nx">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">routed</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">      <span class="nx">log</span><span class="p">.</span><span class="nf">Tracef</span><span class="p">(</span><span class="s">&#34;table sending to route: %s&#34;</span><span class="p">,</span> <span class="nx">final</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nx">route</span><span class="p">.</span><span class="nf">Dispatch</span><span class="p">(</span><span class="nx">final</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">!</span><span class="nx">routed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">table</span><span class="p">.</span><span class="nx">numUnroutable</span><span class="p">.</span><span class="nf">Inc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">log</span><span class="p">.</span><span class="nf">Tracef</span><span class="p">(</span><span class="s">&#34;unrouteable: %s&#34;</span><span class="p">,</span> <span class="nx">final</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>
</div>


<script src="https://hnakamur.github.io/blog/js/copy-button.js"></script>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-KMMXGG2Z56', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  </body>
</html>
