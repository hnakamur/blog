<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja-jp" lang="ja-jp">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.79.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>BadgerのErrConflictについて &middot; hnakamur&#39;s blog</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://hnakamur.github.io/blog/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-53263855-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-53263855-1');
</script>



</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://hnakamur.github.io/blog/"><h1>hnakamur&#39;s blog</h1></a>
      <p class="lead">
       my tech memo 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://hnakamur.github.io/blog/"> blog home </a></li><li><a href="https://github.com/hnakamur"> github @hnakamur </a></li><li><a href="https://twitter.com/hnakamur2"> twitter @hnakamur2 </a></li>
      </ul>
    </nav>

    <p>powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://pages.github.com/">GitHub Pages</a></p>
    <p>&copy; 2021. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>BadgerのErrConflictについて</h1>
  <time datetime=2020-02-29T16:34:32&#43;0900 class="post-date">2020-02-29</time>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#はじめに">はじめに</a></li>
    <li><a href="#errconflict-を返している個所"><code>ErrConflict</code> を返している個所</a></li>
    <li><a href="#oracle-の-commits-フィールド"><code>oracle</code> の <code>commits</code> フィールド</a></li>
    <li><a href="#txn-の-reads-フィールドの更新箇所"><code>Txn</code> の <code>reads</code> フィールドの更新箇所</a>
      <ul>
        <li><a href="#zmemhash-関数"><code>z.MemHash</code> 関数</a></li>
      </ul>
    </li>
    <li><a href="#txn-の-addreadkey-メソッドの呼び出し箇所"><code>Txn</code> の <code>addReadKey</code> メソッドの呼び出し箇所</a></li>
    <li><a href="#txn-の-writes-フィールドの更新箇所"><code>Txn</code> の <code>writes</code> フィールドの更新箇所</a></li>
    <li><a href="#txn-の-readts-の設定箇所"><code>Txn</code> の <code>readTs</code> の設定箇所</a></li>
    <li><a href="#oracle-の-nexttxnts-の更新箇所"><code>oracle</code> の <code>nextTxnTs</code> の更新箇所</a></li>
    <li><a href="#oracle-の-incrementnextts-の呼び出し箇所"><code>oracle</code> の <code>incrementNextTs</code> の呼び出し箇所</a></li>
    <li><a href="#oracle-の-newcommitts-の呼び出し元"><code>oracle</code> の <code>newCommitTs</code> の呼び出し元</a></li>
    <li><a href="#neworacle-関数の定義と呼び出し元"><code>newOracle</code> 関数の定義と呼び出し元</a></li>
    <li><a href="#通常の-read-write-トランザクションでの-errconflict">通常の read write トランザクションでの <code>ErrConflict</code></a></li>
    <li><a href="#streamwriter-は新規-db-作成専用"><code>StreamWriter</code> は新規 DB 作成専用</a></li>
    <li><a href="#writebatch"><code>WriteBatch</code></a>
      <ul>
        <li><a href="#db-の-newwritebatch-メソッド"><code>DB</code> の <code>NewWriteBatch</code> メソッド</a></li>
        <li><a href="#writebatch-の-setentry-メソッド"><code>WriteBatch</code> の <code>SetEntry</code> メソッド</a></li>
        <li><a href="#writebatch-の-set-メソッド"><code>WriteBatch</code> の <code>Set</code> メソッド</a></li>
        <li><a href="#writebatch-の-delete-メソッド"><code>WriteBatch</code> の <code>Delete</code> メソッド</a></li>
        <li><a href="#writebatch-の-commit-メソッド"><code>WriteBatch</code> の <code>commit</code> メソッド</a></li>
        <li><a href="#writebatch-の-callback-メソッド"><code>WriteBatch</code> の <code>callback</code> メソッド</a></li>
        <li><a href="#ythrottle"><code>y.Throttle</code></a></li>
        <li><a href="#writebatch-の-flush-メソッド"><code>WriteBatch</code> の <code>Flush</code> メソッド</a></li>
        <li><a href="#writebatch-のまとめ"><code>WriteBatch</code> のまとめ</a></li>
      </ul>
    </li>
  </ul>
</nav>
  <h2 id="はじめに">はじめに</h2>
<p><a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/README.md">badger の README.md</a> の <a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/README.md#read-write-transactions">Read-write transactions</a> に <code>ErrConflict</code> について以下のように説明があります。</p>
<blockquote>
<p>An ErrConflict error will be reported in case of a conflict. Depending on the state of your application, you have the option to retry the operation if you receive this error.</p>
</blockquote>
<p>一方 <code>DB</code> の <code>NewWriteBatch</code> メソッドの API ドキュメントに blind writes は <code>ErrConflict</code> が起きないと書かれています。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/batch.go#L35-L39">batch.go#L35-L39</a></p>
<pre><code>// NewWriteBatch creates a new WriteBatch. This provides a way to conveniently do a lot of writes,
// batching them up as tightly as possible in a single transaction and using callbacks to avoid
// waiting for them to commit, thus achieving good performance. This API hides away the logic of
// creating and committing transactions. Due to the nature of SSI guaratees provided by Badger,
// blind writes can never encounter transaction conflicts (ErrConflict).
</code></pre><p><code>ErrConflict</code> は具体的にどういうときに起きるか気になったのでコードを読みました。</p>
<h2 id="errconflict-を返している個所"><code>ErrConflict</code> を返している個所</h2>
<p><code>Txn</code> の <code>commitAndSend</code> メソッド内の 1 箇所です。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L466-L469">txn.go#L466-L469</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">  <span class="nx">commitTs</span> <span class="o">:=</span> <span class="nx">orc</span><span class="p">.</span><span class="nf">newCommitTs</span><span class="p">(</span><span class="nx">txn</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">commitTs</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrConflict</span>
  <span class="p">}</span>
</code></pre></div><p><code>oracle</code> の <code>newCommitTs</code> メソッド
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L167-L191">txn.go#L167-L191</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">oracle</span><span class="p">)</span> <span class="nf">newCommitTs</span><span class="p">(</span><span class="nx">txn</span> <span class="o">*</span><span class="nx">Txn</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
	<span class="nx">o</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">o</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nf">hasConflict</span><span class="p">(</span><span class="nx">txn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">ts</span> <span class="kt">uint64</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">o</span><span class="p">.</span><span class="nx">isManaged</span> <span class="p">{</span>
		<span class="c1">// This is the general case, when user doesn&#39;t specify the read and commit ts.
</span><span class="c1"></span>		<span class="nx">ts</span> <span class="p">=</span> <span class="nx">o</span><span class="p">.</span><span class="nx">nextTxnTs</span>
		<span class="nx">o</span><span class="p">.</span><span class="nx">nextTxnTs</span><span class="o">++</span>
		<span class="nx">o</span><span class="p">.</span><span class="nx">txnMark</span><span class="p">.</span><span class="nf">Begin</span><span class="p">(</span><span class="nx">ts</span><span class="p">)</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// If commitTs is set, use it instead.
</span><span class="c1"></span>		<span class="nx">ts</span> <span class="p">=</span> <span class="nx">txn</span><span class="p">.</span><span class="nx">commitTs</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">w</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">txn</span><span class="p">.</span><span class="nx">writes</span> <span class="p">{</span>
		<span class="nx">o</span><span class="p">.</span><span class="nx">commits</span><span class="p">[</span><span class="nx">w</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ts</span> <span class="c1">// Update the commitTs.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ts</span>
<span class="p">}</span>
</code></pre></div><p><code>oracle</code> の <code>hasConflict</code> メソッド
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L152-L165">txn.go#L152-L165</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// hasConflict must be called while having a lock.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">oracle</span><span class="p">)</span> <span class="nf">hasConflict</span><span class="p">(</span><span class="nx">txn</span> <span class="o">*</span><span class="nx">Txn</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">txn</span><span class="p">.</span><span class="nx">reads</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ro</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">txn</span><span class="p">.</span><span class="nx">reads</span> <span class="p">{</span>
		<span class="c1">// A commit at the read timestamp is expected.
</span><span class="c1"></span>		<span class="c1">// But, any commit after the read timestamp should cause a conflict.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ts</span><span class="p">,</span> <span class="nx">has</span> <span class="o">:=</span> <span class="nx">o</span><span class="p">.</span><span class="nx">commits</span><span class="p">[</span><span class="nx">ro</span><span class="p">];</span> <span class="nx">has</span> <span class="o">&amp;&amp;</span> <span class="nx">ts</span> <span class="p">&gt;</span> <span class="nx">txn</span><span class="p">.</span><span class="nx">readTs</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></div><p><code>Txn</code> の <code>reads</code> フィールドと <code>oracle</code> の <code>commit</code> フィールドを突き合せてコンフリクトがあるかを判定しています。</p>
<h2 id="oracle-の-commits-フィールド"><code>oracle</code> の <code>commits</code> フィールド</h2>
<p><code>oracle</code> 構造体
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L34-L59">txn.go#L34-L59</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">oracle</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// A 64-bit integer must be at the top for memory alignment. See issue #311.
</span><span class="c1"></span>	<span class="nx">refCount</span>  <span class="kt">int64</span>
	<span class="nx">isManaged</span> <span class="kt">bool</span> <span class="c1">// Does not change value, so no locking required.
</span><span class="c1"></span>
	<span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// For nextTxnTs and commits.
</span><span class="c1"></span>	<span class="c1">// writeChLock lock is for ensuring that transactions go to the write
</span><span class="c1"></span>	<span class="c1">// channel in the same order as their commit timestamps.
</span><span class="c1"></span>	<span class="nx">writeChLock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">nextTxnTs</span>   <span class="kt">uint64</span>

	<span class="c1">// Used to block NewTransaction, so all previous commits are visible to a new read.
</span><span class="c1"></span>	<span class="nx">txnMark</span> <span class="o">*</span><span class="nx">y</span><span class="p">.</span><span class="nx">WaterMark</span>

	<span class="c1">// Either of these is used to determine which versions can be permanently
</span><span class="c1"></span>	<span class="c1">// discarded during compaction.
</span><span class="c1"></span>	<span class="nx">discardTs</span> <span class="kt">uint64</span>       <span class="c1">// Used by ManagedDB.
</span><span class="c1"></span>	<span class="nx">readMark</span>  <span class="o">*</span><span class="nx">y</span><span class="p">.</span><span class="nx">WaterMark</span> <span class="c1">// Used by DB.
</span><span class="c1"></span>
	<span class="c1">// commits stores a key fingerprint and latest commit counter for it.
</span><span class="c1"></span>	<span class="c1">// refCount is used to clear out commits map to avoid a memory blowup.
</span><span class="c1"></span>	<span class="nx">commits</span> <span class="kd">map</span><span class="p">[</span><span class="kt">uint64</span><span class="p">]</span><span class="kt">uint64</span>

	<span class="c1">// closer is used to stop watermarks.
</span><span class="c1"></span>	<span class="nx">closer</span> <span class="o">*</span><span class="nx">y</span><span class="p">.</span><span class="nx">Closer</span>
<span class="p">}</span>
</code></pre></div><p><code>commits</code> フィールドの値を更新しているのは上記にもある <code>oracle</code> の <code>newCommitTs</code> メソッド内の 1 箇所だけでした。</p>
<p><a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L187-L189">txn.go#L187-L189</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">w</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">txn</span><span class="p">.</span><span class="nx">writes</span> <span class="p">{</span>
		<span class="nx">o</span><span class="p">.</span><span class="nx">commits</span><span class="p">[</span><span class="nx">w</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ts</span> <span class="c1">// Update the commitTs.
</span><span class="c1"></span>	<span class="p">}</span>
</code></pre></div><p><code>oracle</code> の <code>decrRef</code> メソッド内で <code>commits</code> のマップを作り直す場合があります。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L99-L101">txn.go#L99-L101</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">commits</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1000</span> <span class="p">{</span> <span class="c1">// If the map is still small, let it slide.
</span><span class="c1"></span>		<span class="nx">o</span><span class="p">.</span><span class="nx">commits</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">uint64</span><span class="p">]</span><span class="kt">uint64</span><span class="p">)</span>
	<span class="p">}</span>
</code></pre></div><h2 id="txn-の-reads-フィールドの更新箇所"><code>Txn</code> の <code>reads</code> フィールドの更新箇所</h2>
<p><code>Txn</code> 構造体
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L201-L218">txn.go#L201-L218</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Txn represents a Badger transaction.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Txn</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">readTs</span>   <span class="kt">uint64</span>
	<span class="nx">commitTs</span> <span class="kt">uint64</span>

	<span class="nx">update</span> <span class="kt">bool</span>     <span class="c1">// update is used to conditionally keep track of reads.
</span><span class="c1"></span>	<span class="nx">reads</span>  <span class="p">[]</span><span class="kt">uint64</span> <span class="c1">// contains fingerprints of keys read.
</span><span class="c1"></span>	<span class="nx">writes</span> <span class="p">[]</span><span class="kt">uint64</span> <span class="c1">// contains fingerprints of keys written.
</span><span class="c1"></span>
	<span class="nx">pendingWrites</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">Entry</span> <span class="c1">// cache stores any writes done by txn.
</span><span class="c1"></span>
	<span class="nx">db</span>        <span class="o">*</span><span class="nx">DB</span>
	<span class="nx">discarded</span> <span class="kt">bool</span>

	<span class="nx">size</span>         <span class="kt">int64</span>
	<span class="nx">count</span>        <span class="kt">int64</span>
	<span class="nx">numIterators</span> <span class="kt">int32</span>
<span class="p">}</span>
</code></pre></div><p><code>Txn</code> の <code>reads</code> は <code>addReadKey</code> メソッドで追加されていました。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L429-L434">txn.go#L429-L434</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">txn</span> <span class="o">*</span><span class="nx">Txn</span><span class="p">)</span> <span class="nf">addReadKey</span><span class="p">(</span><span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">txn</span><span class="p">.</span><span class="nx">update</span> <span class="p">{</span>
		<span class="nx">fp</span> <span class="o">:=</span> <span class="nx">z</span><span class="p">.</span><span class="nf">MemHash</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
		<span class="nx">txn</span><span class="p">.</span><span class="nx">reads</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">txn</span><span class="p">.</span><span class="nx">reads</span><span class="p">,</span> <span class="nx">fp</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>txn.update</code> が true つまり read-write トランザクションの場合のみ追加されます。</p>
<h3 id="zmemhash-関数"><code>z.MemHash</code> 関数</h3>
<p><code>z.MemHash</code> は <a href="https://github.com/dgraph-io/ristretto">dgraph-io/ristretto: A high performance memory-bound Go cache</a> で定義されています。
<a href="https://github.com/dgraph-io/ristretto/blob/8f368f2f2ab3a54cbe62fb9772cd75ce55e07802/z/rtutil.go#L37-L52">ristretto/z/rtutil.go#L37-L52</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">stringStruct</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">str</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">len</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">//go:noescape
</span><span class="c1">//go:linkname memhash runtime.memhash
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">memhash</span><span class="p">(</span><span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span>

<span class="c1">// MemHash is the hash function used by go map, it utilizes available hardware instructions(behaves
</span><span class="c1">// as aeshash if aes instruction is available).
</span><span class="c1">// NOTE: The hash seed changes for every process. So, this cannot be used as a persistent hash.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">MemHash</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
	<span class="nx">ss</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">stringStruct</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">data</span><span class="p">))</span>
	<span class="k">return</span> <span class="nb">uint64</span><span class="p">(</span><span class="nf">memhash</span><span class="p">(</span><span class="nx">ss</span><span class="p">.</span><span class="nx">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">ss</span><span class="p">.</span><span class="nx">len</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div><p><code>//go:linkname</code> というコメントを使って <code>runtime</code> パッケージの <code>memhash</code> という非公開関数を呼び出しています。
Go 1.14 以降であれば <a href="https://golang.org/pkg/hash/maphash/">hash/maphash</a> を使うところでしょうが、それ以前に作られたのでこのような実装になっています。</p>
<p>本題に戻ると <code>z.MemHash</code> は処理内容としてはバイト列のハッシュ値を計算しているということになります。</p>
<h2 id="txn-の-addreadkey-メソッドの呼び出し箇所"><code>Txn</code> の <code>addReadKey</code> メソッドの呼び出し箇所</h2>
<p>2 箇所あります。</p>
<ol>
<li><code>Txn</code> の <code>Get</code> メソッド内。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L401-L403">txn.go#L401-L403</a></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">		<span class="c1">// Only track reads if this is update txn. No need to track read if txn serviced it
</span><span class="c1"></span>		<span class="c1">// internally.
</span><span class="c1"></span>		<span class="nx">txn</span><span class="p">.</span><span class="nf">addReadKey</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</code></pre></div><ol start="2">
<li><code>Iterator</code> の <code>Item</code> メソッド内。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/iterator.go#L504">iterator.go#L504</a></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">tx</span><span class="p">.</span><span class="nf">addReadKey</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">item</span><span class="p">.</span><span class="nf">Key</span><span class="p">())</span>
</code></pre></div><h2 id="txn-の-writes-フィールドの更新箇所"><code>Txn</code> の <code>writes</code> フィールドの更新箇所</h2>
<p><code>Txn</code> の <code>modify</code> メソッド内の 1 箇所です。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L335-L336">txn.go#L335-L336</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">fp</span> <span class="o">:=</span> <span class="nx">z</span><span class="p">.</span><span class="nf">MemHash</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Key</span><span class="p">)</span> <span class="c1">// Avoid dealing with byte arrays.
</span><span class="c1"></span>	<span class="nx">txn</span><span class="p">.</span><span class="nx">writes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">txn</span><span class="p">.</span><span class="nx">writes</span><span class="p">,</span> <span class="nx">fp</span><span class="p">)</span>
</code></pre></div><p><code>Txn</code> の <code>modify</code> メソッドの呼び出しは <code>SetEntry</code> と <code>Delete</code> メソッドの 2 箇所です。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L350-L373">txn.go#L350-L373</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// SetEntry takes an Entry struct and adds the key-value pair in the struct,
</span><span class="c1">// along with other metadata to the database.
</span><span class="c1">//
</span><span class="c1">// The current transaction keeps a reference to the entry passed in argument.
</span><span class="c1">// Users must not modify the entry until the end of the transaction.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">txn</span> <span class="o">*</span><span class="nx">Txn</span><span class="p">)</span> <span class="nf">SetEntry</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Entry</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">txn</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Delete deletes a key.
</span><span class="c1">//
</span><span class="c1">// This is done by adding a delete marker for the key at commit timestamp.  Any
</span><span class="c1">// reads happening before this timestamp would be unaffected. Any reads after
</span><span class="c1">// this commit would see the deletion.
</span><span class="c1">//
</span><span class="c1">// The current transaction keeps a reference to the key byte slice argument.
</span><span class="c1">// Users must not modify the key until the end of the transaction.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">txn</span> <span class="o">*</span><span class="nx">Txn</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Entry</span><span class="p">{</span>
		<span class="nx">Key</span><span class="p">:</span>  <span class="nx">key</span><span class="p">,</span>
		<span class="nx">meta</span><span class="p">:</span> <span class="nx">bitDelete</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">txn</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="txn-の-readts-の設定箇所"><code>Txn</code> の <code>readTs</code> の設定箇所</h2>
<p><code>Txn</code> の <code>readTs</code> は <code>DB</code> の <code>newTransaction</code> メソッド内で設定されていました。</p>
<p><a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L653-L667">txn.go#L653-L667</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="c1">// It is important that the oracle addRef happens BEFORE we retrieve a read
</span><span class="c1"></span>	<span class="c1">// timestamp. Otherwise, it is possible that the oracle commit map would
</span><span class="c1"></span>	<span class="c1">// become nil after we get the read timestamp.
</span><span class="c1"></span>	<span class="c1">// The sequence of events can be:
</span><span class="c1"></span>	<span class="c1">// 1. This txn gets a read timestamp.
</span><span class="c1"></span>	<span class="c1">// 2. Another txn working on the same keyset commits them, and decrements
</span><span class="c1"></span>	<span class="c1">//    the reference to oracle.
</span><span class="c1"></span>	<span class="c1">// 3. Oracle ref reaches zero, resetting commit map.
</span><span class="c1"></span>	<span class="c1">// 4. This txn increments the oracle reference.
</span><span class="c1"></span>	<span class="c1">// 5. Now this txn would go on to commit the keyset, and no conflicts
</span><span class="c1"></span>	<span class="c1">//    would be detected.
</span><span class="c1"></span>	<span class="c1">// See issue: https://github.com/dgraph-io/badger/issues/574
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">isManaged</span> <span class="p">{</span>
		<span class="nx">txn</span><span class="p">.</span><span class="nx">readTs</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">orc</span><span class="p">.</span><span class="nf">readTs</span><span class="p">()</span>
	<span class="p">}</span>
</code></pre></div><p>上記のコメントの先頭に read timestamp を取得する前に oracle addRef を実行することが重要とありますが、このコメントの直前で呼んでいます。</p>
<p><code>oracle</code> の <code>readTs</code> メソッド。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L104-L121">txn.go#L104-L121</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">oracle</span><span class="p">)</span> <span class="nf">readTs</span><span class="p">()</span> <span class="kt">uint64</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">isManaged</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;ReadTs should not be retrieved for managed DB&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">readTs</span> <span class="kt">uint64</span>
	<span class="nx">o</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">readTs</span> <span class="p">=</span> <span class="nx">o</span><span class="p">.</span><span class="nx">nextTxnTs</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="nx">o</span><span class="p">.</span><span class="nx">readMark</span><span class="p">.</span><span class="nf">Begin</span><span class="p">(</span><span class="nx">readTs</span><span class="p">)</span>
	<span class="nx">o</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="c1">// Wait for all txns which have no conflicts, have been assigned a commit
</span><span class="c1"></span>	<span class="c1">// timestamp and are going through the write to value log and LSM tree
</span><span class="c1"></span>	<span class="c1">// process. Not waiting here could mean that some txns which have been
</span><span class="c1"></span>	<span class="c1">// committed would not be read.
</span><span class="c1"></span>	<span class="nx">y</span><span class="p">.</span><span class="nf">Check</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">txnMark</span><span class="p">.</span><span class="nf">WaitForMark</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">readTs</span><span class="p">))</span>
	<span class="k">return</span> <span class="nx">readTs</span>
<span class="p">}</span>
</code></pre></div><h2 id="oracle-の-nexttxnts-の更新箇所"><code>oracle</code> の <code>nextTxnTs</code> の更新箇所</h2>
<p>以下の 5 箇所です。</p>
<ol>
<li><code>oracle</code> の <code>newCommitTs</code> メソッド内。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L177-L180">txn.go#L177-L180</a></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">		<span class="c1">// This is the general case, when user doesn&#39;t specify the read and commit ts.
</span><span class="c1"></span>		<span class="nx">ts</span> <span class="p">=</span> <span class="nx">o</span><span class="p">.</span><span class="nx">nextTxnTs</span>
		<span class="nx">o</span><span class="p">.</span><span class="nx">nextTxnTs</span><span class="o">++</span>
		<span class="nx">o</span><span class="p">.</span><span class="nx">txnMark</span><span class="p">.</span><span class="nf">Begin</span><span class="p">(</span><span class="nx">ts</span><span class="p">)</span>
</code></pre></div><ol start="2">
<li><code>oracle</code> の <code>incrementNextTs</code> メソッド内。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L129-L133">txn.go#L129-L133</a></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">oracle</span><span class="p">)</span> <span class="nf">incrementNextTs</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">o</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">o</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">o</span><span class="p">.</span><span class="nx">nextTxnTs</span><span class="o">++</span>
<span class="p">}</span>
</code></pre></div><ol start="3">
<li><code>StreamWriter</code> の <code>Flush</code> メソッド内。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/stream_writer.go#L235">stream_writer.go#L235</a></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">		<span class="nx">sw</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">orc</span><span class="p">.</span><span class="nx">nextTxnTs</span> <span class="p">=</span> <span class="nx">sw</span><span class="p">.</span><span class="nx">maxVersion</span>
</code></pre></div><ol start="4">
<li><code>DB</code> の <code>Load</code> メソッド内。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/backup.go#L241-L245">backup.go#L241-L245</a></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">			<span class="c1">// Update nextTxnTs, memtable stores this
</span><span class="c1"></span>			<span class="c1">// timestamp in badger head when flushed.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">Version</span> <span class="o">&gt;=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">orc</span><span class="p">.</span><span class="nx">nextTxnTs</span> <span class="p">{</span>
				<span class="nx">db</span><span class="p">.</span><span class="nx">orc</span><span class="p">.</span><span class="nx">nextTxnTs</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">Version</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="p">}</span>
</code></pre></div><ol start="5">
<li><code>DB</code> の <code>replayFunction</code> メソッドで返す関数 <code>func(Entry, valuePointer) error</code> 内。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/db.go#L125-L127">db.go#L125-L127</a></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">		<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">orc</span><span class="p">.</span><span class="nx">nextTxnTs</span> <span class="p">&lt;</span> <span class="nx">y</span><span class="p">.</span><span class="nf">ParseTs</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Key</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">db</span><span class="p">.</span><span class="nx">orc</span><span class="p">.</span><span class="nx">nextTxnTs</span> <span class="p">=</span> <span class="nx">y</span><span class="p">.</span><span class="nf">ParseTs</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Key</span><span class="p">)</span>
		<span class="p">}</span>
</code></pre></div><h2 id="oracle-の-incrementnextts-の呼び出し箇所"><code>oracle</code> の <code>incrementNextTs</code> の呼び出し箇所</h2>
<p>以下の 2 箇所です。</p>
<ol>
<li><code>Open</code> 関数。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/db.go#L373">db.go#L373</a></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">db</span><span class="p">.</span><span class="nx">orc</span><span class="p">.</span><span class="nf">incrementNextTs</span><span class="p">()</span>
</code></pre></div><ol start="2">
<li><code>StreamWriter</code> の <code>Flush</code> メソッド内。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/stream_writer.go#L238">stream_writer.go#L238</a></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">		<span class="nx">sw</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">orc</span><span class="p">.</span><span class="nf">incrementNextTs</span><span class="p">()</span>
</code></pre></div><h2 id="oracle-の-newcommitts-の呼び出し元"><code>oracle</code> の <code>newCommitTs</code> の呼び出し元</h2>
<p><code>oracle</code> の <code>newCommitTs</code> メソッドの呼び出し元は <code>commitAndSend</code> メソッド内の 1 箇所です（この記事の冒頭参照）。</p>
<p><code>Txn</code> の <code>commitAndSend</code> メソッドの呼び出し元は以下の 2 箇所です。</p>
<ol>
<li><code>Txn</code> の <code>Commit</code> メソッド内。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L546">txn.go#L546</a>
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L520-L555">txn.go#L520-L555</a></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Commit commits the transaction, following these steps:
</span><span class="c1">//
</span><span class="c1">// 1. If there are no writes, return immediately.
</span><span class="c1">//
</span><span class="c1">// 2. Check if read rows were updated since txn started. If so, return ErrConflict.
</span><span class="c1">//
</span><span class="c1">// 3. If no conflict, generate a commit timestamp and update written rows&#39; commit ts.
</span><span class="c1">//
</span><span class="c1">// 4. Batch up all writes, write them to value log and LSM tree.
</span><span class="c1">//
</span><span class="c1">// 5. If callback is provided, Badger will return immediately after checking
</span><span class="c1">// for conflicts. Writes to the database will happen in the background.  If
</span><span class="c1">// there is a conflict, an error will be returned and the callback will not
</span><span class="c1">// run. If there are no conflicts, the callback will be called in the
</span><span class="c1">// background upon successful completion of writes or any error during write.
</span><span class="c1">//
</span><span class="c1">// If error is nil, the transaction is successfully committed. In case of a non-nil error, the LSM
</span><span class="c1">// tree won&#39;t be updated, so there&#39;s no need for any rollback.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">txn</span> <span class="o">*</span><span class="nx">Txn</span><span class="p">)</span> <span class="nf">Commit</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">txn</span><span class="p">.</span><span class="nf">commitPrecheck</span><span class="p">()</span> <span class="c1">// Precheck before discarding txn.
</span><span class="c1"></span>	<span class="k">defer</span> <span class="nx">txn</span><span class="p">.</span><span class="nf">Discard</span><span class="p">()</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">txn</span><span class="p">.</span><span class="nx">writes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span> <span class="c1">// Nothing to do.
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="nx">txnCb</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">txn</span><span class="p">.</span><span class="nf">commitAndSend</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// If batchSet failed, LSM would not have been updated. So, no need to rollback anything.
</span><span class="c1"></span>
	<span class="c1">// TODO: What if some of the txns successfully make it to value log, but others fail.
</span><span class="c1"></span>	<span class="c1">// Nothing gets updated to LSM, until a restart happens.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">txnCb</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>メソッドのコメントの 2. が <code>commitAndSend</code> メソッドの呼び出しに対応していてエラーが返ってきたらそれを返します。</p>
<ol start="2">
<li><code>Txn</code> の <code>CommitWith</code> メソッド内。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L579-L606">txn.go#L579-L606</a></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// CommitWith acts like Commit, but takes a callback, which gets run via a
</span><span class="c1">// goroutine to avoid blocking this function. The callback is guaranteed to run,
</span><span class="c1">// so it is safe to increment sync.WaitGroup before calling CommitWith, and
</span><span class="c1">// decrementing it in the callback; to block until all callbacks are run.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">txn</span> <span class="o">*</span><span class="nx">Txn</span><span class="p">)</span> <span class="nf">CommitWith</span><span class="p">(</span><span class="nx">cb</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">))</span> <span class="p">{</span>
	<span class="nx">txn</span><span class="p">.</span><span class="nf">commitPrecheck</span><span class="p">()</span> <span class="c1">// Precheck before discarding txn.
</span><span class="c1"></span>	<span class="k">defer</span> <span class="nx">txn</span><span class="p">.</span><span class="nf">Discard</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">cb</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Nil callback provided to CommitWith&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">txn</span><span class="p">.</span><span class="nx">writes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Do not run these callbacks from here, because the CommitWith and the
</span><span class="c1"></span>		<span class="c1">// callback might be acquiring the same locks. Instead run the callback
</span><span class="c1"></span>		<span class="c1">// from another goroutine.
</span><span class="c1"></span>		<span class="k">go</span> <span class="nf">runTxnCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">txnCb</span><span class="p">{</span><span class="nx">user</span><span class="p">:</span> <span class="nx">cb</span><span class="p">,</span> <span class="nx">err</span><span class="p">:</span> <span class="kc">nil</span><span class="p">})</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">commitCb</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">txn</span><span class="p">.</span><span class="nf">commitAndSend</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">go</span> <span class="nf">runTxnCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">txnCb</span><span class="p">{</span><span class="nx">user</span><span class="p">:</span> <span class="nx">cb</span><span class="p">,</span> <span class="nx">err</span><span class="p">:</span> <span class="nx">err</span><span class="p">})</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">go</span> <span class="nf">runTxnCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">txnCb</span><span class="p">{</span><span class="nx">user</span><span class="p">:</span> <span class="nx">cb</span><span class="p">,</span> <span class="nx">commit</span><span class="p">:</span> <span class="nx">commitCb</span><span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>ここで使用している <code>txnCb</code> 構造体と <code>runTxnCallback</code> 関数の定義は以下の通りです。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L557-L577">txn.go#L557-L577</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">txnCb</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">commit</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span>
	<span class="nx">user</span>   <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">)</span>
	<span class="nx">err</span>    <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">runTxnCallback</span><span class="p">(</span><span class="nx">cb</span> <span class="o">*</span><span class="nx">txnCb</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">cb</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;txn callback is nil&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">cb</span><span class="p">.</span><span class="nx">user</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Must have caught a nil callback for txn.CommitWith&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">cb</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">:</span>
		<span class="nx">cb</span><span class="p">.</span><span class="nf">user</span><span class="p">(</span><span class="nx">cb</span><span class="p">.</span><span class="nx">err</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">cb</span><span class="p">.</span><span class="nx">commit</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">:</span>
		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">cb</span><span class="p">.</span><span class="nf">commit</span><span class="p">()</span>
		<span class="nx">cb</span><span class="p">.</span><span class="nf">user</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nx">cb</span><span class="p">.</span><span class="nf">user</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="neworacle-関数の定義と呼び出し元"><code>newOracle</code> 関数の定義と呼び出し元</h2>
<p><a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/txn.go#L61-L76">txn.go#L61-L76</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newOracle</span><span class="p">(</span><span class="nx">opt</span> <span class="nx">Options</span><span class="p">)</span> <span class="o">*</span><span class="nx">oracle</span> <span class="p">{</span>
	<span class="nx">orc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">oracle</span><span class="p">{</span>
		<span class="nx">isManaged</span><span class="p">:</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">managedTxns</span><span class="p">,</span>
		<span class="nx">commits</span><span class="p">:</span>   <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">uint64</span><span class="p">]</span><span class="kt">uint64</span><span class="p">),</span>
		<span class="c1">// We&#39;re not initializing nextTxnTs and readOnlyTs. It would be done after replay in Open.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// WaterMarks must be 64-bit aligned for atomic package, hence we must use pointers here.
</span><span class="c1"></span>		<span class="c1">// See https://golang.org/pkg/sync/atomic/#pkg-note-BUG.
</span><span class="c1"></span>		<span class="nx">readMark</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">y</span><span class="p">.</span><span class="nx">WaterMark</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;badger.PendingReads&#34;</span><span class="p">},</span>
		<span class="nx">txnMark</span><span class="p">:</span>  <span class="o">&amp;</span><span class="nx">y</span><span class="p">.</span><span class="nx">WaterMark</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;badger.TxnTimestamp&#34;</span><span class="p">},</span>
		<span class="nx">closer</span><span class="p">:</span>   <span class="nx">y</span><span class="p">.</span><span class="nf">NewCloser</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
	<span class="p">}</span>
	<span class="nx">orc</span><span class="p">.</span><span class="nx">readMark</span><span class="p">.</span><span class="nf">Init</span><span class="p">(</span><span class="nx">orc</span><span class="p">.</span><span class="nx">closer</span><span class="p">,</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">EventLogging</span><span class="p">)</span>
	<span class="nx">orc</span><span class="p">.</span><span class="nx">txnMark</span><span class="p">.</span><span class="nf">Init</span><span class="p">(</span><span class="nx">orc</span><span class="p">.</span><span class="nx">closer</span><span class="p">,</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">EventLogging</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">orc</span>
<span class="p">}</span>
</code></pre></div><p><code>newOracle</code> の呼び出し元は以下の 2 箇所です。</p>
<ol>
<li><code>Open</code> 関数内。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/db.go#L282-L293">db.go#L282-L293</a></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
	<span class="nx">db</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">DB</span><span class="p">{</span>
		<span class="nx">imm</span><span class="p">:</span>           <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">skl</span><span class="p">.</span><span class="nx">Skiplist</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">NumMemtables</span><span class="p">),</span>
		<span class="nx">flushChan</span><span class="p">:</span>     <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">flushTask</span><span class="p">,</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">NumMemtables</span><span class="p">),</span>
		<span class="nx">writeCh</span><span class="p">:</span>       <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">request</span><span class="p">,</span> <span class="nx">kvWriteChCapacity</span><span class="p">),</span>
		<span class="nx">opt</span><span class="p">:</span>           <span class="nx">opt</span><span class="p">,</span>
		<span class="nx">manifest</span><span class="p">:</span>      <span class="nx">manifestFile</span><span class="p">,</span>
		<span class="nx">elog</span><span class="p">:</span>          <span class="nx">elog</span><span class="p">,</span>
		<span class="nx">dirLockGuard</span><span class="p">:</span>  <span class="nx">dirLockGuard</span><span class="p">,</span>
		<span class="nx">valueDirGuard</span><span class="p">:</span> <span class="nx">valueDirLockGuard</span><span class="p">,</span>
		<span class="nx">orc</span><span class="p">:</span>           <span class="nf">newOracle</span><span class="p">(</span><span class="nx">opt</span><span class="p">),</span>
		<span class="nx">pub</span><span class="p">:</span>           <span class="nf">newPublisher</span><span class="p">(),</span>
	<span class="p">}</span>
</code></pre></div><ol start="2">
<li><code>StreamWriter</code> の <code>Flush</code> メソッド内。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/stream_writer.go#L231-L238">stream_writer.go#L231-L238</a></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">		<span class="k">if</span> <span class="nx">sw</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">orc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">sw</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">orc</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">sw</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">orc</span> <span class="p">=</span> <span class="nf">newOracle</span><span class="p">(</span><span class="nx">sw</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">opt</span><span class="p">)</span>
		<span class="nx">sw</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">orc</span><span class="p">.</span><span class="nx">nextTxnTs</span> <span class="p">=</span> <span class="nx">sw</span><span class="p">.</span><span class="nx">maxVersion</span>
		<span class="nx">sw</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">orc</span><span class="p">.</span><span class="nx">txnMark</span><span class="p">.</span><span class="nf">Done</span><span class="p">(</span><span class="nx">sw</span><span class="p">.</span><span class="nx">maxVersion</span><span class="p">)</span>
		<span class="nx">sw</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">orc</span><span class="p">.</span><span class="nx">readMark</span><span class="p">.</span><span class="nf">Done</span><span class="p">(</span><span class="nx">sw</span><span class="p">.</span><span class="nx">maxVersion</span><span class="p">)</span>
		<span class="nx">sw</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">orc</span><span class="p">.</span><span class="nf">incrementNextTs</span><span class="p">()</span>
</code></pre></div><h2 id="通常の-read-write-トランザクションでの-errconflict">通常の read write トランザクションでの <code>ErrConflict</code></h2>
<p>まとめると通常の read write トランザクションについては以下のようになります。</p>
<ul>
<li><code>Open</code> 関数内で作られる <code>oracle</code> は <code>DB</code> 内に 1 対 1 で保持されます。</li>
<li>トランザクションの開始時点の <code>oracle</code> の <code>nextTxnTs - 1</code> が <code>txn</code> の <code>readTs</code> に設定されます。</li>
<li>その後 <code>Txn</code> の <code>Get</code> メソッドか <code>Iterator</code> の <code>Item</code> メソッドで参照されたキーのハッシュが <code>txn</code> の <code>reads</code> フィールドに追加されていきます。</li>
<li>一方 <code>Txn</code> の <code>SetEntry</code> と <code>Delete</code> メソッドが呼ばれると対象のキーのハッシュが <code>txn</code> の <code>writes</code> フィールドに追加されていきます。</li>
<li><code>Txn</code> の <code>Commit</code> か <code>CommitWith</code> メソッドが呼ばれると <code>oracle</code> の <code>nextTxnTs</code> の現在値を取得してインクリメントし、 <code>txn</code> の <code>writes</code> のキーのハッシュ全てについて <code>oracle</code> の <code>commits</code> に <code>nextTxnTs</code> のインクリメント前の値を設定します。</li>
<li><code>oracle</code> の <code>hasConflict</code> メソッド内では <code>txn</code> の <code>reads</code> に含まれるキーのハッシュについて <code>oracle</code> の <code>commits</code> に設定されたタイムスタンプを取得し <code>txn</code> の <code>readTs</code> より大きいものがあればコンフリクトありと判定します。</li>
<li><code>oracle</code> の <code>nextTxnTs</code> は以下の操作でインクリメントされます。
<ul>
<li><code>Txn</code> の <code>Commit</code> か <code>CommitWith</code> メソッドが呼ばれてコミットしたとき。</li>
<li><code>Open</code> 関数でデータベースが開かれたとき。</li>
<li><code>StreamWriter</code> の <code>Flush</code> メソッドが呼ばれたとき。</li>
</ul>
</li>
</ul>
<h2 id="streamwriter-は新規-db-作成専用"><code>StreamWriter</code> は新規 DB 作成専用</h2>
<p><a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/README.md">badger/README.md</a> に <a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/README.md#stream">Stream</a> という項がありますが、 <code>StreamWriter</code> はこれとは別です。</p>
<p><code>StreamWriter</code> は <code>DB</code> の <code>NewStreamWriter</code> メソッドで作成します。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/stream_writer.go#L54-L66">stream_writer.go#L54-L66</a></p>
<p>コメントによると直後に <code>Prepare</code> メソッドを呼ぶ必要があります。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/stream_writer.go#L68-L79">stream_writer.go#L68-L79</a></p>
<p><code>Prepare</code> 内では <code>DB</code> の <code>dropAll</code> メソッド <a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/db.go#L1478-L1517">db.go#L1478-L1517</a> が呼ばれています。</p>
<p><code>dropAll</code> メソッドは上記の <code>StreamWriter</code> の <code>Prepare</code> メソッド以外では <code>DB</code> の <code>DropAll</code> メソッドから呼ばれます。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/db.go#L1458-L1476">db.go#L1458-L1476</a>
コメントによると名前の通り DB 内のすべてのデータを削除するメソッドのようです。</p>
<p><code>StreamWriter</code> 構造体のコメント <a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/stream_writer.go#L33-L52">stream_writer.go#L33-L52</a> に用途が書いてありました。
既存の DB インスタンスに対して使うものではなく、新しい DB を作成するときのみ使用するものとのことです。</p>
<h2 id="writebatch"><code>WriteBatch</code></h2>
<p><a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/README.md">badger/README.md</a> の FAQ の <a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/README.md#my-writes-are-really-slow-why">My writes are really slow. Why?</a> に <code>WriteBatch</code> の使い方の説明があります。</p>
<p>説明の最後に <code>WriteBatch</code> API では DB の値を読み取ることは出来ないと書いてあります。読み取りと書き込みが必要な場合は <code>Transaction</code> API を使う必要があります。</p>
<p><code>WriteBatch</code> の使用例も書かれています。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">wb</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">NewWriteBatch</span><span class="p">()</span>
<span class="k">defer</span> <span class="nx">wb</span><span class="p">.</span><span class="nf">Cancel</span><span class="p">()</span>

<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">wb</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nf">key</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span> <span class="nf">value</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Will create txns as needed.
</span><span class="c1"></span>  <span class="nf">handle</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">handle</span><span class="p">(</span><span class="nx">wb</span><span class="p">.</span><span class="nf">Flush</span><span class="p">())</span> <span class="c1">// Wait for all txns to finish.
</span></code></pre></div><h3 id="db-の-newwritebatch-メソッド"><code>DB</code> の <code>NewWriteBatch</code> メソッド</h3>
<p><a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/batch.go#L35-L53">batch.go#L35-L53</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NewWriteBatch creates a new WriteBatch. This provides a way to conveniently do a lot of writes,
</span><span class="c1">// batching them up as tightly as possible in a single transaction and using callbacks to avoid
</span><span class="c1">// waiting for them to commit, thus achieving good performance. This API hides away the logic of
</span><span class="c1">// creating and committing transactions. Due to the nature of SSI guaratees provided by Badger,
</span><span class="c1">// blind writes can never encounter transaction conflicts (ErrConflict).
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">NewWriteBatch</span><span class="p">()</span> <span class="o">*</span><span class="nx">WriteBatch</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">opt</span><span class="p">.</span><span class="nx">managedTxns</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;cannot use NewWriteBatch in managed mode. Use NewWriteBatchAt instead&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nf">newWriteBatch</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">newWriteBatch</span><span class="p">()</span> <span class="o">*</span><span class="nx">WriteBatch</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">WriteBatch</span><span class="p">{</span>
		<span class="nx">db</span><span class="p">:</span>       <span class="nx">db</span><span class="p">,</span>
		<span class="nx">txn</span><span class="p">:</span>      <span class="nx">db</span><span class="p">.</span><span class="nf">newTransaction</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">),</span>
		<span class="nx">throttle</span><span class="p">:</span> <span class="nx">y</span><span class="p">.</span><span class="nf">NewThrottle</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>コメントにある <code>SSI</code> は <a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/README.md">badger/README.md</a> の Design の <a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/README.md#comparisons">Comparisons</a> に説明がありました。</p>
<p>Transactions の行の Badger の列に Yes, ACID, concurrent with SSI とあり、表の下の注釈に以下のように書かれています。</p>
<blockquote>
<p>SSI: Serializable Snapshot Isolation. For more details, see the blog post <a href="https://blog.dgraph.io/post/badger-txn/">Concurrent ACID Transactions in Badger - Dgraph Blog</a></p>
</blockquote>
<p>このブログ記事に <code>ErrConflict</code> について説明されていました。</p>
<p>コードに戻ると <code>DB</code> の <code>newWriteBatch</code> メソッド内で <code>newTransaction</code> メソッドを呼んで read write トランザクションを作っていることが分かります。</p>
<h3 id="writebatch-の-setentry-メソッド"><code>WriteBatch</code> の <code>SetEntry</code> メソッド</h3>
<p><a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/batch.go#L91-L110">batch.go#L91-L110</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// SetEntry is the equivalent of Txn.SetEntry.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wb</span> <span class="o">*</span><span class="nx">WriteBatch</span><span class="p">)</span> <span class="nf">SetEntry</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Entry</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">wb</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">wb</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">wb</span><span class="p">.</span><span class="nx">txn</span><span class="p">.</span><span class="nf">SetEntry</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">ErrTxnTooBig</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// Txn has reached it&#39;s zenith. Commit now.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cerr</span> <span class="o">:=</span> <span class="nx">wb</span><span class="p">.</span><span class="nf">commit</span><span class="p">();</span> <span class="nx">cerr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">cerr</span>
	<span class="p">}</span>
	<span class="c1">// This time the error must not be ErrTxnTooBig, otherwise, we make the
</span><span class="c1"></span>	<span class="c1">// error permanent.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">wb</span><span class="p">.</span><span class="nx">txn</span><span class="p">.</span><span class="nf">SetEntry</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">wb</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">err</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><ul>
<li><code>wb.txn</code> の <code>SetEntry</code> メソッドを呼びエラーが <code>nil</code> か <code>ErrTxnTooBig</code> 以外のエラーが出たらそれを返します。</li>
<li><code>ErrTxnTooBig</code> だった場合は <code>commit</code> メソッドを呼び、エラーが起きた場合はそのエラーを返します。</li>
<li>エラーが起きなかった場合は再度 <code>wb.txn</code> の <code>SetEntry</code> メソッドを呼びます。コメントによるとここでは <code>ErrTxnTooBig</code> は起きないそうです。エラーが起きたら <code>wb.err</code> に設定しつつ返します。</li>
</ul>
<h3 id="writebatch-の-set-メソッド"><code>WriteBatch</code> の <code>Set</code> メソッド</h3>
<p><code>Entry</code> のインスタンスを作って <code>SetEntry</code> メソッドを呼んでいるだけです。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/batch.go#L112-L116">batch.go#L112-L116</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Set is equivalent of Txn.Set().
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wb</span> <span class="o">*</span><span class="nx">WriteBatch</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Entry</span><span class="p">{</span><span class="nx">Key</span><span class="p">:</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">v</span><span class="p">}</span>
	<span class="k">return</span> <span class="nx">wb</span><span class="p">.</span><span class="nf">SetEntry</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="writebatch-の-delete-メソッド"><code>WriteBatch</code> の <code>Delete</code> メソッド</h3>
<p><code>wb.txn</code> の <code>SetEntry</code> ではなく <code>Delete</code> を呼ぶ点を除いて <code>WriteBatch</code> の <code>SetEntry</code> と全く同じ構造です。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/batch.go#L118-L134">batch.go#L118-L134</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Delete is equivalent of Txn.Delete.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wb</span> <span class="o">*</span><span class="nx">WriteBatch</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">k</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">wb</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">wb</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">wb</span><span class="p">.</span><span class="nx">txn</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">k</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">ErrTxnTooBig</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">wb</span><span class="p">.</span><span class="nf">commit</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">wb</span><span class="p">.</span><span class="nx">txn</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">k</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">wb</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">err</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h3 id="writebatch-の-commit-メソッド"><code>WriteBatch</code> の <code>commit</code> メソッド</h3>
<p><a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/batch.go#L136-L149">batch.go#L136-L149</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Caller to commit must hold a write lock.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wb</span> <span class="o">*</span><span class="nx">WriteBatch</span><span class="p">)</span> <span class="nf">commit</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">wb</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">wb</span><span class="p">.</span><span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">wb</span><span class="p">.</span><span class="nx">throttle</span><span class="p">.</span><span class="nf">Do</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">wb</span><span class="p">.</span><span class="nx">txn</span><span class="p">.</span><span class="nf">CommitWith</span><span class="p">(</span><span class="nx">wb</span><span class="p">.</span><span class="nx">callback</span><span class="p">)</span>
	<span class="nx">wb</span><span class="p">.</span><span class="nx">txn</span> <span class="p">=</span> <span class="nx">wb</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">newTransaction</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="nx">wb</span><span class="p">.</span><span class="nx">txn</span><span class="p">.</span><span class="nx">readTs</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// We&#39;re not reading anything.
</span><span class="c1"></span>	<span class="nx">wb</span><span class="p">.</span><span class="nx">txn</span><span class="p">.</span><span class="nx">commitTs</span> <span class="p">=</span> <span class="nx">wb</span><span class="p">.</span><span class="nx">commitTs</span>
	<span class="k">return</span> <span class="nx">wb</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><p>この中で <code>wb.callback</code> メソッドを引数にして <code>wb.txn</code> の <code>CommitWith</code> メソッドを呼んでいます。</p>
<h3 id="writebatch-の-callback-メソッド"><code>WriteBatch</code> の <code>callback</code> メソッド</h3>
<p><a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/batch.go#L76-L89">batch.go#L76-L89</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">wb</span> <span class="o">*</span><span class="nx">WriteBatch</span><span class="p">)</span> <span class="nf">callback</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// sync.WaitGroup is thread-safe, so it doesn&#39;t need to be run inside wb.Lock.
</span><span class="c1"></span>	<span class="k">defer</span> <span class="nx">wb</span><span class="p">.</span><span class="nx">throttle</span><span class="p">.</span><span class="nf">Done</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">wb</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">wb</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">wb</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">wb</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><h3 id="ythrottle"><code>y.Throttle</code></h3>
<p><code>DB</code> の <code>newWriteBatch</code> メソッド内で <code>y.NewThrottle</code> 関数を呼んで作成している <code>y.Throttle</code> について見ていきます。</p>
<p><code>y.Throttle</code> 構造体。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/y/y.go#L236-L245">y/y.go#L236-L245</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Throttle allows a limited number of workers to run at a time. It also
</span><span class="c1">// provides a mechanism to check for errors encountered by workers and wait for
</span><span class="c1">// them to finish.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Throttle</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">once</span>      <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="nx">wg</span>        <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">ch</span>        <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
	<span class="nx">errCh</span>     <span class="kd">chan</span> <span class="kt">error</span>
	<span class="nx">finishErr</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p><code>NewThrottle</code> 関数。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/y/y.go#L247-L253">y/y.go#L247-L253</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NewThrottle creates a new throttle with a max number of workers.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewThrottle</span><span class="p">(</span><span class="nx">max</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Throttle</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Throttle</span><span class="p">{</span>
		<span class="nx">ch</span><span class="p">:</span>    <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="nx">max</span><span class="p">),</span>
		<span class="nx">errCh</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">max</span><span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>Do</code> メソッド。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/y/y.go#L255-L270">y/y.go#L255-L270</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Do should be called by workers before they start working. It blocks if there
</span><span class="c1">// are already maximum number of workers working. If it detects an error from
</span><span class="c1">// previously Done workers, it would return it.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Throttle</span><span class="p">)</span> <span class="nf">Do</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}:</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="k">case</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">t</span><span class="p">.</span><span class="nx">errCh</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">err</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>t.ch</code> を使って同時に実行するワーカーの最大数が <code>NewThrottle</code> 関数の引数の <code>max</code> に限定されるようになっています。既に <code>max</code> 個のワーカーが動いている場合は、どれかが正常終了するかエラーを返すまで待つことになります。</p>
<p><code>Done</code> メソッド。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/y/y.go#L272-L284">y/y.go#L272-L284</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Done should be called by workers when they finish working. They can also
</span><span class="c1">// pass the error status of work done.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Throttle</span><span class="p">)</span> <span class="nf">Done</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">errCh</span> <span class="o">&lt;-</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">t</span><span class="p">.</span><span class="nx">ch</span><span class="p">:</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Throttle Do Done mismatch&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p><code>Finish</code> メソッド。
<a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/y/y.go#L286-L303">y/y.go#L286-L303</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Finish waits until all workers have finished working. It would return any error passed by Done.
</span><span class="c1">// If Finish is called multiple time, it will wait for workers to finish only once(first time).
</span><span class="c1">// From next calls, it will return same error as found on first call.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Throttle</span><span class="p">)</span> <span class="nf">Finish</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
		<span class="nb">close</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">ch</span><span class="p">)</span>
		<span class="nb">close</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">errCh</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">t</span><span class="p">.</span><span class="nx">errCh</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nx">finishErr</span> <span class="p">=</span> <span class="nx">err</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">})</span>

	<span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">finishErr</span>
<span class="p">}</span>
</code></pre></div><h3 id="writebatch-の-flush-メソッド"><code>WriteBatch</code> の <code>Flush</code> メソッド</h3>
<p><a href="https://github.com/dgraph-io/badger/blob/617ed7c7db9d618b6511adfff5d22dcde2233049/batch.go#L151-L164">batch.go#L151-L164</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Flush must be called at the end to ensure that any pending writes get committed to Badger. Flush
</span><span class="c1">// returns any error stored by WriteBatch.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wb</span> <span class="o">*</span><span class="nx">WriteBatch</span><span class="p">)</span> <span class="nf">Flush</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">wb</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nx">wb</span><span class="p">.</span><span class="nf">commit</span><span class="p">()</span>
	<span class="nx">wb</span><span class="p">.</span><span class="nx">txn</span><span class="p">.</span><span class="nf">Discard</span><span class="p">()</span>
	<span class="nx">wb</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">wb</span><span class="p">.</span><span class="nx">throttle</span><span class="p">.</span><span class="nf">Finish</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">wb</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><h3 id="writebatch-のまとめ"><code>WriteBatch</code> のまとめ</h3>
<p><code>WriteBatch</code> の <code>commit</code> メソッドで <code>callback</code> メソッドを引数に <code>Txn</code> の <code>CommitWith</code> メソッドを呼び、エラーが出たら <code>WriteBatch</code> の <code>err</code> フィールドにセットしています。
このエラーは <code>WriteBatch</code> の <code>SetEntry</code>, <code>Delete</code>, <code>Flush</code> メソッドの戻り値として返ってきます。</p>
<p>これまでの上記のコードを見返してみて <code>NewWriteBatch</code> 関数のコメントの最後の文</p>
<blockquote>
<p>Due to the nature of SSI guaratees provided by Badger, blind writes can never encounter transaction conflicts (ErrConflict).</p>
</blockquote>
<p>は読み取りなしで書き込みだけのトランザクションでは <code>oracle</code> の <code>hasConflict</code> メソッドが <code>false</code> を返すので <code>ErrConflict</code> は絶対に起きないという意味だということに気づきました。</p>
<p>また <code>WriteBatch</code> の <code>SetEntry</code> か <code>Delete</code> を呼んだときに <code>ErrTxnTooBig</code> が起きた時は自動的に一旦コミットして、次のトランザクションを開始し元の <code>SetEntry</code> か <code>Delete</code> の処理を新しいトランザクションで行うようになっています。</p>

</div>


    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-53263855-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  </body>
</html>
